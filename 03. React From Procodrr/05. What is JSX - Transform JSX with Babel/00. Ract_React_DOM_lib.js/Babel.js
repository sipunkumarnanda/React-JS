
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.Babel = {}));
})(this, (function (exports) { 'use strict';

  var NodePath_context = /*#__PURE__*/Object.freeze({
    __proto__: null,
    get _call () { return _call; },
    get _getQueueContexts () { return _getQueueContexts; },
    get _resyncKey () { return _resyncKey; },
    get _resyncList () { return _resyncList; },
    get _resyncParent () { return _resyncParent; },
    get _resyncRemoved () { return _resyncRemoved; },
    get call () { return call; },
    get isDenylisted () { return isDenylisted; },
    get popContext () { return popContext; },
    get pushContext () { return pushContext; },
    get requeue () { return requeue; },
    get requeueComputedKeyAndDecorators () { return requeueComputedKeyAndDecorators; },
    get resync () { return resync; },
    get setContext () { return setContext; },
    get setKey () { return setKey; },
    get setScope () { return setScope; },
    get setup () { return setup; },
    get skip () { return skip; },
    get skipKey () { return skipKey; },
    get stop () { return stop; },
    get visit () { return visit; }
  });
  var _babel = /*#__PURE__*/Object.freeze({
    __proto__: null,
    get DEFAULT_EXTENSIONS () { return DEFAULT_EXTENSIONS; },
    get File () { return File; },
    get buildExternalHelpers () { return babelBuildExternalHelpers; },
    get createConfigItem () { return createConfigItem; },
    get createConfigItemAsync () { return createConfigItemAsync; },
    get createConfigItemSync () { return createConfigItemSync; },
    get getEnv () { return getEnv; },
    get loadOptions () { return loadOptions; },
    get loadOptionsAsync () { return loadOptionsAsync; },
    get loadOptionsSync () { return loadOptionsSync; },
    get loadPartialConfig () { return loadPartialConfig; },
    get loadPartialConfigAsync () { return loadPartialConfigAsync; },
    get loadPartialConfigSync () { return loadPartialConfigSync; },
    get parse () { return parse$1; },
    get parseAsync () { return parseAsync; },
    get parseSync () { return parseSync; },
    get resolvePlugin () { return resolvePlugin; },
    get resolvePreset () { return resolvePreset; },
    get template () { return template$2; },
    get tokTypes () { return tokTypes; },
    get transform () { return transform$3; },
    get transformAsync () { return transformAsync; },
    get transformFile () { return transformFile; },
    get transformFileAsync () { return transformFileAsync; },
    get transformFileSync () { return transformFileSync; },
    get transformFromAst () { return transformFromAst$1; },
    get transformFromAstAsync () { return transformFromAstAsync; },
    get transformFromAstSync () { return transformFromAstSync; },
    get transformSync () { return transformSync; },
    get traverse () { return traverse; },
    get types () { return t$4; },
    get version () { return version$1; }
  });

  function _arrayLikeToArray(r, a) {
    (null == a || a > r.length) && (a = r.length);
    for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
    return n;
  }
  function _arrayWithHoles(r) {
    if (Array.isArray(r)) return r;
  }
  function _arrayWithoutHoles(r) {
    if (Array.isArray(r)) return _arrayLikeToArray(r);
  }
  function asyncGeneratorStep(n, t, e, r, o, a, c) {
    try {
      var i = n[a](c),
        u = i.value;
    } catch (n) {
      return void e(n);
    }
    i.done ? t(u) : Promise.resolve(u).then(r, o);
  }
  function _asyncToGenerator(n) {
    return function () {
      var t = this,
        e = arguments;
      return new Promise(function (r, o) {
        var a = n.apply(t, e);
        function _next(n) {
          asyncGeneratorStep(a, r, o, _next, _throw, "next", n);
        }
        function _throw(n) {
          asyncGeneratorStep(a, r, o, _next, _throw, "throw", n);
        }
        _next(void 0);
      });
    };
  }
  function _construct(t, e, r) {
    if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments);
    var o = [null];
    o.push.apply(o, e);
    var p = new (t.bind.apply(t, o))();
    return r && _setPrototypeOf(p, r.prototype), p;
  }
  function _defineProperties(e, r) {
    for (var t = 0; t < r.length; t++) {
      var o = r[t];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o);
    }
  }
  function _createClass(e, r, t) {
    return r && _defineProperties(e.prototype, r), Object.defineProperty(e, "prototype", {
      writable: !1
    }), e;
  }
  function _createForOfIteratorHelperLoose(r, e) {
    var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
    if (t) return (t = t.call(r)).next.bind(t);
    if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e) {
      t && (r = t);
      var o = 0;
      return function () {
        return o >= r.length ? {
          done: !0
        } : {
          done: !1,
          value: r[o++]
        };
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _getPrototypeOf(t) {
    return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {
      return t.__proto__ || Object.getPrototypeOf(t);
    }, _getPrototypeOf(t);
  }
  function _inherits(t, e) {
    if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
    t.prototype = Object.create(e && e.prototype, {
      constructor: {
        value: t,
        writable: !0,
        configurable: !0
      }
    }), Object.defineProperty(t, "prototype", {
      writable: !1
    }), e && _setPrototypeOf(t, e);
  }
  function _isNativeFunction(t) {
    try {
      return -1 !== Function.toString.call(t).indexOf("[native code]");
    } catch (n) {
      return "function" == typeof t;
    }
  }
  function _isNativeReflectConstruct() {
    try {
      var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    } catch (t) {}
    return (_isNativeReflectConstruct = function () {
      return !!t;
    })();
  }
  function _iterableToArray(r) {
    if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
  }
  function _iterableToArrayLimit(r, l) {
    var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
    if (null != t) {
      var e,
        n,
        i,
        u,
        a = [],
        f = !0,
        o = !1;
      try {
        if (i = (t = t.call(r)).next, 0 === l) {
          if (Object(t) !== t) return;
          f = !1;
        } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);
      } catch (r) {
        o = !0, n = r;
      } finally {
        try {
          if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
        } finally {
          if (o) throw n;
        }
      }
      return a;
    }
  }
  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _objectWithoutProperties(e, t) {
    if (null == e) return {};
    var o,
      r,
      i = _objectWithoutPropertiesLoose(e, t);
    if (Object.getOwnPropertySymbols) {
      var n = Object.getOwnPropertySymbols(e);
      for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
    }
    return i;
  }
  function _objectWithoutPropertiesLoose(r, e) {
    if (null == r) return {};
    var t = {};
    for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
      if (-1 !== e.indexOf(n)) continue;
      t[n] = r[n];
    }
    return t;
  }
  function _regenerator() {
    /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */
    var e,
      t,
      r = "function" == typeof Symbol ? Symbol : {},
      n = r.iterator || "@@iterator",
      o = r.toStringTag || "@@toStringTag";
    function i(r, n, o, i) {
      var c = n && n.prototype instanceof Generator ? n : Generator,
        u = Object.create(c.prototype);
      return _regeneratorDefine(u, "_invoke", function (r, n, o) {
        var i,
          c,
          u,
          f = 0,
          p = o || [],
          y = !1,
          G = {
            p: 0,
            n: 0,
            v: e,
            a: d,
            f: d.bind(e, 4),
            d: function (t, r) {
              return i = t, c = 0, u = e, G.n = r, a;
            }
          };
        function d(r, n) {
          for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) {
            var o,
              i = p[t],
              d = G.p,
              l = i[2];
            r > 3 ? (o = l === n) && (c = i[4] || 3, u = i[5] === e ? i[3] : i[5], i[4] = 3, i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0));
          }
          if (o || r > 1) return a;
          throw y = !0, n;
        }
        return function (o, p, l) {
          if (f > 1) throw TypeError("Generator is already running");
          for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) {
            i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u);
            try {
              if (f = 2, i) {
                if (c || (o = "next"), t = i[o]) {
                  if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object");
                  if (!t.done) return t;
                  u = t.value, c < 2 && (c = 0);
                } else 1 === c && (t = i.return) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1);
                i = e;
              } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break;
            } catch (t) {
              i = e, c = 1, u = t;
            } finally {
              f = 1;
            }
          }
          return {
            value: t,
            done: y
          };
        };
      }(r, o, i), !0), u;
    }
    var a = {};
    function Generator() {}
    function GeneratorFunction() {}
    function GeneratorFunctionPrototype() {}
    t = Object.getPrototypeOf;
    var c = [][n] ? t(t([][n]())) : (_regeneratorDefine(t = {}, n, function () {
        return this;
      }), t),
      u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c);
    function f(e) {
      return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e;
    }
    return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine(u), _regeneratorDefine(u, o, "Generator"), _regeneratorDefine(u, n, function () {
      return this;
    }), _regeneratorDefine(u, "toString", function () {
      return "[object Generator]";
    }), (_regenerator = function () {
      return {
        w: i,
        m: f
      };
    })();
  }
  function _regeneratorDefine(e, r, n, t) {
    var i = Object.defineProperty;
    try {
      i({}, "", {});
    } catch (e) {
      i = 0;
    }
    _regeneratorDefine = function (e, r, n, t) {
      if (r) i ? i(e, r, {
        value: n,
        enumerable: !t,
        configurable: !t,
        writable: !t
      }) : e[r] = n;else {
        function o(r, n) {
          _regeneratorDefine(e, r, function (e) {
            return this._invoke(r, n, e);
          });
        }
        o("next", 0), o("throw", 1), o("return", 2);
      }
    }, _regeneratorDefine(e, r, n, t);
  }
  function _regeneratorValues(e) {
    if (null != e) {
      var t = e["function" == typeof Symbol && Symbol.iterator || "@@iterator"],
        r = 0;
      if (t) return t.call(e);
      if ("function" == typeof e.next) return e;
      if (!isNaN(e.length)) return {
        next: function () {
          return e && r >= e.length && (e = void 0), {
            value: e && e[r++],
            done: !e
          };
        }
      };
    }
    throw new TypeError(typeof e + " is not iterable");
  }
  function _setPrototypeOf(t, e) {
    return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
      return t.__proto__ = e, t;
    }, _setPrototypeOf(t, e);
  }
  function _slicedToArray(r, e) {
    return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();
  }
  function _taggedTemplateLiteralLoose(e, t) {
    return t || (t = e.slice(0)), e.raw = t, e;
  }
  function _toConsumableArray(r) {
    return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread();
  }
  function _toPrimitive(t, r) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r);
      if ("object" != typeof i) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (String )(t);
  }
  function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return "symbol" == typeof i ? i : i + "";
  }
  function _unsupportedIterableToArray(r, a) {
    if (r) {
      if ("string" == typeof r) return _arrayLikeToArray(r, a);
      var t = {}.toString.call(r).slice(8, -1);
      return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
    }
  }
  function _wrapNativeSuper(t) {
    var r = "function" == typeof Map ? new Map() : void 0;
    return _wrapNativeSuper = function (t) {
      if (null === t || !_isNativeFunction(t)) return t;
      if ("function" != typeof t) throw new TypeError("Super expression must either be null or a function");
      if (void 0 !== r) {
        if (r.has(t)) return r.get(t);
        r.set(t, Wrapper);
      }
      function Wrapper() {
        return _construct(t, arguments, _getPrototypeOf(this).constructor);
      }
      return Wrapper.prototype = Object.create(t.prototype, {
        constructor: {
          value: Wrapper,
          enumerable: !1,
          writable: !0,
          configurable: !0
        }
      }), _setPrototypeOf(Wrapper, t);
    }, _wrapNativeSuper(t);
  }

  var global$1 = (typeof global !== "undefined" ? global :
    typeof self !== "undefined" ? self :
    typeof window !== "undefined" ? window : {});

  // shim for using process in browser
  // based off https://github.com/defunctzombie/node-process/blob/master/browser.js

  function defaultSetTimout() {
      throw new Error('setTimeout has not been defined');
  }
  function defaultClearTimeout () {
      throw new Error('clearTimeout has not been defined');
  }
  var cachedSetTimeout = defaultSetTimout;
  var cachedClearTimeout = defaultClearTimeout;
  if (typeof global$1.setTimeout === 'function') {
      cachedSetTimeout = setTimeout;
  }
  if (typeof global$1.clearTimeout === 'function') {
      cachedClearTimeout = clearTimeout;
  }

  function runTimeout(fun) {
      if (cachedSetTimeout === setTimeout) {
          //normal enviroments in sane situations
          return setTimeout(fun, 0);
      }
      // if setTimeout wasn't available but was latter defined
      if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
          cachedSetTimeout = setTimeout;
          return setTimeout(fun, 0);
      }
      try {
          // when when somebody has screwed with setTimeout but no I.E. maddness
          return cachedSetTimeout(fun, 0);
      } catch(e){
          try {
              // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
              return cachedSetTimeout.call(null, fun, 0);
          } catch(e){
              // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
              return cachedSetTimeout.call(this, fun, 0);
          }
      }


  }
  function runClearTimeout(marker) {
      if (cachedClearTimeout === clearTimeout) {
          //normal enviroments in sane situations
          return clearTimeout(marker);
      }
      // if clearTimeout wasn't available but was latter defined
      if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
          cachedClearTimeout = clearTimeout;
          return clearTimeout(marker);
      }
      try {
          // when when somebody has screwed with setTimeout but no I.E. maddness
          return cachedClearTimeout(marker);
      } catch (e){
          try {
              // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
              return cachedClearTimeout.call(null, marker);
          } catch (e){
              // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
              // Some versions of I.E. have different rules for clearTimeout vs setTimeout
              return cachedClearTimeout.call(this, marker);
          }
      }



  }
  var queue = [];
  var draining = false;
  var currentQueue;
  var queueIndex = -1;

  function cleanUpNextTick() {
      if (!draining || !currentQueue) {
          return;
      }
      draining = false;
      if (currentQueue.length) {
          queue = currentQueue.concat(queue);
      } else {
          queueIndex = -1;
      }
      if (queue.length) {
          drainQueue();
      }
  }

  function drainQueue() {
      if (draining) {
          return;
      }
      var timeout = runTimeout(cleanUpNextTick);
      draining = true;

      var len = queue.length;
      while(len) {
          currentQueue = queue;
          queue = [];
          while (++queueIndex < len) {
              if (currentQueue) {
                  currentQueue[queueIndex].run();
              }
          }
          queueIndex = -1;
          len = queue.length;
      }
      currentQueue = null;
      draining = false;
      runClearTimeout(timeout);
  }
  function nextTick(fun) {
      var args = new Array(arguments.length - 1);
      if (arguments.length > 1) {
          for (var i = 1; i < arguments.length; i++) {
              args[i - 1] = arguments[i];
          }
      }
      queue.push(new Item(fun, args));
      if (queue.length === 1 && !draining) {
          runTimeout(drainQueue);
      }
  }
  // v8 likes predictible objects
  function Item(fun, array) {
      this.fun = fun;
      this.array = array;
  }
  Item.prototype.run = function () {
      this.fun.apply(null, this.array);
  };
  var title = 'browser';
  var platform = 'browser';
  var browser$2 = true;
  var env$1 = {};
  var argv = [];
  var version$2 = ''; // empty string to avoid regexp issues
  var versions$2 = {};
  var release = {};
  var config$1 = {};

  function noop$2() {}

  var on = noop$2;
  var addListener = noop$2;
  var once$1 = noop$2;
  var off = noop$2;
  var removeListener = noop$2;
  var removeAllListeners = noop$2;
  var emit = noop$2;

  function binding(name) {
      throw new Error('process.binding is not supported');
  }

  function cwd () { return '/' }
  function chdir (dir) {
      throw new Error('process.chdir is not supported');
  }function umask() { return 0; }

  // from https://github.com/kumavis/browser-process-hrtime/blob/master/index.js
  var performance = global$1.performance || {};
  var performanceNow =
    performance.now        ||
    performance.mozNow     ||
    performance.msNow      ||
    performance.oNow       ||
    performance.webkitNow  ||
    function(){ return (new Date()).getTime() };

  // generate timestamp or delta
  // see http://nodejs.org/api/process.html#process_process_hrtime
  function hrtime(previousTimestamp){
    var clocktime = performanceNow.call(performance)*1e-3;
    var seconds = Math.floor(clocktime);
    var nanoseconds = Math.floor((clocktime%1)*1e9);
    if (previousTimestamp) {
      seconds = seconds - previousTimestamp[0];
      nanoseconds = nanoseconds - previousTimestamp[1];
      if (nanoseconds<0) {
        seconds--;
        nanoseconds += 1e9;
      }
    }
    return [seconds,nanoseconds]
  }

  var startTime = new Date();
  function uptime() {
    var currentTime = new Date();
    var dif = currentTime - startTime;
    return dif / 1000;
  }

  var browser$1$1 = {
    nextTick: nextTick,
    title: title,
    browser: browser$2,
    env: env$1,
    argv: argv,
    version: version$2,
    versions: versions$2,
    on: on,
    addListener: addListener,
    once: once$1,
    off: off,
    removeListener: removeListener,
    removeAllListeners: removeAllListeners,
    emit: emit,
    binding: binding,
    cwd: cwd,
    chdir: chdir,
    umask: umask,
    hrtime: hrtime,
    platform: platform,
    release: release,
    config: config$1,
    uptime: uptime
  };

  function shallowEqual(actual, expected) {
    var keys = Object.keys(expected);
    for (var _i = 0, _keys = keys; _i < _keys.length; _i++) {
      var key = _keys[_i];
      if (actual[key] !== expected[key]) {
        return false;
      }
    }
    return true;
  }

  var warnings = new Set();
  function deprecationWarning$1(oldName, newName, prefix, cacheKey) {
    if (prefix === void 0) {
      prefix = "";
    }
    if (cacheKey === void 0) {
      cacheKey = oldName;
    }
    if (warnings.has(cacheKey)) return;
    warnings.add(cacheKey);
    var _captureShortStackTra = captureShortStackTrace(1, 2),
      internal = _captureShortStackTra.internal,
      trace = _captureShortStackTra.trace;
    if (internal) {
      return;
    }
    console.warn(prefix + "`" + oldName + "` has been deprecated, please migrate to `" + newName + "`\n" + trace);
  }
  function captureShortStackTrace(skip, length) {
    var stackTraceLimit = Error.stackTraceLimit,
      prepareStackTrace = Error.prepareStackTrace;
    var stackTrace;
    Error.stackTraceLimit = 1 + skip + length;
    Error.prepareStackTrace = function (err, stack) {
      stackTrace = stack;
    };
    new Error().stack;
    Error.stackTraceLimit = stackTraceLimit;
    Error.prepareStackTrace = prepareStackTrace;
    if (!stackTrace) return {
      internal: false,
      trace: ""
    };
    var shortStackTrace = stackTrace.slice(1 + skip, 1 + skip + length);
    return {
      internal: /[\\/]@babel[\\/]/.test(shortStackTrace[1].getFileName()),
      trace: shortStackTrace.map(function (frame) {
        return "    at " + frame;
      }).join("\n")
    };
  }

  function isArrayExpression$2(node, opts) {
    if (!node) return false;
    if (node.type !== "ArrayExpression") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isAssignmentExpression$2(node, opts) {
    if (!node) return false;
    if (node.type !== "AssignmentExpression") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isBinaryExpression$1(node, opts) {
    if (!node) return false;
    if (node.type !== "BinaryExpression") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isInterpreterDirective(node, opts) {
    if (!node) return false;
    if (node.type !== "InterpreterDirective") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isDirective(node, opts) {
    if (!node) return false;
    if (node.type !== "Directive") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isDirectiveLiteral(node, opts) {
    if (!node) return false;
    if (node.type !== "DirectiveLiteral") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isBlockStatement$3(node, opts) {
    if (!node) return false;
    if (node.type !== "BlockStatement") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isBreakStatement(node, opts) {
    if (!node) return false;
    if (node.type !== "BreakStatement") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isCallExpression$8(node, opts) {
    if (!node) return false;
    if (node.type !== "CallExpression") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isCatchClause(node, opts) {
    if (!node) return false;
    if (node.type !== "CatchClause") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isConditionalExpression(node, opts) {
    if (!node) return false;
    if (node.type !== "ConditionalExpression") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isContinueStatement(node, opts) {
    if (!node) return false;
    if (node.type !== "ContinueStatement") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isDebuggerStatement(node, opts) {
    if (!node) return false;
    if (node.type !== "DebuggerStatement") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isDoWhileStatement(node, opts) {
    if (!node) return false;
    if (node.type !== "DoWhileStatement") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isEmptyStatement$1(node, opts) {
    if (!node) return false;
    if (node.type !== "EmptyStatement") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isExpressionStatement$2(node, opts) {
    if (!node) return false;
    if (node.type !== "ExpressionStatement") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isFile(node, opts) {
    if (!node) return false;
    if (node.type !== "File") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isForInStatement(node, opts) {
    if (!node) return false;
    if (node.type !== "ForInStatement") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isForStatement$2(node, opts) {
    if (!node) return false;
    if (node.type !== "ForStatement") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isFunctionDeclaration$2(node, opts) {
    if (!node) return false;
    if (node.type !== "FunctionDeclaration") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isFunctionExpression(node, opts) {
    if (!node) return false;
    if (node.type !== "FunctionExpression") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isIdentifier$e(node, opts) {
    if (!node) return false;
    if (node.type !== "Identifier") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isIfStatement$2(node, opts) {
    if (!node) return false;
    if (node.type !== "IfStatement") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isLabeledStatement(node, opts) {
    if (!node) return false;
    if (node.type !== "LabeledStatement") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isStringLiteral$5(node, opts) {
    if (!node) return false;
    if (node.type !== "StringLiteral") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isNumericLiteral(node, opts) {
    if (!node) return false;
    if (node.type !== "NumericLiteral") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isNullLiteral$1(node, opts) {
    if (!node) return false;
    if (node.type !== "NullLiteral") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isBooleanLiteral(node, opts) {
    if (!node) return false;
    if (node.type !== "BooleanLiteral") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isRegExpLiteral$1(node, opts) {
    if (!node) return false;
    if (node.type !== "RegExpLiteral") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isLogicalExpression(node, opts) {
    if (!node) return false;
    if (node.type !== "LogicalExpression") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isMemberExpression$7(node, opts) {
    if (!node) return false;
    if (node.type !== "MemberExpression") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isNewExpression$3(node, opts) {
    if (!node) return false;
    if (node.type !== "NewExpression") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isProgram$1(node, opts) {
    if (!node) return false;
    if (node.type !== "Program") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isObjectExpression$3(node, opts) {
    if (!node) return false;
    if (node.type !== "ObjectExpression") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isObjectMethod(node, opts) {
    if (!node) return false;
    if (node.type !== "ObjectMethod") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isObjectProperty$2(node, opts) {
    if (!node) return false;
    if (node.type !== "ObjectProperty") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isRestElement$2(node, opts) {
    if (!node) return false;
    if (node.type !== "RestElement") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isReturnStatement(node, opts) {
    if (!node) return false;
    if (node.type !== "ReturnStatement") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isSequenceExpression$1(node, opts) {
    if (!node) return false;
    if (node.type !== "SequenceExpression") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isParenthesizedExpression$2(node, opts) {
    if (!node) return false;
    if (node.type !== "ParenthesizedExpression") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isSwitchCase(node, opts) {
    if (!node) return false;
    if (node.type !== "SwitchCase") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isSwitchStatement(node, opts) {
    if (!node) return false;
    if (node.type !== "SwitchStatement") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isThisExpression$2(node, opts) {
    if (!node) return false;
    if (node.type !== "ThisExpression") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isThrowStatement(node, opts) {
    if (!node) return false;
    if (node.type !== "ThrowStatement") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isTryStatement(node, opts) {
    if (!node) return false;
    if (node.type !== "TryStatement") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isUnaryExpression$1(node, opts) {
    if (!node) return false;
    if (node.type !== "UnaryExpression") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isUpdateExpression$1(node, opts) {
    if (!node) return false;
    if (node.type !== "UpdateExpression") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isVariableDeclaration$3(node, opts) {
    if (!node) return false;
    if (node.type !== "VariableDeclaration") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isVariableDeclarator(node, opts) {
    if (!node) return false;
    if (node.type !== "VariableDeclarator") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isWhileStatement(node, opts) {
    if (!node) return false;
    if (node.type !== "WhileStatement") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isWithStatement(node, opts) {
    if (!node) return false;
    if (node.type !== "WithStatement") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isAssignmentPattern$3(node, opts) {
    if (!node) return false;
    if (node.type !== "AssignmentPattern") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isArrayPattern(node, opts) {
    if (!node) return false;
    if (node.type !== "ArrayPattern") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isArrowFunctionExpression(node, opts) {
    if (!node) return false;
    if (node.type !== "ArrowFunctionExpression") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isClassBody$2(node, opts) {
    if (!node) return false;
    if (node.type !== "ClassBody") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isClassExpression(node, opts) {
    if (!node) return false;
    if (node.type !== "ClassExpression") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isClassDeclaration$2(node, opts) {
    if (!node) return false;
    if (node.type !== "ClassDeclaration") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isExportAllDeclaration$1(node, opts) {
    if (!node) return false;
    if (node.type !== "ExportAllDeclaration") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isExportDefaultDeclaration$2(node, opts) {
    if (!node) return false;
    if (node.type !== "ExportDefaultDeclaration") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isExportNamedDeclaration$3(node, opts) {
    if (!node) return false;
    if (node.type !== "ExportNamedDeclaration") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isExportSpecifier(node, opts) {
    if (!node) return false;
    if (node.type !== "ExportSpecifier") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isForOfStatement$2(node, opts) {
    if (!node) return false;
    if (node.type !== "ForOfStatement") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isImportDeclaration$3(node, opts) {
    if (!node) return false;
    if (node.type !== "ImportDeclaration") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isImportDefaultSpecifier$1(node, opts) {
    if (!node) return false;
    if (node.type !== "ImportDefaultSpecifier") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isImportNamespaceSpecifier$1(node, opts) {
    if (!node) return false;
    if (node.type !== "ImportNamespaceSpecifier") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isImportSpecifier$1(node, opts) {
    if (!node) return false;
    if (node.type !== "ImportSpecifier") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isImportExpression(node, opts) {
    if (!node) return false;
    if (node.type !== "ImportExpression") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isMetaProperty$1(node, opts) {
    if (!node) return false;
    if (node.type !== "MetaProperty") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isClassMethod(node, opts) {
    if (!node) return false;
    if (node.type !== "ClassMethod") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isObjectPattern$1(node, opts) {
    if (!node) return false;
    if (node.type !== "ObjectPattern") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isSpreadElement$1(node, opts) {
    if (!node) return false;
    if (node.type !== "SpreadElement") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isSuper$2(node, opts) {
    if (!node) return false;
    if (node.type !== "Super") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isTaggedTemplateExpression$1(node, opts) {
    if (!node) return false;
    if (node.type !== "TaggedTemplateExpression") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isTemplateElement(node, opts) {
    if (!node) return false;
    if (node.type !== "TemplateElement") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isTemplateLiteral$1(node, opts) {
    if (!node) return false;
    if (node.type !== "TemplateLiteral") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isYieldExpression$1(node, opts) {
    if (!node) return false;
    if (node.type !== "YieldExpression") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isAwaitExpression(node, opts) {
    if (!node) return false;
    if (node.type !== "AwaitExpression") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isImport(node, opts) {
    if (!node) return false;
    if (node.type !== "Import") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isBigIntLiteral(node, opts) {
    if (!node) return false;
    if (node.type !== "BigIntLiteral") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isExportNamespaceSpecifier$1(node, opts) {
    if (!node) return false;
    if (node.type !== "ExportNamespaceSpecifier") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isOptionalMemberExpression$3(node, opts) {
    if (!node) return false;
    if (node.type !== "OptionalMemberExpression") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isOptionalCallExpression$2(node, opts) {
    if (!node) return false;
    if (node.type !== "OptionalCallExpression") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isClassProperty(node, opts) {
    if (!node) return false;
    if (node.type !== "ClassProperty") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isClassAccessorProperty(node, opts) {
    if (!node) return false;
    if (node.type !== "ClassAccessorProperty") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isClassPrivateProperty(node, opts) {
    if (!node) return false;
    if (node.type !== "ClassPrivateProperty") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isClassPrivateMethod(node, opts) {
    if (!node) return false;
    if (node.type !== "ClassPrivateMethod") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isPrivateName$2(node, opts) {
    if (!node) return false;
    if (node.type !== "PrivateName") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isStaticBlock(node, opts) {
    if (!node) return false;
    if (node.type !== "StaticBlock") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isImportAttribute(node, opts) {
    if (!node) return false;
    if (node.type !== "ImportAttribute") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isAnyTypeAnnotation$1(node, opts) {
    if (!node) return false;
    if (node.type !== "AnyTypeAnnotation") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isArrayTypeAnnotation$2(node, opts) {
    if (!node) return false;
    if (node.type !== "ArrayTypeAnnotation") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isBooleanTypeAnnotation$1(node, opts) {
    if (!node) return false;
    if (node.type !== "BooleanTypeAnnotation") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isBooleanLiteralTypeAnnotation(node, opts) {
    if (!node) return false;
    if (node.type !== "BooleanLiteralTypeAnnotation") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isNullLiteralTypeAnnotation(node, opts) {
    if (!node) return false;
    if (node.type !== "NullLiteralTypeAnnotation") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isClassImplements(node, opts) {
    if (!node) return false;
    if (node.type !== "ClassImplements") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isDeclareClass(node, opts) {
    if (!node) return false;
    if (node.type !== "DeclareClass") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isDeclareFunction(node, opts) {
    if (!node) return false;
    if (node.type !== "DeclareFunction") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isDeclareInterface(node, opts) {
    if (!node) return false;
    if (node.type !== "DeclareInterface") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isDeclareModule(node, opts) {
    if (!node) return false;
    if (node.type !== "DeclareModule") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isDeclareModuleExports(node, opts) {
    if (!node) return false;
    if (node.type !== "DeclareModuleExports") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isDeclareTypeAlias(node, opts) {
    if (!node) return false;
    if (node.type !== "DeclareTypeAlias") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isDeclareOpaqueType(node, opts) {
    if (!node) return false;
    if (node.type !== "DeclareOpaqueType") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isDeclareVariable(node, opts) {
    if (!node) return false;
    if (node.type !== "DeclareVariable") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isDeclareExportDeclaration$1(node, opts) {
    if (!node) return false;
    if (node.type !== "DeclareExportDeclaration") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isDeclareExportAllDeclaration(node, opts) {
    if (!node) return false;
    if (node.type !== "DeclareExportAllDeclaration") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isDeclaredPredicate(node, opts) {
    if (!node) return false;
    if (node.type !== "DeclaredPredicate") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isExistsTypeAnnotation(node, opts) {
    if (!node) return false;
    if (node.type !== "ExistsTypeAnnotation") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isFunctionTypeAnnotation(node, opts) {
    if (!node) return false;
    if (node.type !== "FunctionTypeAnnotation") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isFunctionTypeParam(node, opts) {
    if (!node) return false;
    if (node.type !== "FunctionTypeParam") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isGenericTypeAnnotation$1(node, opts) {
    if (!node) return false;
    if (node.type !== "GenericTypeAnnotation") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isInferredPredicate(node, opts) {
    if (!node) return false;
    if (node.type !== "InferredPredicate") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isInterfaceExtends(node, opts) {
    if (!node) return false;
    if (node.type !== "InterfaceExtends") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isInterfaceDeclaration(node, opts) {
    if (!node) return false;
    if (node.type !== "InterfaceDeclaration") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isInterfaceTypeAnnotation(node, opts) {
    if (!node) return false;
    if (node.type !== "InterfaceTypeAnnotation") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isIntersectionTypeAnnotation(node, opts) {
    if (!node) return false;
    if (node.type !== "IntersectionTypeAnnotation") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isMixedTypeAnnotation$1(node, opts) {
    if (!node) return false;
    if (node.type !== "MixedTypeAnnotation") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isEmptyTypeAnnotation$1(node, opts) {
    if (!node) return false;
    if (node.type !== "EmptyTypeAnnotation") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isNullableTypeAnnotation(node, opts) {
    if (!node) return false;
    if (node.type !== "NullableTypeAnnotation") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isNumberLiteralTypeAnnotation(node, opts) {
    if (!node) return false;
    if (node.type !== "NumberLiteralTypeAnnotation") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isNumberTypeAnnotation$1(node, opts) {
    if (!node) return false;
    if (node.type !== "NumberTypeAnnotation") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isObjectTypeAnnotation(node, opts) {
    if (!node) return false;
    if (node.type !== "ObjectTypeAnnotation") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isObjectTypeInternalSlot(node, opts) {
    if (!node) return false;
    if (node.type !== "ObjectTypeInternalSlot") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isObjectTypeCallProperty(node, opts) {
    if (!node) return false;
    if (node.type !== "ObjectTypeCallProperty") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isObjectTypeIndexer(node, opts) {
    if (!node) return false;
    if (node.type !== "ObjectTypeIndexer") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isObjectTypeProperty(node, opts) {
    if (!node) return false;
    if (node.type !== "ObjectTypeProperty") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isObjectTypeSpreadProperty(node, opts) {
    if (!node) return false;
    if (node.type !== "ObjectTypeSpreadProperty") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isOpaqueType(node, opts) {
    if (!node) return false;
    if (node.type !== "OpaqueType") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isQualifiedTypeIdentifier(node, opts) {
    if (!node) return false;
    if (node.type !== "QualifiedTypeIdentifier") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isStringLiteralTypeAnnotation(node, opts) {
    if (!node) return false;
    if (node.type !== "StringLiteralTypeAnnotation") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isStringTypeAnnotation$1(node, opts) {
    if (!node) return false;
    if (node.type !== "StringTypeAnnotation") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isSymbolTypeAnnotation(node, opts) {
    if (!node) return false;
    if (node.type !== "SymbolTypeAnnotation") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isThisTypeAnnotation(node, opts) {
    if (!node) return false;
    if (node.type !== "ThisTypeAnnotation") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isTupleTypeAnnotation$1(node, opts) {
    if (!node) return false;
    if (node.type !== "TupleTypeAnnotation") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isTypeofTypeAnnotation(node, opts) {
    if (!node) return false;
    if (node.type !== "TypeofTypeAnnotation") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isTypeAlias(node, opts) {
    if (!node) return false;
    if (node.type !== "TypeAlias") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isTypeAnnotation$1(node, opts) {
    if (!node) return false;
    if (node.type !== "TypeAnnotation") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isTypeCastExpression$1(node, opts) {
    if (!node) return false;
    if (node.type !== "TypeCastExpression") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isTypeParameter(node, opts) {
    if (!node) return false;
    if (node.type !== "TypeParameter") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isTypeParameterDeclaration(node, opts) {
    if (!node) return false;
    if (node.type !== "TypeParameterDeclaration") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isTypeParameterInstantiation(node, opts) {
    if (!node) return false;
    if (node.type !== "TypeParameterInstantiation") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isUnionTypeAnnotation$1(node, opts) {
    if (!node) return false;
    if (node.type !== "UnionTypeAnnotation") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isVariance(node, opts) {
    if (!node) return false;
    if (node.type !== "Variance") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isVoidTypeAnnotation$1(node, opts) {
    if (!node) return false;
    if (node.type !== "VoidTypeAnnotation") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isEnumDeclaration(node, opts) {
    if (!node) return false;
    if (node.type !== "EnumDeclaration") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isEnumBooleanBody(node, opts) {
    if (!node) return false;
    if (node.type !== "EnumBooleanBody") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isEnumNumberBody(node, opts) {
    if (!node) return false;
    if (node.type !== "EnumNumberBody") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isEnumStringBody(node, opts) {
    if (!node) return false;
    if (node.type !== "EnumStringBody") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isEnumSymbolBody(node, opts) {
    if (!node) return false;
    if (node.type !== "EnumSymbolBody") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isEnumBooleanMember(node, opts) {
    if (!node) return false;
    if (node.type !== "EnumBooleanMember") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isEnumNumberMember(node, opts) {
    if (!node) return false;
    if (node.type !== "EnumNumberMember") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isEnumStringMember(node, opts) {
    if (!node) return false;
    if (node.type !== "EnumStringMember") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isEnumDefaultedMember(node, opts) {
    if (!node) return false;
    if (node.type !== "EnumDefaultedMember") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isIndexedAccessType$1(node, opts) {
    if (!node) return false;
    if (node.type !== "IndexedAccessType") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isOptionalIndexedAccessType(node, opts) {
    if (!node) return false;
    if (node.type !== "OptionalIndexedAccessType") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isJSXAttribute(node, opts) {
    if (!node) return false;
    if (node.type !== "JSXAttribute") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isJSXClosingElement(node, opts) {
    if (!node) return false;
    if (node.type !== "JSXClosingElement") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isJSXElement(node, opts) {
    if (!node) return false;
    if (node.type !== "JSXElement") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isJSXEmptyExpression(node, opts) {
    if (!node) return false;
    if (node.type !== "JSXEmptyExpression") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isJSXExpressionContainer$1(node, opts) {
    if (!node) return false;
    if (node.type !== "JSXExpressionContainer") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isJSXSpreadChild(node, opts) {
    if (!node) return false;
    if (node.type !== "JSXSpreadChild") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isJSXIdentifier$3(node, opts) {
    if (!node) return false;
    if (node.type !== "JSXIdentifier") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isJSXMemberExpression$2(node, opts) {
    if (!node) return false;
    if (node.type !== "JSXMemberExpression") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isJSXNamespacedName$1(node, opts) {
    if (!node) return false;
    if (node.type !== "JSXNamespacedName") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isJSXOpeningElement(node, opts) {
    if (!node) return false;
    if (node.type !== "JSXOpeningElement") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isJSXSpreadAttribute$1(node, opts) {
    if (!node) return false;
    if (node.type !== "JSXSpreadAttribute") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isJSXText(node, opts) {
    if (!node) return false;
    if (node.type !== "JSXText") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isJSXFragment(node, opts) {
    if (!node) return false;
    if (node.type !== "JSXFragment") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isJSXOpeningFragment(node, opts) {
    if (!node) return false;
    if (node.type !== "JSXOpeningFragment") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isJSXClosingFragment(node, opts) {
    if (!node) return false;
    if (node.type !== "JSXClosingFragment") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isNoop(node, opts) {
    if (!node) return false;
    if (node.type !== "Noop") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isPlaceholder$1(node, opts) {
    if (!node) return false;
    if (node.type !== "Placeholder") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isV8IntrinsicIdentifier(node, opts) {
    if (!node) return false;
    if (node.type !== "V8IntrinsicIdentifier") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isArgumentPlaceholder(node, opts) {
    if (!node) return false;
    if (node.type !== "ArgumentPlaceholder") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isBindExpression(node, opts) {
    if (!node) return false;
    if (node.type !== "BindExpression") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isDecorator$1(node, opts) {
    if (!node) return false;
    if (node.type !== "Decorator") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isDoExpression(node, opts) {
    if (!node) return false;
    if (node.type !== "DoExpression") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isExportDefaultSpecifier$1(node, opts) {
    if (!node) return false;
    if (node.type !== "ExportDefaultSpecifier") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isRecordExpression$1(node, opts) {
    if (!node) return false;
    if (node.type !== "RecordExpression") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isTupleExpression$1(node, opts) {
    if (!node) return false;
    if (node.type !== "TupleExpression") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isDecimalLiteral(node, opts) {
    if (!node) return false;
    if (node.type !== "DecimalLiteral") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isModuleExpression(node, opts) {
    if (!node) return false;
    if (node.type !== "ModuleExpression") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isTopicReference$1(node, opts) {
    if (!node) return false;
    if (node.type !== "TopicReference") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isPipelineTopicExpression(node, opts) {
    if (!node) return false;
    if (node.type !== "PipelineTopicExpression") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isPipelineBareFunction(node, opts) {
    if (!node) return false;
    if (node.type !== "PipelineBareFunction") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isPipelinePrimaryTopicReference(node, opts) {
    if (!node) return false;
    if (node.type !== "PipelinePrimaryTopicReference") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isVoidPattern(node, opts) {
    if (!node) return false;
    if (node.type !== "VoidPattern") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isTSParameterProperty(node, opts) {
    if (!node) return false;
    if (node.type !== "TSParameterProperty") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isTSDeclareFunction(node, opts) {
    if (!node) return false;
    if (node.type !== "TSDeclareFunction") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isTSDeclareMethod(node, opts) {
    if (!node) return false;
    if (node.type !== "TSDeclareMethod") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isTSQualifiedName(node, opts) {
    if (!node) return false;
    if (node.type !== "TSQualifiedName") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isTSCallSignatureDeclaration(node, opts) {
    if (!node) return false;
    if (node.type !== "TSCallSignatureDeclaration") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isTSConstructSignatureDeclaration(node, opts) {
    if (!node) return false;
    if (node.type !== "TSConstructSignatureDeclaration") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isTSPropertySignature(node, opts) {
    if (!node) return false;
    if (node.type !== "TSPropertySignature") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isTSMethodSignature(node, opts) {
    if (!node) return false;
    if (node.type !== "TSMethodSignature") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isTSIndexSignature(node, opts) {
    if (!node) return false;
    if (node.type !== "TSIndexSignature") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isTSAnyKeyword(node, opts) {
    if (!node) return false;
    if (node.type !== "TSAnyKeyword") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isTSBooleanKeyword(node, opts) {
    if (!node) return false;
    if (node.type !== "TSBooleanKeyword") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isTSBigIntKeyword(node, opts) {
    if (!node) return false;
    if (node.type !== "TSBigIntKeyword") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isTSIntrinsicKeyword(node, opts) {
    if (!node) return false;
    if (node.type !== "TSIntrinsicKeyword") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isTSNeverKeyword(node, opts) {
    if (!node) return false;
    if (node.type !== "TSNeverKeyword") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isTSNullKeyword(node, opts) {
    if (!node) return false;
    if (node.type !== "TSNullKeyword") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isTSNumberKeyword(node, opts) {
    if (!node) return false;
    if (node.type !== "TSNumberKeyword") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isTSObjectKeyword(node, opts) {
    if (!node) return false;
    if (node.type !== "TSObjectKeyword") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isTSStringKeyword(node, opts) {
    if (!node) return false;
    if (node.type !== "TSStringKeyword") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isTSSymbolKeyword(node, opts) {
    if (!node) return false;
    if (node.type !== "TSSymbolKeyword") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isTSUndefinedKeyword(node, opts) {
    if (!node) return false;
    if (node.type !== "TSUndefinedKeyword") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isTSUnknownKeyword(node, opts) {
    if (!node) return false;
    if (node.type !== "TSUnknownKeyword") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isTSVoidKeyword(node, opts) {
    if (!node) return false;
    if (node.type !== "TSVoidKeyword") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isTSThisType(node, opts) {
    if (!node) return false;
    if (node.type !== "TSThisType") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isTSFunctionType(node, opts) {
    if (!node) return false;
    if (node.type !== "TSFunctionType") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isTSConstructorType(node, opts) {
    if (!node) return false;
    if (node.type !== "TSConstructorType") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isTSTypeReference$1(node, opts) {
    if (!node) return false;
    if (node.type !== "TSTypeReference") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isTSTypePredicate(node, opts) {
    if (!node) return false;
    if (node.type !== "TSTypePredicate") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isTSTypeQuery(node, opts) {
    if (!node) return false;
    if (node.type !== "TSTypeQuery") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isTSTypeLiteral(node, opts) {
    if (!node) return false;
    if (node.type !== "TSTypeLiteral") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isTSArrayType$1(node, opts) {
    if (!node) return false;
    if (node.type !== "TSArrayType") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isTSTupleType(node, opts) {
    if (!node) return false;
    if (node.type !== "TSTupleType") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isTSOptionalType(node, opts) {
    if (!node) return false;
    if (node.type !== "TSOptionalType") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isTSRestType(node, opts) {
    if (!node) return false;
    if (node.type !== "TSRestType") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isTSNamedTupleMember(node, opts) {
    if (!node) return false;
    if (node.type !== "TSNamedTupleMember") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isTSUnionType(node, opts) {
    if (!node) return false;
    if (node.type !== "TSUnionType") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isTSIntersectionType(node, opts) {
    if (!node) return false;
    if (node.type !== "TSIntersectionType") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isTSConditionalType(node, opts) {
    if (!node) return false;
    if (node.type !== "TSConditionalType") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isTSInferType(node, opts) {
    if (!node) return false;
    if (node.type !== "TSInferType") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isTSParenthesizedType(node, opts) {
    if (!node) return false;
    if (node.type !== "TSParenthesizedType") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isTSTypeOperator(node, opts) {
    if (!node) return false;
    if (node.type !== "TSTypeOperator") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isTSIndexedAccessType(node, opts) {
    if (!node) return false;
    if (node.type !== "TSIndexedAccessType") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isTSMappedType(node, opts) {
    if (!node) return false;
    if (node.type !== "TSMappedType") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isTSTemplateLiteralType(node, opts) {
    if (!node) return false;
    if (node.type !== "TSTemplateLiteralType") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isTSLiteralType(node, opts) {
    if (!node) return false;
    if (node.type !== "TSLiteralType") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isTSExpressionWithTypeArguments(node, opts) {
    if (!node) return false;
    if (node.type !== "TSExpressionWithTypeArguments") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isTSInterfaceDeclaration(node, opts) {
    if (!node) return false;
    if (node.type !== "TSInterfaceDeclaration") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isTSInterfaceBody$1(node, opts) {
    if (!node) return false;
    if (node.type !== "TSInterfaceBody") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isTSTypeAliasDeclaration(node, opts) {
    if (!node) return false;
    if (node.type !== "TSTypeAliasDeclaration") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isTSInstantiationExpression(node, opts) {
    if (!node) return false;
    if (node.type !== "TSInstantiationExpression") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isTSAsExpression$1(node, opts) {
    if (!node) return false;
    if (node.type !== "TSAsExpression") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isTSSatisfiesExpression$1(node, opts) {
    if (!node) return false;
    if (node.type !== "TSSatisfiesExpression") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isTSTypeAssertion$1(node, opts) {
    if (!node) return false;
    if (node.type !== "TSTypeAssertion") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isTSEnumBody(node, opts) {
    if (!node) return false;
    if (node.type !== "TSEnumBody") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isTSEnumDeclaration(node, opts) {
    if (!node) return false;
    if (node.type !== "TSEnumDeclaration") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isTSEnumMember$1(node, opts) {
    if (!node) return false;
    if (node.type !== "TSEnumMember") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isTSModuleDeclaration(node, opts) {
    if (!node) return false;
    if (node.type !== "TSModuleDeclaration") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isTSModuleBlock(node, opts) {
    if (!node) return false;
    if (node.type !== "TSModuleBlock") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isTSImportType(node, opts) {
    if (!node) return false;
    if (node.type !== "TSImportType") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isTSImportEqualsDeclaration(node, opts) {
    if (!node) return false;
    if (node.type !== "TSImportEqualsDeclaration") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isTSExternalModuleReference(node, opts) {
    if (!node) return false;
    if (node.type !== "TSExternalModuleReference") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isTSNonNullExpression$1(node, opts) {
    if (!node) return false;
    if (node.type !== "TSNonNullExpression") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isTSExportAssignment(node, opts) {
    if (!node) return false;
    if (node.type !== "TSExportAssignment") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isTSNamespaceExportDeclaration(node, opts) {
    if (!node) return false;
    if (node.type !== "TSNamespaceExportDeclaration") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isTSTypeAnnotation$1(node, opts) {
    if (!node) return false;
    if (node.type !== "TSTypeAnnotation") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isTSTypeParameterInstantiation(node, opts) {
    if (!node) return false;
    if (node.type !== "TSTypeParameterInstantiation") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isTSTypeParameterDeclaration(node, opts) {
    if (!node) return false;
    if (node.type !== "TSTypeParameterDeclaration") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isTSTypeParameter(node, opts) {
    if (!node) return false;
    if (node.type !== "TSTypeParameter") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isStandardized(node, opts) {
    if (!node) return false;
    switch (node.type) {
      case "ArrayExpression":
      case "AssignmentExpression":
      case "BinaryExpression":
      case "InterpreterDirective":
      case "Directive":
      case "DirectiveLiteral":
      case "BlockStatement":
      case "BreakStatement":
      case "CallExpression":
      case "CatchClause":
      case "ConditionalExpression":
      case "ContinueStatement":
      case "DebuggerStatement":
      case "DoWhileStatement":
      case "EmptyStatement":
      case "ExpressionStatement":
      case "File":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "Identifier":
      case "IfStatement":
      case "LabeledStatement":
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "LogicalExpression":
      case "MemberExpression":
      case "NewExpression":
      case "Program":
      case "ObjectExpression":
      case "ObjectMethod":
      case "ObjectProperty":
      case "RestElement":
      case "ReturnStatement":
      case "SequenceExpression":
      case "ParenthesizedExpression":
      case "SwitchCase":
      case "SwitchStatement":
      case "ThisExpression":
      case "ThrowStatement":
      case "TryStatement":
      case "UnaryExpression":
      case "UpdateExpression":
      case "VariableDeclaration":
      case "VariableDeclarator":
      case "WhileStatement":
      case "WithStatement":
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ArrowFunctionExpression":
      case "ClassBody":
      case "ClassExpression":
      case "ClassDeclaration":
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ExportSpecifier":
      case "ForOfStatement":
      case "ImportDeclaration":
      case "ImportDefaultSpecifier":
      case "ImportNamespaceSpecifier":
      case "ImportSpecifier":
      case "ImportExpression":
      case "MetaProperty":
      case "ClassMethod":
      case "ObjectPattern":
      case "SpreadElement":
      case "Super":
      case "TaggedTemplateExpression":
      case "TemplateElement":
      case "TemplateLiteral":
      case "YieldExpression":
      case "AwaitExpression":
      case "Import":
      case "BigIntLiteral":
      case "ExportNamespaceSpecifier":
      case "OptionalMemberExpression":
      case "OptionalCallExpression":
      case "ClassProperty":
      case "ClassAccessorProperty":
      case "ClassPrivateProperty":
      case "ClassPrivateMethod":
      case "PrivateName":
      case "StaticBlock":
      case "ImportAttribute":
        break;
      case "Placeholder":
        switch (node.expectedNode) {
          case "Identifier":
          case "StringLiteral":
          case "BlockStatement":
          case "ClassBody":
            break;
          default:
            return false;
        }
        break;
      default:
        return false;
    }
    return opts == null || shallowEqual(node, opts);
  }
  function isExpression$5(node, opts) {
    if (!node) return false;
    switch (node.type) {
      case "ArrayExpression":
      case "AssignmentExpression":
      case "BinaryExpression":
      case "CallExpression":
      case "ConditionalExpression":
      case "FunctionExpression":
      case "Identifier":
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "LogicalExpression":
      case "MemberExpression":
      case "NewExpression":
      case "ObjectExpression":
      case "SequenceExpression":
      case "ParenthesizedExpression":
      case "ThisExpression":
      case "UnaryExpression":
      case "UpdateExpression":
      case "ArrowFunctionExpression":
      case "ClassExpression":
      case "ImportExpression":
      case "MetaProperty":
      case "Super":
      case "TaggedTemplateExpression":
      case "TemplateLiteral":
      case "YieldExpression":
      case "AwaitExpression":
      case "Import":
      case "BigIntLiteral":
      case "OptionalMemberExpression":
      case "OptionalCallExpression":
      case "TypeCastExpression":
      case "JSXElement":
      case "JSXFragment":
      case "BindExpression":
      case "DoExpression":
      case "RecordExpression":
      case "TupleExpression":
      case "DecimalLiteral":
      case "ModuleExpression":
      case "TopicReference":
      case "PipelineTopicExpression":
      case "PipelineBareFunction":
      case "PipelinePrimaryTopicReference":
      case "TSInstantiationExpression":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSNonNullExpression":
        break;
      case "Placeholder":
        switch (node.expectedNode) {
          case "Expression":
          case "Identifier":
          case "StringLiteral":
            break;
          default:
            return false;
        }
        break;
      default:
        return false;
    }
    return opts == null || shallowEqual(node, opts);
  }
  function isBinary$2(node, opts) {
    if (!node) return false;
    switch (node.type) {
      case "BinaryExpression":
      case "LogicalExpression":
        break;
      default:
        return false;
    }
    return opts == null || shallowEqual(node, opts);
  }
  function isScopable(node, opts) {
    if (!node) return false;
    switch (node.type) {
      case "BlockStatement":
      case "CatchClause":
      case "DoWhileStatement":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "Program":
      case "ObjectMethod":
      case "SwitchStatement":
      case "WhileStatement":
      case "ArrowFunctionExpression":
      case "ClassExpression":
      case "ClassDeclaration":
      case "ForOfStatement":
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "StaticBlock":
      case "TSModuleBlock":
        break;
      case "Placeholder":
        if (node.expectedNode === "BlockStatement") break;
      default:
        return false;
    }
    return opts == null || shallowEqual(node, opts);
  }
  function isBlockParent(node, opts) {
    if (!node) return false;
    switch (node.type) {
      case "BlockStatement":
      case "CatchClause":
      case "DoWhileStatement":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "Program":
      case "ObjectMethod":
      case "SwitchStatement":
      case "WhileStatement":
      case "ArrowFunctionExpression":
      case "ForOfStatement":
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "StaticBlock":
      case "TSModuleBlock":
        break;
      case "Placeholder":
        if (node.expectedNode === "BlockStatement") break;
      default:
        return false;
    }
    return opts == null || shallowEqual(node, opts);
  }
  function isBlock(node, opts) {
    if (!node) return false;
    switch (node.type) {
      case "BlockStatement":
      case "Program":
      case "TSModuleBlock":
        break;
      case "Placeholder":
        if (node.expectedNode === "BlockStatement") break;
      default:
        return false;
    }
    return opts == null || shallowEqual(node, opts);
  }
  function isStatement$9(node, opts) {
    if (!node) return false;
    switch (node.type) {
      case "BlockStatement":
      case "BreakStatement":
      case "ContinueStatement":
      case "DebuggerStatement":
      case "DoWhileStatement":
      case "EmptyStatement":
      case "ExpressionStatement":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "IfStatement":
      case "LabeledStatement":
      case "ReturnStatement":
      case "SwitchStatement":
      case "ThrowStatement":
      case "TryStatement":
      case "VariableDeclaration":
      case "WhileStatement":
      case "WithStatement":
      case "ClassDeclaration":
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ForOfStatement":
      case "ImportDeclaration":
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "InterfaceDeclaration":
      case "OpaqueType":
      case "TypeAlias":
      case "EnumDeclaration":
      case "TSDeclareFunction":
      case "TSInterfaceDeclaration":
      case "TSTypeAliasDeclaration":
      case "TSEnumDeclaration":
      case "TSModuleDeclaration":
      case "TSImportEqualsDeclaration":
      case "TSExportAssignment":
      case "TSNamespaceExportDeclaration":
        break;
      case "Placeholder":
        switch (node.expectedNode) {
          case "Statement":
          case "Declaration":
          case "BlockStatement":
            break;
          default:
            return false;
        }
        break;
      default:
        return false;
    }
    return opts == null || shallowEqual(node, opts);
  }
  function isTerminatorless(node, opts) {
    if (!node) return false;
    switch (node.type) {
      case "BreakStatement":
      case "ContinueStatement":
      case "ReturnStatement":
      case "ThrowStatement":
      case "YieldExpression":
      case "AwaitExpression":
        break;
      default:
        return false;
    }
    return opts == null || shallowEqual(node, opts);
  }
  function isCompletionStatement(node, opts) {
    if (!node) return false;
    switch (node.type) {
      case "BreakStatement":
      case "ContinueStatement":
      case "ReturnStatement":
      case "ThrowStatement":
        break;
      default:
        return false;
    }
    return opts == null || shallowEqual(node, opts);
  }
  function isConditional(node, opts) {
    if (!node) return false;
    switch (node.type) {
      case "ConditionalExpression":
      case "IfStatement":
        break;
      default:
        return false;
    }
    return opts == null || shallowEqual(node, opts);
  }
  function isLoop$1(node, opts) {
    if (!node) return false;
    switch (node.type) {
      case "DoWhileStatement":
      case "ForInStatement":
      case "ForStatement":
      case "WhileStatement":
      case "ForOfStatement":
        break;
      default:
        return false;
    }
    return opts == null || shallowEqual(node, opts);
  }
  function isWhile(node, opts) {
    if (!node) return false;
    switch (node.type) {
      case "DoWhileStatement":
      case "WhileStatement":
        break;
      default:
        return false;
    }
    return opts == null || shallowEqual(node, opts);
  }
  function isExpressionWrapper(node, opts) {
    if (!node) return false;
    switch (node.type) {
      case "ExpressionStatement":
      case "ParenthesizedExpression":
      case "TypeCastExpression":
        break;
      default:
        return false;
    }
    return opts == null || shallowEqual(node, opts);
  }
  function isFor$1(node, opts) {
    if (!node) return false;
    switch (node.type) {
      case "ForInStatement":
      case "ForStatement":
      case "ForOfStatement":
        break;
      default:
        return false;
    }
    return opts == null || shallowEqual(node, opts);
  }
  function isForXStatement$1(node, opts) {
    if (!node) return false;
    switch (node.type) {
      case "ForInStatement":
      case "ForOfStatement":
        break;
      default:
        return false;
    }
    return opts == null || shallowEqual(node, opts);
  }
  function isFunction$6(node, opts) {
    if (!node) return false;
    switch (node.type) {
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "ObjectMethod":
      case "ArrowFunctionExpression":
      case "ClassMethod":
      case "ClassPrivateMethod":
        break;
      default:
        return false;
    }
    return opts == null || shallowEqual(node, opts);
  }
  function isFunctionParent(node, opts) {
    if (!node) return false;
    switch (node.type) {
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "ObjectMethod":
      case "ArrowFunctionExpression":
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "StaticBlock":
      case "TSModuleBlock":
        break;
      default:
        return false;
    }
    return opts == null || shallowEqual(node, opts);
  }
  function isPureish$1(node, opts) {
    if (!node) return false;
    switch (node.type) {
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "ArrowFunctionExpression":
      case "BigIntLiteral":
      case "DecimalLiteral":
        break;
      case "Placeholder":
        if (node.expectedNode === "StringLiteral") break;
      default:
        return false;
    }
    return opts == null || shallowEqual(node, opts);
  }
  function isDeclaration(node, opts) {
    if (!node) return false;
    switch (node.type) {
      case "FunctionDeclaration":
      case "VariableDeclaration":
      case "ClassDeclaration":
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ImportDeclaration":
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "InterfaceDeclaration":
      case "OpaqueType":
      case "TypeAlias":
      case "EnumDeclaration":
      case "TSDeclareFunction":
      case "TSInterfaceDeclaration":
      case "TSTypeAliasDeclaration":
      case "TSEnumDeclaration":
      case "TSModuleDeclaration":
      case "TSImportEqualsDeclaration":
        break;
      case "Placeholder":
        if (node.expectedNode === "Declaration") break;
      default:
        return false;
    }
    return opts == null || shallowEqual(node, opts);
  }
  function isFunctionParameter(node, opts) {
    if (!node) return false;
    switch (node.type) {
      case "Identifier":
      case "RestElement":
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ObjectPattern":
      case "VoidPattern":
        break;
      case "Placeholder":
        if (node.expectedNode === "Identifier") break;
      default:
        return false;
    }
    return opts == null || shallowEqual(node, opts);
  }
  function isPatternLike(node, opts) {
    if (!node) return false;
    switch (node.type) {
      case "Identifier":
      case "MemberExpression":
      case "RestElement":
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ObjectPattern":
      case "VoidPattern":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSNonNullExpression":
        break;
      case "Placeholder":
        switch (node.expectedNode) {
          case "Pattern":
          case "Identifier":
            break;
          default:
            return false;
        }
        break;
      default:
        return false;
    }
    return opts == null || shallowEqual(node, opts);
  }
  function isLVal(node, opts) {
    if (!node) return false;
    switch (node.type) {
      case "Identifier":
      case "MemberExpression":
      case "RestElement":
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ObjectPattern":
      case "TSParameterProperty":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSNonNullExpression":
        break;
      case "Placeholder":
        switch (node.expectedNode) {
          case "Pattern":
          case "Identifier":
            break;
          default:
            return false;
        }
        break;
      default:
        return false;
    }
    return opts == null || shallowEqual(node, opts);
  }
  function isTSEntityName(node, opts) {
    if (!node) return false;
    switch (node.type) {
      case "Identifier":
      case "TSQualifiedName":
        break;
      case "Placeholder":
        if (node.expectedNode === "Identifier") break;
      default:
        return false;
    }
    return opts == null || shallowEqual(node, opts);
  }
  function isLiteral$4(node, opts) {
    if (!node) return false;
    switch (node.type) {
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "TemplateLiteral":
      case "BigIntLiteral":
      case "DecimalLiteral":
        break;
      case "Placeholder":
        if (node.expectedNode === "StringLiteral") break;
      default:
        return false;
    }
    return opts == null || shallowEqual(node, opts);
  }
  function isUserWhitespacable(node, opts) {
    if (!node) return false;
    switch (node.type) {
      case "ObjectMethod":
      case "ObjectProperty":
      case "ObjectTypeInternalSlot":
      case "ObjectTypeCallProperty":
      case "ObjectTypeIndexer":
      case "ObjectTypeProperty":
      case "ObjectTypeSpreadProperty":
        break;
      default:
        return false;
    }
    return opts == null || shallowEqual(node, opts);
  }
  function isMethod$1(node, opts) {
    if (!node) return false;
    switch (node.type) {
      case "ObjectMethod":
      case "ClassMethod":
      case "ClassPrivateMethod":
        break;
      default:
        return false;
    }
    return opts == null || shallowEqual(node, opts);
  }
  function isObjectMember(node, opts) {
    if (!node) return false;
    switch (node.type) {
      case "ObjectMethod":
      case "ObjectProperty":
        break;
      default:
        return false;
    }
    return opts == null || shallowEqual(node, opts);
  }
  function isProperty$1(node, opts) {
    if (!node) return false;
    switch (node.type) {
      case "ObjectProperty":
      case "ClassProperty":
      case "ClassAccessorProperty":
      case "ClassPrivateProperty":
        break;
      default:
        return false;
    }
    return opts == null || shallowEqual(node, opts);
  }
  function isUnaryLike(node, opts) {
    if (!node) return false;
    switch (node.type) {
      case "UnaryExpression":
      case "SpreadElement":
        break;
      default:
        return false;
    }
    return opts == null || shallowEqual(node, opts);
  }
  function isPattern$2(node, opts) {
    if (!node) return false;
    switch (node.type) {
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ObjectPattern":
      case "VoidPattern":
        break;
      case "Placeholder":
        if (node.expectedNode === "Pattern") break;
      default:
        return false;
    }
    return opts == null || shallowEqual(node, opts);
  }
  function isClass$1(node, opts) {
    if (!node) return false;
    switch (node.type) {
      case "ClassExpression":
      case "ClassDeclaration":
        break;
      default:
        return false;
    }
    return opts == null || shallowEqual(node, opts);
  }
  function isImportOrExportDeclaration(node, opts) {
    if (!node) return false;
    switch (node.type) {
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ImportDeclaration":
        break;
      default:
        return false;
    }
    return opts == null || shallowEqual(node, opts);
  }
  function isExportDeclaration$2(node, opts) {
    if (!node) return false;
    switch (node.type) {
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
        break;
      default:
        return false;
    }
    return opts == null || shallowEqual(node, opts);
  }
  function isModuleSpecifier$1(node, opts) {
    if (!node) return false;
    switch (node.type) {
      case "ExportSpecifier":
      case "ImportDefaultSpecifier":
      case "ImportNamespaceSpecifier":
      case "ImportSpecifier":
      case "ExportNamespaceSpecifier":
      case "ExportDefaultSpecifier":
        break;
      default:
        return false;
    }
    return opts == null || shallowEqual(node, opts);
  }
  function isAccessor(node, opts) {
    if (!node) return false;
    switch (node.type) {
      case "ClassAccessorProperty":
        break;
      default:
        return false;
    }
    return opts == null || shallowEqual(node, opts);
  }
  function isPrivate(node, opts) {
    if (!node) return false;
    switch (node.type) {
      case "ClassPrivateProperty":
      case "ClassPrivateMethod":
      case "PrivateName":
        break;
      default:
        return false;
    }
    return opts == null || shallowEqual(node, opts);
  }
  function isFlow$1(node, opts) {
    if (!node) return false;
    switch (node.type) {
      case "AnyTypeAnnotation":
      case "ArrayTypeAnnotation":
      case "BooleanTypeAnnotation":
      case "BooleanLiteralTypeAnnotation":
      case "NullLiteralTypeAnnotation":
      case "ClassImplements":
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "DeclaredPredicate":
      case "ExistsTypeAnnotation":
      case "FunctionTypeAnnotation":
      case "FunctionTypeParam":
      case "GenericTypeAnnotation":
      case "InferredPredicate":
      case "InterfaceExtends":
      case "InterfaceDeclaration":
      case "InterfaceTypeAnnotation":
      case "IntersectionTypeAnnotation":
      case "MixedTypeAnnotation":
      case "EmptyTypeAnnotation":
      case "NullableTypeAnnotation":
      case "NumberLiteralTypeAnnotation":
      case "NumberTypeAnnotation":
      case "ObjectTypeAnnotation":
      case "ObjectTypeInternalSlot":
      case "ObjectTypeCallProperty":
      case "ObjectTypeIndexer":
      case "ObjectTypeProperty":
      case "ObjectTypeSpreadProperty":
      case "OpaqueType":
      case "QualifiedTypeIdentifier":
      case "StringLiteralTypeAnnotation":
      case "StringTypeAnnotation":
      case "SymbolTypeAnnotation":
      case "ThisTypeAnnotation":
      case "TupleTypeAnnotation":
      case "TypeofTypeAnnotation":
      case "TypeAlias":
      case "TypeAnnotation":
      case "TypeCastExpression":
      case "TypeParameter":
      case "TypeParameterDeclaration":
      case "TypeParameterInstantiation":
      case "UnionTypeAnnotation":
      case "Variance":
      case "VoidTypeAnnotation":
      case "EnumDeclaration":
      case "EnumBooleanBody":
      case "EnumNumberBody":
      case "EnumStringBody":
      case "EnumSymbolBody":
      case "EnumBooleanMember":
      case "EnumNumberMember":
      case "EnumStringMember":
      case "EnumDefaultedMember":
      case "IndexedAccessType":
      case "OptionalIndexedAccessType":
        break;
      default:
        return false;
    }
    return opts == null || shallowEqual(node, opts);
  }
  function isFlowType$1(node, opts) {
    if (!node) return false;
    switch (node.type) {
      case "AnyTypeAnnotation":
      case "ArrayTypeAnnotation":
      case "BooleanTypeAnnotation":
      case "BooleanLiteralTypeAnnotation":
      case "NullLiteralTypeAnnotation":
      case "ExistsTypeAnnotation":
      case "FunctionTypeAnnotation":
      case "GenericTypeAnnotation":
      case "InterfaceTypeAnnotation":
      case "IntersectionTypeAnnotation":
      case "MixedTypeAnnotation":
      case "EmptyTypeAnnotation":
      case "NullableTypeAnnotation":
      case "NumberLiteralTypeAnnotation":
      case "NumberTypeAnnotation":
      case "ObjectTypeAnnotation":
      case "StringLiteralTypeAnnotation":
      case "StringTypeAnnotation":
      case "SymbolTypeAnnotation":
      case "ThisTypeAnnotation":
      case "TupleTypeAnnotation":
      case "TypeofTypeAnnotation":
      case "UnionTypeAnnotation":
      case "VoidTypeAnnotation":
      case "IndexedAccessType":
      case "OptionalIndexedAccessType":
        break;
      default:
        return false;
    }
    return opts == null || shallowEqual(node, opts);
  }
  function isFlowBaseAnnotation$1(node, opts) {
    if (!node) return false;
    switch (node.type) {
      case "AnyTypeAnnotation":
      case "BooleanTypeAnnotation":
      case "NullLiteralTypeAnnotation":
      case "MixedTypeAnnotation":
      case "EmptyTypeAnnotation":
      case "NumberTypeAnnotation":
      case "StringTypeAnnotation":
      case "SymbolTypeAnnotation":
      case "ThisTypeAnnotation":
      case "VoidTypeAnnotation":
        break;
      default:
        return false;
    }
    return opts == null || shallowEqual(node, opts);
  }
  function isFlowDeclaration(node, opts) {
    if (!node) return false;
    switch (node.type) {
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "InterfaceDeclaration":
      case "OpaqueType":
      case "TypeAlias":
        break;
      default:
        return false;
    }
    return opts == null || shallowEqual(node, opts);
  }
  function isFlowPredicate(node, opts) {
    if (!node) return false;
    switch (node.type) {
      case "DeclaredPredicate":
      case "InferredPredicate":
        break;
      default:
        return false;
    }
    return opts == null || shallowEqual(node, opts);
  }
  function isEnumBody(node, opts) {
    if (!node) return false;
    switch (node.type) {
      case "EnumBooleanBody":
      case "EnumNumberBody":
      case "EnumStringBody":
      case "EnumSymbolBody":
        break;
      default:
        return false;
    }
    return opts == null || shallowEqual(node, opts);
  }
  function isEnumMember(node, opts) {
    if (!node) return false;
    switch (node.type) {
      case "EnumBooleanMember":
      case "EnumNumberMember":
      case "EnumStringMember":
      case "EnumDefaultedMember":
        break;
      default:
        return false;
    }
    return opts == null || shallowEqual(node, opts);
  }
  function isJSX(node, opts) {
    if (!node) return false;
    switch (node.type) {
      case "JSXAttribute":
      case "JSXClosingElement":
      case "JSXElement":
      case "JSXEmptyExpression":
      case "JSXExpressionContainer":
      case "JSXSpreadChild":
      case "JSXIdentifier":
      case "JSXMemberExpression":
      case "JSXNamespacedName":
      case "JSXOpeningElement":
      case "JSXSpreadAttribute":
      case "JSXText":
      case "JSXFragment":
      case "JSXOpeningFragment":
      case "JSXClosingFragment":
        break;
      default:
        return false;
    }
    return opts == null || shallowEqual(node, opts);
  }
  function isMiscellaneous(node, opts) {
    if (!node) return false;
    switch (node.type) {
      case "Noop":
      case "Placeholder":
      case "V8IntrinsicIdentifier":
        break;
      default:
        return false;
    }
    return opts == null || shallowEqual(node, opts);
  }
  function isTypeScript(node, opts) {
    if (!node) return false;
    switch (node.type) {
      case "TSParameterProperty":
      case "TSDeclareFunction":
      case "TSDeclareMethod":
      case "TSQualifiedName":
      case "TSCallSignatureDeclaration":
      case "TSConstructSignatureDeclaration":
      case "TSPropertySignature":
      case "TSMethodSignature":
      case "TSIndexSignature":
      case "TSAnyKeyword":
      case "TSBooleanKeyword":
      case "TSBigIntKeyword":
      case "TSIntrinsicKeyword":
      case "TSNeverKeyword":
      case "TSNullKeyword":
      case "TSNumberKeyword":
      case "TSObjectKeyword":
      case "TSStringKeyword":
      case "TSSymbolKeyword":
      case "TSUndefinedKeyword":
      case "TSUnknownKeyword":
      case "TSVoidKeyword":
      case "TSThisType":
      case "TSFunctionType":
      case "TSConstructorType":
      case "TSTypeReference":
      case "TSTypePredicate":
      case "TSTypeQuery":
      case "TSTypeLiteral":
      case "TSArrayType":
      case "TSTupleType":
      case "TSOptionalType":
      case "TSRestType":
      case "TSNamedTupleMember":
      case "TSUnionType":
      case "TSIntersectionType":
      case "TSConditionalType":
      case "TSInferType":
      case "TSParenthesizedType":
      case "TSTypeOperator":
      case "TSIndexedAccessType":
      case "TSMappedType":
      case "TSTemplateLiteralType":
      case "TSLiteralType":
      case "TSExpressionWithTypeArguments":
      case "TSInterfaceDeclaration":
      case "TSInterfaceBody":
      case "TSTypeAliasDeclaration":
      case "TSInstantiationExpression":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSEnumBody":
      case "TSEnumDeclaration":
      case "TSEnumMember":
      case "TSModuleDeclaration":
      case "TSModuleBlock":
      case "TSImportType":
      case "TSImportEqualsDeclaration":
      case "TSExternalModuleReference":
      case "TSNonNullExpression":
      case "TSExportAssignment":
      case "TSNamespaceExportDeclaration":
      case "TSTypeAnnotation":
      case "TSTypeParameterInstantiation":
      case "TSTypeParameterDeclaration":
      case "TSTypeParameter":
        break;
      default:
        return false;
    }
    return opts == null || shallowEqual(node, opts);
  }
  function isTSTypeElement(node, opts) {
    if (!node) return false;
    switch (node.type) {
      case "TSCallSignatureDeclaration":
      case "TSConstructSignatureDeclaration":
      case "TSPropertySignature":
      case "TSMethodSignature":
      case "TSIndexSignature":
        break;
      default:
        return false;
    }
    return opts == null || shallowEqual(node, opts);
  }
  function isTSType$1(node, opts) {
    if (!node) return false;
    switch (node.type) {
      case "TSAnyKeyword":
      case "TSBooleanKeyword":
      case "TSBigIntKeyword":
      case "TSIntrinsicKeyword":
      case "TSNeverKeyword":
      case "TSNullKeyword":
      case "TSNumberKeyword":
      case "TSObjectKeyword":
      case "TSStringKeyword":
      case "TSSymbolKeyword":
      case "TSUndefinedKeyword":
      case "TSUnknownKeyword":
      case "TSVoidKeyword":
      case "TSThisType":
      case "TSFunctionType":
      case "TSConstructorType":
      case "TSTypeReference":
      case "TSTypePredicate":
      case "TSTypeQuery":
      case "TSTypeLiteral":
      case "TSArrayType":
      case "TSTupleType":
      case "TSOptionalType":
      case "TSRestType":
      case "TSUnionType":
      case "TSIntersectionType":
      case "TSConditionalType":
      case "TSInferType":
      case "TSParenthesizedType":
      case "TSTypeOperator":
      case "TSIndexedAccessType":
      case "TSMappedType":
      case "TSTemplateLiteralType":
      case "TSLiteralType":
      case "TSExpressionWithTypeArguments":
      case "TSImportType":
        break;
      default:
        return false;
    }
    return opts == null || shallowEqual(node, opts);
  }
  function isTSBaseType(node, opts) {
    if (!node) return false;
    switch (node.type) {
      case "TSAnyKeyword":
      case "TSBooleanKeyword":
      case "TSBigIntKeyword":
      case "TSIntrinsicKeyword":
      case "TSNeverKeyword":
      case "TSNullKeyword":
      case "TSNumberKeyword":
      case "TSObjectKeyword":
      case "TSStringKeyword":
      case "TSSymbolKeyword":
      case "TSUndefinedKeyword":
      case "TSUnknownKeyword":
      case "TSVoidKeyword":
      case "TSThisType":
      case "TSTemplateLiteralType":
      case "TSLiteralType":
        break;
      default:
        return false;
    }
    return opts == null || shallowEqual(node, opts);
  }
  function isNumberLiteral(node, opts) {
    deprecationWarning$1("isNumberLiteral", "isNumericLiteral");
    if (!node) return false;
    if (node.type !== "NumberLiteral") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isRegexLiteral(node, opts) {
    deprecationWarning$1("isRegexLiteral", "isRegExpLiteral");
    if (!node) return false;
    if (node.type !== "RegexLiteral") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isRestProperty$1(node, opts) {
    deprecationWarning$1("isRestProperty", "isRestElement");
    if (!node) return false;
    if (node.type !== "RestProperty") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isSpreadProperty$1(node, opts) {
    deprecationWarning$1("isSpreadProperty", "isSpreadElement");
    if (!node) return false;
    if (node.type !== "SpreadProperty") return false;
    return opts == null || shallowEqual(node, opts);
  }
  function isModuleDeclaration(node, opts) {
    deprecationWarning$1("isModuleDeclaration", "isImportOrExportDeclaration");
    return isImportOrExportDeclaration(node, opts);
  }

  function isMemberExpressionLike(node) {
    return isMemberExpression$7(node) || isMetaProperty$1(node);
  }
  function matchesPattern$2(member, match, allowPartial) {
    if (!isMemberExpressionLike(member)) return false;
    var parts = Array.isArray(match) ? match : match.split(".");
    var nodes = [];
    var node;
    for (node = member; isMemberExpressionLike(node); node = (_object = node.object) != null ? _object : node.meta) {
      var _object;
      nodes.push(node.property);
    }
    nodes.push(node);
    if (nodes.length < parts.length) return false;
    if (!allowPartial && nodes.length > parts.length) return false;
    for (var i = 0, j = nodes.length - 1; i < parts.length; i++, j--) {
      var _node = nodes[j];
      var value = void 0;
      if (isIdentifier$e(_node)) {
        value = _node.name;
      } else if (isStringLiteral$5(_node)) {
        value = _node.value;
      } else if (isThisExpression$2(_node)) {
        value = "this";
      } else if (isSuper$2(_node)) {
        value = "super";
      } else if (isPrivateName$2(_node)) {
        value = "#" + _node.id.name;
      } else {
        return false;
      }
      if (parts[i] !== value) return false;
    }
    return true;
  }

  function buildMatchMemberExpression$1(match, allowPartial) {
    var parts = match.split(".");
    return function (member) {
      return matchesPattern$2(member, parts, allowPartial);
    };
  }

  var isReactComponent = buildMatchMemberExpression$1("React.Component");

  function isCompatTag$1(tagName) {
    return !!tagName && /^[a-z]/.test(tagName);
  }

  function isType$2(nodeType, targetType) {
    if (nodeType === targetType) return true;
    if (nodeType == null) return false;
    if (ALIAS_KEYS[targetType]) return false;
    var aliases = FLIPPED_ALIAS_KEYS$3[targetType];
    if (aliases != null && aliases.includes(nodeType)) return true;
    return false;
  }

  function isPlaceholderType(placeholderType, targetType) {
    if (placeholderType === targetType) return true;
    var aliases = PLACEHOLDERS_ALIAS[placeholderType];
    if (aliases != null && aliases.includes(targetType)) return true;
    return false;
  }

  function is(type, node, opts) {
    if (!node) return false;
    var matches = isType$2(node.type, type);
    if (!matches) {
      if (!opts && node.type === "Placeholder" && type in FLIPPED_ALIAS_KEYS$3) {
        return isPlaceholderType(node.expectedNode, type);
      }
      return false;
    }
    if (opts === undefined) {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  var nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C8A\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CD\uA7D0\uA7D1\uA7D3\uA7D5-\uA7DC\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
  var nonASCIIidentifierChars = "\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0897-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65";
  var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
  var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
  nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
  var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 2, 60, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0, 2, 0, 45, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 42, 9, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 229, 29, 3, 0, 496, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191];
  var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 80, 3, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 68, 8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 343, 9, 54, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350, 0, 7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 726, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
  function isInAstralSet(code, set) {
    var pos = 0x10000;
    for (var i = 0, length = set.length; i < length; i += 2) {
      pos += set[i];
      if (pos > code) return false;
      pos += set[i + 1];
      if (pos >= code) return true;
    }
    return false;
  }
  function isIdentifierStart(code) {
    if (code < 65) return code === 36;
    if (code <= 90) return true;
    if (code < 97) return code === 95;
    if (code <= 122) return true;
    if (code <= 0xffff) {
      return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));
    }
    return isInAstralSet(code, astralIdentifierStartCodes);
  }
  function isIdentifierChar(code) {
    if (code < 48) return code === 36;
    if (code < 58) return true;
    if (code < 65) return false;
    if (code <= 90) return true;
    if (code < 97) return code === 95;
    if (code <= 122) return true;
    if (code <= 0xffff) {
      return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));
    }
    return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
  }
  function isIdentifierName(name) {
    var isFirst = true;
    for (var i = 0; i < name.length; i++) {
      var cp = name.charCodeAt(i);
      if ((cp & 0xfc00) === 0xd800 && i + 1 < name.length) {
        var trail = name.charCodeAt(++i);
        if ((trail & 0xfc00) === 0xdc00) {
          cp = 0x10000 + ((cp & 0x3ff) << 10) + (trail & 0x3ff);
        }
      }
      if (isFirst) {
        isFirst = false;
        if (!isIdentifierStart(cp)) {
          return false;
        }
      } else if (!isIdentifierChar(cp)) {
        return false;
      }
    }
    return !isFirst;
  }

  var reservedWords = {
    keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
    strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
    strictBind: ["eval", "arguments"]
  };
  var keywords$1 = new Set(reservedWords.keyword);
  var reservedWordsStrictSet = new Set(reservedWords.strict);
  var reservedWordsStrictBindSet = new Set(reservedWords.strictBind);
  function isReservedWord(word, inModule) {
    return inModule && word === "await" || word === "enum";
  }
  function isStrictReservedWord(word, inModule) {
    return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
  }
  function isStrictBindOnlyReservedWord(word) {
    return reservedWordsStrictBindSet.has(word);
  }
  function isStrictBindReservedWord(word, inModule) {
    return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);
  }
  function isKeyword(word) {
    return keywords$1.has(word);
  }

  function isValidIdentifier$1(name, reserved) {
    if (reserved === void 0) {
      reserved = true;
    }
    if (typeof name !== "string") return false;
    if (reserved) {
      if (isKeyword(name) || isStrictReservedWord(name, true)) {
        return false;
      }
    }
    return isIdentifierName(name);
  }

  var _isDigit = function isDigit(code) {
    return code >= 48 && code <= 57;
  };
  var forbiddenNumericSeparatorSiblings = {
    decBinOct: new Set([46, 66, 69, 79, 95, 98, 101, 111]),
    hex: new Set([46, 88, 95, 120])
  };
  var isAllowedNumericSeparatorSibling = {
    bin: function bin(ch) {
      return ch === 48 || ch === 49;
    },
    oct: function oct(ch) {
      return ch >= 48 && ch <= 55;
    },
    dec: function dec(ch) {
      return ch >= 48 && ch <= 57;
    },
    hex: function hex(ch) {
      return ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102;
    }
  };
  function readStringContents(type, input, pos, lineStart, curLine, errors) {
    var initialPos = pos;
    var initialLineStart = lineStart;
    var initialCurLine = curLine;
    var out = "";
    var firstInvalidLoc = null;
    var chunkStart = pos;
    var length = input.length;
    for (;;) {
      if (pos >= length) {
        errors.unterminated(initialPos, initialLineStart, initialCurLine);
        out += input.slice(chunkStart, pos);
        break;
      }
      var ch = input.charCodeAt(pos);
      if (isStringEnd(type, ch, input, pos)) {
        out += input.slice(chunkStart, pos);
        break;
      }
      if (ch === 92) {
        out += input.slice(chunkStart, pos);
        var res = readEscapedChar(input, pos, lineStart, curLine, type === "template", errors);
        if (res.ch === null && !firstInvalidLoc) {
          firstInvalidLoc = {
            pos: pos,
            lineStart: lineStart,
            curLine: curLine
          };
        } else {
          out += res.ch;
        }
        pos = res.pos;
        lineStart = res.lineStart;
        curLine = res.curLine;
        chunkStart = pos;
      } else if (ch === 8232 || ch === 8233) {
        ++pos;
        ++curLine;
        lineStart = pos;
      } else if (ch === 10 || ch === 13) {
        if (type === "template") {
          out += input.slice(chunkStart, pos) + "\n";
          ++pos;
          if (ch === 13 && input.charCodeAt(pos) === 10) {
            ++pos;
          }
          ++curLine;
          chunkStart = lineStart = pos;
        } else {
          errors.unterminated(initialPos, initialLineStart, initialCurLine);
        }
      } else {
        ++pos;
      }
    }
    return {
      pos: pos,
      str: out,
      firstInvalidLoc: firstInvalidLoc,
      lineStart: lineStart,
      curLine: curLine,
      containsInvalid: !!firstInvalidLoc
    };
  }
  function isStringEnd(type, ch, input, pos) {
    if (type === "template") {
      return ch === 96 || ch === 36 && input.charCodeAt(pos + 1) === 123;
    }
    return ch === (type === "double" ? 34 : 39);
  }
  function readEscapedChar(input, pos, lineStart, curLine, inTemplate, errors) {
    var throwOnInvalid = !inTemplate;
    pos++;
    var res = function res(ch) {
      return {
        pos: pos,
        ch: ch,
        lineStart: lineStart,
        curLine: curLine
      };
    };
    var ch = input.charCodeAt(pos++);
    switch (ch) {
      case 110:
        return res("\n");
      case 114:
        return res("\r");
      case 120:
        {
          var code;
          var _readHexChar = readHexChar(input, pos, lineStart, curLine, 2, false, throwOnInvalid, errors);
          code = _readHexChar.code;
          pos = _readHexChar.pos;
          return res(code === null ? null : String.fromCharCode(code));
        }
      case 117:
        {
          var _code;
          var _readCodePoint = readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors);
          _code = _readCodePoint.code;
          pos = _readCodePoint.pos;
          return res(_code === null ? null : String.fromCodePoint(_code));
        }
      case 116:
        return res("\t");
      case 98:
        return res("\b");
      case 118:
        return res("\x0B");
      case 102:
        return res("\f");
      case 13:
        if (input.charCodeAt(pos) === 10) {
          ++pos;
        }
      case 10:
        lineStart = pos;
        ++curLine;
      case 8232:
      case 8233:
        return res("");
      case 56:
      case 57:
        if (inTemplate) {
          return res(null);
        } else {
          errors.strictNumericEscape(pos - 1, lineStart, curLine);
        }
      default:
        if (ch >= 48 && ch <= 55) {
          var startPos = pos - 1;
          var match = /^[0-7]+/.exec(input.slice(startPos, pos + 2));
          var octalStr = match[0];
          var octal = parseInt(octalStr, 8);
          if (octal > 255) {
            octalStr = octalStr.slice(0, -1);
            octal = parseInt(octalStr, 8);
          }
          pos += octalStr.length - 1;
          var next = input.charCodeAt(pos);
          if (octalStr !== "0" || next === 56 || next === 57) {
            if (inTemplate) {
              return res(null);
            } else {
              errors.strictNumericEscape(startPos, lineStart, curLine);
            }
          }
          return res(String.fromCharCode(octal));
        }
        return res(String.fromCharCode(ch));
    }
  }
  function readHexChar(input, pos, lineStart, curLine, len, forceLen, throwOnInvalid, errors) {
    var initialPos = pos;
    var n;
    var _readInt = readInt(input, pos, lineStart, curLine, 16, len, forceLen, false, errors, !throwOnInvalid);
    n = _readInt.n;
    pos = _readInt.pos;
    if (n === null) {
      if (throwOnInvalid) {
        errors.invalidEscapeSequence(initialPos, lineStart, curLine);
      } else {
        pos = initialPos - 1;
      }
    }
    return {
      code: n,
      pos: pos
    };
  }
  function readInt(input, pos, lineStart, curLine, radix, len, forceLen, allowNumSeparator, errors, bailOnError) {
    var start = pos;
    var forbiddenSiblings = radix === 16 ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct;
    var isAllowedSibling = radix === 16 ? isAllowedNumericSeparatorSibling.hex : radix === 10 ? isAllowedNumericSeparatorSibling.dec : radix === 8 ? isAllowedNumericSeparatorSibling.oct : isAllowedNumericSeparatorSibling.bin;
    var invalid = false;
    var total = 0;
    for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {
      var code = input.charCodeAt(pos);
      var val = void 0;
      if (code === 95 && allowNumSeparator !== "bail") {
        var prev = input.charCodeAt(pos - 1);
        var next = input.charCodeAt(pos + 1);
        if (!allowNumSeparator) {
          if (bailOnError) return {
            n: null,
            pos: pos
          };
          errors.numericSeparatorInEscapeSequence(pos, lineStart, curLine);
        } else if (Number.isNaN(next) || !isAllowedSibling(next) || forbiddenSiblings.has(prev) || forbiddenSiblings.has(next)) {
          if (bailOnError) return {
            n: null,
            pos: pos
          };
          errors.unexpectedNumericSeparator(pos, lineStart, curLine);
        }
        ++pos;
        continue;
      }
      if (code >= 97) {
        val = code - 97 + 10;
      } else if (code >= 65) {
        val = code - 65 + 10;
      } else if (_isDigit(code)) {
        val = code - 48;
      } else {
        val = Infinity;
      }
      if (val >= radix) {
        if (val <= 9 && bailOnError) {
          return {
            n: null,
            pos: pos
          };
        } else if (val <= 9 && errors.invalidDigit(pos, lineStart, curLine, radix)) {
          val = 0;
        } else if (forceLen) {
          val = 0;
          invalid = true;
        } else {
          break;
        }
      }
      ++pos;
      total = total * radix + val;
    }
    if (pos === start || len != null && pos - start !== len || invalid) {
      return {
        n: null,
        pos: pos
      };
    }
    return {
      n: total,
      pos: pos
    };
  }
  function readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors) {
    var ch = input.charCodeAt(pos);
    var code;
    if (ch === 123) {
      ++pos;
      var _readHexChar2 = readHexChar(input, pos, lineStart, curLine, input.indexOf("}", pos) - pos, true, throwOnInvalid, errors);
      code = _readHexChar2.code;
      pos = _readHexChar2.pos;
      ++pos;
      if (code !== null && code > 0x10ffff) {
        if (throwOnInvalid) {
          errors.invalidCodePoint(pos, lineStart, curLine);
        } else {
          return {
            code: null,
            pos: pos
          };
        }
      }
    } else {
      var _readHexChar3 = readHexChar(input, pos, lineStart, curLine, 4, false, throwOnInvalid, errors);
      code = _readHexChar3.code;
      pos = _readHexChar3.pos;
    }
    return {
      code: code,
      pos: pos
    };
  }

  var STATEMENT_OR_BLOCK_KEYS$1 = ["consequent", "body", "alternate"];
  var FLATTENABLE_KEYS = ["body", "expressions"];
  var FOR_INIT_KEYS = ["left", "init"];
  var COMMENT_KEYS = ["leadingComments", "trailingComments", "innerComments"];
  var LOGICAL_OPERATORS$2 = ["||", "&&", "??"];
  var UPDATE_OPERATORS = ["++", "--"];
  var BOOLEAN_NUMBER_BINARY_OPERATORS$1 = [">", "<", ">=", "<="];
  var EQUALITY_BINARY_OPERATORS = ["==", "===", "!=", "!=="];
  var COMPARISON_BINARY_OPERATORS = [].concat(EQUALITY_BINARY_OPERATORS, ["in", "instanceof"]);
  var BOOLEAN_BINARY_OPERATORS$1 = [].concat(_toConsumableArray(COMPARISON_BINARY_OPERATORS), BOOLEAN_NUMBER_BINARY_OPERATORS$1);
  var NUMBER_BINARY_OPERATORS$1 = ["-", "/", "%", "*", "**", "&", "|", ">>", ">>>", "<<", "^"];
  var BINARY_OPERATORS = ["+"].concat(NUMBER_BINARY_OPERATORS$1, _toConsumableArray(BOOLEAN_BINARY_OPERATORS$1), ["|>"]);
  var ASSIGNMENT_OPERATORS = ["=", "+="].concat(_toConsumableArray(NUMBER_BINARY_OPERATORS$1.map(function (op) {
    return op + "=";
  })), _toConsumableArray(LOGICAL_OPERATORS$2.map(function (op) {
    return op + "=";
  })));
  var BOOLEAN_UNARY_OPERATORS$1 = ["delete", "!"];
  var NUMBER_UNARY_OPERATORS$1 = ["+", "-", "~"];
  var STRING_UNARY_OPERATORS$1 = ["typeof"];
  var UNARY_OPERATORS = ["void", "throw"].concat(BOOLEAN_UNARY_OPERATORS$1, NUMBER_UNARY_OPERATORS$1, STRING_UNARY_OPERATORS$1);
  var INHERIT_KEYS = {
    optional: ["typeAnnotation", "typeParameters", "returnType"],
    force: ["start", "loc", "end"]
  };
  {
    exports.BLOCK_SCOPED_SYMBOL = Symbol["for"]("var used to be block scoped");
    exports.NOT_LOCAL_BINDING = Symbol["for"]("should not be considered a local binding");
  }

  var VISITOR_KEYS$7 = {};
  var ALIAS_KEYS = {};
  var FLIPPED_ALIAS_KEYS$3 = {};
  var NODE_FIELDS$1 = {};
  var BUILDER_KEYS = {};
  var DEPRECATED_KEYS$1 = {};
  var NODE_PARENT_VALIDATIONS = {};
  function getType(val) {
    if (Array.isArray(val)) {
      return "array";
    } else if (val === null) {
      return "null";
    } else {
      return typeof val;
    }
  }
  function validate$7(validate) {
    return {
      validate: validate
    };
  }
  function validateType() {
    return validate$7(assertNodeType.apply(void 0, arguments));
  }
  function validateOptional(validate) {
    return {
      validate: validate,
      optional: true
    };
  }
  function validateOptionalType() {
    return {
      validate: assertNodeType.apply(void 0, arguments),
      optional: true
    };
  }
  function arrayOf(elementType) {
    return chain(assertValueType("array"), assertEach(elementType));
  }
  function arrayOfType() {
    return arrayOf(assertNodeType.apply(void 0, arguments));
  }
  function validateArrayOfType() {
    return validate$7(arrayOfType.apply(void 0, arguments));
  }
  function assertEach(callback) {
    var childValidator = browser$1$1.env.BABEL_TYPES_8_BREAKING ? validateChild : function () {};
    function validator(node, key, val) {
      if (!Array.isArray(val)) return;
      var i = 0;
      var subKey = {
        toString: function toString() {
          return key + "[" + i + "]";
        }
      };
      for (; i < val.length; i++) {
        var v = val[i];
        callback(node, subKey, v);
        childValidator(node, subKey, v);
      }
    }
    validator.each = callback;
    return validator;
  }
  function assertOneOf() {
    for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {
      values[_key] = arguments[_key];
    }
    function validate(node, key, val) {
      if (!values.includes(val)) {
        throw new TypeError("Property " + key + " expected value to be one of " + JSON.stringify(values) + " but got " + JSON.stringify(val));
      }
    }
    validate.oneOf = values;
    return validate;
  }
  var allExpandedTypes = [];
  function assertNodeType() {
    for (var _len2 = arguments.length, types = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      types[_key2] = arguments[_key2];
    }
    var expandedTypes = new Set();
    allExpandedTypes.push({
      types: types,
      set: expandedTypes
    });
    function validate(node, key, val) {
      var valType = val == null ? void 0 : val.type;
      if (valType != null) {
        if (expandedTypes.has(valType)) {
          validateChild(node, key, val);
          return;
        }
        if (valType === "Placeholder") {
          for (var _iterator = _createForOfIteratorHelperLoose(types), _step; !(_step = _iterator()).done;) {
            var type = _step.value;
            if (is(type, val)) {
              validateChild(node, key, val);
              return;
            }
          }
        }
      }
      throw new TypeError("Property " + key + " of " + node.type + " expected node to be of a type " + JSON.stringify(types) + " but instead got " + JSON.stringify(valType));
    }
    validate.oneOfNodeTypes = types;
    return validate;
  }
  function assertNodeOrValueType() {
    for (var _len3 = arguments.length, types = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      types[_key3] = arguments[_key3];
    }
    function validate(node, key, val) {
      var primitiveType = getType(val);
      for (var _iterator2 = _createForOfIteratorHelperLoose(types), _step2; !(_step2 = _iterator2()).done;) {
        var type = _step2.value;
        if (primitiveType === type || is(type, val)) {
          validateChild(node, key, val);
          return;
        }
      }
      throw new TypeError("Property " + key + " of " + node.type + " expected node to be of a type " + JSON.stringify(types) + " but instead got " + JSON.stringify(val == null ? void 0 : val.type));
    }
    validate.oneOfNodeOrValueTypes = types;
    return validate;
  }
  function assertValueType(type) {
    function validate(node, key, val) {
      if (getType(val) === type) {
        return;
      }
      throw new TypeError("Property " + key + " expected type of " + type + " but got " + getType(val));
    }
    validate.type = type;
    return validate;
  }
  function assertShape(shape) {
    var keys = Object.keys(shape);
    function validate(node, key, val) {
      var errors = [];
      for (var _iterator3 = _createForOfIteratorHelperLoose(keys), _step3; !(_step3 = _iterator3()).done;) {
        var property = _step3.value;
        try {
          validateField(node, property, val[property], shape[property]);
        } catch (error) {
          if (error instanceof TypeError) {
            errors.push(error.message);
            continue;
          }
          throw error;
        }
      }
      if (errors.length) {
        throw new TypeError("Property " + key + " of " + node.type + " expected to have the following:\n" + errors.join("\n"));
      }
    }
    validate.shapeOf = shape;
    return validate;
  }
  function assertOptionalChainStart() {
    function validate(node) {
      var _current2;
      var current = node;
      while (node) {
        var _current = current,
          type = _current.type;
        if (type === "OptionalCallExpression") {
          if (current.optional) return;
          current = current.callee;
          continue;
        }
        if (type === "OptionalMemberExpression") {
          if (current.optional) return;
          current = current.object;
          continue;
        }
        break;
      }
      throw new TypeError("Non-optional " + node.type + " must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chain from " + ((_current2 = current) == null ? void 0 : _current2.type));
    }
    return validate;
  }
  function chain() {
    for (var _len4 = arguments.length, fns = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      fns[_key4] = arguments[_key4];
    }
    function validate() {
      for (var _iterator4 = _createForOfIteratorHelperLoose(fns), _step4; !(_step4 = _iterator4()).done;) {
        var fn = _step4.value;
        fn.apply(void 0, arguments);
      }
    }
    validate.chainOf = fns;
    if (fns.length >= 2 && "type" in fns[0] && fns[0].type === "array" && !("each" in fns[1])) {
      throw new Error("An assertValueType(\"array\") validator can only be followed by an assertEach(...) validator.");
    }
    return validate;
  }
  var validTypeOpts = new Set(["aliases", "builder", "deprecatedAlias", "fields", "inherits", "visitor", "validate"]);
  var validFieldKeys = new Set(["default", "optional", "deprecated", "validate"]);
  var store = {};
  function defineAliasedType() {
    for (var _len5 = arguments.length, aliases = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
      aliases[_key5] = arguments[_key5];
    }
    return function (type, opts) {
      var _defined;
      if (opts === void 0) {
        opts = {};
      }
      var defined = opts.aliases;
      if (!defined) {
        var _store$opts$inherits$;
        if (opts.inherits) defined = (_store$opts$inherits$ = store[opts.inherits].aliases) == null ? void 0 : _store$opts$inherits$.slice();
        defined != null ? defined : defined = [];
        opts.aliases = defined;
      }
      var additional = aliases.filter(function (a) {
        return !defined.includes(a);
      });
      (_defined = defined).unshift.apply(_defined, _toConsumableArray(additional));
      defineType$5(type, opts);
    };
  }
  function defineType$5(type, opts) {
    if (opts === void 0) {
      opts = {};
    }
    var inherits = opts.inherits && store[opts.inherits] || {};
    var fields = opts.fields;
    if (!fields) {
      fields = {};
      if (inherits.fields) {
        var keys = Object.getOwnPropertyNames(inherits.fields);
        for (var _iterator5 = _createForOfIteratorHelperLoose(keys), _step5; !(_step5 = _iterator5()).done;) {
          var _key6 = _step5.value;
          var field = inherits.fields[_key6];
          var def = field["default"];
          if (Array.isArray(def) ? def.length > 0 : def && typeof def === "object") {
            throw new Error("field defaults can only be primitives or empty arrays currently");
          }
          fields[_key6] = {
            "default": Array.isArray(def) ? [] : def,
            optional: field.optional,
            deprecated: field.deprecated,
            validate: field.validate
          };
        }
      }
    }
    var visitor = opts.visitor || inherits.visitor || [];
    var aliases = opts.aliases || inherits.aliases || [];
    var builder = opts.builder || inherits.builder || opts.visitor || [];
    for (var _i = 0, _Object$keys = Object.keys(opts); _i < _Object$keys.length; _i++) {
      var k = _Object$keys[_i];
      if (!validTypeOpts.has(k)) {
        throw new Error("Unknown type option \"" + k + "\" on " + type);
      }
    }
    if (opts.deprecatedAlias) {
      DEPRECATED_KEYS$1[opts.deprecatedAlias] = type;
    }
    for (var _iterator6 = _createForOfIteratorHelperLoose(visitor.concat(builder)), _step6; !(_step6 = _iterator6()).done;) {
      var _key8 = _step6.value;
      fields[_key8] = fields[_key8] || {};
    }
    for (var _i2 = 0, _Object$keys2 = Object.keys(fields); _i2 < _Object$keys2.length; _i2++) {
      var _key7 = _Object$keys2[_i2];
      var _field = fields[_key7];
      if (_field["default"] !== undefined && !builder.includes(_key7)) {
        _field.optional = true;
      }
      if (_field["default"] === undefined) {
        _field["default"] = null;
      } else if (!_field.validate && _field["default"] != null) {
        _field.validate = assertValueType(getType(_field["default"]));
      }
      for (var _i3 = 0, _Object$keys3 = Object.keys(_field); _i3 < _Object$keys3.length; _i3++) {
        var _k = _Object$keys3[_i3];
        if (!validFieldKeys.has(_k)) {
          throw new Error("Unknown field key \"" + _k + "\" on " + type + "." + _key7);
        }
      }
    }
    VISITOR_KEYS$7[type] = opts.visitor = visitor;
    BUILDER_KEYS[type] = opts.builder = builder;
    NODE_FIELDS$1[type] = opts.fields = fields;
    ALIAS_KEYS[type] = opts.aliases = aliases;
    aliases.forEach(function (alias) {
      FLIPPED_ALIAS_KEYS$3[alias] = FLIPPED_ALIAS_KEYS$3[alias] || [];
      FLIPPED_ALIAS_KEYS$3[alias].push(type);
    });
    if (opts.validate) {
      NODE_PARENT_VALIDATIONS[type] = opts.validate;
    }
    store[type] = opts;
  }

  var _fields$1, _fields2$1, _fields3$1;
  var defineType$4 = defineAliasedType("Standardized");
  defineType$4("ArrayExpression", {
    fields: {
      elements: {
        validate: arrayOf(assertNodeOrValueType("null", "Expression", "SpreadElement")),
        "default": !browser$1$1.env.BABEL_TYPES_8_BREAKING ? [] : undefined
      }
    },
    visitor: ["elements"],
    aliases: ["Expression"]
  });
  defineType$4("AssignmentExpression", {
    fields: {
      operator: {
        validate: !browser$1$1.env.BABEL_TYPES_8_BREAKING ? assertValueType("string") : Object.assign(function () {
          var identifier = assertOneOf.apply(void 0, _toConsumableArray(ASSIGNMENT_OPERATORS));
          var pattern = assertOneOf("=");
          return function (node, key, val) {
            var validator = is("Pattern", node.left) ? pattern : identifier;
            validator(node, key, val);
          };
        }(), {
          oneOf: ASSIGNMENT_OPERATORS
        })
      },
      left: {
        validate: !browser$1$1.env.BABEL_TYPES_8_BREAKING ? assertNodeType("LVal", "OptionalMemberExpression") : assertNodeType("Identifier", "MemberExpression", "OptionalMemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")
      },
      right: {
        validate: assertNodeType("Expression")
      }
    },
    builder: ["operator", "left", "right"],
    visitor: ["left", "right"],
    aliases: ["Expression"]
  });
  defineType$4("BinaryExpression", {
    builder: ["operator", "left", "right"],
    fields: {
      operator: {
        validate: assertOneOf.apply(void 0, _toConsumableArray(BINARY_OPERATORS))
      },
      left: {
        validate: function () {
          var expression = assertNodeType("Expression");
          var inOp = assertNodeType("Expression", "PrivateName");
          var validator = Object.assign(function (node, key, val) {
            var validator = node.operator === "in" ? inOp : expression;
            validator(node, key, val);
          }, {
            oneOfNodeTypes: ["Expression", "PrivateName"]
          });
          return validator;
        }()
      },
      right: {
        validate: assertNodeType("Expression")
      }
    },
    visitor: ["left", "right"],
    aliases: ["Binary", "Expression"]
  });
  defineType$4("InterpreterDirective", {
    builder: ["value"],
    fields: {
      value: {
        validate: assertValueType("string")
      }
    }
  });
  defineType$4("Directive", {
    visitor: ["value"],
    fields: {
      value: {
        validate: assertNodeType("DirectiveLiteral")
      }
    }
  });
  defineType$4("DirectiveLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: assertValueType("string")
      }
    }
  });
  defineType$4("BlockStatement", {
    builder: ["body", "directives"],
    visitor: ["directives", "body"],
    fields: {
      directives: {
        validate: arrayOfType("Directive"),
        "default": []
      },
      body: validateArrayOfType("Statement")
    },
    aliases: ["Scopable", "BlockParent", "Block", "Statement"]
  });
  defineType$4("BreakStatement", {
    visitor: ["label"],
    fields: {
      label: {
        validate: assertNodeType("Identifier"),
        optional: true
      }
    },
    aliases: ["Statement", "Terminatorless", "CompletionStatement"]
  });
  defineType$4("CallExpression", {
    visitor: ["callee", "typeParameters", "typeArguments", "arguments"],
    builder: ["callee", "arguments"],
    aliases: ["Expression"],
    fields: Object.assign({
      callee: {
        validate: assertNodeType("Expression", "Super", "V8IntrinsicIdentifier")
      },
      arguments: validateArrayOfType("Expression", "SpreadElement", "ArgumentPlaceholder"),
      typeArguments: {
        validate: assertNodeType("TypeParameterInstantiation"),
        optional: true
      }
    }, browser$1$1.env.BABEL_TYPES_8_BREAKING ? {} : {
      optional: {
        validate: assertValueType("boolean"),
        optional: true
      },
      typeParameters: {
        validate: assertNodeType("TSTypeParameterInstantiation"),
        optional: true
      }
    })
  });
  defineType$4("CatchClause", {
    visitor: ["param", "body"],
    fields: {
      param: {
        validate: assertNodeType("Identifier", "ArrayPattern", "ObjectPattern"),
        optional: true
      },
      body: {
        validate: assertNodeType("BlockStatement")
      }
    },
    aliases: ["Scopable", "BlockParent"]
  });
  defineType$4("ConditionalExpression", {
    visitor: ["test", "consequent", "alternate"],
    fields: {
      test: {
        validate: assertNodeType("Expression")
      },
      consequent: {
        validate: assertNodeType("Expression")
      },
      alternate: {
        validate: assertNodeType("Expression")
      }
    },
    aliases: ["Expression", "Conditional"]
  });
  defineType$4("ContinueStatement", {
    visitor: ["label"],
    fields: {
      label: {
        validate: assertNodeType("Identifier"),
        optional: true
      }
    },
    aliases: ["Statement", "Terminatorless", "CompletionStatement"]
  });
  defineType$4("DebuggerStatement", {
    aliases: ["Statement"]
  });
  defineType$4("DoWhileStatement", {
    builder: ["test", "body"],
    visitor: ["body", "test"],
    fields: {
      test: {
        validate: assertNodeType("Expression")
      },
      body: {
        validate: assertNodeType("Statement")
      }
    },
    aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"]
  });
  defineType$4("EmptyStatement", {
    aliases: ["Statement"]
  });
  defineType$4("ExpressionStatement", {
    visitor: ["expression"],
    fields: {
      expression: {
        validate: assertNodeType("Expression")
      }
    },
    aliases: ["Statement", "ExpressionWrapper"]
  });
  defineType$4("File", {
    builder: ["program", "comments", "tokens"],
    visitor: ["program"],
    fields: {
      program: {
        validate: assertNodeType("Program")
      },
      comments: {
        validate: !browser$1$1.env.BABEL_TYPES_8_BREAKING ? Object.assign(function () {}, {
          each: {
            oneOfNodeTypes: ["CommentBlock", "CommentLine"]
          }
        }) : assertEach(assertNodeType("CommentBlock", "CommentLine")),
        optional: true
      },
      tokens: {
        validate: assertEach(Object.assign(function () {}, {
          type: "any"
        })),
        optional: true
      }
    }
  });
  defineType$4("ForInStatement", {
    visitor: ["left", "right", "body"],
    aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
    fields: {
      left: {
        validate: !browser$1$1.env.BABEL_TYPES_8_BREAKING ? assertNodeType("VariableDeclaration", "LVal") : assertNodeType("VariableDeclaration", "Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")
      },
      right: {
        validate: assertNodeType("Expression")
      },
      body: {
        validate: assertNodeType("Statement")
      }
    }
  });
  defineType$4("ForStatement", {
    visitor: ["init", "test", "update", "body"],
    aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop"],
    fields: {
      init: {
        validate: assertNodeType("VariableDeclaration", "Expression"),
        optional: true
      },
      test: {
        validate: assertNodeType("Expression"),
        optional: true
      },
      update: {
        validate: assertNodeType("Expression"),
        optional: true
      },
      body: {
        validate: assertNodeType("Statement")
      }
    }
  });
  var functionCommon = function functionCommon() {
    return {
      params: validateArrayOfType("FunctionParameter"),
      generator: {
        "default": false
      },
      async: {
        "default": false
      }
    };
  };
  var functionTypeAnnotationCommon = function functionTypeAnnotationCommon() {
    return {
      returnType: {
        validate: assertNodeType("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: true
      },
      typeParameters: {
        validate: assertNodeType("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
        optional: true
      }
    };
  };
  var functionDeclarationCommon = function functionDeclarationCommon() {
    return Object.assign({}, functionCommon(), {
      declare: {
        validate: assertValueType("boolean"),
        optional: true
      },
      id: {
        validate: assertNodeType("Identifier"),
        optional: true
      }
    });
  };
  defineType$4("FunctionDeclaration", {
    builder: ["id", "params", "body", "generator", "async"],
    visitor: ["id", "typeParameters", "params", "predicate", "returnType", "body"],
    fields: Object.assign({}, functionDeclarationCommon(), functionTypeAnnotationCommon(), {
      body: {
        validate: assertNodeType("BlockStatement")
      },
      predicate: {
        validate: assertNodeType("DeclaredPredicate", "InferredPredicate"),
        optional: true
      }
    }),
    aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Statement", "Pureish", "Declaration"],
    validate: !browser$1$1.env.BABEL_TYPES_8_BREAKING ? undefined : function () {
      var identifier = assertNodeType("Identifier");
      return function (parent, key, node) {
        if (!is("ExportDefaultDeclaration", parent)) {
          identifier(node, "id", node.id);
        }
      };
    }()
  });
  defineType$4("FunctionExpression", {
    inherits: "FunctionDeclaration",
    aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
    fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), {
      id: {
        validate: assertNodeType("Identifier"),
        optional: true
      },
      body: {
        validate: assertNodeType("BlockStatement")
      },
      predicate: {
        validate: assertNodeType("DeclaredPredicate", "InferredPredicate"),
        optional: true
      }
    })
  });
  var patternLikeCommon = function patternLikeCommon() {
    return {
      typeAnnotation: {
        validate: assertNodeType("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: true
      },
      optional: {
        validate: assertValueType("boolean"),
        optional: true
      },
      decorators: {
        validate: arrayOfType("Decorator"),
        optional: true
      }
    };
  };
  defineType$4("Identifier", {
    builder: ["name"],
    visitor: ["typeAnnotation", "decorators"],
    aliases: ["Expression", "FunctionParameter", "PatternLike", "LVal", "TSEntityName"],
    fields: Object.assign({}, patternLikeCommon(), {
      name: {
        validate: browser$1$1.env.BABEL_TYPES_8_BREAKING ? chain(assertValueType("string"), Object.assign(function (node, key, val) {
          if (!isValidIdentifier$1(val, false)) {
            throw new TypeError("\"" + val + "\" is not a valid identifier name");
          }
        }, {
          type: "string"
        })) : assertValueType("string")
      }
    }),
    validate: browser$1$1.env.BABEL_TYPES_8_BREAKING ? function (parent, key, node) {
      var match = /\.(\w+)$/.exec(key.toString());
      if (!match) return;
      var _match = _slicedToArray(match, 2),
        parentKey = _match[1];
      var nonComp = {
        computed: false
      };
      if (parentKey === "property") {
        if (is("MemberExpression", parent, nonComp)) return;
        if (is("OptionalMemberExpression", parent, nonComp)) return;
      } else if (parentKey === "key") {
        if (is("Property", parent, nonComp)) return;
        if (is("Method", parent, nonComp)) return;
      } else if (parentKey === "exported") {
        if (is("ExportSpecifier", parent)) return;
      } else if (parentKey === "imported") {
        if (is("ImportSpecifier", parent, {
          imported: node
        })) return;
      } else if (parentKey === "meta") {
        if (is("MetaProperty", parent, {
          meta: node
        })) return;
      }
      if ((isKeyword(node.name) || isReservedWord(node.name, false)) && node.name !== "this") {
        throw new TypeError("\"" + node.name + "\" is not a valid identifier");
      }
    } : undefined
  });
  defineType$4("IfStatement", {
    visitor: ["test", "consequent", "alternate"],
    aliases: ["Statement", "Conditional"],
    fields: {
      test: {
        validate: assertNodeType("Expression")
      },
      consequent: {
        validate: assertNodeType("Statement")
      },
      alternate: {
        optional: true,
        validate: assertNodeType("Statement")
      }
    }
  });
  defineType$4("LabeledStatement", {
    visitor: ["label", "body"],
    aliases: ["Statement"],
    fields: {
      label: {
        validate: assertNodeType("Identifier")
      },
      body: {
        validate: assertNodeType("Statement")
      }
    }
  });
  defineType$4("StringLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: assertValueType("string")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  defineType$4("NumericLiteral", {
    builder: ["value"],
    deprecatedAlias: "NumberLiteral",
    fields: {
      value: {
        validate: chain(assertValueType("number"), Object.assign(function (node, key, val) {
        }, {
          type: "number"
        }))
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  defineType$4("NullLiteral", {
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  defineType$4("BooleanLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: assertValueType("boolean")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  defineType$4("RegExpLiteral", {
    builder: ["pattern", "flags"],
    deprecatedAlias: "RegexLiteral",
    aliases: ["Expression", "Pureish", "Literal"],
    fields: {
      pattern: {
        validate: assertValueType("string")
      },
      flags: {
        validate: browser$1$1.env.BABEL_TYPES_8_BREAKING ? chain(assertValueType("string"), Object.assign(function (node, key, val) {
          var invalid = /[^gimsuy]/.exec(val);
          if (invalid) {
            throw new TypeError("\"" + invalid[0] + "\" is not a valid RegExp flag");
          }
        }, {
          type: "string"
        })) : assertValueType("string"),
        "default": ""
      }
    }
  });
  defineType$4("LogicalExpression", {
    builder: ["operator", "left", "right"],
    visitor: ["left", "right"],
    aliases: ["Binary", "Expression"],
    fields: {
      operator: {
        validate: assertOneOf.apply(void 0, _toConsumableArray(LOGICAL_OPERATORS$2))
      },
      left: {
        validate: assertNodeType("Expression")
      },
      right: {
        validate: assertNodeType("Expression")
      }
    }
  });
  defineType$4("MemberExpression", {
    builder: ["object", "property", "computed"].concat(_toConsumableArray(!browser$1$1.env.BABEL_TYPES_8_BREAKING ? ["optional"] : [])),
    visitor: ["object", "property"],
    aliases: ["Expression", "LVal", "PatternLike"],
    fields: Object.assign({
      object: {
        validate: assertNodeType("Expression", "Super")
      },
      property: {
        validate: function () {
          var normal = assertNodeType("Identifier", "PrivateName");
          var computed = assertNodeType("Expression");
          var validator = function validator(node, key, val) {
            var validator = node.computed ? computed : normal;
            validator(node, key, val);
          };
          validator.oneOfNodeTypes = ["Expression", "Identifier", "PrivateName"];
          return validator;
        }()
      },
      computed: {
        "default": false
      }
    }, !browser$1$1.env.BABEL_TYPES_8_BREAKING ? {
      optional: {
        validate: assertValueType("boolean"),
        optional: true
      }
    } : {})
  });
  defineType$4("NewExpression", {
    inherits: "CallExpression"
  });
  defineType$4("Program", {
    visitor: ["directives", "body"],
    builder: ["body", "directives", "sourceType", "interpreter"],
    fields: {
      sourceType: {
        validate: assertOneOf("script", "module"),
        "default": "script"
      },
      interpreter: {
        validate: assertNodeType("InterpreterDirective"),
        "default": null,
        optional: true
      },
      directives: {
        validate: arrayOfType("Directive"),
        "default": []
      },
      body: validateArrayOfType("Statement")
    },
    aliases: ["Scopable", "BlockParent", "Block"]
  });
  defineType$4("ObjectExpression", {
    visitor: ["properties"],
    aliases: ["Expression"],
    fields: {
      properties: validateArrayOfType("ObjectMethod", "ObjectProperty", "SpreadElement")
    }
  });
  defineType$4("ObjectMethod", {
    builder: ["kind", "key", "params", "body", "computed", "generator", "async"],
    visitor: ["decorators", "key", "typeParameters", "params", "returnType", "body"],
    fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), {
      kind: Object.assign({
        validate: assertOneOf("method", "get", "set")
      }, !browser$1$1.env.BABEL_TYPES_8_BREAKING ? {
        "default": "method"
      } : {}),
      computed: {
        "default": false
      },
      key: {
        validate: function () {
          var normal = assertNodeType("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral");
          var computed = assertNodeType("Expression");
          var validator = function validator(node, key, val) {
            var validator = node.computed ? computed : normal;
            validator(node, key, val);
          };
          validator.oneOfNodeTypes = ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"];
          return validator;
        }()
      },
      decorators: {
        validate: arrayOfType("Decorator"),
        optional: true
      },
      body: {
        validate: assertNodeType("BlockStatement")
      }
    }),
    aliases: ["UserWhitespacable", "Function", "Scopable", "BlockParent", "FunctionParent", "Method", "ObjectMember"]
  });
  defineType$4("ObjectProperty", {
    builder: ["key", "value", "computed", "shorthand"].concat(_toConsumableArray(!browser$1$1.env.BABEL_TYPES_8_BREAKING ? ["decorators"] : [])),
    fields: {
      computed: {
        "default": false
      },
      key: {
        validate: function () {
          var normal = assertNodeType("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName");
          var computed = assertNodeType("Expression");
          var validator = Object.assign(function (node, key, val) {
            var validator = node.computed ? computed : normal;
            validator(node, key, val);
          }, {
            oneOfNodeTypes: ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName"]
          });
          return validator;
        }()
      },
      value: {
        validate: assertNodeType("Expression", "PatternLike")
      },
      shorthand: {
        validate: browser$1$1.env.BABEL_TYPES_8_BREAKING ? chain(assertValueType("boolean"), Object.assign(function (node, key, shorthand) {
          if (!shorthand) return;
          if (node.computed) {
            throw new TypeError("Property shorthand of ObjectProperty cannot be true if computed is true");
          }
          if (!is("Identifier", node.key)) {
            throw new TypeError("Property shorthand of ObjectProperty cannot be true if key is not an Identifier");
          }
        }, {
          type: "boolean"
        })) : assertValueType("boolean"),
        "default": false
      },
      decorators: {
        validate: arrayOfType("Decorator"),
        optional: true
      }
    },
    visitor: ["decorators", "key", "value"],
    aliases: ["UserWhitespacable", "Property", "ObjectMember"],
    validate: !browser$1$1.env.BABEL_TYPES_8_BREAKING ? undefined : function () {
      var pattern = assertNodeType("Identifier", "Pattern", "TSAsExpression", "TSSatisfiesExpression", "TSNonNullExpression", "TSTypeAssertion");
      var expression = assertNodeType("Expression");
      return function (parent, key, node) {
        var validator = is("ObjectPattern", parent) ? pattern : expression;
        validator(node, "value", node.value);
      };
    }()
  });
  defineType$4("RestElement", {
    visitor: ["argument", "typeAnnotation"],
    builder: ["argument"],
    aliases: ["FunctionParameter", "PatternLike", "LVal"],
    deprecatedAlias: "RestProperty",
    fields: Object.assign({}, patternLikeCommon(), {
      argument: {
        validate: !browser$1$1.env.BABEL_TYPES_8_BREAKING ? assertNodeType("Identifier", "ArrayPattern", "ObjectPattern", "MemberExpression", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression", "RestElement", "AssignmentPattern") : assertNodeType("Identifier", "ArrayPattern", "ObjectPattern", "MemberExpression", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")
      }
    }),
    validate: browser$1$1.env.BABEL_TYPES_8_BREAKING ? function (parent, key) {
      var match = /(\w+)\[(\d+)\]/.exec(key.toString());
      if (!match) throw new Error("Internal Babel error: malformed key.");
      var _ref = match,
        _ref2 = _slicedToArray(_ref, 3),
        listKey = _ref2[1],
        index = _ref2[2];
      if (parent[listKey].length > +index + 1) {
        throw new TypeError("RestElement must be last element of " + listKey);
      }
    } : undefined
  });
  defineType$4("ReturnStatement", {
    visitor: ["argument"],
    aliases: ["Statement", "Terminatorless", "CompletionStatement"],
    fields: {
      argument: {
        validate: assertNodeType("Expression"),
        optional: true
      }
    }
  });
  defineType$4("SequenceExpression", {
    visitor: ["expressions"],
    fields: {
      expressions: validateArrayOfType("Expression")
    },
    aliases: ["Expression"]
  });
  defineType$4("ParenthesizedExpression", {
    visitor: ["expression"],
    aliases: ["Expression", "ExpressionWrapper"],
    fields: {
      expression: {
        validate: assertNodeType("Expression")
      }
    }
  });
  defineType$4("SwitchCase", {
    visitor: ["test", "consequent"],
    fields: {
      test: {
        validate: assertNodeType("Expression"),
        optional: true
      },
      consequent: validateArrayOfType("Statement")
    }
  });
  defineType$4("SwitchStatement", {
    visitor: ["discriminant", "cases"],
    aliases: ["Statement", "BlockParent", "Scopable"],
    fields: {
      discriminant: {
        validate: assertNodeType("Expression")
      },
      cases: validateArrayOfType("SwitchCase")
    }
  });
  defineType$4("ThisExpression", {
    aliases: ["Expression"]
  });
  defineType$4("ThrowStatement", {
    visitor: ["argument"],
    aliases: ["Statement", "Terminatorless", "CompletionStatement"],
    fields: {
      argument: {
        validate: assertNodeType("Expression")
      }
    }
  });
  defineType$4("TryStatement", {
    visitor: ["block", "handler", "finalizer"],
    aliases: ["Statement"],
    fields: {
      block: {
        validate: browser$1$1.env.BABEL_TYPES_8_BREAKING ? chain(assertNodeType("BlockStatement"), Object.assign(function (node) {
          if (!node.handler && !node.finalizer) {
            throw new TypeError("TryStatement expects either a handler or finalizer, or both");
          }
        }, {
          oneOfNodeTypes: ["BlockStatement"]
        })) : assertNodeType("BlockStatement")
      },
      handler: {
        optional: true,
        validate: assertNodeType("CatchClause")
      },
      finalizer: {
        optional: true,
        validate: assertNodeType("BlockStatement")
      }
    }
  });
  defineType$4("UnaryExpression", {
    builder: ["operator", "argument", "prefix"],
    fields: {
      prefix: {
        "default": true
      },
      argument: {
        validate: assertNodeType("Expression")
      },
      operator: {
        validate: assertOneOf.apply(void 0, _toConsumableArray(UNARY_OPERATORS))
      }
    },
    visitor: ["argument"],
    aliases: ["UnaryLike", "Expression"]
  });
  defineType$4("UpdateExpression", {
    builder: ["operator", "argument", "prefix"],
    fields: {
      prefix: {
        "default": false
      },
      argument: {
        validate: !browser$1$1.env.BABEL_TYPES_8_BREAKING ? assertNodeType("Expression") : assertNodeType("Identifier", "MemberExpression")
      },
      operator: {
        validate: assertOneOf.apply(void 0, _toConsumableArray(UPDATE_OPERATORS))
      }
    },
    visitor: ["argument"],
    aliases: ["Expression"]
  });
  defineType$4("VariableDeclaration", {
    builder: ["kind", "declarations"],
    visitor: ["declarations"],
    aliases: ["Statement", "Declaration"],
    fields: {
      declare: {
        validate: assertValueType("boolean"),
        optional: true
      },
      kind: {
        validate: assertOneOf("var", "let", "const", "using", "await using")
      },
      declarations: validateArrayOfType("VariableDeclarator")
    },
    validate: browser$1$1.env.BABEL_TYPES_8_BREAKING ? function () {
      var withoutInit = assertNodeType("Identifier", "Placeholder");
      var constOrLetOrVar = assertNodeType("Identifier", "ArrayPattern", "ObjectPattern", "Placeholder");
      var usingOrAwaitUsing = assertNodeType("Identifier", "VoidPattern", "Placeholder");
      return function (parent, key, node) {
        var kind = node.kind,
          declarations = node.declarations;
        var parentIsForX = is("ForXStatement", parent, {
          left: node
        });
        if (parentIsForX) {
          if (declarations.length !== 1) {
            throw new TypeError("Exactly one VariableDeclarator is required in the VariableDeclaration of a " + parent.type);
          }
        }
        for (var _iterator = _createForOfIteratorHelperLoose(declarations), _step; !(_step = _iterator()).done;) {
          var decl = _step.value;
          if (kind === "const" || kind === "let" || kind === "var") {
            if (!parentIsForX && !decl.init) {
              withoutInit(decl, "id", decl.id);
            } else {
              constOrLetOrVar(decl, "id", decl.id);
            }
          } else {
            usingOrAwaitUsing(decl, "id", decl.id);
          }
        }
      };
    }() : undefined
  });
  defineType$4("VariableDeclarator", {
    visitor: ["id", "init"],
    fields: {
      id: {
        validate: !browser$1$1.env.BABEL_TYPES_8_BREAKING ? assertNodeType("LVal", "VoidPattern") : assertNodeType("Identifier", "ArrayPattern", "ObjectPattern", "VoidPattern")
      },
      definite: {
        optional: true,
        validate: assertValueType("boolean")
      },
      init: {
        optional: true,
        validate: assertNodeType("Expression")
      }
    }
  });
  defineType$4("WhileStatement", {
    visitor: ["test", "body"],
    aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"],
    fields: {
      test: {
        validate: assertNodeType("Expression")
      },
      body: {
        validate: assertNodeType("Statement")
      }
    }
  });
  defineType$4("WithStatement", {
    visitor: ["object", "body"],
    aliases: ["Statement"],
    fields: {
      object: {
        validate: assertNodeType("Expression")
      },
      body: {
        validate: assertNodeType("Statement")
      }
    }
  });
  defineType$4("AssignmentPattern", {
    visitor: ["left", "right", "decorators"],
    builder: ["left", "right"],
    aliases: ["FunctionParameter", "Pattern", "PatternLike", "LVal"],
    fields: Object.assign({}, patternLikeCommon(), {
      left: {
        validate: assertNodeType("Identifier", "ObjectPattern", "ArrayPattern", "MemberExpression", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")
      },
      right: {
        validate: assertNodeType("Expression")
      },
      decorators: {
        validate: arrayOfType("Decorator"),
        optional: true
      }
    })
  });
  defineType$4("ArrayPattern", {
    visitor: ["elements", "typeAnnotation"],
    builder: ["elements"],
    aliases: ["FunctionParameter", "Pattern", "PatternLike", "LVal"],
    fields: Object.assign({}, patternLikeCommon(), {
      elements: {
        validate: chain(assertValueType("array"), assertEach(assertNodeOrValueType("null", "PatternLike")))
      }
    })
  });
  defineType$4("ArrowFunctionExpression", {
    builder: ["params", "body", "async"],
    visitor: ["typeParameters", "params", "predicate", "returnType", "body"],
    aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
    fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), {
      expression: {
        validate: assertValueType("boolean")
      },
      body: {
        validate: assertNodeType("BlockStatement", "Expression")
      },
      predicate: {
        validate: assertNodeType("DeclaredPredicate", "InferredPredicate"),
        optional: true
      }
    })
  });
  defineType$4("ClassBody", {
    visitor: ["body"],
    fields: {
      body: validateArrayOfType("ClassMethod", "ClassPrivateMethod", "ClassProperty", "ClassPrivateProperty", "ClassAccessorProperty", "TSDeclareMethod", "TSIndexSignature", "StaticBlock")
    }
  });
  defineType$4("ClassExpression", {
    builder: ["id", "superClass", "body", "decorators"],
    visitor: ["decorators", "id", "typeParameters", "superClass", "superTypeParameters", "mixins", "implements", "body"],
    aliases: ["Scopable", "Class", "Expression"],
    fields: (_fields$1 = {
      id: {
        validate: assertNodeType("Identifier"),
        optional: true
      },
      typeParameters: {
        validate: assertNodeType("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
        optional: true
      },
      body: {
        validate: assertNodeType("ClassBody")
      },
      superClass: {
        optional: true,
        validate: assertNodeType("Expression")
      }
    }, _fields$1["superTypeParameters"] = {
      validate: assertNodeType("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
      optional: true
    }, _fields$1["implements"] = {
      validate: arrayOfType("TSExpressionWithTypeArguments", "ClassImplements"),
      optional: true
    }, _fields$1.decorators = {
      validate: arrayOfType("Decorator"),
      optional: true
    }, _fields$1.mixins = {
      validate: assertNodeType("InterfaceExtends"),
      optional: true
    }, _fields$1)
  });
  defineType$4("ClassDeclaration", {
    inherits: "ClassExpression",
    aliases: ["Scopable", "Class", "Statement", "Declaration"],
    fields: (_fields2$1 = {
      id: {
        validate: assertNodeType("Identifier"),
        optional: true
      },
      typeParameters: {
        validate: assertNodeType("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
        optional: true
      },
      body: {
        validate: assertNodeType("ClassBody")
      },
      superClass: {
        optional: true,
        validate: assertNodeType("Expression")
      }
    }, _fields2$1["superTypeParameters"] = {
      validate: assertNodeType("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
      optional: true
    }, _fields2$1["implements"] = {
      validate: arrayOfType("TSExpressionWithTypeArguments", "ClassImplements"),
      optional: true
    }, _fields2$1.decorators = {
      validate: arrayOfType("Decorator"),
      optional: true
    }, _fields2$1.mixins = {
      validate: assertNodeType("InterfaceExtends"),
      optional: true
    }, _fields2$1.declare = {
      validate: assertValueType("boolean"),
      optional: true
    }, _fields2$1["abstract"] = {
      validate: assertValueType("boolean"),
      optional: true
    }, _fields2$1),
    validate: !browser$1$1.env.BABEL_TYPES_8_BREAKING ? undefined : function () {
      var identifier = assertNodeType("Identifier");
      return function (parent, key, node) {
        if (!is("ExportDefaultDeclaration", parent)) {
          identifier(node, "id", node.id);
        }
      };
    }()
  });
  var importAttributes = {
    attributes: {
      optional: true,
      validate: arrayOfType("ImportAttribute")
    },
    assertions: {
      deprecated: true,
      optional: true,
      validate: arrayOfType("ImportAttribute")
    }
  };
  defineType$4("ExportAllDeclaration", {
    builder: ["source"],
    visitor: ["source", "attributes", "assertions"],
    aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
    fields: Object.assign({
      source: {
        validate: assertNodeType("StringLiteral")
      },
      exportKind: validateOptional(assertOneOf("type", "value"))
    }, importAttributes)
  });
  defineType$4("ExportDefaultDeclaration", {
    visitor: ["declaration"],
    aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
    fields: {
      declaration: validateType("TSDeclareFunction", "FunctionDeclaration", "ClassDeclaration", "Expression"),
      exportKind: validateOptional(assertOneOf("value"))
    }
  });
  defineType$4("ExportNamedDeclaration", {
    builder: ["declaration", "specifiers", "source"],
    visitor: ["declaration", "specifiers", "source", "attributes", "assertions"],
    aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
    fields: Object.assign({
      declaration: {
        optional: true,
        validate: browser$1$1.env.BABEL_TYPES_8_BREAKING ? chain(assertNodeType("Declaration"), Object.assign(function (node, key, val) {
          if (val && node.specifiers.length) {
            throw new TypeError("Only declaration or specifiers is allowed on ExportNamedDeclaration");
          }
          if (val && node.source) {
            throw new TypeError("Cannot export a declaration from a source");
          }
        }, {
          oneOfNodeTypes: ["Declaration"]
        })) : assertNodeType("Declaration")
      }
    }, importAttributes, {
      specifiers: {
        "default": [],
        validate: arrayOf(function () {
          var sourced = assertNodeType("ExportSpecifier", "ExportDefaultSpecifier", "ExportNamespaceSpecifier");
          var sourceless = assertNodeType("ExportSpecifier");
          if (!browser$1$1.env.BABEL_TYPES_8_BREAKING) return sourced;
          return Object.assign(function (node, key, val) {
            var validator = node.source ? sourced : sourceless;
            validator(node, key, val);
          }, {
            oneOfNodeTypes: ["ExportSpecifier", "ExportDefaultSpecifier", "ExportNamespaceSpecifier"]
          });
        }())
      },
      source: {
        validate: assertNodeType("StringLiteral"),
        optional: true
      },
      exportKind: validateOptional(assertOneOf("type", "value"))
    })
  });
  defineType$4("ExportSpecifier", {
    visitor: ["local", "exported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: assertNodeType("Identifier")
      },
      exported: {
        validate: assertNodeType("Identifier", "StringLiteral")
      },
      exportKind: {
        validate: assertOneOf("type", "value"),
        optional: true
      }
    }
  });
  defineType$4("ForOfStatement", {
    visitor: ["left", "right", "body"],
    builder: ["left", "right", "body", "await"],
    aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
    fields: {
      left: {
        validate: function () {
          if (!browser$1$1.env.BABEL_TYPES_8_BREAKING) {
            return assertNodeType("VariableDeclaration", "LVal");
          }
          var declaration = assertNodeType("VariableDeclaration");
          var lval = assertNodeType("Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression");
          return Object.assign(function (node, key, val) {
            if (is("VariableDeclaration", val)) {
              declaration(node, key, val);
            } else {
              lval(node, key, val);
            }
          }, {
            oneOfNodeTypes: ["VariableDeclaration", "Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression"]
          });
        }()
      },
      right: {
        validate: assertNodeType("Expression")
      },
      body: {
        validate: assertNodeType("Statement")
      },
      "await": {
        "default": false
      }
    }
  });
  defineType$4("ImportDeclaration", {
    builder: ["specifiers", "source"],
    visitor: ["specifiers", "source", "attributes", "assertions"],
    aliases: ["Statement", "Declaration", "ImportOrExportDeclaration"],
    fields: Object.assign({}, importAttributes, {
      module: {
        optional: true,
        validate: assertValueType("boolean")
      },
      phase: {
        "default": null,
        validate: assertOneOf("source", "defer")
      },
      specifiers: validateArrayOfType("ImportSpecifier", "ImportDefaultSpecifier", "ImportNamespaceSpecifier"),
      source: {
        validate: assertNodeType("StringLiteral")
      },
      importKind: {
        validate: assertOneOf("type", "typeof", "value"),
        optional: true
      }
    })
  });
  defineType$4("ImportDefaultSpecifier", {
    visitor: ["local"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: assertNodeType("Identifier")
      }
    }
  });
  defineType$4("ImportNamespaceSpecifier", {
    visitor: ["local"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: assertNodeType("Identifier")
      }
    }
  });
  defineType$4("ImportSpecifier", {
    visitor: ["imported", "local"],
    builder: ["local", "imported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: assertNodeType("Identifier")
      },
      imported: {
        validate: assertNodeType("Identifier", "StringLiteral")
      },
      importKind: {
        validate: assertOneOf("type", "typeof", "value"),
        optional: true
      }
    }
  });
  defineType$4("ImportExpression", {
    visitor: ["source", "options"],
    aliases: ["Expression"],
    fields: {
      phase: {
        "default": null,
        validate: assertOneOf("source", "defer")
      },
      source: {
        validate: assertNodeType("Expression")
      },
      options: {
        validate: assertNodeType("Expression"),
        optional: true
      }
    }
  });
  defineType$4("MetaProperty", {
    visitor: ["meta", "property"],
    aliases: ["Expression"],
    fields: {
      meta: {
        validate: browser$1$1.env.BABEL_TYPES_8_BREAKING ? chain(assertNodeType("Identifier"), Object.assign(function (node, key, val) {
          var property;
          switch (val.name) {
            case "function":
              property = "sent";
              break;
            case "new":
              property = "target";
              break;
            case "import":
              property = "meta";
              break;
          }
          if (!is("Identifier", node.property, {
            name: property
          })) {
            throw new TypeError("Unrecognised MetaProperty");
          }
        }, {
          oneOfNodeTypes: ["Identifier"]
        })) : assertNodeType("Identifier")
      },
      property: {
        validate: assertNodeType("Identifier")
      }
    }
  });
  var classMethodOrPropertyCommon = function classMethodOrPropertyCommon() {
    return {
      "abstract": {
        validate: assertValueType("boolean"),
        optional: true
      },
      accessibility: {
        validate: assertOneOf("public", "private", "protected"),
        optional: true
      },
      "static": {
        "default": false
      },
      override: {
        "default": false
      },
      computed: {
        "default": false
      },
      optional: {
        validate: assertValueType("boolean"),
        optional: true
      },
      key: {
        validate: chain(function () {
          var normal = assertNodeType("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral");
          var computed = assertNodeType("Expression");
          return function (node, key, val) {
            var validator = node.computed ? computed : normal;
            validator(node, key, val);
          };
        }(), assertNodeType("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression"))
      }
    };
  };
  var classMethodOrDeclareMethodCommon = function classMethodOrDeclareMethodCommon() {
    return Object.assign({}, functionCommon(), classMethodOrPropertyCommon(), {
      params: validateArrayOfType("FunctionParameter", "TSParameterProperty"),
      kind: {
        validate: assertOneOf("get", "set", "method", "constructor"),
        "default": "method"
      },
      access: {
        validate: chain(assertValueType("string"), assertOneOf("public", "private", "protected")),
        optional: true
      },
      decorators: {
        validate: arrayOfType("Decorator"),
        optional: true
      }
    });
  };
  defineType$4("ClassMethod", {
    aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method"],
    builder: ["kind", "key", "params", "body", "computed", "static", "generator", "async"],
    visitor: ["decorators", "key", "typeParameters", "params", "returnType", "body"],
    fields: Object.assign({}, classMethodOrDeclareMethodCommon(), functionTypeAnnotationCommon(), {
      body: {
        validate: assertNodeType("BlockStatement")
      }
    })
  });
  defineType$4("ObjectPattern", {
    visitor: ["decorators", "properties", "typeAnnotation"],
    builder: ["properties"],
    aliases: ["FunctionParameter", "Pattern", "PatternLike", "LVal"],
    fields: Object.assign({}, patternLikeCommon(), {
      properties: validateArrayOfType("RestElement", "ObjectProperty")
    })
  });
  defineType$4("SpreadElement", {
    visitor: ["argument"],
    aliases: ["UnaryLike"],
    deprecatedAlias: "SpreadProperty",
    fields: {
      argument: {
        validate: assertNodeType("Expression")
      }
    }
  });
  defineType$4("Super", {
    aliases: ["Expression"]
  });
  defineType$4("TaggedTemplateExpression", {
    visitor: ["tag", "typeParameters", "quasi"],
    builder: ["tag", "quasi"],
    aliases: ["Expression"],
    fields: (_fields3$1 = {
      tag: {
        validate: assertNodeType("Expression")
      },
      quasi: {
        validate: assertNodeType("TemplateLiteral")
      }
    }, _fields3$1["typeParameters"] = {
      validate: assertNodeType("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
      optional: true
    }, _fields3$1)
  });
  defineType$4("TemplateElement", {
    builder: ["value", "tail"],
    fields: {
      value: {
        validate: chain(assertShape({
          raw: {
            validate: assertValueType("string")
          },
          cooked: {
            validate: assertValueType("string"),
            optional: true
          }
        }), function templateElementCookedValidator(node) {
          var raw = node.value.raw;
          var unterminatedCalled = false;
          var error = function error() {
            throw new Error("Internal @babel/types error.");
          };
          var _readStringContents = readStringContents("template", raw, 0, 0, 0, {
              unterminated: function unterminated() {
                unterminatedCalled = true;
              },
              strictNumericEscape: error,
              invalidEscapeSequence: error,
              numericSeparatorInEscapeSequence: error,
              unexpectedNumericSeparator: error,
              invalidDigit: error,
              invalidCodePoint: error
            }),
            str = _readStringContents.str,
            firstInvalidLoc = _readStringContents.firstInvalidLoc;
          if (!unterminatedCalled) throw new Error("Invalid raw");
          node.value.cooked = firstInvalidLoc ? null : str;
        })
      },
      tail: {
        "default": false
      }
    }
  });
  defineType$4("TemplateLiteral", {
    visitor: ["quasis", "expressions"],
    aliases: ["Expression", "Literal"],
    fields: {
      quasis: validateArrayOfType("TemplateElement"),
      expressions: {
        validate: chain(assertValueType("array"), assertEach(assertNodeType("Expression", "TSType")), function (node, key, val) {
          if (node.quasis.length !== val.length + 1) {
            throw new TypeError("Number of " + node.type + " quasis should be exactly one more than the number of expressions.\nExpected " + (val.length + 1) + " quasis but got " + node.quasis.length);
          }
        })
      }
    }
  });
  defineType$4("YieldExpression", {
    builder: ["argument", "delegate"],
    visitor: ["argument"],
    aliases: ["Expression", "Terminatorless"],
    fields: {
      delegate: {
        validate: browser$1$1.env.BABEL_TYPES_8_BREAKING ? chain(assertValueType("boolean"), Object.assign(function (node, key, val) {
          if (val && !node.argument) {
            throw new TypeError("Property delegate of YieldExpression cannot be true if there is no argument");
          }
        }, {
          type: "boolean"
        })) : assertValueType("boolean"),
        "default": false
      },
      argument: {
        optional: true,
        validate: assertNodeType("Expression")
      }
    }
  });
  defineType$4("AwaitExpression", {
    builder: ["argument"],
    visitor: ["argument"],
    aliases: ["Expression", "Terminatorless"],
    fields: {
      argument: {
        validate: assertNodeType("Expression")
      }
    }
  });
  defineType$4("Import", {
    aliases: ["Expression"]
  });
  defineType$4("BigIntLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: assertValueType("string")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  defineType$4("ExportNamespaceSpecifier", {
    visitor: ["exported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      exported: {
        validate: assertNodeType("Identifier")
      }
    }
  });
  defineType$4("OptionalMemberExpression", {
    builder: ["object", "property", "computed", "optional"],
    visitor: ["object", "property"],
    aliases: ["Expression"],
    fields: {
      object: {
        validate: assertNodeType("Expression")
      },
      property: {
        validate: function () {
          var normal = assertNodeType("Identifier");
          var computed = assertNodeType("Expression");
          var validator = Object.assign(function (node, key, val) {
            var validator = node.computed ? computed : normal;
            validator(node, key, val);
          }, {
            oneOfNodeTypes: ["Expression", "Identifier"]
          });
          return validator;
        }()
      },
      computed: {
        "default": false
      },
      optional: {
        validate: !browser$1$1.env.BABEL_TYPES_8_BREAKING ? assertValueType("boolean") : chain(assertValueType("boolean"), assertOptionalChainStart())
      }
    }
  });
  defineType$4("OptionalCallExpression", {
    visitor: ["callee", "typeParameters", "typeArguments", "arguments"],
    builder: ["callee", "arguments", "optional"],
    aliases: ["Expression"],
    fields: Object.assign({
      callee: {
        validate: assertNodeType("Expression")
      },
      arguments: validateArrayOfType("Expression", "SpreadElement", "ArgumentPlaceholder"),
      optional: {
        validate: !browser$1$1.env.BABEL_TYPES_8_BREAKING ? assertValueType("boolean") : chain(assertValueType("boolean"), assertOptionalChainStart())
      },
      typeArguments: {
        validate: assertNodeType("TypeParameterInstantiation"),
        optional: true
      }
    }, {
      typeParameters: {
        validate: assertNodeType("TSTypeParameterInstantiation"),
        optional: true
      }
    })
  });
  defineType$4("ClassProperty", {
    visitor: ["decorators", "variance", "key", "typeAnnotation", "value"],
    builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],
    aliases: ["Property"],
    fields: Object.assign({}, classMethodOrPropertyCommon(), {
      value: {
        validate: assertNodeType("Expression"),
        optional: true
      },
      definite: {
        validate: assertValueType("boolean"),
        optional: true
      },
      typeAnnotation: {
        validate: assertNodeType("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: true
      },
      decorators: {
        validate: arrayOfType("Decorator"),
        optional: true
      },
      readonly: {
        validate: assertValueType("boolean"),
        optional: true
      },
      declare: {
        validate: assertValueType("boolean"),
        optional: true
      },
      variance: {
        validate: assertNodeType("Variance"),
        optional: true
      }
    })
  });
  defineType$4("ClassAccessorProperty", {
    visitor: ["decorators", "key", "typeAnnotation", "value"],
    builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],
    aliases: ["Property", "Accessor"],
    fields: Object.assign({}, classMethodOrPropertyCommon(), {
      key: {
        validate: chain(function () {
          var normal = assertNodeType("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "PrivateName");
          var computed = assertNodeType("Expression");
          return function (node, key, val) {
            var validator = node.computed ? computed : normal;
            validator(node, key, val);
          };
        }(), assertNodeType("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression", "PrivateName"))
      },
      value: {
        validate: assertNodeType("Expression"),
        optional: true
      },
      definite: {
        validate: assertValueType("boolean"),
        optional: true
      },
      typeAnnotation: {
        validate: assertNodeType("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: true
      },
      decorators: {
        validate: arrayOfType("Decorator"),
        optional: true
      },
      readonly: {
        validate: assertValueType("boolean"),
        optional: true
      },
      declare: {
        validate: assertValueType("boolean"),
        optional: true
      },
      variance: {
        validate: assertNodeType("Variance"),
        optional: true
      }
    })
  });
  defineType$4("ClassPrivateProperty", {
    visitor: ["decorators", "variance", "key", "typeAnnotation", "value"],
    builder: ["key", "value", "decorators", "static"],
    aliases: ["Property", "Private"],
    fields: {
      key: {
        validate: assertNodeType("PrivateName")
      },
      value: {
        validate: assertNodeType("Expression"),
        optional: true
      },
      typeAnnotation: {
        validate: assertNodeType("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: true
      },
      decorators: {
        validate: arrayOfType("Decorator"),
        optional: true
      },
      "static": {
        validate: assertValueType("boolean"),
        "default": false
      },
      readonly: {
        validate: assertValueType("boolean"),
        optional: true
      },
      optional: {
        validate: assertValueType("boolean"),
        optional: true
      },
      definite: {
        validate: assertValueType("boolean"),
        optional: true
      },
      variance: {
        validate: assertNodeType("Variance"),
        optional: true
      }
    }
  });
  defineType$4("ClassPrivateMethod", {
    builder: ["kind", "key", "params", "body", "static"],
    visitor: ["decorators", "key", "typeParameters", "params", "returnType", "body"],
    aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method", "Private"],
    fields: Object.assign({}, classMethodOrDeclareMethodCommon(), functionTypeAnnotationCommon(), {
      kind: {
        validate: assertOneOf("get", "set", "method"),
        "default": "method"
      },
      key: {
        validate: assertNodeType("PrivateName")
      },
      body: {
        validate: assertNodeType("BlockStatement")
      }
    })
  });
  defineType$4("PrivateName", {
    visitor: ["id"],
    aliases: ["Private"],
    fields: {
      id: {
        validate: assertNodeType("Identifier")
      }
    }
  });
  defineType$4("StaticBlock", {
    visitor: ["body"],
    fields: {
      body: validateArrayOfType("Statement")
    },
    aliases: ["Scopable", "BlockParent", "FunctionParent"]
  });
  defineType$4("ImportAttribute", {
    visitor: ["key", "value"],
    fields: {
      key: {
        validate: assertNodeType("Identifier", "StringLiteral")
      },
      value: {
        validate: assertNodeType("StringLiteral")
      }
    }
  });

  var defineType$3 = defineAliasedType("Flow");
  var defineInterfaceishType = function defineInterfaceishType(name) {
    var isDeclareClass = name === "DeclareClass";
    defineType$3(name, {
      builder: ["id", "typeParameters", "extends", "body"],
      visitor: ["id", "typeParameters", "extends"].concat(_toConsumableArray(isDeclareClass ? ["mixins", "implements"] : []), ["body"]),
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: Object.assign({
        id: validateType("Identifier"),
        typeParameters: validateOptionalType("TypeParameterDeclaration"),
        "extends": validateOptional(arrayOfType("InterfaceExtends"))
      }, isDeclareClass ? {
        mixins: validateOptional(arrayOfType("InterfaceExtends")),
        "implements": validateOptional(arrayOfType("ClassImplements"))
      } : {}, {
        body: validateType("ObjectTypeAnnotation")
      })
    });
  };
  defineType$3("AnyTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  defineType$3("ArrayTypeAnnotation", {
    visitor: ["elementType"],
    aliases: ["FlowType"],
    fields: {
      elementType: validateType("FlowType")
    }
  });
  defineType$3("BooleanTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  defineType$3("BooleanLiteralTypeAnnotation", {
    builder: ["value"],
    aliases: ["FlowType"],
    fields: {
      value: validate$7(assertValueType("boolean"))
    }
  });
  defineType$3("NullLiteralTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  defineType$3("ClassImplements", {
    visitor: ["id", "typeParameters"],
    fields: {
      id: validateType("Identifier"),
      typeParameters: validateOptionalType("TypeParameterInstantiation")
    }
  });
  defineInterfaceishType("DeclareClass");
  defineType$3("DeclareFunction", {
    builder: ["id"],
    visitor: ["id", "predicate"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: validateType("Identifier"),
      predicate: validateOptionalType("DeclaredPredicate")
    }
  });
  defineInterfaceishType("DeclareInterface");
  defineType$3("DeclareModule", {
    builder: ["id", "body", "kind"],
    visitor: ["id", "body"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: validateType("Identifier", "StringLiteral"),
      body: validateType("BlockStatement"),
      kind: validateOptional(assertOneOf("CommonJS", "ES"))
    }
  });
  defineType$3("DeclareModuleExports", {
    visitor: ["typeAnnotation"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      typeAnnotation: validateType("TypeAnnotation")
    }
  });
  defineType$3("DeclareTypeAlias", {
    visitor: ["id", "typeParameters", "right"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: validateType("Identifier"),
      typeParameters: validateOptionalType("TypeParameterDeclaration"),
      right: validateType("FlowType")
    }
  });
  defineType$3("DeclareOpaqueType", {
    visitor: ["id", "typeParameters", "supertype"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: validateType("Identifier"),
      typeParameters: validateOptionalType("TypeParameterDeclaration"),
      supertype: validateOptionalType("FlowType"),
      impltype: validateOptionalType("FlowType")
    }
  });
  defineType$3("DeclareVariable", {
    visitor: ["id"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: validateType("Identifier")
    }
  });
  defineType$3("DeclareExportDeclaration", {
    visitor: ["declaration", "specifiers", "source", "attributes"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: Object.assign({
      declaration: validateOptionalType("Flow"),
      specifiers: validateOptional(arrayOfType("ExportSpecifier", "ExportNamespaceSpecifier")),
      source: validateOptionalType("StringLiteral"),
      "default": validateOptional(assertValueType("boolean"))
    }, importAttributes)
  });
  defineType$3("DeclareExportAllDeclaration", {
    visitor: ["source", "attributes"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: Object.assign({
      source: validateType("StringLiteral"),
      exportKind: validateOptional(assertOneOf("type", "value"))
    }, importAttributes)
  });
  defineType$3("DeclaredPredicate", {
    visitor: ["value"],
    aliases: ["FlowPredicate"],
    fields: {
      value: validateType("Flow")
    }
  });
  defineType$3("ExistsTypeAnnotation", {
    aliases: ["FlowType"]
  });
  defineType$3("FunctionTypeAnnotation", {
    builder: ["typeParameters", "params", "rest", "returnType"],
    visitor: ["typeParameters", "this", "params", "rest", "returnType"],
    aliases: ["FlowType"],
    fields: {
      typeParameters: validateOptionalType("TypeParameterDeclaration"),
      params: validateArrayOfType("FunctionTypeParam"),
      rest: validateOptionalType("FunctionTypeParam"),
      "this": validateOptionalType("FunctionTypeParam"),
      returnType: validateType("FlowType")
    }
  });
  defineType$3("FunctionTypeParam", {
    visitor: ["name", "typeAnnotation"],
    fields: {
      name: validateOptionalType("Identifier"),
      typeAnnotation: validateType("FlowType"),
      optional: validateOptional(assertValueType("boolean"))
    }
  });
  defineType$3("GenericTypeAnnotation", {
    visitor: ["id", "typeParameters"],
    aliases: ["FlowType"],
    fields: {
      id: validateType("Identifier", "QualifiedTypeIdentifier"),
      typeParameters: validateOptionalType("TypeParameterInstantiation")
    }
  });
  defineType$3("InferredPredicate", {
    aliases: ["FlowPredicate"]
  });
  defineType$3("InterfaceExtends", {
    visitor: ["id", "typeParameters"],
    fields: {
      id: validateType("Identifier", "QualifiedTypeIdentifier"),
      typeParameters: validateOptionalType("TypeParameterInstantiation")
    }
  });
  defineInterfaceishType("InterfaceDeclaration");
  defineType$3("InterfaceTypeAnnotation", {
    visitor: ["extends", "body"],
    aliases: ["FlowType"],
    fields: {
      "extends": validateOptional(arrayOfType("InterfaceExtends")),
      body: validateType("ObjectTypeAnnotation")
    }
  });
  defineType$3("IntersectionTypeAnnotation", {
    visitor: ["types"],
    aliases: ["FlowType"],
    fields: {
      types: validate$7(arrayOfType("FlowType"))
    }
  });
  defineType$3("MixedTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  defineType$3("EmptyTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  defineType$3("NullableTypeAnnotation", {
    visitor: ["typeAnnotation"],
    aliases: ["FlowType"],
    fields: {
      typeAnnotation: validateType("FlowType")
    }
  });
  defineType$3("NumberLiteralTypeAnnotation", {
    builder: ["value"],
    aliases: ["FlowType"],
    fields: {
      value: validate$7(assertValueType("number"))
    }
  });
  defineType$3("NumberTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  defineType$3("ObjectTypeAnnotation", {
    visitor: ["properties", "indexers", "callProperties", "internalSlots"],
    aliases: ["FlowType"],
    builder: ["properties", "indexers", "callProperties", "internalSlots", "exact"],
    fields: {
      properties: validate$7(arrayOfType("ObjectTypeProperty", "ObjectTypeSpreadProperty")),
      indexers: {
        validate: arrayOfType("ObjectTypeIndexer"),
        optional: true,
        "default": []
      },
      callProperties: {
        validate: arrayOfType("ObjectTypeCallProperty"),
        optional: true,
        "default": []
      },
      internalSlots: {
        validate: arrayOfType("ObjectTypeInternalSlot"),
        optional: true,
        "default": []
      },
      exact: {
        validate: assertValueType("boolean"),
        "default": false
      },
      inexact: validateOptional(assertValueType("boolean"))
    }
  });
  defineType$3("ObjectTypeInternalSlot", {
    visitor: ["id", "value"],
    builder: ["id", "value", "optional", "static", "method"],
    aliases: ["UserWhitespacable"],
    fields: {
      id: validateType("Identifier"),
      value: validateType("FlowType"),
      optional: validate$7(assertValueType("boolean")),
      "static": validate$7(assertValueType("boolean")),
      method: validate$7(assertValueType("boolean"))
    }
  });
  defineType$3("ObjectTypeCallProperty", {
    visitor: ["value"],
    aliases: ["UserWhitespacable"],
    fields: {
      value: validateType("FlowType"),
      "static": validate$7(assertValueType("boolean"))
    }
  });
  defineType$3("ObjectTypeIndexer", {
    visitor: ["variance", "id", "key", "value"],
    builder: ["id", "key", "value", "variance"],
    aliases: ["UserWhitespacable"],
    fields: {
      id: validateOptionalType("Identifier"),
      key: validateType("FlowType"),
      value: validateType("FlowType"),
      "static": validate$7(assertValueType("boolean")),
      variance: validateOptionalType("Variance")
    }
  });
  defineType$3("ObjectTypeProperty", {
    visitor: ["key", "value", "variance"],
    aliases: ["UserWhitespacable"],
    fields: {
      key: validateType("Identifier", "StringLiteral"),
      value: validateType("FlowType"),
      kind: validate$7(assertOneOf("init", "get", "set")),
      "static": validate$7(assertValueType("boolean")),
      proto: validate$7(assertValueType("boolean")),
      optional: validate$7(assertValueType("boolean")),
      variance: validateOptionalType("Variance"),
      method: validate$7(assertValueType("boolean"))
    }
  });
  defineType$3("ObjectTypeSpreadProperty", {
    visitor: ["argument"],
    aliases: ["UserWhitespacable"],
    fields: {
      argument: validateType("FlowType")
    }
  });
  defineType$3("OpaqueType", {
    visitor: ["id", "typeParameters", "supertype", "impltype"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: validateType("Identifier"),
      typeParameters: validateOptionalType("TypeParameterDeclaration"),
      supertype: validateOptionalType("FlowType"),
      impltype: validateType("FlowType")
    }
  });
  defineType$3("QualifiedTypeIdentifier", {
    visitor: ["qualification", "id"],
    builder: ["id", "qualification"],
    fields: {
      id: validateType("Identifier"),
      qualification: validateType("Identifier", "QualifiedTypeIdentifier")
    }
  });
  defineType$3("StringLiteralTypeAnnotation", {
    builder: ["value"],
    aliases: ["FlowType"],
    fields: {
      value: validate$7(assertValueType("string"))
    }
  });
  defineType$3("StringTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  defineType$3("SymbolTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  defineType$3("ThisTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  defineType$3("TupleTypeAnnotation", {
    visitor: ["types"],
    aliases: ["FlowType"],
    fields: {
      types: validate$7(arrayOfType("FlowType"))
    }
  });
  defineType$3("TypeofTypeAnnotation", {
    visitor: ["argument"],
    aliases: ["FlowType"],
    fields: {
      argument: validateType("FlowType")
    }
  });
  defineType$3("TypeAlias", {
    visitor: ["id", "typeParameters", "right"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: validateType("Identifier"),
      typeParameters: validateOptionalType("TypeParameterDeclaration"),
      right: validateType("FlowType")
    }
  });
  defineType$3("TypeAnnotation", {
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: validateType("FlowType")
    }
  });
  defineType$3("TypeCastExpression", {
    visitor: ["expression", "typeAnnotation"],
    aliases: ["ExpressionWrapper", "Expression"],
    fields: {
      expression: validateType("Expression"),
      typeAnnotation: validateType("TypeAnnotation")
    }
  });
  defineType$3("TypeParameter", {
    visitor: ["bound", "default", "variance"],
    fields: {
      name: validate$7(assertValueType("string")),
      bound: validateOptionalType("TypeAnnotation"),
      "default": validateOptionalType("FlowType"),
      variance: validateOptionalType("Variance")
    }
  });
  defineType$3("TypeParameterDeclaration", {
    visitor: ["params"],
    fields: {
      params: validate$7(arrayOfType("TypeParameter"))
    }
  });
  defineType$3("TypeParameterInstantiation", {
    visitor: ["params"],
    fields: {
      params: validate$7(arrayOfType("FlowType"))
    }
  });
  defineType$3("UnionTypeAnnotation", {
    visitor: ["types"],
    aliases: ["FlowType"],
    fields: {
      types: validate$7(arrayOfType("FlowType"))
    }
  });
  defineType$3("Variance", {
    builder: ["kind"],
    fields: {
      kind: validate$7(assertOneOf("minus", "plus"))
    }
  });
  defineType$3("VoidTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  defineType$3("EnumDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "body"],
    fields: {
      id: validateType("Identifier"),
      body: validateType("EnumBooleanBody", "EnumNumberBody", "EnumStringBody", "EnumSymbolBody")
    }
  });
  defineType$3("EnumBooleanBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      explicitType: validate$7(assertValueType("boolean")),
      members: validateArrayOfType("EnumBooleanMember"),
      hasUnknownMembers: validate$7(assertValueType("boolean"))
    }
  });
  defineType$3("EnumNumberBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      explicitType: validate$7(assertValueType("boolean")),
      members: validateArrayOfType("EnumNumberMember"),
      hasUnknownMembers: validate$7(assertValueType("boolean"))
    }
  });
  defineType$3("EnumStringBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      explicitType: validate$7(assertValueType("boolean")),
      members: validateArrayOfType("EnumStringMember", "EnumDefaultedMember"),
      hasUnknownMembers: validate$7(assertValueType("boolean"))
    }
  });
  defineType$3("EnumSymbolBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      members: validateArrayOfType("EnumDefaultedMember"),
      hasUnknownMembers: validate$7(assertValueType("boolean"))
    }
  });
  defineType$3("EnumBooleanMember", {
    aliases: ["EnumMember"],
    builder: ["id"],
    visitor: ["id", "init"],
    fields: {
      id: validateType("Identifier"),
      init: validateType("BooleanLiteral")
    }
  });
  defineType$3("EnumNumberMember", {
    aliases: ["EnumMember"],
    visitor: ["id", "init"],
    fields: {
      id: validateType("Identifier"),
      init: validateType("NumericLiteral")
    }
  });
  defineType$3("EnumStringMember", {
    aliases: ["EnumMember"],
    visitor: ["id", "init"],
    fields: {
      id: validateType("Identifier"),
      init: validateType("StringLiteral")
    }
  });
  defineType$3("EnumDefaultedMember", {
    aliases: ["EnumMember"],
    visitor: ["id"],
    fields: {
      id: validateType("Identifier")
    }
  });
  defineType$3("IndexedAccessType", {
    visitor: ["objectType", "indexType"],
    aliases: ["FlowType"],
    fields: {
      objectType: validateType("FlowType"),
      indexType: validateType("FlowType")
    }
  });
  defineType$3("OptionalIndexedAccessType", {
    visitor: ["objectType", "indexType"],
    aliases: ["FlowType"],
    fields: {
      objectType: validateType("FlowType"),
      indexType: validateType("FlowType"),
      optional: validate$7(assertValueType("boolean"))
    }
  });

  var defineType$2 = defineAliasedType("JSX");
  defineType$2("JSXAttribute", {
    visitor: ["name", "value"],
    aliases: ["Immutable"],
    fields: {
      name: {
        validate: assertNodeType("JSXIdentifier", "JSXNamespacedName")
      },
      value: {
        optional: true,
        validate: assertNodeType("JSXElement", "JSXFragment", "StringLiteral", "JSXExpressionContainer")
      }
    }
  });
  defineType$2("JSXClosingElement", {
    visitor: ["name"],
    aliases: ["Immutable"],
    fields: {
      name: {
        validate: assertNodeType("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
      }
    }
  });
  defineType$2("JSXElement", {
    builder: ["openingElement", "closingElement", "children", "selfClosing"],
    visitor: ["openingElement", "children", "closingElement"],
    aliases: ["Immutable", "Expression"],
    fields: Object.assign({
      openingElement: {
        validate: assertNodeType("JSXOpeningElement")
      },
      closingElement: {
        optional: true,
        validate: assertNodeType("JSXClosingElement")
      },
      children: validateArrayOfType("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")
    }, {
      selfClosing: {
        validate: assertValueType("boolean"),
        optional: true
      }
    })
  });
  defineType$2("JSXEmptyExpression", {});
  defineType$2("JSXExpressionContainer", {
    visitor: ["expression"],
    aliases: ["Immutable"],
    fields: {
      expression: {
        validate: assertNodeType("Expression", "JSXEmptyExpression")
      }
    }
  });
  defineType$2("JSXSpreadChild", {
    visitor: ["expression"],
    aliases: ["Immutable"],
    fields: {
      expression: {
        validate: assertNodeType("Expression")
      }
    }
  });
  defineType$2("JSXIdentifier", {
    builder: ["name"],
    fields: {
      name: {
        validate: assertValueType("string")
      }
    }
  });
  defineType$2("JSXMemberExpression", {
    visitor: ["object", "property"],
    fields: {
      object: {
        validate: assertNodeType("JSXMemberExpression", "JSXIdentifier")
      },
      property: {
        validate: assertNodeType("JSXIdentifier")
      }
    }
  });
  defineType$2("JSXNamespacedName", {
    visitor: ["namespace", "name"],
    fields: {
      namespace: {
        validate: assertNodeType("JSXIdentifier")
      },
      name: {
        validate: assertNodeType("JSXIdentifier")
      }
    }
  });
  defineType$2("JSXOpeningElement", {
    builder: ["name", "attributes", "selfClosing"],
    visitor: ["name", "typeParameters", "typeArguments", "attributes"],
    aliases: ["Immutable"],
    fields: Object.assign({
      name: {
        validate: assertNodeType("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
      },
      selfClosing: {
        "default": false
      },
      attributes: validateArrayOfType("JSXAttribute", "JSXSpreadAttribute"),
      typeArguments: {
        validate: assertNodeType("TypeParameterInstantiation"),
        optional: true
      }
    }, {
      typeParameters: {
        validate: assertNodeType("TSTypeParameterInstantiation"),
        optional: true
      }
    })
  });
  defineType$2("JSXSpreadAttribute", {
    visitor: ["argument"],
    fields: {
      argument: {
        validate: assertNodeType("Expression")
      }
    }
  });
  defineType$2("JSXText", {
    aliases: ["Immutable"],
    builder: ["value"],
    fields: {
      value: {
        validate: assertValueType("string")
      }
    }
  });
  defineType$2("JSXFragment", {
    builder: ["openingFragment", "closingFragment", "children"],
    visitor: ["openingFragment", "children", "closingFragment"],
    aliases: ["Immutable", "Expression"],
    fields: {
      openingFragment: {
        validate: assertNodeType("JSXOpeningFragment")
      },
      closingFragment: {
        validate: assertNodeType("JSXClosingFragment")
      },
      children: validateArrayOfType("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")
    }
  });
  defineType$2("JSXOpeningFragment", {
    aliases: ["Immutable"]
  });
  defineType$2("JSXClosingFragment", {
    aliases: ["Immutable"]
  });

  var PLACEHOLDERS = ["Identifier", "StringLiteral", "Expression", "Statement", "Declaration", "BlockStatement", "ClassBody", "Pattern"];
  var PLACEHOLDERS_ALIAS = {
    Declaration: ["Statement"],
    Pattern: ["PatternLike", "LVal"]
  };
  for (var _i$2 = 0, _PLACEHOLDERS = PLACEHOLDERS; _i$2 < _PLACEHOLDERS.length; _i$2++) {
    var type$4 = _PLACEHOLDERS[_i$2];
    var alias$1 = ALIAS_KEYS[type$4];
    if (alias$1 != null && alias$1.length) PLACEHOLDERS_ALIAS[type$4] = alias$1;
  }
  var PLACEHOLDERS_FLIPPED_ALIAS = {};
  Object.keys(PLACEHOLDERS_ALIAS).forEach(function (type) {
    PLACEHOLDERS_ALIAS[type].forEach(function (alias) {
      if (!hasOwnProperty.call(PLACEHOLDERS_FLIPPED_ALIAS, alias)) {
        PLACEHOLDERS_FLIPPED_ALIAS[alias] = [];
      }
      PLACEHOLDERS_FLIPPED_ALIAS[alias].push(type);
    });
  });

  var defineType$1 = defineAliasedType("Miscellaneous");
  {
    defineType$1("Noop", {
      visitor: []
    });
  }
  defineType$1("Placeholder", {
    visitor: [],
    builder: ["expectedNode", "name"],
    fields: Object.assign({
      name: {
        validate: assertNodeType("Identifier")
      },
      expectedNode: {
        validate: assertOneOf.apply(void 0, _toConsumableArray(PLACEHOLDERS))
      }
    }, patternLikeCommon())
  });
  defineType$1("V8IntrinsicIdentifier", {
    builder: ["name"],
    fields: {
      name: {
        validate: assertValueType("string")
      }
    }
  });

  defineType$5("ArgumentPlaceholder", {});
  defineType$5("BindExpression", {
    visitor: ["object", "callee"],
    aliases: ["Expression"],
    fields: !browser$1$1.env.BABEL_TYPES_8_BREAKING ? {
      object: {
        validate: Object.assign(function () {}, {
          oneOfNodeTypes: ["Expression"]
        })
      },
      callee: {
        validate: Object.assign(function () {}, {
          oneOfNodeTypes: ["Expression"]
        })
      }
    } : {
      object: {
        validate: assertNodeType("Expression")
      },
      callee: {
        validate: assertNodeType("Expression")
      }
    }
  });
  defineType$5("Decorator", {
    visitor: ["expression"],
    fields: {
      expression: {
        validate: assertNodeType("Expression")
      }
    }
  });
  defineType$5("DoExpression", {
    visitor: ["body"],
    builder: ["body", "async"],
    aliases: ["Expression"],
    fields: {
      body: {
        validate: assertNodeType("BlockStatement")
      },
      async: {
        validate: assertValueType("boolean"),
        "default": false
      }
    }
  });
  defineType$5("ExportDefaultSpecifier", {
    visitor: ["exported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      exported: {
        validate: assertNodeType("Identifier")
      }
    }
  });
  defineType$5("RecordExpression", {
    visitor: ["properties"],
    aliases: ["Expression"],
    fields: {
      properties: validateArrayOfType("ObjectProperty", "SpreadElement")
    }
  });
  defineType$5("TupleExpression", {
    fields: {
      elements: {
        validate: arrayOfType("Expression", "SpreadElement"),
        "default": []
      }
    },
    visitor: ["elements"],
    aliases: ["Expression"]
  });
  {
    defineType$5("DecimalLiteral", {
      builder: ["value"],
      fields: {
        value: {
          validate: assertValueType("string")
        }
      },
      aliases: ["Expression", "Pureish", "Literal", "Immutable"]
    });
  }
  defineType$5("ModuleExpression", {
    visitor: ["body"],
    fields: {
      body: {
        validate: assertNodeType("Program")
      }
    },
    aliases: ["Expression"]
  });
  defineType$5("TopicReference", {
    aliases: ["Expression"]
  });
  defineType$5("PipelineTopicExpression", {
    builder: ["expression"],
    visitor: ["expression"],
    fields: {
      expression: {
        validate: assertNodeType("Expression")
      }
    },
    aliases: ["Expression"]
  });
  defineType$5("PipelineBareFunction", {
    builder: ["callee"],
    visitor: ["callee"],
    fields: {
      callee: {
        validate: assertNodeType("Expression")
      }
    },
    aliases: ["Expression"]
  });
  defineType$5("PipelinePrimaryTopicReference", {
    aliases: ["Expression"]
  });
  defineType$5("VoidPattern", {
    aliases: ["Pattern", "PatternLike", "FunctionParameter"]
  });

  var _fields, _fields2, _fields3, _fields4;
  var defineType = defineAliasedType("TypeScript");
  var bool$8 = assertValueType("boolean");
  var tSFunctionTypeAnnotationCommon = function tSFunctionTypeAnnotationCommon() {
    return {
      returnType: {
        validate: assertNodeType("TSTypeAnnotation", "Noop"),
        optional: true
      },
      typeParameters: {
        validate: assertNodeType("TSTypeParameterDeclaration", "Noop"),
        optional: true
      }
    };
  };
  defineType("TSParameterProperty", {
    aliases: ["LVal"],
    visitor: ["parameter"],
    fields: {
      accessibility: {
        validate: assertOneOf("public", "private", "protected"),
        optional: true
      },
      readonly: {
        validate: assertValueType("boolean"),
        optional: true
      },
      parameter: {
        validate: assertNodeType("Identifier", "AssignmentPattern")
      },
      override: {
        validate: assertValueType("boolean"),
        optional: true
      },
      decorators: {
        validate: arrayOfType("Decorator"),
        optional: true
      }
    }
  });
  defineType("TSDeclareFunction", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "typeParameters", "params", "returnType"],
    fields: Object.assign({}, functionDeclarationCommon(), tSFunctionTypeAnnotationCommon())
  });
  defineType("TSDeclareMethod", {
    visitor: ["decorators", "key", "typeParameters", "params", "returnType"],
    fields: Object.assign({}, classMethodOrDeclareMethodCommon(), tSFunctionTypeAnnotationCommon())
  });
  defineType("TSQualifiedName", {
    aliases: ["TSEntityName"],
    visitor: ["left", "right"],
    fields: {
      left: validateType("TSEntityName"),
      right: validateType("Identifier")
    }
  });
  var signatureDeclarationCommon = function signatureDeclarationCommon() {
    var _ref;
    return _ref = {
      typeParameters: validateOptionalType("TSTypeParameterDeclaration")
    }, _ref["parameters"] = validateArrayOfType("ArrayPattern", "Identifier", "ObjectPattern", "RestElement"), _ref["typeAnnotation"] = validateOptionalType("TSTypeAnnotation"), _ref;
  };
  var callConstructSignatureDeclaration = {
    aliases: ["TSTypeElement"],
    visitor: ["typeParameters", "parameters", "typeAnnotation"],
    fields: signatureDeclarationCommon()
  };
  defineType("TSCallSignatureDeclaration", callConstructSignatureDeclaration);
  defineType("TSConstructSignatureDeclaration", callConstructSignatureDeclaration);
  var namedTypeElementCommon = function namedTypeElementCommon() {
    return {
      key: validateType("Expression"),
      computed: {
        "default": false
      },
      optional: validateOptional(bool$8)
    };
  };
  defineType("TSPropertySignature", {
    aliases: ["TSTypeElement"],
    visitor: ["key", "typeAnnotation"],
    fields: Object.assign({}, namedTypeElementCommon(), {
      readonly: validateOptional(bool$8),
      typeAnnotation: validateOptionalType("TSTypeAnnotation"),
      kind: {
        optional: true,
        validate: assertOneOf("get", "set")
      }
    })
  });
  defineType("TSMethodSignature", {
    aliases: ["TSTypeElement"],
    visitor: ["key", "typeParameters", "parameters", "typeAnnotation"],
    fields: Object.assign({}, signatureDeclarationCommon(), namedTypeElementCommon(), {
      kind: {
        validate: assertOneOf("method", "get", "set")
      }
    })
  });
  defineType("TSIndexSignature", {
    aliases: ["TSTypeElement"],
    visitor: ["parameters", "typeAnnotation"],
    fields: {
      readonly: validateOptional(bool$8),
      "static": validateOptional(bool$8),
      parameters: validateArrayOfType("Identifier"),
      typeAnnotation: validateOptionalType("TSTypeAnnotation")
    }
  });
  var tsKeywordTypes = ["TSAnyKeyword", "TSBooleanKeyword", "TSBigIntKeyword", "TSIntrinsicKeyword", "TSNeverKeyword", "TSNullKeyword", "TSNumberKeyword", "TSObjectKeyword", "TSStringKeyword", "TSSymbolKeyword", "TSUndefinedKeyword", "TSUnknownKeyword", "TSVoidKeyword"];
  for (var _i$1 = 0, _tsKeywordTypes = tsKeywordTypes; _i$1 < _tsKeywordTypes.length; _i$1++) {
    var type$3 = _tsKeywordTypes[_i$1];
    defineType(type$3, {
      aliases: ["TSType", "TSBaseType"],
      visitor: [],
      fields: {}
    });
  }
  defineType("TSThisType", {
    aliases: ["TSType", "TSBaseType"],
    visitor: [],
    fields: {}
  });
  var fnOrCtrBase = {
    aliases: ["TSType"],
    visitor: ["typeParameters", "parameters", "typeAnnotation"]
  };
  defineType("TSFunctionType", Object.assign({}, fnOrCtrBase, {
    fields: signatureDeclarationCommon()
  }));
  defineType("TSConstructorType", Object.assign({}, fnOrCtrBase, {
    fields: Object.assign({}, signatureDeclarationCommon(), {
      "abstract": validateOptional(bool$8)
    })
  }));
  defineType("TSTypeReference", {
    aliases: ["TSType"],
    visitor: ["typeName", "typeParameters"],
    fields: (_fields = {
      typeName: validateType("TSEntityName")
    }, _fields["typeParameters"] = validateOptionalType("TSTypeParameterInstantiation"), _fields)
  });
  defineType("TSTypePredicate", {
    aliases: ["TSType"],
    visitor: ["parameterName", "typeAnnotation"],
    builder: ["parameterName", "typeAnnotation", "asserts"],
    fields: {
      parameterName: validateType("Identifier", "TSThisType"),
      typeAnnotation: validateOptionalType("TSTypeAnnotation"),
      asserts: validateOptional(bool$8)
    }
  });
  defineType("TSTypeQuery", {
    aliases: ["TSType"],
    visitor: ["exprName", "typeParameters"],
    fields: (_fields2 = {
      exprName: validateType("TSEntityName", "TSImportType")
    }, _fields2["typeParameters"] = validateOptionalType("TSTypeParameterInstantiation"), _fields2)
  });
  defineType("TSTypeLiteral", {
    aliases: ["TSType"],
    visitor: ["members"],
    fields: {
      members: validateArrayOfType("TSTypeElement")
    }
  });
  defineType("TSArrayType", {
    aliases: ["TSType"],
    visitor: ["elementType"],
    fields: {
      elementType: validateType("TSType")
    }
  });
  defineType("TSTupleType", {
    aliases: ["TSType"],
    visitor: ["elementTypes"],
    fields: {
      elementTypes: validateArrayOfType("TSType", "TSNamedTupleMember")
    }
  });
  defineType("TSOptionalType", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: validateType("TSType")
    }
  });
  defineType("TSRestType", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: validateType("TSType")
    }
  });
  defineType("TSNamedTupleMember", {
    visitor: ["label", "elementType"],
    builder: ["label", "elementType", "optional"],
    fields: {
      label: validateType("Identifier"),
      optional: {
        validate: bool$8,
        "default": false
      },
      elementType: validateType("TSType")
    }
  });
  var unionOrIntersection = {
    aliases: ["TSType"],
    visitor: ["types"],
    fields: {
      types: validateArrayOfType("TSType")
    }
  };
  defineType("TSUnionType", unionOrIntersection);
  defineType("TSIntersectionType", unionOrIntersection);
  defineType("TSConditionalType", {
    aliases: ["TSType"],
    visitor: ["checkType", "extendsType", "trueType", "falseType"],
    fields: {
      checkType: validateType("TSType"),
      extendsType: validateType("TSType"),
      trueType: validateType("TSType"),
      falseType: validateType("TSType")
    }
  });
  defineType("TSInferType", {
    aliases: ["TSType"],
    visitor: ["typeParameter"],
    fields: {
      typeParameter: validateType("TSTypeParameter")
    }
  });
  defineType("TSParenthesizedType", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: validateType("TSType")
    }
  });
  defineType("TSTypeOperator", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    builder: ["typeAnnotation", "operator"],
    fields: {
      operator: {
        validate: assertValueType("string")
      },
      typeAnnotation: validateType("TSType")
    }
  });
  defineType("TSIndexedAccessType", {
    aliases: ["TSType"],
    visitor: ["objectType", "indexType"],
    fields: {
      objectType: validateType("TSType"),
      indexType: validateType("TSType")
    }
  });
  defineType("TSMappedType", {
    aliases: ["TSType"],
    visitor: ["typeParameter", "nameType", "typeAnnotation"],
    builder: ["typeParameter", "typeAnnotation", "nameType"],
    fields: Object.assign({}, {
      typeParameter: validateType("TSTypeParameter")
    }, {
      readonly: validateOptional(assertOneOf(true, false, "+", "-")),
      optional: validateOptional(assertOneOf(true, false, "+", "-")),
      typeAnnotation: validateOptionalType("TSType"),
      nameType: validateOptionalType("TSType")
    })
  });
  defineType("TSTemplateLiteralType", {
    aliases: ["TSType", "TSBaseType"],
    visitor: ["quasis", "types"],
    fields: {
      quasis: validateArrayOfType("TemplateElement"),
      types: {
        validate: chain(assertValueType("array"), assertEach(assertNodeType("TSType")), function (node, key, val) {
          if (node.quasis.length !== val.length + 1) {
            throw new TypeError("Number of " + node.type + " quasis should be exactly one more than the number of types.\nExpected " + (val.length + 1) + " quasis but got " + node.quasis.length);
          }
        })
      }
    }
  });
  defineType("TSLiteralType", {
    aliases: ["TSType", "TSBaseType"],
    visitor: ["literal"],
    fields: {
      literal: {
        validate: function () {
          var unaryExpression = assertNodeType("NumericLiteral", "BigIntLiteral");
          var unaryOperator = assertOneOf("-");
          var literal = assertNodeType("NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiteral");
          function validator(parent, key, node) {
            if (is("UnaryExpression", node)) {
              unaryOperator(node, "operator", node.operator);
              unaryExpression(node, "argument", node.argument);
            } else {
              literal(parent, key, node);
            }
          }
          validator.oneOfNodeTypes = ["NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiteral", "UnaryExpression"];
          return validator;
        }()
      }
    }
  });
  {
    defineType("TSExpressionWithTypeArguments", {
      aliases: ["TSType"],
      visitor: ["expression", "typeParameters"],
      fields: {
        expression: validateType("TSEntityName"),
        typeParameters: validateOptionalType("TSTypeParameterInstantiation")
      }
    });
  }
  defineType("TSInterfaceDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "typeParameters", "extends", "body"],
    fields: {
      declare: validateOptional(bool$8),
      id: validateType("Identifier"),
      typeParameters: validateOptionalType("TSTypeParameterDeclaration"),
      "extends": validateOptional(arrayOfType("TSExpressionWithTypeArguments")),
      body: validateType("TSInterfaceBody")
    }
  });
  defineType("TSInterfaceBody", {
    visitor: ["body"],
    fields: {
      body: validateArrayOfType("TSTypeElement")
    }
  });
  defineType("TSTypeAliasDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "typeParameters", "typeAnnotation"],
    fields: {
      declare: validateOptional(bool$8),
      id: validateType("Identifier"),
      typeParameters: validateOptionalType("TSTypeParameterDeclaration"),
      typeAnnotation: validateType("TSType")
    }
  });
  defineType("TSInstantiationExpression", {
    aliases: ["Expression"],
    visitor: ["expression", "typeParameters"],
    fields: (_fields3 = {
      expression: validateType("Expression")
    }, _fields3["typeParameters"] = validateOptionalType("TSTypeParameterInstantiation"), _fields3)
  });
  var TSTypeExpression$1 = {
    aliases: ["Expression", "LVal", "PatternLike"],
    visitor: ["expression", "typeAnnotation"],
    fields: {
      expression: validateType("Expression"),
      typeAnnotation: validateType("TSType")
    }
  };
  defineType("TSAsExpression", TSTypeExpression$1);
  defineType("TSSatisfiesExpression", TSTypeExpression$1);
  defineType("TSTypeAssertion", {
    aliases: ["Expression", "LVal", "PatternLike"],
    visitor: ["typeAnnotation", "expression"],
    fields: {
      typeAnnotation: validateType("TSType"),
      expression: validateType("Expression")
    }
  });
  defineType("TSEnumBody", {
    visitor: ["members"],
    fields: {
      members: validateArrayOfType("TSEnumMember")
    }
  });
  {
    defineType("TSEnumDeclaration", {
      aliases: ["Statement", "Declaration"],
      visitor: ["id", "members"],
      fields: {
        declare: validateOptional(bool$8),
        "const": validateOptional(bool$8),
        id: validateType("Identifier"),
        members: validateArrayOfType("TSEnumMember"),
        initializer: validateOptionalType("Expression"),
        body: validateOptionalType("TSEnumBody")
      }
    });
  }
  defineType("TSEnumMember", {
    visitor: ["id", "initializer"],
    fields: {
      id: validateType("Identifier", "StringLiteral"),
      initializer: validateOptionalType("Expression")
    }
  });
  defineType("TSModuleDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "body"],
    fields: Object.assign({
      kind: {
        validate: assertOneOf("global", "module", "namespace")
      },
      declare: validateOptional(bool$8)
    }, {
      global: validateOptional(bool$8)
    }, {
      id: validateType("Identifier", "StringLiteral"),
      body: validateType("TSModuleBlock", "TSModuleDeclaration")
    })
  });
  defineType("TSModuleBlock", {
    aliases: ["Scopable", "Block", "BlockParent", "FunctionParent"],
    visitor: ["body"],
    fields: {
      body: validateArrayOfType("Statement")
    }
  });
  defineType("TSImportType", {
    aliases: ["TSType"],
    builder: ["argument", "qualifier", "typeParameters"],
    visitor: ["argument", "options", "qualifier", "typeParameters"],
    fields: (_fields4 = {
      argument: validateType("StringLiteral"),
      qualifier: validateOptionalType("TSEntityName")
    }, _fields4["typeParameters"] = validateOptionalType("TSTypeParameterInstantiation"), _fields4.options = {
      validate: assertNodeType("ObjectExpression"),
      optional: true
    }, _fields4)
  });
  defineType("TSImportEqualsDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "moduleReference"],
    fields: Object.assign({}, {
      isExport: validate$7(bool$8)
    }, {
      id: validateType("Identifier"),
      moduleReference: validateType("TSEntityName", "TSExternalModuleReference"),
      importKind: {
        validate: assertOneOf("type", "value"),
        optional: true
      }
    })
  });
  defineType("TSExternalModuleReference", {
    visitor: ["expression"],
    fields: {
      expression: validateType("StringLiteral")
    }
  });
  defineType("TSNonNullExpression", {
    aliases: ["Expression", "LVal", "PatternLike"],
    visitor: ["expression"],
    fields: {
      expression: validateType("Expression")
    }
  });
  defineType("TSExportAssignment", {
    aliases: ["Statement"],
    visitor: ["expression"],
    fields: {
      expression: validateType("Expression")
    }
  });
  defineType("TSNamespaceExportDeclaration", {
    aliases: ["Statement"],
    visitor: ["id"],
    fields: {
      id: validateType("Identifier")
    }
  });
  defineType("TSTypeAnnotation", {
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: {
        validate: assertNodeType("TSType")
      }
    }
  });
  defineType("TSTypeParameterInstantiation", {
    visitor: ["params"],
    fields: {
      params: validateArrayOfType("TSType")
    }
  });
  defineType("TSTypeParameterDeclaration", {
    visitor: ["params"],
    fields: {
      params: validateArrayOfType("TSTypeParameter")
    }
  });
  defineType("TSTypeParameter", {
    builder: ["constraint", "default", "name"],
    visitor: ["constraint", "default"],
    fields: {
      name: {
        validate: assertValueType("string")
      },
      "in": {
        validate: assertValueType("boolean"),
        optional: true
      },
      out: {
        validate: assertValueType("boolean"),
        optional: true
      },
      "const": {
        validate: assertValueType("boolean"),
        optional: true
      },
      constraint: {
        validate: assertNodeType("TSType"),
        optional: true
      },
      "default": {
        validate: assertNodeType("TSType"),
        optional: true
      }
    }
  });

  var DEPRECATED_ALIASES$1 = {
    ModuleDeclaration: "ImportOrExportDeclaration"
  };

  Object.keys(DEPRECATED_ALIASES$1).forEach(function (deprecatedAlias) {
    FLIPPED_ALIAS_KEYS$3[deprecatedAlias] = FLIPPED_ALIAS_KEYS$3[DEPRECATED_ALIASES$1[deprecatedAlias]];
  });
  for (var _iterator$1 = _createForOfIteratorHelperLoose(allExpandedTypes), _step$1; !(_step$1 = _iterator$1()).done;) {
    var _step$value = _step$1.value,
      types$1 = _step$value.types,
      set$1 = _step$value.set;
    for (var _iterator2 = _createForOfIteratorHelperLoose(types$1), _step2; !(_step2 = _iterator2()).done;) {
      var type$2 = _step2.value;
      var aliases = FLIPPED_ALIAS_KEYS$3[type$2];
      if (aliases) {
        aliases.forEach(set$1.add, set$1);
      } else {
        set$1.add(type$2);
      }
    }
  }
  var TYPES$1 = [].concat(Object.keys(VISITOR_KEYS$7), Object.keys(FLIPPED_ALIAS_KEYS$3), Object.keys(DEPRECATED_KEYS$1));

  function validate$6(node, key, val) {
    if (!node) return;
    var fields = NODE_FIELDS$1[node.type];
    if (!fields) return;
    var field = fields[key];
    validateField(node, key, val, field);
    validateChild(node, key, val);
  }
  function validateInternal(field, node, key, val, maybeNode) {
    if (!(field != null && field.validate)) return;
    if (field.optional && val == null) return;
    field.validate(node, key, val);
    if (maybeNode) {
      var _NODE_PARENT_VALIDATI;
      var type = val.type;
      if (type == null) return;
      (_NODE_PARENT_VALIDATI = NODE_PARENT_VALIDATIONS[type]) == null || _NODE_PARENT_VALIDATI.call(NODE_PARENT_VALIDATIONS, node, key, val);
    }
  }
  function validateField(node, key, val, field) {
    if (!(field != null && field.validate)) return;
    if (field.optional && val == null) return;
    field.validate(node, key, val);
  }
  function validateChild(node, key, val) {
    var _NODE_PARENT_VALIDATI2;
    var type = val == null ? void 0 : val.type;
    if (type == null) return;
    (_NODE_PARENT_VALIDATI2 = NODE_PARENT_VALIDATIONS[type]) == null || _NODE_PARENT_VALIDATI2.call(NODE_PARENT_VALIDATIONS, node, key, val);
  }

  var validate$5 = validateInternal;
  var NODE_FIELDS = NODE_FIELDS$1;
  function bigIntLiteral(value) {
    if (typeof value === "bigint") {
      value = value.toString();
    }
    var node = {
      type: "BigIntLiteral",
      value: value
    };
    var defs = NODE_FIELDS.BigIntLiteral;
    validate$5(defs.value, node, "value", value);
    return node;
  }
  function arrayExpression$1(elements) {
    if (elements === void 0) {
      elements = [];
    }
    var node = {
      type: "ArrayExpression",
      elements: elements
    };
    var defs = NODE_FIELDS.ArrayExpression;
    validate$5(defs.elements, node, "elements", elements, 1);
    return node;
  }
  function assignmentExpression$8(operator, left, right) {
    var node = {
      type: "AssignmentExpression",
      operator: operator,
      left: left,
      right: right
    };
    var defs = NODE_FIELDS.AssignmentExpression;
    validate$5(defs.operator, node, "operator", operator);
    validate$5(defs.left, node, "left", left, 1);
    validate$5(defs.right, node, "right", right, 1);
    return node;
  }
  function binaryExpression$4(operator, left, right) {
    var node = {
      type: "BinaryExpression",
      operator: operator,
      left: left,
      right: right
    };
    var defs = NODE_FIELDS.BinaryExpression;
    validate$5(defs.operator, node, "operator", operator);
    validate$5(defs.left, node, "left", left, 1);
    validate$5(defs.right, node, "right", right, 1);
    return node;
  }
  function interpreterDirective$1(value) {
    var node = {
      type: "InterpreterDirective",
      value: value
    };
    var defs = NODE_FIELDS.InterpreterDirective;
    validate$5(defs.value, node, "value", value);
    return node;
  }
  function directive(value) {
    var node = {
      type: "Directive",
      value: value
    };
    var defs = NODE_FIELDS.Directive;
    validate$5(defs.value, node, "value", value, 1);
    return node;
  }
  function directiveLiteral(value) {
    var node = {
      type: "DirectiveLiteral",
      value: value
    };
    var defs = NODE_FIELDS.DirectiveLiteral;
    validate$5(defs.value, node, "value", value);
    return node;
  }
  function blockStatement$6(body, directives) {
    if (directives === void 0) {
      directives = [];
    }
    var node = {
      type: "BlockStatement",
      body: body,
      directives: directives
    };
    var defs = NODE_FIELDS.BlockStatement;
    validate$5(defs.body, node, "body", body, 1);
    validate$5(defs.directives, node, "directives", directives, 1);
    return node;
  }
  function breakStatement(label) {
    if (label === void 0) {
      label = null;
    }
    var node = {
      type: "BreakStatement",
      label: label
    };
    var defs = NODE_FIELDS.BreakStatement;
    validate$5(defs.label, node, "label", label, 1);
    return node;
  }
  function callExpression$c(callee, _arguments) {
    var node = {
      type: "CallExpression",
      callee: callee,
      arguments: _arguments
    };
    var defs = NODE_FIELDS.CallExpression;
    validate$5(defs.callee, node, "callee", callee, 1);
    validate$5(defs.arguments, node, "arguments", _arguments, 1);
    return node;
  }
  function catchClause(param, body) {
    if (param === void 0) {
      param = null;
    }
    var node = {
      type: "CatchClause",
      param: param,
      body: body
    };
    var defs = NODE_FIELDS.CatchClause;
    validate$5(defs.param, node, "param", param, 1);
    validate$5(defs.body, node, "body", body, 1);
    return node;
  }
  function conditionalExpression$5(test, consequent, alternate) {
    var node = {
      type: "ConditionalExpression",
      test: test,
      consequent: consequent,
      alternate: alternate
    };
    var defs = NODE_FIELDS.ConditionalExpression;
    validate$5(defs.test, node, "test", test, 1);
    validate$5(defs.consequent, node, "consequent", consequent, 1);
    validate$5(defs.alternate, node, "alternate", alternate, 1);
    return node;
  }
  function continueStatement(label) {
    if (label === void 0) {
      label = null;
    }
    var node = {
      type: "ContinueStatement",
      label: label
    };
    var defs = NODE_FIELDS.ContinueStatement;
    validate$5(defs.label, node, "label", label, 1);
    return node;
  }
  function debuggerStatement() {
    return {
      type: "DebuggerStatement"
    };
  }
  function doWhileStatement(test, body) {
    var node = {
      type: "DoWhileStatement",
      test: test,
      body: body
    };
    var defs = NODE_FIELDS.DoWhileStatement;
    validate$5(defs.test, node, "test", test, 1);
    validate$5(defs.body, node, "body", body, 1);
    return node;
  }
  function emptyStatement$1() {
    return {
      type: "EmptyStatement"
    };
  }
  function expressionStatement$7(expression) {
    var node = {
      type: "ExpressionStatement",
      expression: expression
    };
    var defs = NODE_FIELDS.ExpressionStatement;
    validate$5(defs.expression, node, "expression", expression, 1);
    return node;
  }
  function file$1(program, comments, tokens) {
    if (comments === void 0) {
      comments = null;
    }
    if (tokens === void 0) {
      tokens = null;
    }
    var node = {
      type: "File",
      program: program,
      comments: comments,
      tokens: tokens
    };
    var defs = NODE_FIELDS.File;
    validate$5(defs.program, node, "program", program, 1);
    validate$5(defs.comments, node, "comments", comments, 1);
    validate$5(defs.tokens, node, "tokens", tokens);
    return node;
  }
  function forInStatement(left, right, body) {
    var node = {
      type: "ForInStatement",
      left: left,
      right: right,
      body: body
    };
    var defs = NODE_FIELDS.ForInStatement;
    validate$5(defs.left, node, "left", left, 1);
    validate$5(defs.right, node, "right", right, 1);
    validate$5(defs.body, node, "body", body, 1);
    return node;
  }
  function forStatement(init, test, update, body) {
    if (init === void 0) {
      init = null;
    }
    if (test === void 0) {
      test = null;
    }
    if (update === void 0) {
      update = null;
    }
    var node = {
      type: "ForStatement",
      init: init,
      test: test,
      update: update,
      body: body
    };
    var defs = NODE_FIELDS.ForStatement;
    validate$5(defs.init, node, "init", init, 1);
    validate$5(defs.test, node, "test", test, 1);
    validate$5(defs.update, node, "update", update, 1);
    validate$5(defs.body, node, "body", body, 1);
    return node;
  }
  function functionDeclaration(id, params, body, generator, async) {
    if (id === void 0) {
      id = null;
    }
    if (generator === void 0) {
      generator = false;
    }
    if (async === void 0) {
      async = false;
    }
    var node = {
      type: "FunctionDeclaration",
      id: id,
      params: params,
      body: body,
      generator: generator,
      async: async
    };
    var defs = NODE_FIELDS.FunctionDeclaration;
    validate$5(defs.id, node, "id", id, 1);
    validate$5(defs.params, node, "params", params, 1);
    validate$5(defs.body, node, "body", body, 1);
    validate$5(defs.generator, node, "generator", generator);
    validate$5(defs.async, node, "async", async);
    return node;
  }
  function functionExpression$2(id, params, body, generator, async) {
    if (id === void 0) {
      id = null;
    }
    if (generator === void 0) {
      generator = false;
    }
    if (async === void 0) {
      async = false;
    }
    var node = {
      type: "FunctionExpression",
      id: id,
      params: params,
      body: body,
      generator: generator,
      async: async
    };
    var defs = NODE_FIELDS.FunctionExpression;
    validate$5(defs.id, node, "id", id, 1);
    validate$5(defs.params, node, "params", params, 1);
    validate$5(defs.body, node, "body", body, 1);
    validate$5(defs.generator, node, "generator", generator);
    validate$5(defs.async, node, "async", async);
    return node;
  }
  function identifier$e(name) {
    var node = {
      type: "Identifier",
      name: name
    };
    var defs = NODE_FIELDS.Identifier;
    validate$5(defs.name, node, "name", name);
    return node;
  }
  function ifStatement(test, consequent, alternate) {
    if (alternate === void 0) {
      alternate = null;
    }
    var node = {
      type: "IfStatement",
      test: test,
      consequent: consequent,
      alternate: alternate
    };
    var defs = NODE_FIELDS.IfStatement;
    validate$5(defs.test, node, "test", test, 1);
    validate$5(defs.consequent, node, "consequent", consequent, 1);
    validate$5(defs.alternate, node, "alternate", alternate, 1);
    return node;
  }
  function labeledStatement(label, body) {
    var node = {
      type: "LabeledStatement",
      label: label,
      body: body
    };
    var defs = NODE_FIELDS.LabeledStatement;
    validate$5(defs.label, node, "label", label, 1);
    validate$5(defs.body, node, "body", body, 1);
    return node;
  }
  function stringLiteral$6(value) {
    var node = {
      type: "StringLiteral",
      value: value
    };
    var defs = NODE_FIELDS.StringLiteral;
    validate$5(defs.value, node, "value", value);
    return node;
  }
  function numericLiteral$5(value) {
    var node = {
      type: "NumericLiteral",
      value: value
    };
    var defs = NODE_FIELDS.NumericLiteral;
    validate$5(defs.value, node, "value", value);
    return node;
  }
  function nullLiteral$2() {
    return {
      type: "NullLiteral"
    };
  }
  function booleanLiteral$2(value) {
    var node = {
      type: "BooleanLiteral",
      value: value
    };
    var defs = NODE_FIELDS.BooleanLiteral;
    validate$5(defs.value, node, "value", value);
    return node;
  }
  function regExpLiteral(pattern, flags) {
    if (flags === void 0) {
      flags = "";
    }
    var node = {
      type: "RegExpLiteral",
      pattern: pattern,
      flags: flags
    };
    var defs = NODE_FIELDS.RegExpLiteral;
    validate$5(defs.pattern, node, "pattern", pattern);
    validate$5(defs.flags, node, "flags", flags);
    return node;
  }
  function logicalExpression$2(operator, left, right) {
    var node = {
      type: "LogicalExpression",
      operator: operator,
      left: left,
      right: right
    };
    var defs = NODE_FIELDS.LogicalExpression;
    validate$5(defs.operator, node, "operator", operator);
    validate$5(defs.left, node, "left", left, 1);
    validate$5(defs.right, node, "right", right, 1);
    return node;
  }
  function memberExpression$a(object, property, computed, optional) {
    if (computed === void 0) {
      computed = false;
    }
    if (optional === void 0) {
      optional = null;
    }
    var node = {
      type: "MemberExpression",
      object: object,
      property: property,
      computed: computed,
      optional: optional
    };
    var defs = NODE_FIELDS.MemberExpression;
    validate$5(defs.object, node, "object", object, 1);
    validate$5(defs.property, node, "property", property, 1);
    validate$5(defs.computed, node, "computed", computed);
    validate$5(defs.optional, node, "optional", optional);
    return node;
  }
  function newExpression(callee, _arguments) {
    var node = {
      type: "NewExpression",
      callee: callee,
      arguments: _arguments
    };
    var defs = NODE_FIELDS.NewExpression;
    validate$5(defs.callee, node, "callee", callee, 1);
    validate$5(defs.arguments, node, "arguments", _arguments, 1);
    return node;
  }
  function program$3(body, directives, sourceType, interpreter) {
    if (directives === void 0) {
      directives = [];
    }
    if (sourceType === void 0) {
      sourceType = "script";
    }
    if (interpreter === void 0) {
      interpreter = null;
    }
    var node = {
      type: "Program",
      body: body,
      directives: directives,
      sourceType: sourceType,
      interpreter: interpreter
    };
    var defs = NODE_FIELDS.Program;
    validate$5(defs.body, node, "body", body, 1);
    validate$5(defs.directives, node, "directives", directives, 1);
    validate$5(defs.sourceType, node, "sourceType", sourceType);
    validate$5(defs.interpreter, node, "interpreter", interpreter, 1);
    return node;
  }
  function objectExpression$3(properties) {
    var node = {
      type: "ObjectExpression",
      properties: properties
    };
    var defs = NODE_FIELDS.ObjectExpression;
    validate$5(defs.properties, node, "properties", properties, 1);
    return node;
  }
  function objectMethod(kind, key, params, body, computed, generator, async) {
    if (kind === void 0) {
      kind = "method";
    }
    if (computed === void 0) {
      computed = false;
    }
    if (generator === void 0) {
      generator = false;
    }
    if (async === void 0) {
      async = false;
    }
    var node = {
      type: "ObjectMethod",
      kind: kind,
      key: key,
      params: params,
      body: body,
      computed: computed,
      generator: generator,
      async: async
    };
    var defs = NODE_FIELDS.ObjectMethod;
    validate$5(defs.kind, node, "kind", kind);
    validate$5(defs.key, node, "key", key, 1);
    validate$5(defs.params, node, "params", params, 1);
    validate$5(defs.body, node, "body", body, 1);
    validate$5(defs.computed, node, "computed", computed);
    validate$5(defs.generator, node, "generator", generator);
    validate$5(defs.async, node, "async", async);
    return node;
  }
  function objectProperty$1(key, value, computed, shorthand, decorators) {
    if (computed === void 0) {
      computed = false;
    }
    if (shorthand === void 0) {
      shorthand = false;
    }
    if (decorators === void 0) {
      decorators = null;
    }
    var node = {
      type: "ObjectProperty",
      key: key,
      value: value,
      computed: computed,
      shorthand: shorthand,
      decorators: decorators
    };
    var defs = NODE_FIELDS.ObjectProperty;
    validate$5(defs.key, node, "key", key, 1);
    validate$5(defs.value, node, "value", value, 1);
    validate$5(defs.computed, node, "computed", computed);
    validate$5(defs.shorthand, node, "shorthand", shorthand);
    validate$5(defs.decorators, node, "decorators", decorators, 1);
    return node;
  }
  function restElement$2(argument) {
    var node = {
      type: "RestElement",
      argument: argument
    };
    var defs = NODE_FIELDS.RestElement;
    validate$5(defs.argument, node, "argument", argument, 1);
    return node;
  }
  function returnStatement$3(argument) {
    if (argument === void 0) {
      argument = null;
    }
    var node = {
      type: "ReturnStatement",
      argument: argument
    };
    var defs = NODE_FIELDS.ReturnStatement;
    validate$5(defs.argument, node, "argument", argument, 1);
    return node;
  }
  function sequenceExpression$6(expressions) {
    var node = {
      type: "SequenceExpression",
      expressions: expressions
    };
    var defs = NODE_FIELDS.SequenceExpression;
    validate$5(defs.expressions, node, "expressions", expressions, 1);
    return node;
  }
  function parenthesizedExpression(expression) {
    var node = {
      type: "ParenthesizedExpression",
      expression: expression
    };
    var defs = NODE_FIELDS.ParenthesizedExpression;
    validate$5(defs.expression, node, "expression", expression, 1);
    return node;
  }
  function switchCase(test, consequent) {
    if (test === void 0) {
      test = null;
    }
    var node = {
      type: "SwitchCase",
      test: test,
      consequent: consequent
    };
    var defs = NODE_FIELDS.SwitchCase;
    validate$5(defs.test, node, "test", test, 1);
    validate$5(defs.consequent, node, "consequent", consequent, 1);
    return node;
  }
  function switchStatement(discriminant, cases) {
    var node = {
      type: "SwitchStatement",
      discriminant: discriminant,
      cases: cases
    };
    var defs = NODE_FIELDS.SwitchStatement;
    validate$5(defs.discriminant, node, "discriminant", discriminant, 1);
    validate$5(defs.cases, node, "cases", cases, 1);
    return node;
  }
  function thisExpression$5() {
    return {
      type: "ThisExpression"
    };
  }
  function throwStatement(argument) {
    var node = {
      type: "ThrowStatement",
      argument: argument
    };
    var defs = NODE_FIELDS.ThrowStatement;
    validate$5(defs.argument, node, "argument", argument, 1);
    return node;
  }
  function tryStatement(block, handler, finalizer) {
    if (handler === void 0) {
      handler = null;
    }
    if (finalizer === void 0) {
      finalizer = null;
    }
    var node = {
      type: "TryStatement",
      block: block,
      handler: handler,
      finalizer: finalizer
    };
    var defs = NODE_FIELDS.TryStatement;
    validate$5(defs.block, node, "block", block, 1);
    validate$5(defs.handler, node, "handler", handler, 1);
    validate$5(defs.finalizer, node, "finalizer", finalizer, 1);
    return node;
  }
  function unaryExpression$4(operator, argument, prefix) {
    if (prefix === void 0) {
      prefix = true;
    }
    var node = {
      type: "UnaryExpression",
      operator: operator,
      argument: argument,
      prefix: prefix
    };
    var defs = NODE_FIELDS.UnaryExpression;
    validate$5(defs.operator, node, "operator", operator);
    validate$5(defs.argument, node, "argument", argument, 1);
    validate$5(defs.prefix, node, "prefix", prefix);
    return node;
  }
  function updateExpression$1(operator, argument, prefix) {
    if (prefix === void 0) {
      prefix = false;
    }
    var node = {
      type: "UpdateExpression",
      operator: operator,
      argument: argument,
      prefix: prefix
    };
    var defs = NODE_FIELDS.UpdateExpression;
    validate$5(defs.operator, node, "operator", operator);
    validate$5(defs.argument, node, "argument", argument, 1);
    validate$5(defs.prefix, node, "prefix", prefix);
    return node;
  }
  function variableDeclaration$6(kind, declarations) {
    var node = {
      type: "VariableDeclaration",
      kind: kind,
      declarations: declarations
    };
    var defs = NODE_FIELDS.VariableDeclaration;
    validate$5(defs.kind, node, "kind", kind);
    validate$5(defs.declarations, node, "declarations", declarations, 1);
    return node;
  }
  function variableDeclarator$6(id, init) {
    if (init === void 0) {
      init = null;
    }
    var node = {
      type: "VariableDeclarator",
      id: id,
      init: init
    };
    var defs = NODE_FIELDS.VariableDeclarator;
    validate$5(defs.id, node, "id", id, 1);
    validate$5(defs.init, node, "init", init, 1);
    return node;
  }
  function whileStatement(test, body) {
    var node = {
      type: "WhileStatement",
      test: test,
      body: body
    };
    var defs = NODE_FIELDS.WhileStatement;
    validate$5(defs.test, node, "test", test, 1);
    validate$5(defs.body, node, "body", body, 1);
    return node;
  }
  function withStatement(object, body) {
    var node = {
      type: "WithStatement",
      object: object,
      body: body
    };
    var defs = NODE_FIELDS.WithStatement;
    validate$5(defs.object, node, "object", object, 1);
    validate$5(defs.body, node, "body", body, 1);
    return node;
  }
  function assignmentPattern(left, right) {
    var node = {
      type: "AssignmentPattern",
      left: left,
      right: right
    };
    var defs = NODE_FIELDS.AssignmentPattern;
    validate$5(defs.left, node, "left", left, 1);
    validate$5(defs.right, node, "right", right, 1);
    return node;
  }
  function arrayPattern(elements) {
    var node = {
      type: "ArrayPattern",
      elements: elements
    };
    var defs = NODE_FIELDS.ArrayPattern;
    validate$5(defs.elements, node, "elements", elements, 1);
    return node;
  }
  function arrowFunctionExpression$4(params, body, async) {
    if (async === void 0) {
      async = false;
    }
    var node = {
      type: "ArrowFunctionExpression",
      params: params,
      body: body,
      async: async,
      expression: null
    };
    var defs = NODE_FIELDS.ArrowFunctionExpression;
    validate$5(defs.params, node, "params", params, 1);
    validate$5(defs.body, node, "body", body, 1);
    validate$5(defs.async, node, "async", async);
    return node;
  }
  function classBody(body) {
    var node = {
      type: "ClassBody",
      body: body
    };
    var defs = NODE_FIELDS.ClassBody;
    validate$5(defs.body, node, "body", body, 1);
    return node;
  }
  function classExpression(id, superClass, body, decorators) {
    if (id === void 0) {
      id = null;
    }
    if (superClass === void 0) {
      superClass = null;
    }
    if (decorators === void 0) {
      decorators = null;
    }
    var node = {
      type: "ClassExpression",
      id: id,
      superClass: superClass,
      body: body,
      decorators: decorators
    };
    var defs = NODE_FIELDS.ClassExpression;
    validate$5(defs.id, node, "id", id, 1);
    validate$5(defs.superClass, node, "superClass", superClass, 1);
    validate$5(defs.body, node, "body", body, 1);
    validate$5(defs.decorators, node, "decorators", decorators, 1);
    return node;
  }
  function classDeclaration(id, superClass, body, decorators) {
    if (id === void 0) {
      id = null;
    }
    if (superClass === void 0) {
      superClass = null;
    }
    if (decorators === void 0) {
      decorators = null;
    }
    var node = {
      type: "ClassDeclaration",
      id: id,
      superClass: superClass,
      body: body,
      decorators: decorators
    };
    var defs = NODE_FIELDS.ClassDeclaration;
    validate$5(defs.id, node, "id", id, 1);
    validate$5(defs.superClass, node, "superClass", superClass, 1);
    validate$5(defs.body, node, "body", body, 1);
    validate$5(defs.decorators, node, "decorators", decorators, 1);
    return node;
  }
  function exportAllDeclaration(source) {
    var node = {
      type: "ExportAllDeclaration",
      source: source
    };
    var defs = NODE_FIELDS.ExportAllDeclaration;
    validate$5(defs.source, node, "source", source, 1);
    return node;
  }
  function exportDefaultDeclaration(declaration) {
    var node = {
      type: "ExportDefaultDeclaration",
      declaration: declaration
    };
    var defs = NODE_FIELDS.ExportDefaultDeclaration;
    validate$5(defs.declaration, node, "declaration", declaration, 1);
    return node;
  }
  function exportNamedDeclaration$2(declaration, specifiers, source) {
    if (declaration === void 0) {
      declaration = null;
    }
    if (specifiers === void 0) {
      specifiers = [];
    }
    if (source === void 0) {
      source = null;
    }
    var node = {
      type: "ExportNamedDeclaration",
      declaration: declaration,
      specifiers: specifiers,
      source: source
    };
    var defs = NODE_FIELDS.ExportNamedDeclaration;
    validate$5(defs.declaration, node, "declaration", declaration, 1);
    validate$5(defs.specifiers, node, "specifiers", specifiers, 1);
    validate$5(defs.source, node, "source", source, 1);
    return node;
  }
  function exportSpecifier$2(local, exported) {
    var node = {
      type: "ExportSpecifier",
      local: local,
      exported: exported
    };
    var defs = NODE_FIELDS.ExportSpecifier;
    validate$5(defs.local, node, "local", local, 1);
    validate$5(defs.exported, node, "exported", exported, 1);
    return node;
  }
  function forOfStatement(left, right, body, _await) {
    if (_await === void 0) {
      _await = false;
    }
    var node = {
      type: "ForOfStatement",
      left: left,
      right: right,
      body: body,
      "await": _await
    };
    var defs = NODE_FIELDS.ForOfStatement;
    validate$5(defs.left, node, "left", left, 1);
    validate$5(defs.right, node, "right", right, 1);
    validate$5(defs.body, node, "body", body, 1);
    validate$5(defs["await"], node, "await", _await);
    return node;
  }
  function importDeclaration$1(specifiers, source) {
    var node = {
      type: "ImportDeclaration",
      specifiers: specifiers,
      source: source
    };
    var defs = NODE_FIELDS.ImportDeclaration;
    validate$5(defs.specifiers, node, "specifiers", specifiers, 1);
    validate$5(defs.source, node, "source", source, 1);
    return node;
  }
  function importDefaultSpecifier$1(local) {
    var node = {
      type: "ImportDefaultSpecifier",
      local: local
    };
    var defs = NODE_FIELDS.ImportDefaultSpecifier;
    validate$5(defs.local, node, "local", local, 1);
    return node;
  }
  function importNamespaceSpecifier$1(local) {
    var node = {
      type: "ImportNamespaceSpecifier",
      local: local
    };
    var defs = NODE_FIELDS.ImportNamespaceSpecifier;
    validate$5(defs.local, node, "local", local, 1);
    return node;
  }
  function importSpecifier$2(local, imported) {
    var node = {
      type: "ImportSpecifier",
      local: local,
      imported: imported
    };
    var defs = NODE_FIELDS.ImportSpecifier;
    validate$5(defs.local, node, "local", local, 1);
    validate$5(defs.imported, node, "imported", imported, 1);
    return node;
  }
  function importExpression(source, options) {
    if (options === void 0) {
      options = null;
    }
    var node = {
      type: "ImportExpression",
      source: source,
      options: options
    };
    var defs = NODE_FIELDS.ImportExpression;
    validate$5(defs.source, node, "source", source, 1);
    validate$5(defs.options, node, "options", options, 1);
    return node;
  }
  function metaProperty$1(meta, property) {
    var node = {
      type: "MetaProperty",
      meta: meta,
      property: property
    };
    var defs = NODE_FIELDS.MetaProperty;
    validate$5(defs.meta, node, "meta", meta, 1);
    validate$5(defs.property, node, "property", property, 1);
    return node;
  }
  function classMethod(kind, key, params, body, computed, _static, generator, async) {
    if (kind === void 0) {
      kind = "method";
    }
    if (computed === void 0) {
      computed = false;
    }
    if (_static === void 0) {
      _static = false;
    }
    if (generator === void 0) {
      generator = false;
    }
    if (async === void 0) {
      async = false;
    }
    var node = {
      type: "ClassMethod",
      kind: kind,
      key: key,
      params: params,
      body: body,
      computed: computed,
      "static": _static,
      generator: generator,
      async: async
    };
    var defs = NODE_FIELDS.ClassMethod;
    validate$5(defs.kind, node, "kind", kind);
    validate$5(defs.key, node, "key", key, 1);
    validate$5(defs.params, node, "params", params, 1);
    validate$5(defs.body, node, "body", body, 1);
    validate$5(defs.computed, node, "computed", computed);
    validate$5(defs["static"], node, "static", _static);
    validate$5(defs.generator, node, "generator", generator);
    validate$5(defs.async, node, "async", async);
    return node;
  }
  function objectPattern$1(properties) {
    var node = {
      type: "ObjectPattern",
      properties: properties
    };
    var defs = NODE_FIELDS.ObjectPattern;
    validate$5(defs.properties, node, "properties", properties, 1);
    return node;
  }
  function spreadElement$2(argument) {
    var node = {
      type: "SpreadElement",
      argument: argument
    };
    var defs = NODE_FIELDS.SpreadElement;
    validate$5(defs.argument, node, "argument", argument, 1);
    return node;
  }
  function _super$1() {
    return {
      type: "Super"
    };
  }
  function taggedTemplateExpression(tag, quasi) {
    var node = {
      type: "TaggedTemplateExpression",
      tag: tag,
      quasi: quasi
    };
    var defs = NODE_FIELDS.TaggedTemplateExpression;
    validate$5(defs.tag, node, "tag", tag, 1);
    validate$5(defs.quasi, node, "quasi", quasi, 1);
    return node;
  }
  function templateElement(value, tail) {
    if (tail === void 0) {
      tail = false;
    }
    var node = {
      type: "TemplateElement",
      value: value,
      tail: tail
    };
    var defs = NODE_FIELDS.TemplateElement;
    validate$5(defs.value, node, "value", value);
    validate$5(defs.tail, node, "tail", tail);
    return node;
  }
  function templateLiteral(quasis, expressions) {
    var node = {
      type: "TemplateLiteral",
      quasis: quasis,
      expressions: expressions
    };
    var defs = NODE_FIELDS.TemplateLiteral;
    validate$5(defs.quasis, node, "quasis", quasis, 1);
    validate$5(defs.expressions, node, "expressions", expressions, 1);
    return node;
  }
  function yieldExpression$2(argument, delegate) {
    if (argument === void 0) {
      argument = null;
    }
    if (delegate === void 0) {
      delegate = false;
    }
    var node = {
      type: "YieldExpression",
      argument: argument,
      delegate: delegate
    };
    var defs = NODE_FIELDS.YieldExpression;
    validate$5(defs.argument, node, "argument", argument, 1);
    validate$5(defs.delegate, node, "delegate", delegate);
    return node;
  }
  function awaitExpression$1(argument) {
    var node = {
      type: "AwaitExpression",
      argument: argument
    };
    var defs = NODE_FIELDS.AwaitExpression;
    validate$5(defs.argument, node, "argument", argument, 1);
    return node;
  }
  function _import() {
    return {
      type: "Import"
    };
  }
  function exportNamespaceSpecifier(exported) {
    var node = {
      type: "ExportNamespaceSpecifier",
      exported: exported
    };
    var defs = NODE_FIELDS.ExportNamespaceSpecifier;
    validate$5(defs.exported, node, "exported", exported, 1);
    return node;
  }
  function optionalMemberExpression$2(object, property, computed, optional) {
    if (computed === void 0) {
      computed = false;
    }
    var node = {
      type: "OptionalMemberExpression",
      object: object,
      property: property,
      computed: computed,
      optional: optional
    };
    var defs = NODE_FIELDS.OptionalMemberExpression;
    validate$5(defs.object, node, "object", object, 1);
    validate$5(defs.property, node, "property", property, 1);
    validate$5(defs.computed, node, "computed", computed);
    validate$5(defs.optional, node, "optional", optional);
    return node;
  }
  function optionalCallExpression$2(callee, _arguments, optional) {
    var node = {
      type: "OptionalCallExpression",
      callee: callee,
      arguments: _arguments,
      optional: optional
    };
    var defs = NODE_FIELDS.OptionalCallExpression;
    validate$5(defs.callee, node, "callee", callee, 1);
    validate$5(defs.arguments, node, "arguments", _arguments, 1);
    validate$5(defs.optional, node, "optional", optional);
    return node;
  }
  function classProperty(key, value, typeAnnotation, decorators, computed, _static) {
    if (value === void 0) {
      value = null;
    }
    if (typeAnnotation === void 0) {
      typeAnnotation = null;
    }
    if (decorators === void 0) {
      decorators = null;
    }
    if (computed === void 0) {
      computed = false;
    }
    if (_static === void 0) {
      _static = false;
    }
    var node = {
      type: "ClassProperty",
      key: key,
      value: value,
      typeAnnotation: typeAnnotation,
      decorators: decorators,
      computed: computed,
      "static": _static
    };
    var defs = NODE_FIELDS.ClassProperty;
    validate$5(defs.key, node, "key", key, 1);
    validate$5(defs.value, node, "value", value, 1);
    validate$5(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
    validate$5(defs.decorators, node, "decorators", decorators, 1);
    validate$5(defs.computed, node, "computed", computed);
    validate$5(defs["static"], node, "static", _static);
    return node;
  }
  function classAccessorProperty(key, value, typeAnnotation, decorators, computed, _static) {
    if (value === void 0) {
      value = null;
    }
    if (typeAnnotation === void 0) {
      typeAnnotation = null;
    }
    if (decorators === void 0) {
      decorators = null;
    }
    if (computed === void 0) {
      computed = false;
    }
    if (_static === void 0) {
      _static = false;
    }
    var node = {
      type: "ClassAccessorProperty",
      key: key,
      value: value,
      typeAnnotation: typeAnnotation,
      decorators: decorators,
      computed: computed,
      "static": _static
    };
    var defs = NODE_FIELDS.ClassAccessorProperty;
    validate$5(defs.key, node, "key", key, 1);
    validate$5(defs.value, node, "value", value, 1);
    validate$5(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
    validate$5(defs.decorators, node, "decorators", decorators, 1);
    validate$5(defs.computed, node, "computed", computed);
    validate$5(defs["static"], node, "static", _static);
    return node;
  }
  function classPrivateProperty(key, value, decorators, _static) {
    if (value === void 0) {
      value = null;
    }
    if (decorators === void 0) {
      decorators = null;
    }
    if (_static === void 0) {
      _static = false;
    }
    var node = {
      type: "ClassPrivateProperty",
      key: key,
      value: value,
      decorators: decorators,
      "static": _static
    };
    var defs = NODE_FIELDS.ClassPrivateProperty;
    validate$5(defs.key, node, "key", key, 1);
    validate$5(defs.value, node, "value", value, 1);
    validate$5(defs.decorators, node, "decorators", decorators, 1);
    validate$5(defs["static"], node, "static", _static);
    return node;
  }
  function classPrivateMethod(kind, key, params, body, _static) {
    if (kind === void 0) {
      kind = "method";
    }
    if (_static === void 0) {
      _static = false;
    }
    var node = {
      type: "ClassPrivateMethod",
      kind: kind,
      key: key,
      params: params,
      body: body,
      "static": _static
    };
    var defs = NODE_FIELDS.ClassPrivateMethod;
    validate$5(defs.kind, node, "kind", kind);
    validate$5(defs.key, node, "key", key, 1);
    validate$5(defs.params, node, "params", params, 1);
    validate$5(defs.body, node, "body", body, 1);
    validate$5(defs["static"], node, "static", _static);
    return node;
  }
  function privateName(id) {
    var node = {
      type: "PrivateName",
      id: id
    };
    var defs = NODE_FIELDS.PrivateName;
    validate$5(defs.id, node, "id", id, 1);
    return node;
  }
  function staticBlock(body) {
    var node = {
      type: "StaticBlock",
      body: body
    };
    var defs = NODE_FIELDS.StaticBlock;
    validate$5(defs.body, node, "body", body, 1);
    return node;
  }
  function importAttribute(key, value) {
    var node = {
      type: "ImportAttribute",
      key: key,
      value: value
    };
    var defs = NODE_FIELDS.ImportAttribute;
    validate$5(defs.key, node, "key", key, 1);
    validate$5(defs.value, node, "value", value, 1);
    return node;
  }
  function anyTypeAnnotation$2() {
    return {
      type: "AnyTypeAnnotation"
    };
  }
  function arrayTypeAnnotation$1(elementType) {
    var node = {
      type: "ArrayTypeAnnotation",
      elementType: elementType
    };
    var defs = NODE_FIELDS.ArrayTypeAnnotation;
    validate$5(defs.elementType, node, "elementType", elementType, 1);
    return node;
  }
  function booleanTypeAnnotation$1() {
    return {
      type: "BooleanTypeAnnotation"
    };
  }
  function booleanLiteralTypeAnnotation(value) {
    var node = {
      type: "BooleanLiteralTypeAnnotation",
      value: value
    };
    var defs = NODE_FIELDS.BooleanLiteralTypeAnnotation;
    validate$5(defs.value, node, "value", value);
    return node;
  }
  function nullLiteralTypeAnnotation$1() {
    return {
      type: "NullLiteralTypeAnnotation"
    };
  }
  function classImplements(id, typeParameters) {
    if (typeParameters === void 0) {
      typeParameters = null;
    }
    var node = {
      type: "ClassImplements",
      id: id,
      typeParameters: typeParameters
    };
    var defs = NODE_FIELDS.ClassImplements;
    validate$5(defs.id, node, "id", id, 1);
    validate$5(defs.typeParameters, node, "typeParameters", typeParameters, 1);
    return node;
  }
  function declareClass(id, typeParameters, _extends, body) {
    if (typeParameters === void 0) {
      typeParameters = null;
    }
    if (_extends === void 0) {
      _extends = null;
    }
    var node = {
      type: "DeclareClass",
      id: id,
      typeParameters: typeParameters,
      "extends": _extends,
      body: body
    };
    var defs = NODE_FIELDS.DeclareClass;
    validate$5(defs.id, node, "id", id, 1);
    validate$5(defs.typeParameters, node, "typeParameters", typeParameters, 1);
    validate$5(defs["extends"], node, "extends", _extends, 1);
    validate$5(defs.body, node, "body", body, 1);
    return node;
  }
  function declareFunction(id) {
    var node = {
      type: "DeclareFunction",
      id: id
    };
    var defs = NODE_FIELDS.DeclareFunction;
    validate$5(defs.id, node, "id", id, 1);
    return node;
  }
  function declareInterface(id, typeParameters, _extends, body) {
    if (typeParameters === void 0) {
      typeParameters = null;
    }
    if (_extends === void 0) {
      _extends = null;
    }
    var node = {
      type: "DeclareInterface",
      id: id,
      typeParameters: typeParameters,
      "extends": _extends,
      body: body
    };
    var defs = NODE_FIELDS.DeclareInterface;
    validate$5(defs.id, node, "id", id, 1);
    validate$5(defs.typeParameters, node, "typeParameters", typeParameters, 1);
    validate$5(defs["extends"], node, "extends", _extends, 1);
    validate$5(defs.body, node, "body", body, 1);
    return node;
  }
  function declareModule(id, body, kind) {
    if (kind === void 0) {
      kind = null;
    }
    var node = {
      type: "DeclareModule",
      id: id,
      body: body,
      kind: kind
    };
    var defs = NODE_FIELDS.DeclareModule;
    validate$5(defs.id, node, "id", id, 1);
    validate$5(defs.body, node, "body", body, 1);
    validate$5(defs.kind, node, "kind", kind);
    return node;
  }
  function declareModuleExports(typeAnnotation) {
    var node = {
      type: "DeclareModuleExports",
      typeAnnotation: typeAnnotation
    };
    var defs = NODE_FIELDS.DeclareModuleExports;
    validate$5(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
    return node;
  }
  function declareTypeAlias(id, typeParameters, right) {
    if (typeParameters === void 0) {
      typeParameters = null;
    }
    var node = {
      type: "DeclareTypeAlias",
      id: id,
      typeParameters: typeParameters,
      right: right
    };
    var defs = NODE_FIELDS.DeclareTypeAlias;
    validate$5(defs.id, node, "id", id, 1);
    validate$5(defs.typeParameters, node, "typeParameters", typeParameters, 1);
    validate$5(defs.right, node, "right", right, 1);
    return node;
  }
  function declareOpaqueType(id, typeParameters, supertype) {
    if (typeParameters === void 0) {
      typeParameters = null;
    }
    if (supertype === void 0) {
      supertype = null;
    }
    var node = {
      type: "DeclareOpaqueType",
      id: id,
      typeParameters: typeParameters,
      supertype: supertype
    };
    var defs = NODE_FIELDS.DeclareOpaqueType;
    validate$5(defs.id, node, "id", id, 1);
    validate$5(defs.typeParameters, node, "typeParameters", typeParameters, 1);
    validate$5(defs.supertype, node, "supertype", supertype, 1);
    return node;
  }
  function declareVariable(id) {
    var node = {
      type: "DeclareVariable",
      id: id
    };
    var defs = NODE_FIELDS.DeclareVariable;
    validate$5(defs.id, node, "id", id, 1);
    return node;
  }
  function declareExportDeclaration(declaration, specifiers, source, attributes) {
    if (declaration === void 0) {
      declaration = null;
    }
    if (specifiers === void 0) {
      specifiers = null;
    }
    if (source === void 0) {
      source = null;
    }
    if (attributes === void 0) {
      attributes = null;
    }
    var node = {
      type: "DeclareExportDeclaration",
      declaration: declaration,
      specifiers: specifiers,
      source: source,
      attributes: attributes
    };
    var defs = NODE_FIELDS.DeclareExportDeclaration;
    validate$5(defs.declaration, node, "declaration", declaration, 1);
    validate$5(defs.specifiers, node, "specifiers", specifiers, 1);
    validate$5(defs.source, node, "source", source, 1);
    validate$5(defs.attributes, node, "attributes", attributes, 1);
    return node;
  }
  function declareExportAllDeclaration(source, attributes) {
    if (attributes === void 0) {
      attributes = null;
    }
    var node = {
      type: "DeclareExportAllDeclaration",
      source: source,
      attributes: attributes
    };
    var defs = NODE_FIELDS.DeclareExportAllDeclaration;
    validate$5(defs.source, node, "source", source, 1);
    validate$5(defs.attributes, node, "attributes", attributes, 1);
    return node;
  }
  function declaredPredicate(value) {
    var node = {
      type: "DeclaredPredicate",
      value: value
    };
    var defs = NODE_FIELDS.DeclaredPredicate;
    validate$5(defs.value, node, "value", value, 1);
    return node;
  }
  function existsTypeAnnotation() {
    return {
      type: "ExistsTypeAnnotation"
    };
  }
  function functionTypeAnnotation(typeParameters, params, rest, returnType) {
    if (typeParameters === void 0) {
      typeParameters = null;
    }
    if (rest === void 0) {
      rest = null;
    }
    var node = {
      type: "FunctionTypeAnnotation",
      typeParameters: typeParameters,
      params: params,
      rest: rest,
      returnType: returnType
    };
    var defs = NODE_FIELDS.FunctionTypeAnnotation;
    validate$5(defs.typeParameters, node, "typeParameters", typeParameters, 1);
    validate$5(defs.params, node, "params", params, 1);
    validate$5(defs.rest, node, "rest", rest, 1);
    validate$5(defs.returnType, node, "returnType", returnType, 1);
    return node;
  }
  function functionTypeParam(name, typeAnnotation) {
    if (name === void 0) {
      name = null;
    }
    var node = {
      type: "FunctionTypeParam",
      name: name,
      typeAnnotation: typeAnnotation
    };
    var defs = NODE_FIELDS.FunctionTypeParam;
    validate$5(defs.name, node, "name", name, 1);
    validate$5(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
    return node;
  }
  function genericTypeAnnotation$1(id, typeParameters) {
    if (typeParameters === void 0) {
      typeParameters = null;
    }
    var node = {
      type: "GenericTypeAnnotation",
      id: id,
      typeParameters: typeParameters
    };
    var defs = NODE_FIELDS.GenericTypeAnnotation;
    validate$5(defs.id, node, "id", id, 1);
    validate$5(defs.typeParameters, node, "typeParameters", typeParameters, 1);
    return node;
  }
  function inferredPredicate() {
    return {
      type: "InferredPredicate"
    };
  }
  function interfaceExtends(id, typeParameters) {
    if (typeParameters === void 0) {
      typeParameters = null;
    }
    var node = {
      type: "InterfaceExtends",
      id: id,
      typeParameters: typeParameters
    };
    var defs = NODE_FIELDS.InterfaceExtends;
    validate$5(defs.id, node, "id", id, 1);
    validate$5(defs.typeParameters, node, "typeParameters", typeParameters, 1);
    return node;
  }
  function interfaceDeclaration(id, typeParameters, _extends, body) {
    if (typeParameters === void 0) {
      typeParameters = null;
    }
    if (_extends === void 0) {
      _extends = null;
    }
    var node = {
      type: "InterfaceDeclaration",
      id: id,
      typeParameters: typeParameters,
      "extends": _extends,
      body: body
    };
    var defs = NODE_FIELDS.InterfaceDeclaration;
    validate$5(defs.id, node, "id", id, 1);
    validate$5(defs.typeParameters, node, "typeParameters", typeParameters, 1);
    validate$5(defs["extends"], node, "extends", _extends, 1);
    validate$5(defs.body, node, "body", body, 1);
    return node;
  }
  function interfaceTypeAnnotation(_extends, body) {
    if (_extends === void 0) {
      _extends = null;
    }
    var node = {
      type: "InterfaceTypeAnnotation",
      "extends": _extends,
      body: body
    };
    var defs = NODE_FIELDS.InterfaceTypeAnnotation;
    validate$5(defs["extends"], node, "extends", _extends, 1);
    validate$5(defs.body, node, "body", body, 1);
    return node;
  }
  function intersectionTypeAnnotation(types) {
    var node = {
      type: "IntersectionTypeAnnotation",
      types: types
    };
    var defs = NODE_FIELDS.IntersectionTypeAnnotation;
    validate$5(defs.types, node, "types", types, 1);
    return node;
  }
  function mixedTypeAnnotation() {
    return {
      type: "MixedTypeAnnotation"
    };
  }
  function emptyTypeAnnotation() {
    return {
      type: "EmptyTypeAnnotation"
    };
  }
  function nullableTypeAnnotation(typeAnnotation) {
    var node = {
      type: "NullableTypeAnnotation",
      typeAnnotation: typeAnnotation
    };
    var defs = NODE_FIELDS.NullableTypeAnnotation;
    validate$5(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
    return node;
  }
  function numberLiteralTypeAnnotation(value) {
    var node = {
      type: "NumberLiteralTypeAnnotation",
      value: value
    };
    var defs = NODE_FIELDS.NumberLiteralTypeAnnotation;
    validate$5(defs.value, node, "value", value);
    return node;
  }
  function numberTypeAnnotation$2() {
    return {
      type: "NumberTypeAnnotation"
    };
  }
  function objectTypeAnnotation(properties, indexers, callProperties, internalSlots, exact) {
    if (indexers === void 0) {
      indexers = [];
    }
    if (callProperties === void 0) {
      callProperties = [];
    }
    if (internalSlots === void 0) {
      internalSlots = [];
    }
    if (exact === void 0) {
      exact = false;
    }
    var node = {
      type: "ObjectTypeAnnotation",
      properties: properties,
      indexers: indexers,
      callProperties: callProperties,
      internalSlots: internalSlots,
      exact: exact
    };
    var defs = NODE_FIELDS.ObjectTypeAnnotation;
    validate$5(defs.properties, node, "properties", properties, 1);
    validate$5(defs.indexers, node, "indexers", indexers, 1);
    validate$5(defs.callProperties, node, "callProperties", callProperties, 1);
    validate$5(defs.internalSlots, node, "internalSlots", internalSlots, 1);
    validate$5(defs.exact, node, "exact", exact);
    return node;
  }
  function objectTypeInternalSlot(id, value, optional, _static, method) {
    var node = {
      type: "ObjectTypeInternalSlot",
      id: id,
      value: value,
      optional: optional,
      "static": _static,
      method: method
    };
    var defs = NODE_FIELDS.ObjectTypeInternalSlot;
    validate$5(defs.id, node, "id", id, 1);
    validate$5(defs.value, node, "value", value, 1);
    validate$5(defs.optional, node, "optional", optional);
    validate$5(defs["static"], node, "static", _static);
    validate$5(defs.method, node, "method", method);
    return node;
  }
  function objectTypeCallProperty(value) {
    var node = {
      type: "ObjectTypeCallProperty",
      value: value,
      "static": null
    };
    var defs = NODE_FIELDS.ObjectTypeCallProperty;
    validate$5(defs.value, node, "value", value, 1);
    return node;
  }
  function objectTypeIndexer(id, key, value, variance) {
    if (id === void 0) {
      id = null;
    }
    if (variance === void 0) {
      variance = null;
    }
    var node = {
      type: "ObjectTypeIndexer",
      id: id,
      key: key,
      value: value,
      variance: variance,
      "static": null
    };
    var defs = NODE_FIELDS.ObjectTypeIndexer;
    validate$5(defs.id, node, "id", id, 1);
    validate$5(defs.key, node, "key", key, 1);
    validate$5(defs.value, node, "value", value, 1);
    validate$5(defs.variance, node, "variance", variance, 1);
    return node;
  }
  function objectTypeProperty(key, value, variance) {
    if (variance === void 0) {
      variance = null;
    }
    var node = {
      type: "ObjectTypeProperty",
      key: key,
      value: value,
      variance: variance,
      kind: null,
      method: null,
      optional: null,
      proto: null,
      "static": null
    };
    var defs = NODE_FIELDS.ObjectTypeProperty;
    validate$5(defs.key, node, "key", key, 1);
    validate$5(defs.value, node, "value", value, 1);
    validate$5(defs.variance, node, "variance", variance, 1);
    return node;
  }
  function objectTypeSpreadProperty(argument) {
    var node = {
      type: "ObjectTypeSpreadProperty",
      argument: argument
    };
    var defs = NODE_FIELDS.ObjectTypeSpreadProperty;
    validate$5(defs.argument, node, "argument", argument, 1);
    return node;
  }
  function opaqueType(id, typeParameters, supertype, impltype) {
    if (typeParameters === void 0) {
      typeParameters = null;
    }
    if (supertype === void 0) {
      supertype = null;
    }
    var node = {
      type: "OpaqueType",
      id: id,
      typeParameters: typeParameters,
      supertype: supertype,
      impltype: impltype
    };
    var defs = NODE_FIELDS.OpaqueType;
    validate$5(defs.id, node, "id", id, 1);
    validate$5(defs.typeParameters, node, "typeParameters", typeParameters, 1);
    validate$5(defs.supertype, node, "supertype", supertype, 1);
    validate$5(defs.impltype, node, "impltype", impltype, 1);
    return node;
  }
  function qualifiedTypeIdentifier(id, qualification) {
    var node = {
      type: "QualifiedTypeIdentifier",
      id: id,
      qualification: qualification
    };
    var defs = NODE_FIELDS.QualifiedTypeIdentifier;
    validate$5(defs.id, node, "id", id, 1);
    validate$5(defs.qualification, node, "qualification", qualification, 1);
    return node;
  }
  function stringLiteralTypeAnnotation(value) {
    var node = {
      type: "StringLiteralTypeAnnotation",
      value: value
    };
    var defs = NODE_FIELDS.StringLiteralTypeAnnotation;
    validate$5(defs.value, node, "value", value);
    return node;
  }
  function stringTypeAnnotation$2() {
    return {
      type: "StringTypeAnnotation"
    };
  }
  function symbolTypeAnnotation() {
    return {
      type: "SymbolTypeAnnotation"
    };
  }
  function thisTypeAnnotation() {
    return {
      type: "ThisTypeAnnotation"
    };
  }
  function tupleTypeAnnotation$1(types) {
    var node = {
      type: "TupleTypeAnnotation",
      types: types
    };
    var defs = NODE_FIELDS.TupleTypeAnnotation;
    validate$5(defs.types, node, "types", types, 1);
    return node;
  }
  function typeofTypeAnnotation(argument) {
    var node = {
      type: "TypeofTypeAnnotation",
      argument: argument
    };
    var defs = NODE_FIELDS.TypeofTypeAnnotation;
    validate$5(defs.argument, node, "argument", argument, 1);
    return node;
  }
  function typeAlias(id, typeParameters, right) {
    if (typeParameters === void 0) {
      typeParameters = null;
    }
    var node = {
      type: "TypeAlias",
      id: id,
      typeParameters: typeParameters,
      right: right
    };
    var defs = NODE_FIELDS.TypeAlias;
    validate$5(defs.id, node, "id", id, 1);
    validate$5(defs.typeParameters, node, "typeParameters", typeParameters, 1);
    validate$5(defs.right, node, "right", right, 1);
    return node;
  }
  function typeAnnotation(typeAnnotation) {
    var node = {
      type: "TypeAnnotation",
      typeAnnotation: typeAnnotation
    };
    var defs = NODE_FIELDS.TypeAnnotation;
    validate$5(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
    return node;
  }
  function typeCastExpression(expression, typeAnnotation) {
    var node = {
      type: "TypeCastExpression",
      expression: expression,
      typeAnnotation: typeAnnotation
    };
    var defs = NODE_FIELDS.TypeCastExpression;
    validate$5(defs.expression, node, "expression", expression, 1);
    validate$5(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
    return node;
  }
  function typeParameter(bound, _default, variance) {
    if (bound === void 0) {
      bound = null;
    }
    if (_default === void 0) {
      _default = null;
    }
    if (variance === void 0) {
      variance = null;
    }
    var node = {
      type: "TypeParameter",
      bound: bound,
      "default": _default,
      variance: variance,
      name: null
    };
    var defs = NODE_FIELDS.TypeParameter;
    validate$5(defs.bound, node, "bound", bound, 1);
    validate$5(defs["default"], node, "default", _default, 1);
    validate$5(defs.variance, node, "variance", variance, 1);
    return node;
  }
  function typeParameterDeclaration(params) {
    var node = {
      type: "TypeParameterDeclaration",
      params: params
    };
    var defs = NODE_FIELDS.TypeParameterDeclaration;
    validate$5(defs.params, node, "params", params, 1);
    return node;
  }
  function typeParameterInstantiation(params) {
    var node = {
      type: "TypeParameterInstantiation",
      params: params
    };
    var defs = NODE_FIELDS.TypeParameterInstantiation;
    validate$5(defs.params, node, "params", params, 1);
    return node;
  }
  function unionTypeAnnotation$1(types) {
    var node = {
      type: "UnionTypeAnnotation",
      types: types
    };
    var defs = NODE_FIELDS.UnionTypeAnnotation;
    validate$5(defs.types, node, "types", types, 1);
    return node;
  }
  function variance(kind) {
    var node = {
      type: "Variance",
      kind: kind
    };
    var defs = NODE_FIELDS.Variance;
    validate$5(defs.kind, node, "kind", kind);
    return node;
  }
  function voidTypeAnnotation$3() {
    return {
      type: "VoidTypeAnnotation"
    };
  }
  function enumDeclaration(id, body) {
    var node = {
      type: "EnumDeclaration",
      id: id,
      body: body
    };
    var defs = NODE_FIELDS.EnumDeclaration;
    validate$5(defs.id, node, "id", id, 1);
    validate$5(defs.body, node, "body", body, 1);
    return node;
  }
  function enumBooleanBody(members) {
    var node = {
      type: "EnumBooleanBody",
      members: members,
      explicitType: null,
      hasUnknownMembers: null
    };
    var defs = NODE_FIELDS.EnumBooleanBody;
    validate$5(defs.members, node, "members", members, 1);
    return node;
  }
  function enumNumberBody(members) {
    var node = {
      type: "EnumNumberBody",
      members: members,
      explicitType: null,
      hasUnknownMembers: null
    };
    var defs = NODE_FIELDS.EnumNumberBody;
    validate$5(defs.members, node, "members", members, 1);
    return node;
  }
  function enumStringBody(members) {
    var node = {
      type: "EnumStringBody",
      members: members,
      explicitType: null,
      hasUnknownMembers: null
    };
    var defs = NODE_FIELDS.EnumStringBody;
    validate$5(defs.members, node, "members", members, 1);
    return node;
  }
  function enumSymbolBody(members) {
    var node = {
      type: "EnumSymbolBody",
      members: members,
      hasUnknownMembers: null
    };
    var defs = NODE_FIELDS.EnumSymbolBody;
    validate$5(defs.members, node, "members", members, 1);
    return node;
  }
  function enumBooleanMember(id) {
    var node = {
      type: "EnumBooleanMember",
      id: id,
      init: null
    };
    var defs = NODE_FIELDS.EnumBooleanMember;
    validate$5(defs.id, node, "id", id, 1);
    return node;
  }
  function enumNumberMember(id, init) {
    var node = {
      type: "EnumNumberMember",
      id: id,
      init: init
    };
    var defs = NODE_FIELDS.EnumNumberMember;
    validate$5(defs.id, node, "id", id, 1);
    validate$5(defs.init, node, "init", init, 1);
    return node;
  }
  function enumStringMember(id, init) {
    var node = {
      type: "EnumStringMember",
      id: id,
      init: init
    };
    var defs = NODE_FIELDS.EnumStringMember;
    validate$5(defs.id, node, "id", id, 1);
    validate$5(defs.init, node, "init", init, 1);
    return node;
  }
  function enumDefaultedMember(id) {
    var node = {
      type: "EnumDefaultedMember",
      id: id
    };
    var defs = NODE_FIELDS.EnumDefaultedMember;
    validate$5(defs.id, node, "id", id, 1);
    return node;
  }
  function indexedAccessType(objectType, indexType) {
    var node = {
      type: "IndexedAccessType",
      objectType: objectType,
      indexType: indexType
    };
    var defs = NODE_FIELDS.IndexedAccessType;
    validate$5(defs.objectType, node, "objectType", objectType, 1);
    validate$5(defs.indexType, node, "indexType", indexType, 1);
    return node;
  }
  function optionalIndexedAccessType(objectType, indexType) {
    var node = {
      type: "OptionalIndexedAccessType",
      objectType: objectType,
      indexType: indexType,
      optional: null
    };
    var defs = NODE_FIELDS.OptionalIndexedAccessType;
    validate$5(defs.objectType, node, "objectType", objectType, 1);
    validate$5(defs.indexType, node, "indexType", indexType, 1);
    return node;
  }
  function jsxAttribute(name, value) {
    if (value === void 0) {
      value = null;
    }
    var node = {
      type: "JSXAttribute",
      name: name,
      value: value
    };
    var defs = NODE_FIELDS.JSXAttribute;
    validate$5(defs.name, node, "name", name, 1);
    validate$5(defs.value, node, "value", value, 1);
    return node;
  }
  function jsxClosingElement(name) {
    var node = {
      type: "JSXClosingElement",
      name: name
    };
    var defs = NODE_FIELDS.JSXClosingElement;
    validate$5(defs.name, node, "name", name, 1);
    return node;
  }
  function jsxElement(openingElement, closingElement, children, selfClosing) {
    if (closingElement === void 0) {
      closingElement = null;
    }
    if (selfClosing === void 0) {
      selfClosing = null;
    }
    var node = {
      type: "JSXElement",
      openingElement: openingElement,
      closingElement: closingElement,
      children: children,
      selfClosing: selfClosing
    };
    var defs = NODE_FIELDS.JSXElement;
    validate$5(defs.openingElement, node, "openingElement", openingElement, 1);
    validate$5(defs.closingElement, node, "closingElement", closingElement, 1);
    validate$5(defs.children, node, "children", children, 1);
    validate$5(defs.selfClosing, node, "selfClosing", selfClosing);
    return node;
  }
  function jsxEmptyExpression() {
    return {
      type: "JSXEmptyExpression"
    };
  }
  function jsxExpressionContainer$1(expression) {
    var node = {
      type: "JSXExpressionContainer",
      expression: expression
    };
    var defs = NODE_FIELDS.JSXExpressionContainer;
    validate$5(defs.expression, node, "expression", expression, 1);
    return node;
  }
  function jsxSpreadChild(expression) {
    var node = {
      type: "JSXSpreadChild",
      expression: expression
    };
    var defs = NODE_FIELDS.JSXSpreadChild;
    validate$5(defs.expression, node, "expression", expression, 1);
    return node;
  }
  function jsxIdentifier$1(name) {
    var node = {
      type: "JSXIdentifier",
      name: name
    };
    var defs = NODE_FIELDS.JSXIdentifier;
    validate$5(defs.name, node, "name", name);
    return node;
  }
  function jsxMemberExpression(object, property) {
    var node = {
      type: "JSXMemberExpression",
      object: object,
      property: property
    };
    var defs = NODE_FIELDS.JSXMemberExpression;
    validate$5(defs.object, node, "object", object, 1);
    validate$5(defs.property, node, "property", property, 1);
    return node;
  }
  function jsxNamespacedName(namespace, name) {
    var node = {
      type: "JSXNamespacedName",
      namespace: namespace,
      name: name
    };
    var defs = NODE_FIELDS.JSXNamespacedName;
    validate$5(defs.namespace, node, "namespace", namespace, 1);
    validate$5(defs.name, node, "name", name, 1);
    return node;
  }
  function jsxOpeningElement(name, attributes, selfClosing) {
    if (selfClosing === void 0) {
      selfClosing = false;
    }
    var node = {
      type: "JSXOpeningElement",
      name: name,
      attributes: attributes,
      selfClosing: selfClosing
    };
    var defs = NODE_FIELDS.JSXOpeningElement;
    validate$5(defs.name, node, "name", name, 1);
    validate$5(defs.attributes, node, "attributes", attributes, 1);
    validate$5(defs.selfClosing, node, "selfClosing", selfClosing);
    return node;
  }
  function jsxSpreadAttribute(argument) {
    var node = {
      type: "JSXSpreadAttribute",
      argument: argument
    };
    var defs = NODE_FIELDS.JSXSpreadAttribute;
    validate$5(defs.argument, node, "argument", argument, 1);
    return node;
  }
  function jsxText(value) {
    var node = {
      type: "JSXText",
      value: value
    };
    var defs = NODE_FIELDS.JSXText;
    validate$5(defs.value, node, "value", value);
    return node;
  }
  function jsxFragment(openingFragment, closingFragment, children) {
    var node = {
      type: "JSXFragment",
      openingFragment: openingFragment,
      closingFragment: closingFragment,
      children: children
    };
    var defs = NODE_FIELDS.JSXFragment;
    validate$5(defs.openingFragment, node, "openingFragment", openingFragment, 1);
    validate$5(defs.closingFragment, node, "closingFragment", closingFragment, 1);
    validate$5(defs.children, node, "children", children, 1);
    return node;
  }
  function jsxOpeningFragment() {
    return {
      type: "JSXOpeningFragment"
    };
  }
  function jsxClosingFragment() {
    return {
      type: "JSXClosingFragment"
    };
  }
  function noop$1() {
    return {
      type: "Noop"
    };
  }
  function placeholder(expectedNode, name) {
    var node = {
      type: "Placeholder",
      expectedNode: expectedNode,
      name: name
    };
    var defs = NODE_FIELDS.Placeholder;
    validate$5(defs.expectedNode, node, "expectedNode", expectedNode);
    validate$5(defs.name, node, "name", name, 1);
    return node;
  }
  function v8IntrinsicIdentifier(name) {
    var node = {
      type: "V8IntrinsicIdentifier",
      name: name
    };
    var defs = NODE_FIELDS.V8IntrinsicIdentifier;
    validate$5(defs.name, node, "name", name);
    return node;
  }
  function argumentPlaceholder() {
    return {
      type: "ArgumentPlaceholder"
    };
  }
  function bindExpression(object, callee) {
    var node = {
      type: "BindExpression",
      object: object,
      callee: callee
    };
    var defs = NODE_FIELDS.BindExpression;
    validate$5(defs.object, node, "object", object, 1);
    validate$5(defs.callee, node, "callee", callee, 1);
    return node;
  }
  function decorator(expression) {
    var node = {
      type: "Decorator",
      expression: expression
    };
    var defs = NODE_FIELDS.Decorator;
    validate$5(defs.expression, node, "expression", expression, 1);
    return node;
  }
  function doExpression(body, async) {
    if (async === void 0) {
      async = false;
    }
    var node = {
      type: "DoExpression",
      body: body,
      async: async
    };
    var defs = NODE_FIELDS.DoExpression;
    validate$5(defs.body, node, "body", body, 1);
    validate$5(defs.async, node, "async", async);
    return node;
  }
  function exportDefaultSpecifier(exported) {
    var node = {
      type: "ExportDefaultSpecifier",
      exported: exported
    };
    var defs = NODE_FIELDS.ExportDefaultSpecifier;
    validate$5(defs.exported, node, "exported", exported, 1);
    return node;
  }
  function recordExpression(properties) {
    var node = {
      type: "RecordExpression",
      properties: properties
    };
    var defs = NODE_FIELDS.RecordExpression;
    validate$5(defs.properties, node, "properties", properties, 1);
    return node;
  }
  function tupleExpression(elements) {
    if (elements === void 0) {
      elements = [];
    }
    var node = {
      type: "TupleExpression",
      elements: elements
    };
    var defs = NODE_FIELDS.TupleExpression;
    validate$5(defs.elements, node, "elements", elements, 1);
    return node;
  }
  function decimalLiteral(value) {
    var node = {
      type: "DecimalLiteral",
      value: value
    };
    var defs = NODE_FIELDS.DecimalLiteral;
    validate$5(defs.value, node, "value", value);
    return node;
  }
  function moduleExpression(body) {
    var node = {
      type: "ModuleExpression",
      body: body
    };
    var defs = NODE_FIELDS.ModuleExpression;
    validate$5(defs.body, node, "body", body, 1);
    return node;
  }
  function topicReference() {
    return {
      type: "TopicReference"
    };
  }
  function pipelineTopicExpression(expression) {
    var node = {
      type: "PipelineTopicExpression",
      expression: expression
    };
    var defs = NODE_FIELDS.PipelineTopicExpression;
    validate$5(defs.expression, node, "expression", expression, 1);
    return node;
  }
  function pipelineBareFunction(callee) {
    var node = {
      type: "PipelineBareFunction",
      callee: callee
    };
    var defs = NODE_FIELDS.PipelineBareFunction;
    validate$5(defs.callee, node, "callee", callee, 1);
    return node;
  }
  function pipelinePrimaryTopicReference() {
    return {
      type: "PipelinePrimaryTopicReference"
    };
  }
  function voidPattern() {
    return {
      type: "VoidPattern"
    };
  }
  function tsParameterProperty(parameter) {
    var node = {
      type: "TSParameterProperty",
      parameter: parameter
    };
    var defs = NODE_FIELDS.TSParameterProperty;
    validate$5(defs.parameter, node, "parameter", parameter, 1);
    return node;
  }
  function tsDeclareFunction(id, typeParameters, params, returnType) {
    if (id === void 0) {
      id = null;
    }
    if (typeParameters === void 0) {
      typeParameters = null;
    }
    if (returnType === void 0) {
      returnType = null;
    }
    var node = {
      type: "TSDeclareFunction",
      id: id,
      typeParameters: typeParameters,
      params: params,
      returnType: returnType
    };
    var defs = NODE_FIELDS.TSDeclareFunction;
    validate$5(defs.id, node, "id", id, 1);
    validate$5(defs.typeParameters, node, "typeParameters", typeParameters, 1);
    validate$5(defs.params, node, "params", params, 1);
    validate$5(defs.returnType, node, "returnType", returnType, 1);
    return node;
  }
  function tsDeclareMethod(decorators, key, typeParameters, params, returnType) {
    if (decorators === void 0) {
      decorators = null;
    }
    if (typeParameters === void 0) {
      typeParameters = null;
    }
    if (returnType === void 0) {
      returnType = null;
    }
    var node = {
      type: "TSDeclareMethod",
      decorators: decorators,
      key: key,
      typeParameters: typeParameters,
      params: params,
      returnType: returnType
    };
    var defs = NODE_FIELDS.TSDeclareMethod;
    validate$5(defs.decorators, node, "decorators", decorators, 1);
    validate$5(defs.key, node, "key", key, 1);
    validate$5(defs.typeParameters, node, "typeParameters", typeParameters, 1);
    validate$5(defs.params, node, "params", params, 1);
    validate$5(defs.returnType, node, "returnType", returnType, 1);
    return node;
  }
  function tsQualifiedName(left, right) {
    var node = {
      type: "TSQualifiedName",
      left: left,
      right: right
    };
    var defs = NODE_FIELDS.TSQualifiedName;
    validate$5(defs.left, node, "left", left, 1);
    validate$5(defs.right, node, "right", right, 1);
    return node;
  }
  function tsCallSignatureDeclaration(typeParameters, parameters, typeAnnotation) {
    if (typeParameters === void 0) {
      typeParameters = null;
    }
    if (typeAnnotation === void 0) {
      typeAnnotation = null;
    }
    var node = {
      type: "TSCallSignatureDeclaration",
      typeParameters: typeParameters,
      parameters: parameters,
      typeAnnotation: typeAnnotation
    };
    var defs = NODE_FIELDS.TSCallSignatureDeclaration;
    validate$5(defs.typeParameters, node, "typeParameters", typeParameters, 1);
    validate$5(defs.parameters, node, "parameters", parameters, 1);
    validate$5(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
    return node;
  }
  function tsConstructSignatureDeclaration(typeParameters, parameters, typeAnnotation) {
    if (typeParameters === void 0) {
      typeParameters = null;
    }
    if (typeAnnotation === void 0) {
      typeAnnotation = null;
    }
    var node = {
      type: "TSConstructSignatureDeclaration",
      typeParameters: typeParameters,
      parameters: parameters,
      typeAnnotation: typeAnnotation
    };
    var defs = NODE_FIELDS.TSConstructSignatureDeclaration;
    validate$5(defs.typeParameters, node, "typeParameters", typeParameters, 1);
    validate$5(defs.parameters, node, "parameters", parameters, 1);
    validate$5(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
    return node;
  }
  function tsPropertySignature(key, typeAnnotation) {
    if (typeAnnotation === void 0) {
      typeAnnotation = null;
    }
    var node = {
      type: "TSPropertySignature",
      key: key,
      typeAnnotation: typeAnnotation
    };
    var defs = NODE_FIELDS.TSPropertySignature;
    validate$5(defs.key, node, "key", key, 1);
    validate$5(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
    return node;
  }
  function tsMethodSignature(key, typeParameters, parameters, typeAnnotation) {
    if (typeParameters === void 0) {
      typeParameters = null;
    }
    if (typeAnnotation === void 0) {
      typeAnnotation = null;
    }
    var node = {
      type: "TSMethodSignature",
      key: key,
      typeParameters: typeParameters,
      parameters: parameters,
      typeAnnotation: typeAnnotation,
      kind: null
    };
    var defs = NODE_FIELDS.TSMethodSignature;
    validate$5(defs.key, node, "key", key, 1);
    validate$5(defs.typeParameters, node, "typeParameters", typeParameters, 1);
    validate$5(defs.parameters, node, "parameters", parameters, 1);
    validate$5(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
    return node;
  }
  function tsIndexSignature(parameters, typeAnnotation) {
    if (typeAnnotation === void 0) {
      typeAnnotation = null;
    }
    var node = {
      type: "TSIndexSignature",
      parameters: parameters,
      typeAnnotation: typeAnnotation
    };
    var defs = NODE_FIELDS.TSIndexSignature;
    validate$5(defs.parameters, node, "parameters", parameters, 1);
    validate$5(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
    return node;
  }
  function tsAnyKeyword() {
    return {
      type: "TSAnyKeyword"
    };
  }
  function tsBooleanKeyword() {
    return {
      type: "TSBooleanKeyword"
    };
  }
  function tsBigIntKeyword() {
    return {
      type: "TSBigIntKeyword"
    };
  }
  function tsIntrinsicKeyword() {
    return {
      type: "TSIntrinsicKeyword"
    };
  }
  function tsNeverKeyword() {
    return {
      type: "TSNeverKeyword"
    };
  }
  function tsNullKeyword() {
    return {
      type: "TSNullKeyword"
    };
  }
  function tsNumberKeyword() {
    return {
      type: "TSNumberKeyword"
    };
  }
  function tsObjectKeyword() {
    return {
      type: "TSObjectKeyword"
    };
  }
  function tsStringKeyword() {
    return {
      type: "TSStringKeyword"
    };
  }
  function tsSymbolKeyword() {
    return {
      type: "TSSymbolKeyword"
    };
  }
  function tsUndefinedKeyword() {
    return {
      type: "TSUndefinedKeyword"
    };
  }
  function tsUnknownKeyword() {
    return {
      type: "TSUnknownKeyword"
    };
  }
  function tsVoidKeyword() {
    return {
      type: "TSVoidKeyword"
    };
  }
  function tsThisType() {
    return {
      type: "TSThisType"
    };
  }
  function tsFunctionType(typeParameters, parameters, typeAnnotation) {
    if (typeParameters === void 0) {
      typeParameters = null;
    }
    if (typeAnnotation === void 0) {
      typeAnnotation = null;
    }
    var node = {
      type: "TSFunctionType",
      typeParameters: typeParameters,
      parameters: parameters,
      typeAnnotation: typeAnnotation
    };
    var defs = NODE_FIELDS.TSFunctionType;
    validate$5(defs.typeParameters, node, "typeParameters", typeParameters, 1);
    validate$5(defs.parameters, node, "parameters", parameters, 1);
    validate$5(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
    return node;
  }
  function tsConstructorType(typeParameters, parameters, typeAnnotation) {
    if (typeParameters === void 0) {
      typeParameters = null;
    }
    if (typeAnnotation === void 0) {
      typeAnnotation = null;
    }
    var node = {
      type: "TSConstructorType",
      typeParameters: typeParameters,
      parameters: parameters,
      typeAnnotation: typeAnnotation
    };
    var defs = NODE_FIELDS.TSConstructorType;
    validate$5(defs.typeParameters, node, "typeParameters", typeParameters, 1);
    validate$5(defs.parameters, node, "parameters", parameters, 1);
    validate$5(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
    return node;
  }
  function tsTypeReference(typeName, typeParameters) {
    if (typeParameters === void 0) {
      typeParameters = null;
    }
    var node = {
      type: "TSTypeReference",
      typeName: typeName,
      typeParameters: typeParameters
    };
    var defs = NODE_FIELDS.TSTypeReference;
    validate$5(defs.typeName, node, "typeName", typeName, 1);
    validate$5(defs.typeParameters, node, "typeParameters", typeParameters, 1);
    return node;
  }
  function tsTypePredicate(parameterName, typeAnnotation, asserts) {
    if (typeAnnotation === void 0) {
      typeAnnotation = null;
    }
    if (asserts === void 0) {
      asserts = null;
    }
    var node = {
      type: "TSTypePredicate",
      parameterName: parameterName,
      typeAnnotation: typeAnnotation,
      asserts: asserts
    };
    var defs = NODE_FIELDS.TSTypePredicate;
    validate$5(defs.parameterName, node, "parameterName", parameterName, 1);
    validate$5(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
    validate$5(defs.asserts, node, "asserts", asserts);
    return node;
  }
  function tsTypeQuery(exprName, typeParameters) {
    if (typeParameters === void 0) {
      typeParameters = null;
    }
    var node = {
      type: "TSTypeQuery",
      exprName: exprName,
      typeParameters: typeParameters
    };
    var defs = NODE_FIELDS.TSTypeQuery;
    validate$5(defs.exprName, node, "exprName", exprName, 1);
    validate$5(defs.typeParameters, node, "typeParameters", typeParameters, 1);
    return node;
  }
  function tsTypeLiteral(members) {
    var node = {
      type: "TSTypeLiteral",
      members: members
    };
    var defs = NODE_FIELDS.TSTypeLiteral;
    validate$5(defs.members, node, "members", members, 1);
    return node;
  }
  function tsArrayType(elementType) {
    var node = {
      type: "TSArrayType",
      elementType: elementType
    };
    var defs = NODE_FIELDS.TSArrayType;
    validate$5(defs.elementType, node, "elementType", elementType, 1);
    return node;
  }
  function tsTupleType(elementTypes) {
    var node = {
      type: "TSTupleType",
      elementTypes: elementTypes
    };
    var defs = NODE_FIELDS.TSTupleType;
    validate$5(defs.elementTypes, node, "elementTypes", elementTypes, 1);
    return node;
  }
  function tsOptionalType(typeAnnotation) {
    var node = {
      type: "TSOptionalType",
      typeAnnotation: typeAnnotation
    };
    var defs = NODE_FIELDS.TSOptionalType;
    validate$5(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
    return node;
  }
  function tsRestType(typeAnnotation) {
    var node = {
      type: "TSRestType",
      typeAnnotation: typeAnnotation
    };
    var defs = NODE_FIELDS.TSRestType;
    validate$5(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
    return node;
  }
  function tsNamedTupleMember(label, elementType, optional) {
    if (optional === void 0) {
      optional = false;
    }
    var node = {
      type: "TSNamedTupleMember",
      label: label,
      elementType: elementType,
      optional: optional
    };
    var defs = NODE_FIELDS.TSNamedTupleMember;
    validate$5(defs.label, node, "label", label, 1);
    validate$5(defs.elementType, node, "elementType", elementType, 1);
    validate$5(defs.optional, node, "optional", optional);
    return node;
  }
  function tsUnionType(types) {
    var node = {
      type: "TSUnionType",
      types: types
    };
    var defs = NODE_FIELDS.TSUnionType;
    validate$5(defs.types, node, "types", types, 1);
    return node;
  }
  function tsIntersectionType(types) {
    var node = {
      type: "TSIntersectionType",
      types: types
    };
    var defs = NODE_FIELDS.TSIntersectionType;
    validate$5(defs.types, node, "types", types, 1);
    return node;
  }
  function tsConditionalType(checkType, extendsType, trueType, falseType) {
    var node = {
      type: "TSConditionalType",
      checkType: checkType,
      extendsType: extendsType,
      trueType: trueType,
      falseType: falseType
    };
    var defs = NODE_FIELDS.TSConditionalType;
    validate$5(defs.checkType, node, "checkType", checkType, 1);
    validate$5(defs.extendsType, node, "extendsType", extendsType, 1);
    validate$5(defs.trueType, node, "trueType", trueType, 1);
    validate$5(defs.falseType, node, "falseType", falseType, 1);
    return node;
  }
  function tsInferType(typeParameter) {
    var node = {
      type: "TSInferType",
      typeParameter: typeParameter
    };
    var defs = NODE_FIELDS.TSInferType;
    validate$5(defs.typeParameter, node, "typeParameter", typeParameter, 1);
    return node;
  }
  function tsParenthesizedType(typeAnnotation) {
    var node = {
      type: "TSParenthesizedType",
      typeAnnotation: typeAnnotation
    };
    var defs = NODE_FIELDS.TSParenthesizedType;
    validate$5(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
    return node;
  }
  function tsTypeOperator(typeAnnotation, operator) {
    var node = {
      type: "TSTypeOperator",
      typeAnnotation: typeAnnotation,
      operator: operator
    };
    var defs = NODE_FIELDS.TSTypeOperator;
    validate$5(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
    validate$5(defs.operator, node, "operator", operator);
    return node;
  }
  function tsIndexedAccessType(objectType, indexType) {
    var node = {
      type: "TSIndexedAccessType",
      objectType: objectType,
      indexType: indexType
    };
    var defs = NODE_FIELDS.TSIndexedAccessType;
    validate$5(defs.objectType, node, "objectType", objectType, 1);
    validate$5(defs.indexType, node, "indexType", indexType, 1);
    return node;
  }
  function tsMappedType(typeParameter, typeAnnotation, nameType) {
    if (typeAnnotation === void 0) {
      typeAnnotation = null;
    }
    if (nameType === void 0) {
      nameType = null;
    }
    var node = {
      type: "TSMappedType",
      typeParameter: typeParameter,
      typeAnnotation: typeAnnotation,
      nameType: nameType
    };
    var defs = NODE_FIELDS.TSMappedType;
    validate$5(defs.typeParameter, node, "typeParameter", typeParameter, 1);
    validate$5(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
    validate$5(defs.nameType, node, "nameType", nameType, 1);
    return node;
  }
  function tsTemplateLiteralType(quasis, types) {
    var node = {
      type: "TSTemplateLiteralType",
      quasis: quasis,
      types: types
    };
    var defs = NODE_FIELDS.TSTemplateLiteralType;
    validate$5(defs.quasis, node, "quasis", quasis, 1);
    validate$5(defs.types, node, "types", types, 1);
    return node;
  }
  function tsLiteralType(literal) {
    var node = {
      type: "TSLiteralType",
      literal: literal
    };
    var defs = NODE_FIELDS.TSLiteralType;
    validate$5(defs.literal, node, "literal", literal, 1);
    return node;
  }
  function tsExpressionWithTypeArguments(expression, typeParameters) {
    if (typeParameters === void 0) {
      typeParameters = null;
    }
    var node = {
      type: "TSExpressionWithTypeArguments",
      expression: expression,
      typeParameters: typeParameters
    };
    var defs = NODE_FIELDS.TSExpressionWithTypeArguments;
    validate$5(defs.expression, node, "expression", expression, 1);
    validate$5(defs.typeParameters, node, "typeParameters", typeParameters, 1);
    return node;
  }
  function tsInterfaceDeclaration(id, typeParameters, _extends, body) {
    if (typeParameters === void 0) {
      typeParameters = null;
    }
    if (_extends === void 0) {
      _extends = null;
    }
    var node = {
      type: "TSInterfaceDeclaration",
      id: id,
      typeParameters: typeParameters,
      "extends": _extends,
      body: body
    };
    var defs = NODE_FIELDS.TSInterfaceDeclaration;
    validate$5(defs.id, node, "id", id, 1);
    validate$5(defs.typeParameters, node, "typeParameters", typeParameters, 1);
    validate$5(defs["extends"], node, "extends", _extends, 1);
    validate$5(defs.body, node, "body", body, 1);
    return node;
  }
  function tsInterfaceBody(body) {
    var node = {
      type: "TSInterfaceBody",
      body: body
    };
    var defs = NODE_FIELDS.TSInterfaceBody;
    validate$5(defs.body, node, "body", body, 1);
    return node;
  }
  function tsTypeAliasDeclaration(id, typeParameters, typeAnnotation) {
    if (typeParameters === void 0) {
      typeParameters = null;
    }
    var node = {
      type: "TSTypeAliasDeclaration",
      id: id,
      typeParameters: typeParameters,
      typeAnnotation: typeAnnotation
    };
    var defs = NODE_FIELDS.TSTypeAliasDeclaration;
    validate$5(defs.id, node, "id", id, 1);
    validate$5(defs.typeParameters, node, "typeParameters", typeParameters, 1);
    validate$5(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
    return node;
  }
  function tsInstantiationExpression(expression, typeParameters) {
    if (typeParameters === void 0) {
      typeParameters = null;
    }
    var node = {
      type: "TSInstantiationExpression",
      expression: expression,
      typeParameters: typeParameters
    };
    var defs = NODE_FIELDS.TSInstantiationExpression;
    validate$5(defs.expression, node, "expression", expression, 1);
    validate$5(defs.typeParameters, node, "typeParameters", typeParameters, 1);
    return node;
  }
  function tsAsExpression(expression, typeAnnotation) {
    var node = {
      type: "TSAsExpression",
      expression: expression,
      typeAnnotation: typeAnnotation
    };
    var defs = NODE_FIELDS.TSAsExpression;
    validate$5(defs.expression, node, "expression", expression, 1);
    validate$5(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
    return node;
  }
  function tsSatisfiesExpression(expression, typeAnnotation) {
    var node = {
      type: "TSSatisfiesExpression",
      expression: expression,
      typeAnnotation: typeAnnotation
    };
    var defs = NODE_FIELDS.TSSatisfiesExpression;
    validate$5(defs.expression, node, "expression", expression, 1);
    validate$5(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
    return node;
  }
  function tsTypeAssertion(typeAnnotation, expression) {
    var node = {
      type: "TSTypeAssertion",
      typeAnnotation: typeAnnotation,
      expression: expression
    };
    var defs = NODE_FIELDS.TSTypeAssertion;
    validate$5(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
    validate$5(defs.expression, node, "expression", expression, 1);
    return node;
  }
  function tsEnumBody(members) {
    var node = {
      type: "TSEnumBody",
      members: members
    };
    var defs = NODE_FIELDS.TSEnumBody;
    validate$5(defs.members, node, "members", members, 1);
    return node;
  }
  function tsEnumDeclaration(id, members) {
    var node = {
      type: "TSEnumDeclaration",
      id: id,
      members: members
    };
    var defs = NODE_FIELDS.TSEnumDeclaration;
    validate$5(defs.id, node, "id", id, 1);
    validate$5(defs.members, node, "members", members, 1);
    return node;
  }
  function tsEnumMember(id, initializer) {
    if (initializer === void 0) {
      initializer = null;
    }
    var node = {
      type: "TSEnumMember",
      id: id,
      initializer: initializer
    };
    var defs = NODE_FIELDS.TSEnumMember;
    validate$5(defs.id, node, "id", id, 1);
    validate$5(defs.initializer, node, "initializer", initializer, 1);
    return node;
  }
  function tsModuleDeclaration(id, body) {
    var node = {
      type: "TSModuleDeclaration",
      id: id,
      body: body,
      kind: null
    };
    var defs = NODE_FIELDS.TSModuleDeclaration;
    validate$5(defs.id, node, "id", id, 1);
    validate$5(defs.body, node, "body", body, 1);
    return node;
  }
  function tsModuleBlock(body) {
    var node = {
      type: "TSModuleBlock",
      body: body
    };
    var defs = NODE_FIELDS.TSModuleBlock;
    validate$5(defs.body, node, "body", body, 1);
    return node;
  }
  function tsImportType(argument, qualifier, typeParameters) {
    if (qualifier === void 0) {
      qualifier = null;
    }
    if (typeParameters === void 0) {
      typeParameters = null;
    }
    var node = {
      type: "TSImportType",
      argument: argument,
      qualifier: qualifier,
      typeParameters: typeParameters
    };
    var defs = NODE_FIELDS.TSImportType;
    validate$5(defs.argument, node, "argument", argument, 1);
    validate$5(defs.qualifier, node, "qualifier", qualifier, 1);
    validate$5(defs.typeParameters, node, "typeParameters", typeParameters, 1);
    return node;
  }
  function tsImportEqualsDeclaration(id, moduleReference) {
    var node = {
      type: "TSImportEqualsDeclaration",
      id: id,
      moduleReference: moduleReference,
      isExport: null
    };
    var defs = NODE_FIELDS.TSImportEqualsDeclaration;
    validate$5(defs.id, node, "id", id, 1);
    validate$5(defs.moduleReference, node, "moduleReference", moduleReference, 1);
    return node;
  }
  function tsExternalModuleReference(expression) {
    var node = {
      type: "TSExternalModuleReference",
      expression: expression
    };
    var defs = NODE_FIELDS.TSExternalModuleReference;
    validate$5(defs.expression, node, "expression", expression, 1);
    return node;
  }
  function tsNonNullExpression(expression) {
    var node = {
      type: "TSNonNullExpression",
      expression: expression
    };
    var defs = NODE_FIELDS.TSNonNullExpression;
    validate$5(defs.expression, node, "expression", expression, 1);
    return node;
  }
  function tsExportAssignment(expression) {
    var node = {
      type: "TSExportAssignment",
      expression: expression
    };
    var defs = NODE_FIELDS.TSExportAssignment;
    validate$5(defs.expression, node, "expression", expression, 1);
    return node;
  }
  function tsNamespaceExportDeclaration(id) {
    var node = {
      type: "TSNamespaceExportDeclaration",
      id: id
    };
    var defs = NODE_FIELDS.TSNamespaceExportDeclaration;
    validate$5(defs.id, node, "id", id, 1);
    return node;
  }
  function tsTypeAnnotation(typeAnnotation) {
    var node = {
      type: "TSTypeAnnotation",
      typeAnnotation: typeAnnotation
    };
    var defs = NODE_FIELDS.TSTypeAnnotation;
    validate$5(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
    return node;
  }
  function tsTypeParameterInstantiation(params) {
    var node = {
      type: "TSTypeParameterInstantiation",
      params: params
    };
    var defs = NODE_FIELDS.TSTypeParameterInstantiation;
    validate$5(defs.params, node, "params", params, 1);
    return node;
  }
  function tsTypeParameterDeclaration(params) {
    var node = {
      type: "TSTypeParameterDeclaration",
      params: params
    };
    var defs = NODE_FIELDS.TSTypeParameterDeclaration;
    validate$5(defs.params, node, "params", params, 1);
    return node;
  }
  function tsTypeParameter(constraint, _default, name) {
    if (constraint === void 0) {
      constraint = null;
    }
    if (_default === void 0) {
      _default = null;
    }
    var node = {
      type: "TSTypeParameter",
      constraint: constraint,
      "default": _default,
      name: name
    };
    var defs = NODE_FIELDS.TSTypeParameter;
    validate$5(defs.constraint, node, "constraint", constraint, 1);
    validate$5(defs["default"], node, "default", _default, 1);
    validate$5(defs.name, node, "name", name);
    return node;
  }
  function NumberLiteral$1(value) {
    deprecationWarning$1("NumberLiteral", "NumericLiteral", "The node type ");
    return numericLiteral$5(value);
  }
  function RegexLiteral$1(pattern, flags) {
    if (flags === void 0) {
      flags = "";
    }
    deprecationWarning$1("RegexLiteral", "RegExpLiteral", "The node type ");
    return regExpLiteral(pattern, flags);
  }
  function RestProperty$2(argument) {
    deprecationWarning$1("RestProperty", "RestElement", "The node type ");
    return restElement$2(argument);
  }
  function SpreadProperty$2(argument) {
    deprecationWarning$1("SpreadProperty", "SpreadElement", "The node type ");
    return spreadElement$2(argument);
  }

  var b = /*#__PURE__*/Object.freeze({
    __proto__: null,
    anyTypeAnnotation: anyTypeAnnotation$2,
    argumentPlaceholder: argumentPlaceholder,
    arrayExpression: arrayExpression$1,
    arrayPattern: arrayPattern,
    arrayTypeAnnotation: arrayTypeAnnotation$1,
    arrowFunctionExpression: arrowFunctionExpression$4,
    assignmentExpression: assignmentExpression$8,
    assignmentPattern: assignmentPattern,
    awaitExpression: awaitExpression$1,
    bigIntLiteral: bigIntLiteral,
    binaryExpression: binaryExpression$4,
    bindExpression: bindExpression,
    blockStatement: blockStatement$6,
    booleanLiteral: booleanLiteral$2,
    booleanLiteralTypeAnnotation: booleanLiteralTypeAnnotation,
    booleanTypeAnnotation: booleanTypeAnnotation$1,
    breakStatement: breakStatement,
    callExpression: callExpression$c,
    catchClause: catchClause,
    classAccessorProperty: classAccessorProperty,
    classBody: classBody,
    classDeclaration: classDeclaration,
    classExpression: classExpression,
    classImplements: classImplements,
    classMethod: classMethod,
    classPrivateMethod: classPrivateMethod,
    classPrivateProperty: classPrivateProperty,
    classProperty: classProperty,
    conditionalExpression: conditionalExpression$5,
    continueStatement: continueStatement,
    debuggerStatement: debuggerStatement,
    decimalLiteral: decimalLiteral,
    declareClass: declareClass,
    declareExportAllDeclaration: declareExportAllDeclaration,
    declareExportDeclaration: declareExportDeclaration,
    declareFunction: declareFunction,
    declareInterface: declareInterface,
    declareModule: declareModule,
    declareModuleExports: declareModuleExports,
    declareOpaqueType: declareOpaqueType,
    declareTypeAlias: declareTypeAlias,
    declareVariable: declareVariable,
    declaredPredicate: declaredPredicate,
    decorator: decorator,
    directive: directive,
    directiveLiteral: directiveLiteral,
    doExpression: doExpression,
    doWhileStatement: doWhileStatement,
    emptyStatement: emptyStatement$1,
    emptyTypeAnnotation: emptyTypeAnnotation,
    enumBooleanBody: enumBooleanBody,
    enumBooleanMember: enumBooleanMember,
    enumDeclaration: enumDeclaration,
    enumDefaultedMember: enumDefaultedMember,
    enumNumberBody: enumNumberBody,
    enumNumberMember: enumNumberMember,
    enumStringBody: enumStringBody,
    enumStringMember: enumStringMember,
    enumSymbolBody: enumSymbolBody,
    existsTypeAnnotation: existsTypeAnnotation,
    exportAllDeclaration: exportAllDeclaration,
    exportDefaultDeclaration: exportDefaultDeclaration,
    exportDefaultSpecifier: exportDefaultSpecifier,
    exportNamedDeclaration: exportNamedDeclaration$2,
    exportNamespaceSpecifier: exportNamespaceSpecifier,
    exportSpecifier: exportSpecifier$2,
    expressionStatement: expressionStatement$7,
    file: file$1,
    forInStatement: forInStatement,
    forOfStatement: forOfStatement,
    forStatement: forStatement,
    functionDeclaration: functionDeclaration,
    functionExpression: functionExpression$2,
    functionTypeAnnotation: functionTypeAnnotation,
    functionTypeParam: functionTypeParam,
    genericTypeAnnotation: genericTypeAnnotation$1,
    identifier: identifier$e,
    ifStatement: ifStatement,
    import: _import,
    importAttribute: importAttribute,
    importDeclaration: importDeclaration$1,
    importDefaultSpecifier: importDefaultSpecifier$1,
    importExpression: importExpression,
    importNamespaceSpecifier: importNamespaceSpecifier$1,
    importSpecifier: importSpecifier$2,
    indexedAccessType: indexedAccessType,
    inferredPredicate: inferredPredicate,
    interfaceDeclaration: interfaceDeclaration,
    interfaceExtends: interfaceExtends,
    interfaceTypeAnnotation: interfaceTypeAnnotation,
    interpreterDirective: interpreterDirective$1,
    intersectionTypeAnnotation: intersectionTypeAnnotation,
    jSXAttribute: jsxAttribute,
    jSXClosingElement: jsxClosingElement,
    jSXClosingFragment: jsxClosingFragment,
    jSXElement: jsxElement,
    jSXEmptyExpression: jsxEmptyExpression,
    jSXExpressionContainer: jsxExpressionContainer$1,
    jSXFragment: jsxFragment,
    jSXIdentifier: jsxIdentifier$1,
    jSXMemberExpression: jsxMemberExpression,
    jSXNamespacedName: jsxNamespacedName,
    jSXOpeningElement: jsxOpeningElement,
    jSXOpeningFragment: jsxOpeningFragment,
    jSXSpreadAttribute: jsxSpreadAttribute,
    jSXSpreadChild: jsxSpreadChild,
    jSXText: jsxText,
    jsxAttribute: jsxAttribute,
    jsxClosingElement: jsxClosingElement,
    jsxClosingFragment: jsxClosingFragment,
    jsxElement: jsxElement,
    jsxEmptyExpression: jsxEmptyExpression,
    jsxExpressionContainer: jsxExpressionContainer$1,
    jsxFragment: jsxFragment,
    jsxIdentifier: jsxIdentifier$1,
    jsxMemberExpression: jsxMemberExpression,
    jsxNamespacedName: jsxNamespacedName,
    jsxOpeningElement: jsxOpeningElement,
    jsxOpeningFragment: jsxOpeningFragment,
    jsxSpreadAttribute: jsxSpreadAttribute,
    jsxSpreadChild: jsxSpreadChild,
    jsxText: jsxText,
    labeledStatement: labeledStatement,
    logicalExpression: logicalExpression$2,
    memberExpression: memberExpression$a,
    metaProperty: metaProperty$1,
    mixedTypeAnnotation: mixedTypeAnnotation,
    moduleExpression: moduleExpression,
    newExpression: newExpression,
    noop: noop$1,
    nullLiteral: nullLiteral$2,
    nullLiteralTypeAnnotation: nullLiteralTypeAnnotation$1,
    nullableTypeAnnotation: nullableTypeAnnotation,
    numberLiteral: NumberLiteral$1,
    numberLiteralTypeAnnotation: numberLiteralTypeAnnotation,
    numberTypeAnnotation: numberTypeAnnotation$2,
    numericLiteral: numericLiteral$5,
    objectExpression: objectExpression$3,
    objectMethod: objectMethod,
    objectPattern: objectPattern$1,
    objectProperty: objectProperty$1,
    objectTypeAnnotation: objectTypeAnnotation,
    objectTypeCallProperty: objectTypeCallProperty,
    objectTypeIndexer: objectTypeIndexer,
    objectTypeInternalSlot: objectTypeInternalSlot,
    objectTypeProperty: objectTypeProperty,
    objectTypeSpreadProperty: objectTypeSpreadProperty,
    opaqueType: opaqueType,
    optionalCallExpression: optionalCallExpression$2,
    optionalIndexedAccessType: optionalIndexedAccessType,
    optionalMemberExpression: optionalMemberExpression$2,
    parenthesizedExpression: parenthesizedExpression,
    pipelineBareFunction: pipelineBareFunction,
    pipelinePrimaryTopicReference: pipelinePrimaryTopicReference,
    pipelineTopicExpression: pipelineTopicExpression,
    placeholder: placeholder,
    privateName: privateName,
    program: program$3,
    qualifiedTypeIdentifier: qualifiedTypeIdentifier,
    recordExpression: recordExpression,
    regExpLiteral: regExpLiteral,
    regexLiteral: RegexLiteral$1,
    restElement: restElement$2,
    restProperty: RestProperty$2,
    returnStatement: returnStatement$3,
    sequenceExpression: sequenceExpression$6,
    spreadElement: spreadElement$2,
    spreadProperty: SpreadProperty$2,
    staticBlock: staticBlock,
    stringLiteral: stringLiteral$6,
    stringLiteralTypeAnnotation: stringLiteralTypeAnnotation,
    stringTypeAnnotation: stringTypeAnnotation$2,
    super: _super$1,
    switchCase: switchCase,
    switchStatement: switchStatement,
    symbolTypeAnnotation: symbolTypeAnnotation,
    tSAnyKeyword: tsAnyKeyword,
    tSArrayType: tsArrayType,
    tSAsExpression: tsAsExpression,
    tSBigIntKeyword: tsBigIntKeyword,
    tSBooleanKeyword: tsBooleanKeyword,
    tSCallSignatureDeclaration: tsCallSignatureDeclaration,
    tSConditionalType: tsConditionalType,
    tSConstructSignatureDeclaration: tsConstructSignatureDeclaration,
    tSConstructorType: tsConstructorType,
    tSDeclareFunction: tsDeclareFunction,
    tSDeclareMethod: tsDeclareMethod,
    tSEnumBody: tsEnumBody,
    tSEnumDeclaration: tsEnumDeclaration,
    tSEnumMember: tsEnumMember,
    tSExportAssignment: tsExportAssignment,
    tSExpressionWithTypeArguments: tsExpressionWithTypeArguments,
    tSExternalModuleReference: tsExternalModuleReference,
    tSFunctionType: tsFunctionType,
    tSImportEqualsDeclaration: tsImportEqualsDeclaration,
    tSImportType: tsImportType,
    tSIndexSignature: tsIndexSignature,
    tSIndexedAccessType: tsIndexedAccessType,
    tSInferType: tsInferType,
    tSInstantiationExpression: tsInstantiationExpression,
    tSInterfaceBody: tsInterfaceBody,
    tSInterfaceDeclaration: tsInterfaceDeclaration,
    tSIntersectionType: tsIntersectionType,
    tSIntrinsicKeyword: tsIntrinsicKeyword,
    tSLiteralType: tsLiteralType,
    tSMappedType: tsMappedType,
    tSMethodSignature: tsMethodSignature,
    tSModuleBlock: tsModuleBlock,
    tSModuleDeclaration: tsModuleDeclaration,
    tSNamedTupleMember: tsNamedTupleMember,
    tSNamespaceExportDeclaration: tsNamespaceExportDeclaration,
    tSNeverKeyword: tsNeverKeyword,
    tSNonNullExpression: tsNonNullExpression,
    tSNullKeyword: tsNullKeyword,
    tSNumberKeyword: tsNumberKeyword,
    tSObjectKeyword: tsObjectKeyword,
    tSOptionalType: tsOptionalType,
    tSParameterProperty: tsParameterProperty,
    tSParenthesizedType: tsParenthesizedType,
    tSPropertySignature: tsPropertySignature,
    tSQualifiedName: tsQualifiedName,
    tSRestType: tsRestType,
    tSSatisfiesExpression: tsSatisfiesExpression,
    tSStringKeyword: tsStringKeyword,
    tSSymbolKeyword: tsSymbolKeyword,
    tSTemplateLiteralType: tsTemplateLiteralType,
    tSThisType: tsThisType,
    tSTupleType: tsTupleType,
    tSTypeAliasDeclaration: tsTypeAliasDeclaration,
    tSTypeAnnotation: tsTypeAnnotation,
    tSTypeAssertion: tsTypeAssertion,
    tSTypeLiteral: tsTypeLiteral,
    tSTypeOperator: tsTypeOperator,
    tSTypeParameter: tsTypeParameter,
    tSTypeParameterDeclaration: tsTypeParameterDeclaration,
    tSTypeParameterInstantiation: tsTypeParameterInstantiation,
    tSTypePredicate: tsTypePredicate,
    tSTypeQuery: tsTypeQuery,
    tSTypeReference: tsTypeReference,
    tSUndefinedKeyword: tsUndefinedKeyword,
    tSUnionType: tsUnionType,
    tSUnknownKeyword: tsUnknownKeyword,
    tSVoidKeyword: tsVoidKeyword,
    taggedTemplateExpression: taggedTemplateExpression,
    templateElement: templateElement,
    templateLiteral: templateLiteral,
    thisExpression: thisExpression$5,
    thisTypeAnnotation: thisTypeAnnotation,
    throwStatement: throwStatement,
    topicReference: topicReference,
    tryStatement: tryStatement,
    tsAnyKeyword: tsAnyKeyword,
    tsArrayType: tsArrayType,
    tsAsExpression: tsAsExpression,
    tsBigIntKeyword: tsBigIntKeyword,
    tsBooleanKeyword: tsBooleanKeyword,
    tsCallSignatureDeclaration: tsCallSignatureDeclaration,
    tsConditionalType: tsConditionalType,
    tsConstructSignatureDeclaration: tsConstructSignatureDeclaration,
    tsConstructorType: tsConstructorType,
    tsDeclareFunction: tsDeclareFunction,
    tsDeclareMethod: tsDeclareMethod,
    tsEnumBody: tsEnumBody,
    tsEnumDeclaration: tsEnumDeclaration,
    tsEnumMember: tsEnumMember,
    tsExportAssignment: tsExportAssignment,
    tsExpressionWithTypeArguments: tsExpressionWithTypeArguments,
    tsExternalModuleReference: tsExternalModuleReference,
    tsFunctionType: tsFunctionType,
    tsImportEqualsDeclaration: tsImportEqualsDeclaration,
    tsImportType: tsImportType,
    tsIndexSignature: tsIndexSignature,
    tsIndexedAccessType: tsIndexedAccessType,
    tsInferType: tsInferType,
    tsInstantiationExpression: tsInstantiationExpression,
    tsInterfaceBody: tsInterfaceBody,
    tsInterfaceDeclaration: tsInterfaceDeclaration,
    tsIntersectionType: tsIntersectionType,
    tsIntrinsicKeyword: tsIntrinsicKeyword,
    tsLiteralType: tsLiteralType,
    tsMappedType: tsMappedType,
    tsMethodSignature: tsMethodSignature,
    tsModuleBlock: tsModuleBlock,
    tsModuleDeclaration: tsModuleDeclaration,
    tsNamedTupleMember: tsNamedTupleMember,
    tsNamespaceExportDeclaration: tsNamespaceExportDeclaration,
    tsNeverKeyword: tsNeverKeyword,
    tsNonNullExpression: tsNonNullExpression,
    tsNullKeyword: tsNullKeyword,
    tsNumberKeyword: tsNumberKeyword,
    tsObjectKeyword: tsObjectKeyword,
    tsOptionalType: tsOptionalType,
    tsParameterProperty: tsParameterProperty,
    tsParenthesizedType: tsParenthesizedType,
    tsPropertySignature: tsPropertySignature,
    tsQualifiedName: tsQualifiedName,
    tsRestType: tsRestType,
    tsSatisfiesExpression: tsSatisfiesExpression,
    tsStringKeyword: tsStringKeyword,
    tsSymbolKeyword: tsSymbolKeyword,
    tsTemplateLiteralType: tsTemplateLiteralType,
    tsThisType: tsThisType,
    tsTupleType: tsTupleType,
    tsTypeAliasDeclaration: tsTypeAliasDeclaration,
    tsTypeAnnotation: tsTypeAnnotation,
    tsTypeAssertion: tsTypeAssertion,
    tsTypeLiteral: tsTypeLiteral,
    tsTypeOperator: tsTypeOperator,
    tsTypeParameter: tsTypeParameter,
    tsTypeParameterDeclaration: tsTypeParameterDeclaration,
    tsTypeParameterInstantiation: tsTypeParameterInstantiation,
    tsTypePredicate: tsTypePredicate,
    tsTypeQuery: tsTypeQuery,
    tsTypeReference: tsTypeReference,
    tsUndefinedKeyword: tsUndefinedKeyword,
    tsUnionType: tsUnionType,
    tsUnknownKeyword: tsUnknownKeyword,
    tsVoidKeyword: tsVoidKeyword,
    tupleExpression: tupleExpression,
    tupleTypeAnnotation: tupleTypeAnnotation$1,
    typeAlias: typeAlias,
    typeAnnotation: typeAnnotation,
    typeCastExpression: typeCastExpression,
    typeParameter: typeParameter,
    typeParameterDeclaration: typeParameterDeclaration,
    typeParameterInstantiation: typeParameterInstantiation,
    typeofTypeAnnotation: typeofTypeAnnotation,
    unaryExpression: unaryExpression$4,
    unionTypeAnnotation: unionTypeAnnotation$1,
    updateExpression: updateExpression$1,
    v8IntrinsicIdentifier: v8IntrinsicIdentifier,
    variableDeclaration: variableDeclaration$6,
    variableDeclarator: variableDeclarator$6,
    variance: variance,
    voidPattern: voidPattern,
    voidTypeAnnotation: voidTypeAnnotation$3,
    whileStatement: whileStatement,
    withStatement: withStatement,
    yieldExpression: yieldExpression$2
  });

  function alias(lowercase) {
    {
      return b[lowercase];
    }
  }
  var ArrayExpression$2 = alias("arrayExpression"),
    AssignmentExpression$3 = alias("assignmentExpression"),
    BinaryExpression$2 = alias("binaryExpression"),
    InterpreterDirective$1 = alias("interpreterDirective"),
    Directive$1 = alias("directive"),
    DirectiveLiteral$1 = alias("directiveLiteral"),
    BlockStatement$1 = alias("blockStatement"),
    BreakStatement$1 = alias("breakStatement"),
    CallExpression$2 = alias("callExpression"),
    CatchClause$1 = alias("catchClause"),
    ConditionalExpression$3 = alias("conditionalExpression"),
    ContinueStatement$1 = alias("continueStatement"),
    DebuggerStatement$1 = alias("debuggerStatement"),
    DoWhileStatement$1 = alias("doWhileStatement"),
    EmptyStatement$1 = alias("emptyStatement"),
    ExpressionStatement$1 = alias("expressionStatement"),
    File$2 = alias("file"),
    ForInStatement$1 = alias("forInStatement"),
    ForStatement$1 = alias("forStatement"),
    FunctionDeclaration = alias("functionDeclaration"),
    FunctionExpression$2 = alias("functionExpression"),
    Identifier$2 = alias("identifier"),
    IfStatement$1 = alias("ifStatement"),
    LabeledStatement$1 = alias("labeledStatement"),
    StringLiteral$2 = alias("stringLiteral"),
    NumericLiteral$2 = alias("numericLiteral"),
    NullLiteral$2 = alias("nullLiteral"),
    BooleanLiteral$2 = alias("booleanLiteral"),
    RegExpLiteral$2 = alias("regExpLiteral"),
    LogicalExpression$2 = alias("logicalExpression"),
    MemberExpression$1 = alias("memberExpression"),
    NewExpression$2 = alias("newExpression"),
    Program$1 = alias("program"),
    ObjectExpression$3 = alias("objectExpression"),
    ObjectMethod$1 = alias("objectMethod"),
    ObjectProperty$1 = alias("objectProperty"),
    RestElement$2 = alias("restElement"),
    ReturnStatement$1 = alias("returnStatement"),
    SequenceExpression$3 = alias("sequenceExpression"),
    ParenthesizedExpression$2 = alias("parenthesizedExpression"),
    SwitchCase$1 = alias("switchCase"),
    SwitchStatement$1 = alias("switchStatement"),
    ThisExpression$1 = alias("thisExpression"),
    ThrowStatement$1 = alias("throwStatement"),
    TryStatement$1 = alias("tryStatement"),
    UnaryExpression$2 = alias("unaryExpression"),
    UpdateExpression$3 = alias("updateExpression"),
    VariableDeclaration$1 = alias("variableDeclaration"),
    VariableDeclarator$2 = alias("variableDeclarator"),
    WhileStatement$1 = alias("whileStatement"),
    WithStatement$1 = alias("withStatement"),
    AssignmentPattern$1 = alias("assignmentPattern"),
    ArrayPattern = alias("arrayPattern"),
    ArrowFunctionExpression$1 = alias("arrowFunctionExpression"),
    ClassBody$1 = alias("classBody"),
    ClassExpression$1 = alias("classExpression"),
    ClassDeclaration$1 = alias("classDeclaration"),
    ExportAllDeclaration$1 = alias("exportAllDeclaration"),
    ExportDefaultDeclaration$1 = alias("exportDefaultDeclaration"),
    ExportNamedDeclaration$1 = alias("exportNamedDeclaration"),
    ExportSpecifier$1 = alias("exportSpecifier"),
    ForOfStatement$1 = alias("forOfStatement"),
    ImportDeclaration$1 = alias("importDeclaration"),
    ImportDefaultSpecifier$1 = alias("importDefaultSpecifier"),
    ImportNamespaceSpecifier$1 = alias("importNamespaceSpecifier"),
    ImportSpecifier$1 = alias("importSpecifier"),
    ImportExpression$1 = alias("importExpression"),
    MetaProperty$1 = alias("metaProperty"),
    ClassMethod$1 = alias("classMethod"),
    ObjectPattern = alias("objectPattern"),
    SpreadElement = alias("spreadElement"),
    Super$1 = alias("super"),
    TaggedTemplateExpression$2 = alias("taggedTemplateExpression"),
    TemplateElement$1 = alias("templateElement"),
    TemplateLiteral$2 = alias("templateLiteral"),
    YieldExpression$2 = alias("yieldExpression"),
    AwaitExpression$1 = alias("awaitExpression"),
    Import$1 = alias("import"),
    BigIntLiteral$1 = alias("bigIntLiteral"),
    ExportNamespaceSpecifier$1 = alias("exportNamespaceSpecifier"),
    OptionalMemberExpression$2 = alias("optionalMemberExpression"),
    OptionalCallExpression$1 = alias("optionalCallExpression"),
    ClassProperty$1 = alias("classProperty"),
    ClassAccessorProperty$1 = alias("classAccessorProperty"),
    ClassPrivateProperty$1 = alias("classPrivateProperty"),
    ClassPrivateMethod$1 = alias("classPrivateMethod"),
    PrivateName$1 = alias("privateName"),
    StaticBlock$1 = alias("staticBlock"),
    ImportAttribute$1 = alias("importAttribute"),
    AnyTypeAnnotation$1 = alias("anyTypeAnnotation"),
    ArrayTypeAnnotation$1 = alias("arrayTypeAnnotation"),
    BooleanTypeAnnotation$1 = alias("booleanTypeAnnotation"),
    BooleanLiteralTypeAnnotation$1 = alias("booleanLiteralTypeAnnotation"),
    NullLiteralTypeAnnotation$1 = alias("nullLiteralTypeAnnotation"),
    ClassImplements = alias("classImplements"),
    DeclareClass$1 = alias("declareClass"),
    DeclareFunction$1 = alias("declareFunction"),
    DeclareInterface$1 = alias("declareInterface"),
    DeclareModule$1 = alias("declareModule"),
    DeclareModuleExports$1 = alias("declareModuleExports"),
    DeclareTypeAlias$1 = alias("declareTypeAlias"),
    DeclareOpaqueType$1 = alias("declareOpaqueType"),
    DeclareVariable$1 = alias("declareVariable"),
    DeclareExportDeclaration$1 = alias("declareExportDeclaration"),
    DeclareExportAllDeclaration$1 = alias("declareExportAllDeclaration"),
    DeclaredPredicate$1 = alias("declaredPredicate"),
    ExistsTypeAnnotation$1 = alias("existsTypeAnnotation"),
    FunctionTypeAnnotation$2 = alias("functionTypeAnnotation"),
    FunctionTypeParam$1 = alias("functionTypeParam"),
    GenericTypeAnnotation = alias("genericTypeAnnotation"),
    InferredPredicate$1 = alias("inferredPredicate"),
    InterfaceExtends$1 = alias("interfaceExtends"),
    InterfaceDeclaration$1 = alias("interfaceDeclaration"),
    InterfaceTypeAnnotation$1 = alias("interfaceTypeAnnotation"),
    IntersectionTypeAnnotation$1 = alias("intersectionTypeAnnotation"),
    MixedTypeAnnotation$1 = alias("mixedTypeAnnotation"),
    EmptyTypeAnnotation$1 = alias("emptyTypeAnnotation"),
    NullableTypeAnnotation$2 = alias("nullableTypeAnnotation"),
    NumberLiteralTypeAnnotation = alias("numberLiteralTypeAnnotation"),
    NumberTypeAnnotation$1 = alias("numberTypeAnnotation"),
    ObjectTypeAnnotation$1 = alias("objectTypeAnnotation"),
    ObjectTypeInternalSlot$1 = alias("objectTypeInternalSlot"),
    ObjectTypeCallProperty$1 = alias("objectTypeCallProperty"),
    ObjectTypeIndexer$1 = alias("objectTypeIndexer"),
    ObjectTypeProperty$1 = alias("objectTypeProperty"),
    ObjectTypeSpreadProperty$1 = alias("objectTypeSpreadProperty"),
    OpaqueType$1 = alias("opaqueType"),
    QualifiedTypeIdentifier$1 = alias("qualifiedTypeIdentifier"),
    StringLiteralTypeAnnotation = alias("stringLiteralTypeAnnotation"),
    StringTypeAnnotation$1 = alias("stringTypeAnnotation"),
    SymbolTypeAnnotation$1 = alias("symbolTypeAnnotation"),
    ThisTypeAnnotation$1 = alias("thisTypeAnnotation"),
    TupleTypeAnnotation$1 = alias("tupleTypeAnnotation"),
    TypeofTypeAnnotation$1 = alias("typeofTypeAnnotation"),
    TypeAlias$1 = alias("typeAlias"),
    TypeAnnotation$1 = alias("typeAnnotation"),
    TypeCastExpression$2 = alias("typeCastExpression"),
    TypeParameter$1 = alias("typeParameter"),
    TypeParameterDeclaration = alias("typeParameterDeclaration"),
    TypeParameterInstantiation$1 = alias("typeParameterInstantiation"),
    UnionTypeAnnotation$2 = alias("unionTypeAnnotation"),
    Variance$1 = alias("variance"),
    VoidTypeAnnotation$1 = alias("voidTypeAnnotation"),
    EnumDeclaration$1 = alias("enumDeclaration"),
    EnumBooleanBody$1 = alias("enumBooleanBody"),
    EnumNumberBody$1 = alias("enumNumberBody"),
    EnumStringBody$1 = alias("enumStringBody"),
    EnumSymbolBody$1 = alias("enumSymbolBody"),
    EnumBooleanMember$1 = alias("enumBooleanMember"),
    EnumNumberMember$1 = alias("enumNumberMember"),
    EnumStringMember$1 = alias("enumStringMember"),
    EnumDefaultedMember$1 = alias("enumDefaultedMember"),
    IndexedAccessType$1 = alias("indexedAccessType"),
    OptionalIndexedAccessType$2 = alias("optionalIndexedAccessType"),
    JSXAttribute$1 = alias("jsxAttribute"),
    JSXClosingElement$1 = alias("jsxClosingElement"),
    JSXElement$1 = alias("jsxElement"),
    JSXEmptyExpression$1 = alias("jsxEmptyExpression"),
    JSXExpressionContainer$1 = alias("jsxExpressionContainer"),
    JSXSpreadChild$1 = alias("jsxSpreadChild"),
    JSXIdentifier$1 = alias("jsxIdentifier"),
    JSXMemberExpression$1 = alias("jsxMemberExpression"),
    JSXNamespacedName$1 = alias("jsxNamespacedName"),
    JSXOpeningElement$1 = alias("jsxOpeningElement"),
    JSXSpreadAttribute$1 = alias("jsxSpreadAttribute"),
    JSXText$1 = alias("jsxText"),
    JSXFragment$1 = alias("jsxFragment"),
    JSXOpeningFragment$1 = alias("jsxOpeningFragment"),
    JSXClosingFragment$1 = alias("jsxClosingFragment"),
    Noop = alias("noop"),
    Placeholder$1 = alias("placeholder"),
    V8IntrinsicIdentifier$1 = alias("v8IntrinsicIdentifier"),
    ArgumentPlaceholder$1 = alias("argumentPlaceholder"),
    BindExpression$1 = alias("bindExpression"),
    Decorator$1 = alias("decorator"),
    DoExpression$2 = alias("doExpression"),
    ExportDefaultSpecifier$1 = alias("exportDefaultSpecifier"),
    RecordExpression$1 = alias("recordExpression"),
    TupleExpression$1 = alias("tupleExpression"),
    DecimalLiteral = alias("decimalLiteral"),
    ModuleExpression$1 = alias("moduleExpression"),
    TopicReference$1 = alias("topicReference"),
    PipelineTopicExpression$1 = alias("pipelineTopicExpression"),
    PipelineBareFunction$1 = alias("pipelineBareFunction"),
    PipelinePrimaryTopicReference$1 = alias("pipelinePrimaryTopicReference"),
    VoidPattern$1 = alias("voidPattern"),
    TSParameterProperty$1 = alias("tsParameterProperty"),
    TSDeclareFunction$1 = alias("tsDeclareFunction"),
    TSDeclareMethod$1 = alias("tsDeclareMethod"),
    TSQualifiedName$1 = alias("tsQualifiedName"),
    TSCallSignatureDeclaration$1 = alias("tsCallSignatureDeclaration"),
    TSConstructSignatureDeclaration$1 = alias("tsConstructSignatureDeclaration"),
    TSPropertySignature$1 = alias("tsPropertySignature"),
    TSMethodSignature$1 = alias("tsMethodSignature"),
    TSIndexSignature$1 = alias("tsIndexSignature"),
    TSAnyKeyword$1 = alias("tsAnyKeyword"),
    TSBooleanKeyword$1 = alias("tsBooleanKeyword"),
    TSBigIntKeyword$1 = alias("tsBigIntKeyword"),
    TSIntrinsicKeyword$1 = alias("tsIntrinsicKeyword"),
    TSNeverKeyword$1 = alias("tsNeverKeyword"),
    TSNullKeyword$1 = alias("tsNullKeyword"),
    TSNumberKeyword$1 = alias("tsNumberKeyword"),
    TSObjectKeyword$1 = alias("tsObjectKeyword"),
    TSStringKeyword$1 = alias("tsStringKeyword"),
    TSSymbolKeyword$1 = alias("tsSymbolKeyword"),
    TSUndefinedKeyword$1 = alias("tsUndefinedKeyword"),
    TSUnknownKeyword$1 = alias("tsUnknownKeyword"),
    TSVoidKeyword$1 = alias("tsVoidKeyword"),
    TSThisType$1 = alias("tsThisType"),
    TSFunctionType$2 = alias("tsFunctionType"),
    TSConstructorType$1 = alias("tsConstructorType"),
    TSTypeReference$1 = alias("tsTypeReference"),
    TSTypePredicate$1 = alias("tsTypePredicate"),
    TSTypeQuery$1 = alias("tsTypeQuery"),
    TSTypeLiteral$1 = alias("tsTypeLiteral"),
    TSArrayType$1 = alias("tsArrayType"),
    TSTupleType$1 = alias("tsTupleType"),
    TSOptionalType$1 = alias("tsOptionalType"),
    TSRestType$1 = alias("tsRestType"),
    TSNamedTupleMember$1 = alias("tsNamedTupleMember"),
    TSUnionType$2 = alias("tsUnionType"),
    TSIntersectionType$2 = alias("tsIntersectionType"),
    TSConditionalType$2 = alias("tsConditionalType"),
    TSInferType$2 = alias("tsInferType"),
    TSParenthesizedType$1 = alias("tsParenthesizedType"),
    TSTypeOperator$2 = alias("tsTypeOperator"),
    TSIndexedAccessType$1 = alias("tsIndexedAccessType"),
    TSMappedType$1 = alias("tsMappedType"),
    TSTemplateLiteralType$1 = alias("tsTemplateLiteralType"),
    TSLiteralType$1 = alias("tsLiteralType"),
    TSExpressionWithTypeArguments = alias("tsExpressionWithTypeArguments"),
    TSInterfaceDeclaration$1 = alias("tsInterfaceDeclaration"),
    TSInterfaceBody$1 = alias("tsInterfaceBody"),
    TSTypeAliasDeclaration$1 = alias("tsTypeAliasDeclaration"),
    TSInstantiationExpression$2 = alias("tsInstantiationExpression"),
    TSAsExpression$2 = alias("tsAsExpression"),
    TSSatisfiesExpression = alias("tsSatisfiesExpression"),
    TSTypeAssertion$1 = alias("tsTypeAssertion"),
    TSEnumBody$1 = alias("tsEnumBody"),
    TSEnumDeclaration$1 = alias("tsEnumDeclaration"),
    TSEnumMember$1 = alias("tsEnumMember"),
    TSModuleDeclaration$1 = alias("tsModuleDeclaration"),
    TSModuleBlock$1 = alias("tsModuleBlock"),
    TSImportType$1 = alias("tsImportType"),
    TSImportEqualsDeclaration$1 = alias("tsImportEqualsDeclaration"),
    TSExternalModuleReference$1 = alias("tsExternalModuleReference"),
    TSNonNullExpression$2 = alias("tsNonNullExpression"),
    TSExportAssignment$1 = alias("tsExportAssignment"),
    TSNamespaceExportDeclaration$1 = alias("tsNamespaceExportDeclaration"),
    TSTypeAnnotation$1 = alias("tsTypeAnnotation"),
    TSTypeParameterInstantiation$1 = alias("tsTypeParameterInstantiation"),
    TSTypeParameterDeclaration = alias("tsTypeParameterDeclaration"),
    TSTypeParameter$1 = alias("tsTypeParameter");
  var NumberLiteral = NumberLiteral$1,
    RegexLiteral = RegexLiteral$1,
    RestProperty$1 = RestProperty$2,
    SpreadProperty$1 = SpreadProperty$2;

  function cleanJSXElementLiteralChild(child, args) {
    var lines = child.value.split(/\r\n|\n|\r/);
    var lastNonEmptyLine = 0;
    for (var i = 0; i < lines.length; i++) {
      if (/[^ \t]/.exec(lines[i])) {
        lastNonEmptyLine = i;
      }
    }
    var str = "";
    for (var _i = 0; _i < lines.length; _i++) {
      var line = lines[_i];
      var isFirstLine = _i === 0;
      var isLastLine = _i === lines.length - 1;
      var isLastNonEmptyLine = _i === lastNonEmptyLine;
      var trimmedLine = line.replace(/\t/g, " ");
      if (!isFirstLine) {
        trimmedLine = trimmedLine.replace(/^ +/, "");
      }
      if (!isLastLine) {
        trimmedLine = trimmedLine.replace(/ +$/, "");
      }
      if (trimmedLine) {
        if (!isLastNonEmptyLine) {
          trimmedLine += " ";
        }
        str += trimmedLine;
      }
    }
    if (str) args.push(inherits$3(stringLiteral$6(str), child));
  }

  function buildChildren(node) {
    var elements = [];
    for (var i = 0; i < node.children.length; i++) {
      var child = node.children[i];
      if (isJSXText(child)) {
        cleanJSXElementLiteralChild(child, elements);
        continue;
      }
      if (isJSXExpressionContainer$1(child)) child = child.expression;
      if (isJSXEmptyExpression(child)) continue;
      elements.push(child);
    }
    return elements;
  }

  function isNode(node) {
    return !!(node && VISITOR_KEYS$7[node.type]);
  }

  function assertNode(node) {
    if (!isNode(node)) {
      var _node$type;
      var type = (_node$type = node == null ? void 0 : node.type) != null ? _node$type : JSON.stringify(node);
      throw new TypeError("Not a valid node of type \"" + type + "\"");
    }
  }

  function assert$2(type, node, opts) {
    if (!is(type, node, opts)) {
      throw new Error("Expected type \"" + type + "\" with option " + JSON.stringify(opts) + ", " + ("but instead got \"" + node.type + "\"."));
    }
  }
  function assertArrayExpression(node, opts) {
    assert$2("ArrayExpression", node, opts);
  }
  function assertAssignmentExpression(node, opts) {
    assert$2("AssignmentExpression", node, opts);
  }
  function assertBinaryExpression(node, opts) {
    assert$2("BinaryExpression", node, opts);
  }
  function assertInterpreterDirective(node, opts) {
    assert$2("InterpreterDirective", node, opts);
  }
  function assertDirective(node, opts) {
    assert$2("Directive", node, opts);
  }
  function assertDirectiveLiteral(node, opts) {
    assert$2("DirectiveLiteral", node, opts);
  }
  function assertBlockStatement(node, opts) {
    assert$2("BlockStatement", node, opts);
  }
  function assertBreakStatement(node, opts) {
    assert$2("BreakStatement", node, opts);
  }
  function assertCallExpression(node, opts) {
    assert$2("CallExpression", node, opts);
  }
  function assertCatchClause(node, opts) {
    assert$2("CatchClause", node, opts);
  }
  function assertConditionalExpression(node, opts) {
    assert$2("ConditionalExpression", node, opts);
  }
  function assertContinueStatement(node, opts) {
    assert$2("ContinueStatement", node, opts);
  }
  function assertDebuggerStatement(node, opts) {
    assert$2("DebuggerStatement", node, opts);
  }
  function assertDoWhileStatement(node, opts) {
    assert$2("DoWhileStatement", node, opts);
  }
  function assertEmptyStatement(node, opts) {
    assert$2("EmptyStatement", node, opts);
  }
  function assertExpressionStatement$1(node, opts) {
    assert$2("ExpressionStatement", node, opts);
  }
  function assertFile(node, opts) {
    assert$2("File", node, opts);
  }
  function assertForInStatement(node, opts) {
    assert$2("ForInStatement", node, opts);
  }
  function assertForStatement(node, opts) {
    assert$2("ForStatement", node, opts);
  }
  function assertFunctionDeclaration(node, opts) {
    assert$2("FunctionDeclaration", node, opts);
  }
  function assertFunctionExpression(node, opts) {
    assert$2("FunctionExpression", node, opts);
  }
  function assertIdentifier(node, opts) {
    assert$2("Identifier", node, opts);
  }
  function assertIfStatement(node, opts) {
    assert$2("IfStatement", node, opts);
  }
  function assertLabeledStatement(node, opts) {
    assert$2("LabeledStatement", node, opts);
  }
  function assertStringLiteral(node, opts) {
    assert$2("StringLiteral", node, opts);
  }
  function assertNumericLiteral(node, opts) {
    assert$2("NumericLiteral", node, opts);
  }
  function assertNullLiteral(node, opts) {
    assert$2("NullLiteral", node, opts);
  }
  function assertBooleanLiteral(node, opts) {
    assert$2("BooleanLiteral", node, opts);
  }
  function assertRegExpLiteral(node, opts) {
    assert$2("RegExpLiteral", node, opts);
  }
  function assertLogicalExpression(node, opts) {
    assert$2("LogicalExpression", node, opts);
  }
  function assertMemberExpression(node, opts) {
    assert$2("MemberExpression", node, opts);
  }
  function assertNewExpression(node, opts) {
    assert$2("NewExpression", node, opts);
  }
  function assertProgram(node, opts) {
    assert$2("Program", node, opts);
  }
  function assertObjectExpression(node, opts) {
    assert$2("ObjectExpression", node, opts);
  }
  function assertObjectMethod(node, opts) {
    assert$2("ObjectMethod", node, opts);
  }
  function assertObjectProperty(node, opts) {
    assert$2("ObjectProperty", node, opts);
  }
  function assertRestElement(node, opts) {
    assert$2("RestElement", node, opts);
  }
  function assertReturnStatement(node, opts) {
    assert$2("ReturnStatement", node, opts);
  }
  function assertSequenceExpression(node, opts) {
    assert$2("SequenceExpression", node, opts);
  }
  function assertParenthesizedExpression(node, opts) {
    assert$2("ParenthesizedExpression", node, opts);
  }
  function assertSwitchCase(node, opts) {
    assert$2("SwitchCase", node, opts);
  }
  function assertSwitchStatement(node, opts) {
    assert$2("SwitchStatement", node, opts);
  }
  function assertThisExpression(node, opts) {
    assert$2("ThisExpression", node, opts);
  }
  function assertThrowStatement(node, opts) {
    assert$2("ThrowStatement", node, opts);
  }
  function assertTryStatement(node, opts) {
    assert$2("TryStatement", node, opts);
  }
  function assertUnaryExpression(node, opts) {
    assert$2("UnaryExpression", node, opts);
  }
  function assertUpdateExpression(node, opts) {
    assert$2("UpdateExpression", node, opts);
  }
  function assertVariableDeclaration(node, opts) {
    assert$2("VariableDeclaration", node, opts);
  }
  function assertVariableDeclarator(node, opts) {
    assert$2("VariableDeclarator", node, opts);
  }
  function assertWhileStatement(node, opts) {
    assert$2("WhileStatement", node, opts);
  }
  function assertWithStatement(node, opts) {
    assert$2("WithStatement", node, opts);
  }
  function assertAssignmentPattern(node, opts) {
    assert$2("AssignmentPattern", node, opts);
  }
  function assertArrayPattern(node, opts) {
    assert$2("ArrayPattern", node, opts);
  }
  function assertArrowFunctionExpression(node, opts) {
    assert$2("ArrowFunctionExpression", node, opts);
  }
  function assertClassBody(node, opts) {
    assert$2("ClassBody", node, opts);
  }
  function assertClassExpression(node, opts) {
    assert$2("ClassExpression", node, opts);
  }
  function assertClassDeclaration(node, opts) {
    assert$2("ClassDeclaration", node, opts);
  }
  function assertExportAllDeclaration(node, opts) {
    assert$2("ExportAllDeclaration", node, opts);
  }
  function assertExportDefaultDeclaration(node, opts) {
    assert$2("ExportDefaultDeclaration", node, opts);
  }
  function assertExportNamedDeclaration(node, opts) {
    assert$2("ExportNamedDeclaration", node, opts);
  }
  function assertExportSpecifier$1(node, opts) {
    assert$2("ExportSpecifier", node, opts);
  }
  function assertForOfStatement(node, opts) {
    assert$2("ForOfStatement", node, opts);
  }
  function assertImportDeclaration(node, opts) {
    assert$2("ImportDeclaration", node, opts);
  }
  function assertImportDefaultSpecifier(node, opts) {
    assert$2("ImportDefaultSpecifier", node, opts);
  }
  function assertImportNamespaceSpecifier(node, opts) {
    assert$2("ImportNamespaceSpecifier", node, opts);
  }
  function assertImportSpecifier(node, opts) {
    assert$2("ImportSpecifier", node, opts);
  }
  function assertImportExpression(node, opts) {
    assert$2("ImportExpression", node, opts);
  }
  function assertMetaProperty(node, opts) {
    assert$2("MetaProperty", node, opts);
  }
  function assertClassMethod(node, opts) {
    assert$2("ClassMethod", node, opts);
  }
  function assertObjectPattern(node, opts) {
    assert$2("ObjectPattern", node, opts);
  }
  function assertSpreadElement(node, opts) {
    assert$2("SpreadElement", node, opts);
  }
  function assertSuper(node, opts) {
    assert$2("Super", node, opts);
  }
  function assertTaggedTemplateExpression(node, opts) {
    assert$2("TaggedTemplateExpression", node, opts);
  }
  function assertTemplateElement(node, opts) {
    assert$2("TemplateElement", node, opts);
  }
  function assertTemplateLiteral(node, opts) {
    assert$2("TemplateLiteral", node, opts);
  }
  function assertYieldExpression(node, opts) {
    assert$2("YieldExpression", node, opts);
  }
  function assertAwaitExpression(node, opts) {
    assert$2("AwaitExpression", node, opts);
  }
  function assertImport(node, opts) {
    assert$2("Import", node, opts);
  }
  function assertBigIntLiteral(node, opts) {
    assert$2("BigIntLiteral", node, opts);
  }
  function assertExportNamespaceSpecifier(node, opts) {
    assert$2("ExportNamespaceSpecifier", node, opts);
  }
  function assertOptionalMemberExpression(node, opts) {
    assert$2("OptionalMemberExpression", node, opts);
  }
  function assertOptionalCallExpression(node, opts) {
    assert$2("OptionalCallExpression", node, opts);
  }
  function assertClassProperty(node, opts) {
    assert$2("ClassProperty", node, opts);
  }
  function assertClassAccessorProperty(node, opts) {
    assert$2("ClassAccessorProperty", node, opts);
  }
  function assertClassPrivateProperty(node, opts) {
    assert$2("ClassPrivateProperty", node, opts);
  }
  function assertClassPrivateMethod(node, opts) {
    assert$2("ClassPrivateMethod", node, opts);
  }
  function assertPrivateName(node, opts) {
    assert$2("PrivateName", node, opts);
  }
  function assertStaticBlock(node, opts) {
    assert$2("StaticBlock", node, opts);
  }
  function assertImportAttribute(node, opts) {
    assert$2("ImportAttribute", node, opts);
  }
  function assertAnyTypeAnnotation(node, opts) {
    assert$2("AnyTypeAnnotation", node, opts);
  }
  function assertArrayTypeAnnotation(node, opts) {
    assert$2("ArrayTypeAnnotation", node, opts);
  }
  function assertBooleanTypeAnnotation(node, opts) {
    assert$2("BooleanTypeAnnotation", node, opts);
  }
  function assertBooleanLiteralTypeAnnotation(node, opts) {
    assert$2("BooleanLiteralTypeAnnotation", node, opts);
  }
  function assertNullLiteralTypeAnnotation(node, opts) {
    assert$2("NullLiteralTypeAnnotation", node, opts);
  }
  function assertClassImplements(node, opts) {
    assert$2("ClassImplements", node, opts);
  }
  function assertDeclareClass(node, opts) {
    assert$2("DeclareClass", node, opts);
  }
  function assertDeclareFunction(node, opts) {
    assert$2("DeclareFunction", node, opts);
  }
  function assertDeclareInterface(node, opts) {
    assert$2("DeclareInterface", node, opts);
  }
  function assertDeclareModule(node, opts) {
    assert$2("DeclareModule", node, opts);
  }
  function assertDeclareModuleExports(node, opts) {
    assert$2("DeclareModuleExports", node, opts);
  }
  function assertDeclareTypeAlias(node, opts) {
    assert$2("DeclareTypeAlias", node, opts);
  }
  function assertDeclareOpaqueType(node, opts) {
    assert$2("DeclareOpaqueType", node, opts);
  }
  function assertDeclareVariable(node, opts) {
    assert$2("DeclareVariable", node, opts);
  }
  function assertDeclareExportDeclaration(node, opts) {
    assert$2("DeclareExportDeclaration", node, opts);
  }
  function assertDeclareExportAllDeclaration(node, opts) {
    assert$2("DeclareExportAllDeclaration", node, opts);
  }
  function assertDeclaredPredicate(node, opts) {
    assert$2("DeclaredPredicate", node, opts);
  }
  function assertExistsTypeAnnotation(node, opts) {
    assert$2("ExistsTypeAnnotation", node, opts);
  }
  function assertFunctionTypeAnnotation(node, opts) {
    assert$2("FunctionTypeAnnotation", node, opts);
  }
  function assertFunctionTypeParam(node, opts) {
    assert$2("FunctionTypeParam", node, opts);
  }
  function assertGenericTypeAnnotation(node, opts) {
    assert$2("GenericTypeAnnotation", node, opts);
  }
  function assertInferredPredicate(node, opts) {
    assert$2("InferredPredicate", node, opts);
  }
  function assertInterfaceExtends(node, opts) {
    assert$2("InterfaceExtends", node, opts);
  }
  function assertInterfaceDeclaration(node, opts) {
    assert$2("InterfaceDeclaration", node, opts);
  }
  function assertInterfaceTypeAnnotation(node, opts) {
    assert$2("InterfaceTypeAnnotation", node, opts);
  }
  function assertIntersectionTypeAnnotation(node, opts) {
    assert$2("IntersectionTypeAnnotation", node, opts);
  }
  function assertMixedTypeAnnotation(node, opts) {
    assert$2("MixedTypeAnnotation", node, opts);
  }
  function assertEmptyTypeAnnotation(node, opts) {
    assert$2("EmptyTypeAnnotation", node, opts);
  }
  function assertNullableTypeAnnotation(node, opts) {
    assert$2("NullableTypeAnnotation", node, opts);
  }
  function assertNumberLiteralTypeAnnotation(node, opts) {
    assert$2("NumberLiteralTypeAnnotation", node, opts);
  }
  function assertNumberTypeAnnotation(node, opts) {
    assert$2("NumberTypeAnnotation", node, opts);
  }
  function assertObjectTypeAnnotation(node, opts) {
    assert$2("ObjectTypeAnnotation", node, opts);
  }
  function assertObjectTypeInternalSlot(node, opts) {
    assert$2("ObjectTypeInternalSlot", node, opts);
  }
  function assertObjectTypeCallProperty(node, opts) {
    assert$2("ObjectTypeCallProperty", node, opts);
  }
  function assertObjectTypeIndexer(node, opts) {
    assert$2("ObjectTypeIndexer", node, opts);
  }
  function assertObjectTypeProperty(node, opts) {
    assert$2("ObjectTypeProperty", node, opts);
  }
  function assertObjectTypeSpreadProperty(node, opts) {
    assert$2("ObjectTypeSpreadProperty", node, opts);
  }
  function assertOpaqueType(node, opts) {
    assert$2("OpaqueType", node, opts);
  }
  function assertQualifiedTypeIdentifier(node, opts) {
    assert$2("QualifiedTypeIdentifier", node, opts);
  }
  function assertStringLiteralTypeAnnotation(node, opts) {
    assert$2("StringLiteralTypeAnnotation", node, opts);
  }
  function assertStringTypeAnnotation(node, opts) {
    assert$2("StringTypeAnnotation", node, opts);
  }
  function assertSymbolTypeAnnotation(node, opts) {
    assert$2("SymbolTypeAnnotation", node, opts);
  }
  function assertThisTypeAnnotation(node, opts) {
    assert$2("ThisTypeAnnotation", node, opts);
  }
  function assertTupleTypeAnnotation(node, opts) {
    assert$2("TupleTypeAnnotation", node, opts);
  }
  function assertTypeofTypeAnnotation(node, opts) {
    assert$2("TypeofTypeAnnotation", node, opts);
  }
  function assertTypeAlias(node, opts) {
    assert$2("TypeAlias", node, opts);
  }
  function assertTypeAnnotation(node, opts) {
    assert$2("TypeAnnotation", node, opts);
  }
  function assertTypeCastExpression(node, opts) {
    assert$2("TypeCastExpression", node, opts);
  }
  function assertTypeParameter(node, opts) {
    assert$2("TypeParameter", node, opts);
  }
  function assertTypeParameterDeclaration(node, opts) {
    assert$2("TypeParameterDeclaration", node, opts);
  }
  function assertTypeParameterInstantiation(node, opts) {
    assert$2("TypeParameterInstantiation", node, opts);
  }
  function assertUnionTypeAnnotation(node, opts) {
    assert$2("UnionTypeAnnotation", node, opts);
  }
  function assertVariance(node, opts) {
    assert$2("Variance", node, opts);
  }
  function assertVoidTypeAnnotation(node, opts) {
    assert$2("VoidTypeAnnotation", node, opts);
  }
  function assertEnumDeclaration(node, opts) {
    assert$2("EnumDeclaration", node, opts);
  }
  function assertEnumBooleanBody(node, opts) {
    assert$2("EnumBooleanBody", node, opts);
  }
  function assertEnumNumberBody(node, opts) {
    assert$2("EnumNumberBody", node, opts);
  }
  function assertEnumStringBody(node, opts) {
    assert$2("EnumStringBody", node, opts);
  }
  function assertEnumSymbolBody(node, opts) {
    assert$2("EnumSymbolBody", node, opts);
  }
  function assertEnumBooleanMember(node, opts) {
    assert$2("EnumBooleanMember", node, opts);
  }
  function assertEnumNumberMember(node, opts) {
    assert$2("EnumNumberMember", node, opts);
  }
  function assertEnumStringMember(node, opts) {
    assert$2("EnumStringMember", node, opts);
  }
  function assertEnumDefaultedMember(node, opts) {
    assert$2("EnumDefaultedMember", node, opts);
  }
  function assertIndexedAccessType(node, opts) {
    assert$2("IndexedAccessType", node, opts);
  }
  function assertOptionalIndexedAccessType(node, opts) {
    assert$2("OptionalIndexedAccessType", node, opts);
  }
  function assertJSXAttribute(node, opts) {
    assert$2("JSXAttribute", node, opts);
  }
  function assertJSXClosingElement(node, opts) {
    assert$2("JSXClosingElement", node, opts);
  }
  function assertJSXElement(node, opts) {
    assert$2("JSXElement", node, opts);
  }
  function assertJSXEmptyExpression(node, opts) {
    assert$2("JSXEmptyExpression", node, opts);
  }
  function assertJSXExpressionContainer(node, opts) {
    assert$2("JSXExpressionContainer", node, opts);
  }
  function assertJSXSpreadChild(node, opts) {
    assert$2("JSXSpreadChild", node, opts);
  }
  function assertJSXIdentifier(node, opts) {
    assert$2("JSXIdentifier", node, opts);
  }
  function assertJSXMemberExpression(node, opts) {
    assert$2("JSXMemberExpression", node, opts);
  }
  function assertJSXNamespacedName(node, opts) {
    assert$2("JSXNamespacedName", node, opts);
  }
  function assertJSXOpeningElement(node, opts) {
    assert$2("JSXOpeningElement", node, opts);
  }
  function assertJSXSpreadAttribute(node, opts) {
    assert$2("JSXSpreadAttribute", node, opts);
  }
  function assertJSXText(node, opts) {
    assert$2("JSXText", node, opts);
  }
  function assertJSXFragment(node, opts) {
    assert$2("JSXFragment", node, opts);
  }
  function assertJSXOpeningFragment(node, opts) {
    assert$2("JSXOpeningFragment", node, opts);
  }
  function assertJSXClosingFragment(node, opts) {
    assert$2("JSXClosingFragment", node, opts);
  }
  function assertNoop(node, opts) {
    assert$2("Noop", node, opts);
  }
  function assertPlaceholder(node, opts) {
    assert$2("Placeholder", node, opts);
  }
  function assertV8IntrinsicIdentifier(node, opts) {
    assert$2("V8IntrinsicIdentifier", node, opts);
  }
  function assertArgumentPlaceholder(node, opts) {
    assert$2("ArgumentPlaceholder", node, opts);
  }
  function assertBindExpression(node, opts) {
    assert$2("BindExpression", node, opts);
  }
  function assertDecorator(node, opts) {
    assert$2("Decorator", node, opts);
  }
  function assertDoExpression(node, opts) {
    assert$2("DoExpression", node, opts);
  }
  function assertExportDefaultSpecifier(node, opts) {
    assert$2("ExportDefaultSpecifier", node, opts);
  }
  function assertRecordExpression(node, opts) {
    assert$2("RecordExpression", node, opts);
  }
  function assertTupleExpression(node, opts) {
    assert$2("TupleExpression", node, opts);
  }
  function assertDecimalLiteral(node, opts) {
    assert$2("DecimalLiteral", node, opts);
  }
  function assertModuleExpression(node, opts) {
    assert$2("ModuleExpression", node, opts);
  }
  function assertTopicReference(node, opts) {
    assert$2("TopicReference", node, opts);
  }
  function assertPipelineTopicExpression(node, opts) {
    assert$2("PipelineTopicExpression", node, opts);
  }
  function assertPipelineBareFunction(node, opts) {
    assert$2("PipelineBareFunction", node, opts);
  }
  function assertPipelinePrimaryTopicReference(node, opts) {
    assert$2("PipelinePrimaryTopicReference", node, opts);
  }
  function assertVoidPattern(node, opts) {
    assert$2("VoidPattern", node, opts);
  }
  function assertTSParameterProperty(node, opts) {
    assert$2("TSParameterProperty", node, opts);
  }
  function assertTSDeclareFunction(node, opts) {
    assert$2("TSDeclareFunction", node, opts);
  }
  function assertTSDeclareMethod(node, opts) {
    assert$2("TSDeclareMethod", node, opts);
  }
  function assertTSQualifiedName(node, opts) {
    assert$2("TSQualifiedName", node, opts);
  }
  function assertTSCallSignatureDeclaration(node, opts) {
    assert$2("TSCallSignatureDeclaration", node, opts);
  }
  function assertTSConstructSignatureDeclaration(node, opts) {
    assert$2("TSConstructSignatureDeclaration", node, opts);
  }
  function assertTSPropertySignature(node, opts) {
    assert$2("TSPropertySignature", node, opts);
  }
  function assertTSMethodSignature(node, opts) {
    assert$2("TSMethodSignature", node, opts);
  }
  function assertTSIndexSignature(node, opts) {
    assert$2("TSIndexSignature", node, opts);
  }
  function assertTSAnyKeyword(node, opts) {
    assert$2("TSAnyKeyword", node, opts);
  }
  function assertTSBooleanKeyword(node, opts) {
    assert$2("TSBooleanKeyword", node, opts);
  }
  function assertTSBigIntKeyword(node, opts) {
    assert$2("TSBigIntKeyword", node, opts);
  }
  function assertTSIntrinsicKeyword(node, opts) {
    assert$2("TSIntrinsicKeyword", node, opts);
  }
  function assertTSNeverKeyword(node, opts) {
    assert$2("TSNeverKeyword", node, opts);
  }
  function assertTSNullKeyword(node, opts) {
    assert$2("TSNullKeyword", node, opts);
  }
  function assertTSNumberKeyword(node, opts) {
    assert$2("TSNumberKeyword", node, opts);
  }
  function assertTSObjectKeyword(node, opts) {
    assert$2("TSObjectKeyword", node, opts);
  }
  function assertTSStringKeyword(node, opts) {
    assert$2("TSStringKeyword", node, opts);
  }
  function assertTSSymbolKeyword(node, opts) {
    assert$2("TSSymbolKeyword", node, opts);
  }
  function assertTSUndefinedKeyword(node, opts) {
    assert$2("TSUndefinedKeyword", node, opts);
  }
  function assertTSUnknownKeyword(node, opts) {
    assert$2("TSUnknownKeyword", node, opts);
  }
  function assertTSVoidKeyword(node, opts) {
    assert$2("TSVoidKeyword", node, opts);
  }
  function assertTSThisType(node, opts) {
    assert$2("TSThisType", node, opts);
  }
  function assertTSFunctionType(node, opts) {
    assert$2("TSFunctionType", node, opts);
  }
  function assertTSConstructorType(node, opts) {
    assert$2("TSConstructorType", node, opts);
  }
  function assertTSTypeReference(node, opts) {
    assert$2("TSTypeReference", node, opts);
  }
  function assertTSTypePredicate(node, opts) {
    assert$2("TSTypePredicate", node, opts);
  }
  function assertTSTypeQuery(node, opts) {
    assert$2("TSTypeQuery", node, opts);
  }
  function assertTSTypeLiteral(node, opts) {
    assert$2("TSTypeLiteral", node, opts);
  }
  function assertTSArrayType(node, opts) {
    assert$2("TSArrayType", node, opts);
  }
  function assertTSTupleType(node, opts) {
    assert$2("TSTupleType", node, opts);
  }
  function assertTSOptionalType(node, opts) {
    assert$2("TSOptionalType", node, opts);
  }
  function assertTSRestType(node, opts) {
    assert$2("TSRestType", node, opts);
  }
  function assertTSNamedTupleMember(node, opts) {
    assert$2("TSNamedTupleMember", node, opts);
  }
  function assertTSUnionType(node, opts) {
    assert$2("TSUnionType", node, opts);
  }
  function assertTSIntersectionType(node, opts) {
    assert$2("TSIntersectionType", node, opts);
  }
  function assertTSConditionalType(node, opts) {
    assert$2("TSConditionalType", node, opts);
  }
  function assertTSInferType(node, opts) {
    assert$2("TSInferType", node, opts);
  }
  function assertTSParenthesizedType(node, opts) {
    assert$2("TSParenthesizedType", node, opts);
  }
  function assertTSTypeOperator(node, opts) {
    assert$2("TSTypeOperator", node, opts);
  }
  function assertTSIndexedAccessType(node, opts) {
    assert$2("TSIndexedAccessType", node, opts);
  }
  function assertTSMappedType(node, opts) {
    assert$2("TSMappedType", node, opts);
  }
  function assertTSTemplateLiteralType(node, opts) {
    assert$2("TSTemplateLiteralType", node, opts);
  }
  function assertTSLiteralType(node, opts) {
    assert$2("TSLiteralType", node, opts);
  }
  function assertTSExpressionWithTypeArguments(node, opts) {
    assert$2("TSExpressionWithTypeArguments", node, opts);
  }
  function assertTSInterfaceDeclaration(node, opts) {
    assert$2("TSInterfaceDeclaration", node, opts);
  }
  function assertTSInterfaceBody(node, opts) {
    assert$2("TSInterfaceBody", node, opts);
  }
  function assertTSTypeAliasDeclaration(node, opts) {
    assert$2("TSTypeAliasDeclaration", node, opts);
  }
  function assertTSInstantiationExpression(node, opts) {
    assert$2("TSInstantiationExpression", node, opts);
  }
  function assertTSAsExpression(node, opts) {
    assert$2("TSAsExpression", node, opts);
  }
  function assertTSSatisfiesExpression(node, opts) {
    assert$2("TSSatisfiesExpression", node, opts);
  }
  function assertTSTypeAssertion(node, opts) {
    assert$2("TSTypeAssertion", node, opts);
  }
  function assertTSEnumBody(node, opts) {
    assert$2("TSEnumBody", node, opts);
  }
  function assertTSEnumDeclaration(node, opts) {
    assert$2("TSEnumDeclaration", node, opts);
  }
  function assertTSEnumMember(node, opts) {
    assert$2("TSEnumMember", node, opts);
  }
  function assertTSModuleDeclaration(node, opts) {
    assert$2("TSModuleDeclaration", node, opts);
  }
  function assertTSModuleBlock(node, opts) {
    assert$2("TSModuleBlock", node, opts);
  }
  function assertTSImportType(node, opts) {
    assert$2("TSImportType", node, opts);
  }
  function assertTSImportEqualsDeclaration(node, opts) {
    assert$2("TSImportEqualsDeclaration", node, opts);
  }
  function assertTSExternalModuleReference(node, opts) {
    assert$2("TSExternalModuleReference", node, opts);
  }
  function assertTSNonNullExpression(node, opts) {
    assert$2("TSNonNullExpression", node, opts);
  }
  function assertTSExportAssignment(node, opts) {
    assert$2("TSExportAssignment", node, opts);
  }
  function assertTSNamespaceExportDeclaration(node, opts) {
    assert$2("TSNamespaceExportDeclaration", node, opts);
  }
  function assertTSTypeAnnotation(node, opts) {
    assert$2("TSTypeAnnotation", node, opts);
  }
  function assertTSTypeParameterInstantiation(node, opts) {
    assert$2("TSTypeParameterInstantiation", node, opts);
  }
  function assertTSTypeParameterDeclaration(node, opts) {
    assert$2("TSTypeParameterDeclaration", node, opts);
  }
  function assertTSTypeParameter(node, opts) {
    assert$2("TSTypeParameter", node, opts);
  }
  function assertStandardized(node, opts) {
    assert$2("Standardized", node, opts);
  }
  function assertExpression$1(node, opts) {
    assert$2("Expression", node, opts);
  }
  function assertBinary(node, opts) {
    assert$2("Binary", node, opts);
  }
  function assertScopable(node, opts) {
    assert$2("Scopable", node, opts);
  }
  function assertBlockParent(node, opts) {
    assert$2("BlockParent", node, opts);
  }
  function assertBlock(node, opts) {
    assert$2("Block", node, opts);
  }
  function assertStatement(node, opts) {
    assert$2("Statement", node, opts);
  }
  function assertTerminatorless(node, opts) {
    assert$2("Terminatorless", node, opts);
  }
  function assertCompletionStatement(node, opts) {
    assert$2("CompletionStatement", node, opts);
  }
  function assertConditional(node, opts) {
    assert$2("Conditional", node, opts);
  }
  function assertLoop(node, opts) {
    assert$2("Loop", node, opts);
  }
  function assertWhile(node, opts) {
    assert$2("While", node, opts);
  }
  function assertExpressionWrapper(node, opts) {
    assert$2("ExpressionWrapper", node, opts);
  }
  function assertFor(node, opts) {
    assert$2("For", node, opts);
  }
  function assertForXStatement(node, opts) {
    assert$2("ForXStatement", node, opts);
  }
  function assertFunction$1(node, opts) {
    assert$2("Function", node, opts);
  }
  function assertFunctionParent(node, opts) {
    assert$2("FunctionParent", node, opts);
  }
  function assertPureish(node, opts) {
    assert$2("Pureish", node, opts);
  }
  function assertDeclaration(node, opts) {
    assert$2("Declaration", node, opts);
  }
  function assertFunctionParameter(node, opts) {
    assert$2("FunctionParameter", node, opts);
  }
  function assertPatternLike(node, opts) {
    assert$2("PatternLike", node, opts);
  }
  function assertLVal(node, opts) {
    assert$2("LVal", node, opts);
  }
  function assertTSEntityName(node, opts) {
    assert$2("TSEntityName", node, opts);
  }
  function assertLiteral(node, opts) {
    assert$2("Literal", node, opts);
  }
  function assertImmutable(node, opts) {
    assert$2("Immutable", node, opts);
  }
  function assertUserWhitespacable(node, opts) {
    assert$2("UserWhitespacable", node, opts);
  }
  function assertMethod(node, opts) {
    assert$2("Method", node, opts);
  }
  function assertObjectMember(node, opts) {
    assert$2("ObjectMember", node, opts);
  }
  function assertProperty(node, opts) {
    assert$2("Property", node, opts);
  }
  function assertUnaryLike(node, opts) {
    assert$2("UnaryLike", node, opts);
  }
  function assertPattern(node, opts) {
    assert$2("Pattern", node, opts);
  }
  function assertClass(node, opts) {
    assert$2("Class", node, opts);
  }
  function assertImportOrExportDeclaration(node, opts) {
    assert$2("ImportOrExportDeclaration", node, opts);
  }
  function assertExportDeclaration(node, opts) {
    assert$2("ExportDeclaration", node, opts);
  }
  function assertModuleSpecifier(node, opts) {
    assert$2("ModuleSpecifier", node, opts);
  }
  function assertAccessor(node, opts) {
    assert$2("Accessor", node, opts);
  }
  function assertPrivate(node, opts) {
    assert$2("Private", node, opts);
  }
  function assertFlow(node, opts) {
    assert$2("Flow", node, opts);
  }
  function assertFlowType(node, opts) {
    assert$2("FlowType", node, opts);
  }
  function assertFlowBaseAnnotation(node, opts) {
    assert$2("FlowBaseAnnotation", node, opts);
  }
  function assertFlowDeclaration(node, opts) {
    assert$2("FlowDeclaration", node, opts);
  }
  function assertFlowPredicate(node, opts) {
    assert$2("FlowPredicate", node, opts);
  }
  function assertEnumBody(node, opts) {
    assert$2("EnumBody", node, opts);
  }
  function assertEnumMember(node, opts) {
    assert$2("EnumMember", node, opts);
  }
  function assertJSX(node, opts) {
    assert$2("JSX", node, opts);
  }
  function assertMiscellaneous(node, opts) {
    assert$2("Miscellaneous", node, opts);
  }
  function assertTypeScript(node, opts) {
    assert$2("TypeScript", node, opts);
  }
  function assertTSTypeElement(node, opts) {
    assert$2("TSTypeElement", node, opts);
  }
  function assertTSType(node, opts) {
    assert$2("TSType", node, opts);
  }
  function assertTSBaseType(node, opts) {
    assert$2("TSBaseType", node, opts);
  }
  function assertNumberLiteral(node, opts) {
    deprecationWarning$1("assertNumberLiteral", "assertNumericLiteral");
    assert$2("NumberLiteral", node, opts);
  }
  function assertRegexLiteral(node, opts) {
    deprecationWarning$1("assertRegexLiteral", "assertRegExpLiteral");
    assert$2("RegexLiteral", node, opts);
  }
  function assertRestProperty(node, opts) {
    deprecationWarning$1("assertRestProperty", "assertRestElement");
    assert$2("RestProperty", node, opts);
  }
  function assertSpreadProperty(node, opts) {
    deprecationWarning$1("assertSpreadProperty", "assertSpreadElement");
    assert$2("SpreadProperty", node, opts);
  }
  function assertModuleDeclaration(node, opts) {
    deprecationWarning$1("assertModuleDeclaration", "assertImportOrExportDeclaration");
    assert$2("ModuleDeclaration", node, opts);
  }

  function createTypeAnnotationBasedOnTypeof$1(type) {
    switch (type) {
      case "string":
        return stringTypeAnnotation$2();
      case "number":
        return numberTypeAnnotation$2();
      case "undefined":
        return voidTypeAnnotation$3();
      case "boolean":
        return booleanTypeAnnotation$1();
      case "function":
        return genericTypeAnnotation$1(identifier$e("Function"));
      case "object":
        return genericTypeAnnotation$1(identifier$e("Object"));
      case "symbol":
        return genericTypeAnnotation$1(identifier$e("Symbol"));
      case "bigint":
        return anyTypeAnnotation$2();
    }
    throw new Error("Invalid typeof value: " + type);
  }

  function getQualifiedName$1(node) {
    return isIdentifier$e(node) ? node.name : node.id.name + "." + getQualifiedName$1(node.qualification);
  }
  function removeTypeDuplicates$1(nodesIn) {
    var nodes = Array.from(nodesIn);
    var generics = new Map();
    var bases = new Map();
    var typeGroups = new Set();
    var types = [];
    for (var i = 0; i < nodes.length; i++) {
      var node = nodes[i];
      if (!node) continue;
      if (types.includes(node)) {
        continue;
      }
      if (isAnyTypeAnnotation$1(node)) {
        return [node];
      }
      if (isFlowBaseAnnotation$1(node)) {
        bases.set(node.type, node);
        continue;
      }
      if (isUnionTypeAnnotation$1(node)) {
        if (!typeGroups.has(node.types)) {
          nodes.push.apply(nodes, _toConsumableArray(node.types));
          typeGroups.add(node.types);
        }
        continue;
      }
      if (isGenericTypeAnnotation$1(node)) {
        var name = getQualifiedName$1(node.id);
        if (generics.has(name)) {
          var existing = generics.get(name);
          if (existing.typeParameters) {
            if (node.typeParameters) {
              var _existing$typeParamet;
              (_existing$typeParamet = existing.typeParameters.params).push.apply(_existing$typeParamet, _toConsumableArray(node.typeParameters.params));
              existing.typeParameters.params = removeTypeDuplicates$1(existing.typeParameters.params);
            }
          } else {
            existing = node.typeParameters;
          }
        } else {
          generics.set(name, node);
        }
        continue;
      }
      types.push(node);
    }
    for (var _iterator = _createForOfIteratorHelperLoose(bases), _step; !(_step = _iterator()).done;) {
      var _step$value = _slicedToArray(_step.value, 2),
        baseType = _step$value[1];
      types.push(baseType);
    }
    for (var _iterator2 = _createForOfIteratorHelperLoose(generics), _step2; !(_step2 = _iterator2()).done;) {
      var _step2$value = _slicedToArray(_step2.value, 2),
        genericName = _step2$value[1];
      types.push(genericName);
    }
    return types;
  }

  function createFlowUnionType$1(types) {
    var flattened = removeTypeDuplicates$1(types);
    if (flattened.length === 1) {
      return flattened[0];
    } else {
      return unionTypeAnnotation$1(flattened);
    }
  }

  function getQualifiedName(node) {
    return isIdentifier$e(node) ? node.name : isThisExpression$2(node) ? "this" : node.right.name + "." + getQualifiedName(node.left);
  }
  function removeTypeDuplicates(nodesIn) {
    var nodes = Array.from(nodesIn);
    var generics = new Map();
    var bases = new Map();
    var typeGroups = new Set();
    var types = [];
    for (var i = 0; i < nodes.length; i++) {
      var node = nodes[i];
      if (!node) continue;
      if (types.includes(node)) {
        continue;
      }
      if (isTSAnyKeyword(node)) {
        return [node];
      }
      if (isTSBaseType(node)) {
        bases.set(node.type, node);
        continue;
      }
      if (isTSUnionType(node)) {
        if (!typeGroups.has(node.types)) {
          nodes.push.apply(nodes, _toConsumableArray(node.types));
          typeGroups.add(node.types);
        }
        continue;
      }
      var typeArgumentsKey = "typeParameters";
      if (isTSTypeReference$1(node) && node[typeArgumentsKey]) {
        var typeArguments = node[typeArgumentsKey];
        var name = getQualifiedName(node.typeName);
        if (generics.has(name)) {
          var existing = generics.get(name);
          var existingTypeArguments = existing[typeArgumentsKey];
          if (existingTypeArguments) {
            var _existingTypeArgument;
            (_existingTypeArgument = existingTypeArguments.params).push.apply(_existingTypeArgument, _toConsumableArray(typeArguments.params));
            existingTypeArguments.params = removeTypeDuplicates(existingTypeArguments.params);
          } else {
            existing = typeArguments;
          }
        } else {
          generics.set(name, node);
        }
        continue;
      }
      types.push(node);
    }
    for (var _iterator = _createForOfIteratorHelperLoose(bases), _step; !(_step = _iterator()).done;) {
      var _step$value = _slicedToArray(_step.value, 2),
        baseType = _step$value[1];
      types.push(baseType);
    }
    for (var _iterator2 = _createForOfIteratorHelperLoose(generics), _step2; !(_step2 = _iterator2()).done;) {
      var _step2$value = _slicedToArray(_step2.value, 2),
        genericName = _step2$value[1];
      types.push(genericName);
    }
    return types;
  }

  function createTSUnionType$1(typeAnnotations) {
    var types = typeAnnotations.map(function (type) {
      return isTSTypeAnnotation$1(type) ? type.typeAnnotation : type;
    });
    var flattened = removeTypeDuplicates(types);
    if (flattened.length === 1) {
      return flattened[0];
    } else {
      return tsUnionType(flattened);
    }
  }

  function buildUndefinedNode$2() {
    return unaryExpression$4("void", numericLiteral$5(0), true);
  }

  var _ref$1 = {
      hasOwn: Function.call.bind(Object.prototype.hasOwnProperty)
    },
    hasOwn$3 = _ref$1.hasOwn;
  function cloneIfNode(obj, deep, withoutLoc, commentsCache) {
    if (obj && typeof obj.type === "string") {
      return cloneNodeInternal(obj, deep, withoutLoc, commentsCache);
    }
    return obj;
  }
  function cloneIfNodeOrArray(obj, deep, withoutLoc, commentsCache) {
    if (Array.isArray(obj)) {
      return obj.map(function (node) {
        return cloneIfNode(node, deep, withoutLoc, commentsCache);
      });
    }
    return cloneIfNode(obj, deep, withoutLoc, commentsCache);
  }
  function cloneNode$e(node, deep, withoutLoc) {
    if (deep === void 0) {
      deep = true;
    }
    if (withoutLoc === void 0) {
      withoutLoc = false;
    }
    return cloneNodeInternal(node, deep, withoutLoc, new Map());
  }
  function cloneNodeInternal(node, deep, withoutLoc, commentsCache) {
    if (deep === void 0) {
      deep = true;
    }
    if (withoutLoc === void 0) {
      withoutLoc = false;
    }
    if (!node) return node;
    var type = node.type;
    var newNode = {
      type: node.type
    };
    if (isIdentifier$e(node)) {
      newNode.name = node.name;
      if (hasOwn$3(node, "optional") && typeof node.optional === "boolean") {
        newNode.optional = node.optional;
      }
      if (hasOwn$3(node, "typeAnnotation")) {
        newNode.typeAnnotation = deep ? cloneIfNodeOrArray(node.typeAnnotation, true, withoutLoc, commentsCache) : node.typeAnnotation;
      }
      if (hasOwn$3(node, "decorators")) {
        newNode.decorators = deep ? cloneIfNodeOrArray(node.decorators, true, withoutLoc, commentsCache) : node.decorators;
      }
    } else if (!hasOwn$3(NODE_FIELDS$1, type)) {
      throw new Error("Unknown node type: \"" + type + "\"");
    } else {
      for (var _i = 0, _Object$keys = Object.keys(NODE_FIELDS$1[type]); _i < _Object$keys.length; _i++) {
        var field = _Object$keys[_i];
        if (hasOwn$3(node, field)) {
          if (deep) {
            newNode[field] = isFile(node) && field === "comments" ? maybeCloneComments(node.comments, deep, withoutLoc, commentsCache) : cloneIfNodeOrArray(node[field], true, withoutLoc, commentsCache);
          } else {
            newNode[field] = node[field];
          }
        }
      }
    }
    if (hasOwn$3(node, "loc")) {
      if (withoutLoc) {
        newNode.loc = null;
      } else {
        newNode.loc = node.loc;
      }
    }
    if (hasOwn$3(node, "leadingComments")) {
      newNode.leadingComments = maybeCloneComments(node.leadingComments, deep, withoutLoc, commentsCache);
    }
    if (hasOwn$3(node, "innerComments")) {
      newNode.innerComments = maybeCloneComments(node.innerComments, deep, withoutLoc, commentsCache);
    }
    if (hasOwn$3(node, "trailingComments")) {
      newNode.trailingComments = maybeCloneComments(node.trailingComments, deep, withoutLoc, commentsCache);
    }
    if (hasOwn$3(node, "extra")) {
      newNode.extra = Object.assign({}, node.extra);
    }
    return newNode;
  }
  function maybeCloneComments(comments, deep, withoutLoc, commentsCache) {
    if (!comments || !deep) {
      return comments;
    }
    return comments.map(function (comment) {
      var cache = commentsCache.get(comment);
      if (cache) return cache;
      var type = comment.type,
        value = comment.value,
        loc = comment.loc;
      var ret = {
        type: type,
        value: value,
        loc: loc
      };
      if (withoutLoc) {
        ret.loc = null;
      }
      commentsCache.set(comment, ret);
      return ret;
    });
  }

  function clone(node) {
    return cloneNode$e(node, false);
  }

  function cloneDeep$1(node) {
    return cloneNode$e(node);
  }

  function cloneDeepWithoutLoc(node) {
    return cloneNode$e(node, true, true);
  }

  function cloneWithoutLoc(node) {
    return cloneNode$e(node, false, true);
  }

  function addComments$1(node, type, comments) {
    if (!comments || !node) return node;
    var key = type + "Comments";
    if (node[key]) {
      if (type === "leading") {
        node[key] = comments.concat(node[key]);
      } else {
        var _node$key;
        (_node$key = node[key]).push.apply(_node$key, _toConsumableArray(comments));
      }
    } else {
      node[key] = comments;
    }
    return node;
  }

  function addComment$2(node, type, content, line) {
    return addComments$1(node, type, [{
      type: line ? "CommentLine" : "CommentBlock",
      value: content
    }]);
  }

  function inherit(key, child, parent) {
    if (child && parent) {
      child[key] = Array.from(new Set([].concat(child[key], parent[key]).filter(Boolean)));
    }
  }

  function inheritInnerComments(child, parent) {
    inherit("innerComments", child, parent);
  }

  function inheritLeadingComments$1(child, parent) {
    inherit("leadingComments", child, parent);
  }

  function inheritTrailingComments$1(child, parent) {
    inherit("trailingComments", child, parent);
  }

  function inheritsComments$1(child, parent) {
    inheritTrailingComments$1(child, parent);
    inheritLeadingComments$1(child, parent);
    inheritInnerComments(child, parent);
    return child;
  }

  function removeComments$1(node) {
    COMMENT_KEYS.forEach(function (key) {
      node[key] = null;
    });
    return node;
  }

  var STANDARDIZED_TYPES = FLIPPED_ALIAS_KEYS$3["Standardized"];
  var EXPRESSION_TYPES = FLIPPED_ALIAS_KEYS$3["Expression"];
  var BINARY_TYPES = FLIPPED_ALIAS_KEYS$3["Binary"];
  var SCOPABLE_TYPES = FLIPPED_ALIAS_KEYS$3["Scopable"];
  var BLOCKPARENT_TYPES = FLIPPED_ALIAS_KEYS$3["BlockParent"];
  var BLOCK_TYPES = FLIPPED_ALIAS_KEYS$3["Block"];
  var STATEMENT_TYPES = FLIPPED_ALIAS_KEYS$3["Statement"];
  var TERMINATORLESS_TYPES = FLIPPED_ALIAS_KEYS$3["Terminatorless"];
  var COMPLETIONSTATEMENT_TYPES = FLIPPED_ALIAS_KEYS$3["CompletionStatement"];
  var CONDITIONAL_TYPES = FLIPPED_ALIAS_KEYS$3["Conditional"];
  var LOOP_TYPES = FLIPPED_ALIAS_KEYS$3["Loop"];
  var WHILE_TYPES = FLIPPED_ALIAS_KEYS$3["While"];
  var EXPRESSIONWRAPPER_TYPES = FLIPPED_ALIAS_KEYS$3["ExpressionWrapper"];
  var FOR_TYPES = FLIPPED_ALIAS_KEYS$3["For"];
  var FORXSTATEMENT_TYPES = FLIPPED_ALIAS_KEYS$3["ForXStatement"];
  var FUNCTION_TYPES$1 = FLIPPED_ALIAS_KEYS$3["Function"];
  var FUNCTIONPARENT_TYPES = FLIPPED_ALIAS_KEYS$3["FunctionParent"];
  var PUREISH_TYPES = FLIPPED_ALIAS_KEYS$3["Pureish"];
  var DECLARATION_TYPES = FLIPPED_ALIAS_KEYS$3["Declaration"];
  var FUNCTIONPARAMETER_TYPES = FLIPPED_ALIAS_KEYS$3["FunctionParameter"];
  var PATTERNLIKE_TYPES = FLIPPED_ALIAS_KEYS$3["PatternLike"];
  var LVAL_TYPES = FLIPPED_ALIAS_KEYS$3["LVal"];
  var TSENTITYNAME_TYPES = FLIPPED_ALIAS_KEYS$3["TSEntityName"];
  var LITERAL_TYPES = FLIPPED_ALIAS_KEYS$3["Literal"];
  var IMMUTABLE_TYPES = FLIPPED_ALIAS_KEYS$3["Immutable"];
  var USERWHITESPACABLE_TYPES = FLIPPED_ALIAS_KEYS$3["UserWhitespacable"];
  var METHOD_TYPES = FLIPPED_ALIAS_KEYS$3["Method"];
  var OBJECTMEMBER_TYPES = FLIPPED_ALIAS_KEYS$3["ObjectMember"];
  var PROPERTY_TYPES = FLIPPED_ALIAS_KEYS$3["Property"];
  var UNARYLIKE_TYPES = FLIPPED_ALIAS_KEYS$3["UnaryLike"];
  var PATTERN_TYPES = FLIPPED_ALIAS_KEYS$3["Pattern"];
  var CLASS_TYPES = FLIPPED_ALIAS_KEYS$3["Class"];
  var IMPORTOREXPORTDECLARATION_TYPES = FLIPPED_ALIAS_KEYS$3["ImportOrExportDeclaration"];
  var EXPORTDECLARATION_TYPES = FLIPPED_ALIAS_KEYS$3["ExportDeclaration"];
  var MODULESPECIFIER_TYPES = FLIPPED_ALIAS_KEYS$3["ModuleSpecifier"];
  var ACCESSOR_TYPES = FLIPPED_ALIAS_KEYS$3["Accessor"];
  var PRIVATE_TYPES = FLIPPED_ALIAS_KEYS$3["Private"];
  var FLOW_TYPES = FLIPPED_ALIAS_KEYS$3["Flow"];
  var FLOWTYPE_TYPES = FLIPPED_ALIAS_KEYS$3["FlowType"];
  var FLOWBASEANNOTATION_TYPES = FLIPPED_ALIAS_KEYS$3["FlowBaseAnnotation"];
  var FLOWDECLARATION_TYPES = FLIPPED_ALIAS_KEYS$3["FlowDeclaration"];
  var FLOWPREDICATE_TYPES = FLIPPED_ALIAS_KEYS$3["FlowPredicate"];
  var ENUMBODY_TYPES = FLIPPED_ALIAS_KEYS$3["EnumBody"];
  var ENUMMEMBER_TYPES = FLIPPED_ALIAS_KEYS$3["EnumMember"];
  var JSX_TYPES = FLIPPED_ALIAS_KEYS$3["JSX"];
  var MISCELLANEOUS_TYPES = FLIPPED_ALIAS_KEYS$3["Miscellaneous"];
  var TYPESCRIPT_TYPES = FLIPPED_ALIAS_KEYS$3["TypeScript"];
  var TSTYPEELEMENT_TYPES = FLIPPED_ALIAS_KEYS$3["TSTypeElement"];
  var TSTYPE_TYPES = FLIPPED_ALIAS_KEYS$3["TSType"];
  var TSBASETYPE_TYPES = FLIPPED_ALIAS_KEYS$3["TSBaseType"];
  var MODULEDECLARATION_TYPES = IMPORTOREXPORTDECLARATION_TYPES;

  function toBlock(node, parent) {
    if (isBlockStatement$3(node)) {
      return node;
    }
    var blockNodes = [];
    if (isEmptyStatement$1(node)) {
      blockNodes = [];
    } else {
      if (!isStatement$9(node)) {
        if (isFunction$6(parent)) {
          node = returnStatement$3(node);
        } else {
          node = expressionStatement$7(node);
        }
      }
      blockNodes = [node];
    }
    return blockStatement$6(blockNodes);
  }

  function ensureBlock$1(node, key) {
    if (key === void 0) {
      key = "body";
    }
    var result = toBlock(node[key], node);
    node[key] = result;
    return result;
  }

  function toIdentifier$1(input) {
    input = input + "";
    var name = "";
    for (var _iterator = _createForOfIteratorHelperLoose(input), _step; !(_step = _iterator()).done;) {
      var c = _step.value;
      name += isIdentifierChar(c.codePointAt(0)) ? c : "-";
    }
    name = name.replace(/^[-0-9]+/, "");
    name = name.replace(/[-\s]+(.)?/g, function (match, c) {
      return c ? c.toUpperCase() : "";
    });
    if (!isValidIdentifier$1(name)) {
      name = "_" + name;
    }
    return name || "_";
  }

  function toBindingIdentifierName$1(name) {
    name = toIdentifier$1(name);
    if (name === "eval" || name === "arguments") name = "_" + name;
    return name;
  }

  function toComputedKey$1(node, key) {
    if (key === void 0) {
      key = node.key || node.property;
    }
    if (!node.computed && isIdentifier$e(key)) key = stringLiteral$6(key.name);
    return key;
  }

  function toExpression$1(node) {
    if (isExpressionStatement$2(node)) {
      node = node.expression;
    }
    if (isExpression$5(node)) {
      return node;
    }
    if (isClass$1(node)) {
      node.type = "ClassExpression";
      node["abstract"] = false;
    } else if (isFunction$6(node)) {
      node.type = "FunctionExpression";
    }
    if (!isExpression$5(node)) {
      throw new Error("cannot turn " + node.type + " to an expression");
    }
    return node;
  }

  var _skip = Symbol();
  var _stop = Symbol();
  function traverseFast$3(node, enter, opts) {
    if (!node) return false;
    var keys = VISITOR_KEYS$7[node.type];
    if (!keys) return false;
    opts = opts || {};
    var ret = enter(node, opts);
    if (ret !== undefined) {
      switch (ret) {
        case _skip:
          return false;
        case _stop:
          return true;
      }
    }
    for (var _iterator = _createForOfIteratorHelperLoose(keys), _step; !(_step = _iterator()).done;) {
      var key = _step.value;
      var subNode = node[key];
      if (!subNode) continue;
      if (Array.isArray(subNode)) {
        for (var _iterator2 = _createForOfIteratorHelperLoose(subNode), _step2; !(_step2 = _iterator2()).done;) {
          var _node = _step2.value;
          if (traverseFast$3(_node, enter, opts)) return true;
        }
      } else {
        if (traverseFast$3(subNode, enter, opts)) return true;
      }
    }
    return false;
  }
  traverseFast$3.skip = _skip;
  traverseFast$3.stop = _stop;

  var CLEAR_KEYS = ["tokens", "start", "end", "loc", "raw", "rawValue"];
  var CLEAR_KEYS_PLUS_COMMENTS = [].concat(_toConsumableArray(COMMENT_KEYS), ["comments"], CLEAR_KEYS);
  function removeProperties$1(node, opts) {
    if (opts === void 0) {
      opts = {};
    }
    var map = opts.preserveComments ? CLEAR_KEYS : CLEAR_KEYS_PLUS_COMMENTS;
    for (var _iterator = _createForOfIteratorHelperLoose(map), _step; !(_step = _iterator()).done;) {
      var _key = _step.value;
      if (node[_key] != null) node[_key] = undefined;
    }
    for (var _i = 0, _Object$keys = Object.keys(node); _i < _Object$keys.length; _i++) {
      var key = _Object$keys[_i];
      if (key[0] === "_" && node[key] != null) node[key] = undefined;
    }
    var symbols = Object.getOwnPropertySymbols(node);
    for (var _iterator2 = _createForOfIteratorHelperLoose(symbols), _step2; !(_step2 = _iterator2()).done;) {
      var sym = _step2.value;
      node[sym] = null;
    }
  }

  function removePropertiesDeep$1(tree, opts) {
    traverseFast$3(tree, removeProperties$1, opts);
    return tree;
  }

  function toKeyAlias(node, key) {
    if (key === void 0) {
      key = node.key;
    }
    var alias;
    if (node.kind === "method") {
      return toKeyAlias.increment() + "";
    } else if (isIdentifier$e(key)) {
      alias = key.name;
    } else if (isStringLiteral$5(key)) {
      alias = JSON.stringify(key.value);
    } else {
      alias = JSON.stringify(removePropertiesDeep$1(cloneNode$e(key)));
    }
    if (node.computed) {
      alias = "[" + alias + "]";
    }
    if (node["static"]) {
      alias = "static:" + alias;
    }
    return alias;
  }
  toKeyAlias.uid = 0;
  toKeyAlias.increment = function () {
    if (toKeyAlias.uid >= Number.MAX_SAFE_INTEGER) {
      return toKeyAlias.uid = 0;
    } else {
      return toKeyAlias.uid++;
    }
  };

  function toStatement(node, ignore) {
    if (isStatement$9(node)) {
      return node;
    }
    var mustHaveId = false;
    var newType;
    if (isClass$1(node)) {
      mustHaveId = true;
      newType = "ClassDeclaration";
    } else if (isFunction$6(node)) {
      mustHaveId = true;
      newType = "FunctionDeclaration";
    } else if (isAssignmentExpression$2(node)) {
      return expressionStatement$7(node);
    }
    if (mustHaveId && !node.id) {
      newType = false;
    }
    if (!newType) {
      if (ignore) {
        return false;
      } else {
        throw new Error("cannot turn " + node.type + " to a statement");
      }
    }
    node.type = newType;
    return node;
  }

  var objectToString$1 = Function.call.bind(Object.prototype.toString);
  function isRegExp$1(value) {
    return objectToString$1(value) === "[object RegExp]";
  }
  function isPlainObject(value) {
    if (typeof value !== "object" || value === null || Object.prototype.toString.call(value) !== "[object Object]") {
      return false;
    }
    var proto = Object.getPrototypeOf(value);
    return proto === null || Object.getPrototypeOf(proto) === null;
  }
  function valueToNode(value) {
    if (value === undefined) {
      return identifier$e("undefined");
    }
    if (value === true || value === false) {
      return booleanLiteral$2(value);
    }
    if (value === null) {
      return nullLiteral$2();
    }
    if (typeof value === "string") {
      return stringLiteral$6(value);
    }
    if (typeof value === "number") {
      var result;
      if (Number.isFinite(value)) {
        result = numericLiteral$5(Math.abs(value));
      } else {
        var numerator;
        if (Number.isNaN(value)) {
          numerator = numericLiteral$5(0);
        } else {
          numerator = numericLiteral$5(1);
        }
        result = binaryExpression$4("/", numerator, numericLiteral$5(0));
      }
      if (value < 0 || Object.is(value, -0)) {
        result = unaryExpression$4("-", result);
      }
      return result;
    }
    if (typeof value === "bigint") {
      if (value < 0) {
        return unaryExpression$4("-", bigIntLiteral(-value));
      } else {
        return bigIntLiteral(value);
      }
    }
    if (isRegExp$1(value)) {
      var pattern = value.source;
      var flags = /\/([a-z]*)$/.exec(value.toString())[1];
      return regExpLiteral(pattern, flags);
    }
    if (Array.isArray(value)) {
      return arrayExpression$1(value.map(valueToNode));
    }
    if (isPlainObject(value)) {
      var props = [];
      for (var _i = 0, _Object$keys = Object.keys(value); _i < _Object$keys.length; _i++) {
        var key = _Object$keys[_i];
        var nodeKey = void 0,
          computed = false;
        if (isValidIdentifier$1(key)) {
          if (key === "__proto__") {
            computed = true;
            nodeKey = stringLiteral$6(key);
          } else {
            nodeKey = identifier$e(key);
          }
        } else {
          nodeKey = stringLiteral$6(key);
        }
        props.push(objectProperty$1(nodeKey, valueToNode(value[key]), computed));
      }
      return objectExpression$3(props);
    }
    throw new Error("don't know how to turn this value into a node");
  }

  function appendToMemberExpression(member, append, computed) {
    if (computed === void 0) {
      computed = false;
    }
    member.object = memberExpression$a(member.object, member.property, member.computed);
    member.property = append;
    member.computed = !!computed;
    return member;
  }

  function inherits$3(child, parent) {
    if (!child || !parent) return child;
    for (var _iterator = _createForOfIteratorHelperLoose(INHERIT_KEYS.optional), _step; !(_step = _iterator()).done;) {
      var _key = _step.value;
      if (child[_key] == null) {
        child[_key] = parent[_key];
      }
    }
    for (var _i = 0, _Object$keys = Object.keys(parent); _i < _Object$keys.length; _i++) {
      var key = _Object$keys[_i];
      if (key[0] === "_" && key !== "__clone") {
        child[key] = parent[key];
      }
    }
    for (var _iterator2 = _createForOfIteratorHelperLoose(INHERIT_KEYS.force), _step2; !(_step2 = _iterator2()).done;) {
      var _key2 = _step2.value;
      child[_key2] = parent[_key2];
    }
    inheritsComments$1(child, parent);
    return child;
  }

  function prependToMemberExpression(member, prepend) {
    if (isSuper$2(member.object)) {
      throw new Error("Cannot prepend node to super property access (`super.foo`).");
    }
    member.object = memberExpression$a(prepend, member.object);
    return member;
  }

  function getAssignmentIdentifiers$2(node) {
    var search = [].concat(node);
    var ids = Object.create(null);
    while (search.length) {
      var id = search.pop();
      if (!id) continue;
      switch (id.type) {
        case "ArrayPattern":
          search.push.apply(search, _toConsumableArray(id.elements));
          break;
        case "AssignmentExpression":
        case "AssignmentPattern":
        case "ForInStatement":
        case "ForOfStatement":
          search.push(id.left);
          break;
        case "ObjectPattern":
          search.push.apply(search, _toConsumableArray(id.properties));
          break;
        case "ObjectProperty":
          search.push(id.value);
          break;
        case "RestElement":
        case "UpdateExpression":
          search.push(id.argument);
          break;
        case "UnaryExpression":
          if (id.operator === "delete") {
            search.push(id.argument);
          }
          break;
        case "Identifier":
          ids[id.name] = id;
          break;
      }
    }
    return ids;
  }

  function getBindingIdentifiers$4(node, duplicates, outerOnly, newBindingsOnly) {
    var search = [].concat(node);
    var ids = Object.create(null);
    while (search.length) {
      var id = search.shift();
      if (!id) continue;
      if (newBindingsOnly && (isAssignmentExpression$2(id) || isUnaryExpression$1(id) || isUpdateExpression$1(id))) {
        continue;
      }
      if (isIdentifier$e(id)) {
        if (duplicates) {
          var _ids = ids[id.name] = ids[id.name] || [];
          _ids.push(id);
        } else {
          ids[id.name] = id;
        }
        continue;
      }
      if (isExportDeclaration$2(id) && !isExportAllDeclaration$1(id)) {
        if (isDeclaration(id.declaration)) {
          search.push(id.declaration);
        }
        continue;
      }
      if (outerOnly) {
        if (isFunctionDeclaration$2(id)) {
          search.push(id.id);
          continue;
        }
        if (isFunctionExpression(id)) {
          continue;
        }
      }
      var _keys = getBindingIdentifiers$4.keys[id.type];
      if (_keys) {
        for (var i = 0; i < _keys.length; i++) {
          var key = _keys[i];
          var nodes = id[key];
          if (nodes) {
            if (Array.isArray(nodes)) {
              search.push.apply(search, _toConsumableArray(nodes));
            } else {
              search.push(nodes);
            }
          }
        }
      }
    }
    return ids;
  }
  var keys$1 = {
    DeclareClass: ["id"],
    DeclareFunction: ["id"],
    DeclareModule: ["id"],
    DeclareVariable: ["id"],
    DeclareInterface: ["id"],
    DeclareTypeAlias: ["id"],
    DeclareOpaqueType: ["id"],
    InterfaceDeclaration: ["id"],
    TypeAlias: ["id"],
    OpaqueType: ["id"],
    CatchClause: ["param"],
    LabeledStatement: ["label"],
    UnaryExpression: ["argument"],
    AssignmentExpression: ["left"],
    ImportSpecifier: ["local"],
    ImportNamespaceSpecifier: ["local"],
    ImportDefaultSpecifier: ["local"],
    ImportDeclaration: ["specifiers"],
    TSImportEqualsDeclaration: ["id"],
    ExportSpecifier: ["exported"],
    ExportNamespaceSpecifier: ["exported"],
    ExportDefaultSpecifier: ["exported"],
    FunctionDeclaration: ["id", "params"],
    FunctionExpression: ["id", "params"],
    ArrowFunctionExpression: ["params"],
    ObjectMethod: ["params"],
    ClassMethod: ["params"],
    ClassPrivateMethod: ["params"],
    ForInStatement: ["left"],
    ForOfStatement: ["left"],
    ClassDeclaration: ["id"],
    ClassExpression: ["id"],
    RestElement: ["argument"],
    UpdateExpression: ["argument"],
    ObjectProperty: ["value"],
    AssignmentPattern: ["left"],
    ArrayPattern: ["elements"],
    ObjectPattern: ["properties"],
    VariableDeclaration: ["declarations"],
    VariableDeclarator: ["id"]
  };
  getBindingIdentifiers$4.keys = keys$1;

  function getOuterBindingIdentifiers$1(node, duplicates) {
    return getBindingIdentifiers$4(node, duplicates, true);
  }

  function getNameFromLiteralId(id) {
    if (isNullLiteral$1(id)) {
      return "null";
    }
    if (isRegExpLiteral$1(id)) {
      return "/" + id.pattern + "/" + id.flags;
    }
    if (isTemplateLiteral$1(id)) {
      return id.quasis.map(function (quasi) {
        return quasi.value.raw;
      }).join("");
    }
    if (id.value !== undefined) {
      return String(id.value);
    }
    return null;
  }
  function getObjectMemberKey(node) {
    if (!node.computed || isLiteral$4(node.key)) {
      return node.key;
    }
  }
  function getFunctionName$1(node, parent) {
    if ("id" in node && node.id) {
      return {
        name: node.id.name,
        originalNode: node.id
      };
    }
    var prefix = "";
    var id;
    if (isObjectProperty$2(parent, {
      value: node
    })) {
      id = getObjectMemberKey(parent);
    } else if (isObjectMethod(node) || isClassMethod(node)) {
      id = getObjectMemberKey(node);
      if (node.kind === "get") prefix = "get ";else if (node.kind === "set") prefix = "set ";
    } else if (isVariableDeclarator(parent, {
      init: node
    })) {
      id = parent.id;
    } else if (isAssignmentExpression$2(parent, {
      operator: "=",
      right: node
    })) {
      id = parent.left;
    }
    if (!id) return null;
    var name = isLiteral$4(id) ? getNameFromLiteralId(id) : isIdentifier$e(id) ? id.name : isPrivateName$2(id) ? id.id.name : null;
    if (name == null) return null;
    return {
      name: prefix + name,
      originalNode: id
    };
  }

  function traverse$2(node, handlers, state) {
    if (typeof handlers === "function") {
      handlers = {
        enter: handlers
      };
    }
    var _handlers = handlers,
      enter = _handlers.enter,
      exit = _handlers.exit;
    traverseSimpleImpl(node, enter, exit, state, []);
  }
  function traverseSimpleImpl(node, enter, exit, state, ancestors) {
    var keys = VISITOR_KEYS$7[node.type];
    if (!keys) return;
    if (enter) enter(node, ancestors, state);
    for (var _iterator = _createForOfIteratorHelperLoose(keys), _step; !(_step = _iterator()).done;) {
      var key = _step.value;
      var subNode = node[key];
      if (Array.isArray(subNode)) {
        for (var i = 0; i < subNode.length; i++) {
          var child = subNode[i];
          if (!child) continue;
          ancestors.push({
            node: node,
            key: key,
            index: i
          });
          traverseSimpleImpl(child, enter, exit, state, ancestors);
          ancestors.pop();
        }
      } else if (subNode) {
        ancestors.push({
          node: node,
          key: key
        });
        traverseSimpleImpl(subNode, enter, exit, state, ancestors);
        ancestors.pop();
      }
    }
    if (exit) exit(node, ancestors, state);
  }

  function isBinding$1(node, parent, grandparent) {
    if (grandparent && node.type === "Identifier" && parent.type === "ObjectProperty" && grandparent.type === "ObjectExpression") {
      return false;
    }
    var keys = getBindingIdentifiers$4.keys[parent.type];
    if (keys) {
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        var val = parent[key];
        if (Array.isArray(val)) {
          if (val.includes(node)) return true;
        } else {
          if (val === node) return true;
        }
      }
    }
    return false;
  }

  {
    var BLOCK_SCOPED_SYMBOL$1 = Symbol["for"]("var used to be block scoped");
  }
  function isLet(node) {
    {
      return isVariableDeclaration$3(node) && (node.kind !== "var" || node[BLOCK_SCOPED_SYMBOL$1]);
    }
  }

  function isBlockScoped$2(node) {
    return isFunctionDeclaration$2(node) || isClassDeclaration$2(node) || isLet(node);
  }

  function isImmutable(node) {
    if (isType$2(node.type, "Immutable")) return true;
    if (isIdentifier$e(node)) {
      if (node.name === "undefined") {
        return true;
      } else {
        return false;
      }
    }
    return false;
  }

  function isNodesEquivalent(a, b) {
    if (typeof a !== "object" || typeof b !== "object" || a == null || b == null) {
      return a === b;
    }
    if (a.type !== b.type) {
      return false;
    }
    var fields = Object.keys(NODE_FIELDS$1[a.type] || a.type);
    var visitorKeys = VISITOR_KEYS$7[a.type];
    for (var _i = 0, _fields = fields; _i < _fields.length; _i++) {
      var field = _fields[_i];
      var val_a = a[field];
      var val_b = b[field];
      if (typeof val_a !== typeof val_b) {
        return false;
      }
      if (val_a == null && val_b == null) {
        continue;
      } else if (val_a == null || val_b == null) {
        return false;
      }
      if (Array.isArray(val_a)) {
        if (!Array.isArray(val_b)) {
          return false;
        }
        if (val_a.length !== val_b.length) {
          return false;
        }
        for (var i = 0; i < val_a.length; i++) {
          if (!isNodesEquivalent(val_a[i], val_b[i])) {
            return false;
          }
        }
        continue;
      }
      if (typeof val_a === "object" && !(visitorKeys != null && visitorKeys.includes(field))) {
        for (var _i2 = 0, _Object$keys = Object.keys(val_a); _i2 < _Object$keys.length; _i2++) {
          var key = _Object$keys[_i2];
          if (val_a[key] !== val_b[key]) {
            return false;
          }
        }
        continue;
      }
      if (!isNodesEquivalent(val_a, val_b)) {
        return false;
      }
    }
    return true;
  }

  function isReferenced$2(node, parent, grandparent) {
    switch (parent.type) {
      case "MemberExpression":
      case "OptionalMemberExpression":
        if (parent.property === node) {
          return !!parent.computed;
        }
        return parent.object === node;
      case "JSXMemberExpression":
        return parent.object === node;
      case "VariableDeclarator":
        return parent.init === node;
      case "ArrowFunctionExpression":
        return parent.body === node;
      case "PrivateName":
        return false;
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "ObjectMethod":
        if (parent.key === node) {
          return !!parent.computed;
        }
        return false;
      case "ObjectProperty":
        if (parent.key === node) {
          return !!parent.computed;
        }
        return !grandparent || grandparent.type !== "ObjectPattern";
      case "ClassProperty":
      case "ClassAccessorProperty":
        if (parent.key === node) {
          return !!parent.computed;
        }
        return true;
      case "ClassPrivateProperty":
        return parent.key !== node;
      case "ClassDeclaration":
      case "ClassExpression":
        return parent.superClass === node;
      case "AssignmentExpression":
        return parent.right === node;
      case "AssignmentPattern":
        return parent.right === node;
      case "LabeledStatement":
        return false;
      case "CatchClause":
        return false;
      case "RestElement":
        return false;
      case "BreakStatement":
      case "ContinueStatement":
        return false;
      case "FunctionDeclaration":
      case "FunctionExpression":
        return false;
      case "ExportNamespaceSpecifier":
      case "ExportDefaultSpecifier":
        return false;
      case "ExportSpecifier":
        if (grandparent != null && grandparent.source) {
          return false;
        }
        return parent.local === node;
      case "ImportDefaultSpecifier":
      case "ImportNamespaceSpecifier":
      case "ImportSpecifier":
        return false;
      case "ImportAttribute":
        return false;
      case "JSXAttribute":
        return false;
      case "ObjectPattern":
      case "ArrayPattern":
        return false;
      case "MetaProperty":
        return false;
      case "ObjectTypeProperty":
        return parent.key !== node;
      case "TSEnumMember":
        return parent.id !== node;
      case "TSPropertySignature":
        if (parent.key === node) {
          return !!parent.computed;
        }
        return true;
    }
    return true;
  }

  function isScope$1(node, parent) {
    if (isBlockStatement$3(node) && (isFunction$6(parent) || isCatchClause(parent))) {
      return false;
    }
    if (isPattern$2(node) && (isFunction$6(parent) || isCatchClause(parent))) {
      return true;
    }
    return isScopable(node);
  }

  function isSpecifierDefault(specifier) {
    return isImportDefaultSpecifier$1(specifier) || isIdentifier$e(specifier.imported || specifier.exported, {
      name: "default"
    });
  }

  var RESERVED_WORDS_ES3_ONLY = new Set(["abstract", "boolean", "byte", "char", "double", "enum", "final", "float", "goto", "implements", "int", "interface", "long", "native", "package", "private", "protected", "public", "short", "static", "synchronized", "throws", "transient", "volatile"]);
  function isValidES3Identifier(name) {
    return isValidIdentifier$1(name) && !RESERVED_WORDS_ES3_ONLY.has(name);
  }

  {
    var BLOCK_SCOPED_SYMBOL = Symbol["for"]("var used to be block scoped");
  }
  function isVar$1(node) {
    {
      return isVariableDeclaration$3(node, {
        kind: "var"
      }) && !node[BLOCK_SCOPED_SYMBOL];
    }
  }

  var react$3 = {
    isReactComponent: isReactComponent,
    isCompatTag: isCompatTag$1,
    buildChildren: buildChildren
  };
  if (browser$1$1.env.BABEL_TYPES_8_BREAKING) {
    console.warn("BABEL_TYPES_8_BREAKING is not supported anymore. Use the latest Babel 8.0.0 pre-release instead!");
  }

  var t$4 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ACCESSOR_TYPES: ACCESSOR_TYPES,
    ALIAS_KEYS: ALIAS_KEYS,
    ASSIGNMENT_OPERATORS: ASSIGNMENT_OPERATORS,
    AnyTypeAnnotation: AnyTypeAnnotation$1,
    ArgumentPlaceholder: ArgumentPlaceholder$1,
    ArrayExpression: ArrayExpression$2,
    ArrayPattern: ArrayPattern,
    ArrayTypeAnnotation: ArrayTypeAnnotation$1,
    ArrowFunctionExpression: ArrowFunctionExpression$1,
    AssignmentExpression: AssignmentExpression$3,
    AssignmentPattern: AssignmentPattern$1,
    AwaitExpression: AwaitExpression$1,
    BINARY_OPERATORS: BINARY_OPERATORS,
    BINARY_TYPES: BINARY_TYPES,
    BLOCKPARENT_TYPES: BLOCKPARENT_TYPES,
    BLOCK_TYPES: BLOCK_TYPES,
    BOOLEAN_BINARY_OPERATORS: BOOLEAN_BINARY_OPERATORS$1,
    BOOLEAN_NUMBER_BINARY_OPERATORS: BOOLEAN_NUMBER_BINARY_OPERATORS$1,
    BOOLEAN_UNARY_OPERATORS: BOOLEAN_UNARY_OPERATORS$1,
    BUILDER_KEYS: BUILDER_KEYS,
    BigIntLiteral: BigIntLiteral$1,
    BinaryExpression: BinaryExpression$2,
    BindExpression: BindExpression$1,
    BlockStatement: BlockStatement$1,
    BooleanLiteral: BooleanLiteral$2,
    BooleanLiteralTypeAnnotation: BooleanLiteralTypeAnnotation$1,
    BooleanTypeAnnotation: BooleanTypeAnnotation$1,
    BreakStatement: BreakStatement$1,
    CLASS_TYPES: CLASS_TYPES,
    COMMENT_KEYS: COMMENT_KEYS,
    COMPARISON_BINARY_OPERATORS: COMPARISON_BINARY_OPERATORS,
    COMPLETIONSTATEMENT_TYPES: COMPLETIONSTATEMENT_TYPES,
    CONDITIONAL_TYPES: CONDITIONAL_TYPES,
    CallExpression: CallExpression$2,
    CatchClause: CatchClause$1,
    ClassAccessorProperty: ClassAccessorProperty$1,
    ClassBody: ClassBody$1,
    ClassDeclaration: ClassDeclaration$1,
    ClassExpression: ClassExpression$1,
    ClassImplements: ClassImplements,
    ClassMethod: ClassMethod$1,
    ClassPrivateMethod: ClassPrivateMethod$1,
    ClassPrivateProperty: ClassPrivateProperty$1,
    ClassProperty: ClassProperty$1,
    ConditionalExpression: ConditionalExpression$3,
    ContinueStatement: ContinueStatement$1,
    DECLARATION_TYPES: DECLARATION_TYPES,
    DEPRECATED_ALIASES: DEPRECATED_ALIASES$1,
    DEPRECATED_KEYS: DEPRECATED_KEYS$1,
    DebuggerStatement: DebuggerStatement$1,
    DecimalLiteral: DecimalLiteral,
    DeclareClass: DeclareClass$1,
    DeclareExportAllDeclaration: DeclareExportAllDeclaration$1,
    DeclareExportDeclaration: DeclareExportDeclaration$1,
    DeclareFunction: DeclareFunction$1,
    DeclareInterface: DeclareInterface$1,
    DeclareModule: DeclareModule$1,
    DeclareModuleExports: DeclareModuleExports$1,
    DeclareOpaqueType: DeclareOpaqueType$1,
    DeclareTypeAlias: DeclareTypeAlias$1,
    DeclareVariable: DeclareVariable$1,
    DeclaredPredicate: DeclaredPredicate$1,
    Decorator: Decorator$1,
    Directive: Directive$1,
    DirectiveLiteral: DirectiveLiteral$1,
    DoExpression: DoExpression$2,
    DoWhileStatement: DoWhileStatement$1,
    ENUMBODY_TYPES: ENUMBODY_TYPES,
    ENUMMEMBER_TYPES: ENUMMEMBER_TYPES,
    EQUALITY_BINARY_OPERATORS: EQUALITY_BINARY_OPERATORS,
    EXPORTDECLARATION_TYPES: EXPORTDECLARATION_TYPES,
    EXPRESSIONWRAPPER_TYPES: EXPRESSIONWRAPPER_TYPES,
    EXPRESSION_TYPES: EXPRESSION_TYPES,
    EmptyStatement: EmptyStatement$1,
    EmptyTypeAnnotation: EmptyTypeAnnotation$1,
    EnumBooleanBody: EnumBooleanBody$1,
    EnumBooleanMember: EnumBooleanMember$1,
    EnumDeclaration: EnumDeclaration$1,
    EnumDefaultedMember: EnumDefaultedMember$1,
    EnumNumberBody: EnumNumberBody$1,
    EnumNumberMember: EnumNumberMember$1,
    EnumStringBody: EnumStringBody$1,
    EnumStringMember: EnumStringMember$1,
    EnumSymbolBody: EnumSymbolBody$1,
    ExistsTypeAnnotation: ExistsTypeAnnotation$1,
    ExportAllDeclaration: ExportAllDeclaration$1,
    ExportDefaultDeclaration: ExportDefaultDeclaration$1,
    ExportDefaultSpecifier: ExportDefaultSpecifier$1,
    ExportNamedDeclaration: ExportNamedDeclaration$1,
    ExportNamespaceSpecifier: ExportNamespaceSpecifier$1,
    ExportSpecifier: ExportSpecifier$1,
    ExpressionStatement: ExpressionStatement$1,
    FLATTENABLE_KEYS: FLATTENABLE_KEYS,
    FLIPPED_ALIAS_KEYS: FLIPPED_ALIAS_KEYS$3,
    FLOWBASEANNOTATION_TYPES: FLOWBASEANNOTATION_TYPES,
    FLOWDECLARATION_TYPES: FLOWDECLARATION_TYPES,
    FLOWPREDICATE_TYPES: FLOWPREDICATE_TYPES,
    FLOWTYPE_TYPES: FLOWTYPE_TYPES,
    FLOW_TYPES: FLOW_TYPES,
    FORXSTATEMENT_TYPES: FORXSTATEMENT_TYPES,
    FOR_INIT_KEYS: FOR_INIT_KEYS,
    FOR_TYPES: FOR_TYPES,
    FUNCTIONPARAMETER_TYPES: FUNCTIONPARAMETER_TYPES,
    FUNCTIONPARENT_TYPES: FUNCTIONPARENT_TYPES,
    FUNCTION_TYPES: FUNCTION_TYPES$1,
    File: File$2,
    ForInStatement: ForInStatement$1,
    ForOfStatement: ForOfStatement$1,
    ForStatement: ForStatement$1,
    FunctionDeclaration: FunctionDeclaration,
    FunctionExpression: FunctionExpression$2,
    FunctionTypeAnnotation: FunctionTypeAnnotation$2,
    FunctionTypeParam: FunctionTypeParam$1,
    GenericTypeAnnotation: GenericTypeAnnotation,
    IMMUTABLE_TYPES: IMMUTABLE_TYPES,
    IMPORTOREXPORTDECLARATION_TYPES: IMPORTOREXPORTDECLARATION_TYPES,
    INHERIT_KEYS: INHERIT_KEYS,
    Identifier: Identifier$2,
    IfStatement: IfStatement$1,
    Import: Import$1,
    ImportAttribute: ImportAttribute$1,
    ImportDeclaration: ImportDeclaration$1,
    ImportDefaultSpecifier: ImportDefaultSpecifier$1,
    ImportExpression: ImportExpression$1,
    ImportNamespaceSpecifier: ImportNamespaceSpecifier$1,
    ImportSpecifier: ImportSpecifier$1,
    IndexedAccessType: IndexedAccessType$1,
    InferredPredicate: InferredPredicate$1,
    InterfaceDeclaration: InterfaceDeclaration$1,
    InterfaceExtends: InterfaceExtends$1,
    InterfaceTypeAnnotation: InterfaceTypeAnnotation$1,
    InterpreterDirective: InterpreterDirective$1,
    IntersectionTypeAnnotation: IntersectionTypeAnnotation$1,
    JSXAttribute: JSXAttribute$1,
    JSXClosingElement: JSXClosingElement$1,
    JSXClosingFragment: JSXClosingFragment$1,
    JSXElement: JSXElement$1,
    JSXEmptyExpression: JSXEmptyExpression$1,
    JSXExpressionContainer: JSXExpressionContainer$1,
    JSXFragment: JSXFragment$1,
    JSXIdentifier: JSXIdentifier$1,
    JSXMemberExpression: JSXMemberExpression$1,
    JSXNamespacedName: JSXNamespacedName$1,
    JSXOpeningElement: JSXOpeningElement$1,
    JSXOpeningFragment: JSXOpeningFragment$1,
    JSXSpreadAttribute: JSXSpreadAttribute$1,
    JSXSpreadChild: JSXSpreadChild$1,
    JSXText: JSXText$1,
    JSX_TYPES: JSX_TYPES,
    LITERAL_TYPES: LITERAL_TYPES,
    LOGICAL_OPERATORS: LOGICAL_OPERATORS$2,
    LOOP_TYPES: LOOP_TYPES,
    LVAL_TYPES: LVAL_TYPES,
    LabeledStatement: LabeledStatement$1,
    LogicalExpression: LogicalExpression$2,
    METHOD_TYPES: METHOD_TYPES,
    MISCELLANEOUS_TYPES: MISCELLANEOUS_TYPES,
    MODULEDECLARATION_TYPES: MODULEDECLARATION_TYPES,
    MODULESPECIFIER_TYPES: MODULESPECIFIER_TYPES,
    MemberExpression: MemberExpression$1,
    MetaProperty: MetaProperty$1,
    MixedTypeAnnotation: MixedTypeAnnotation$1,
    ModuleExpression: ModuleExpression$1,
    NODE_FIELDS: NODE_FIELDS$1,
    NODE_PARENT_VALIDATIONS: NODE_PARENT_VALIDATIONS,
    NUMBER_BINARY_OPERATORS: NUMBER_BINARY_OPERATORS$1,
    NUMBER_UNARY_OPERATORS: NUMBER_UNARY_OPERATORS$1,
    NewExpression: NewExpression$2,
    Noop: Noop,
    NullLiteral: NullLiteral$2,
    NullLiteralTypeAnnotation: NullLiteralTypeAnnotation$1,
    NullableTypeAnnotation: NullableTypeAnnotation$2,
    NumberLiteral: NumberLiteral,
    NumberLiteralTypeAnnotation: NumberLiteralTypeAnnotation,
    NumberTypeAnnotation: NumberTypeAnnotation$1,
    NumericLiteral: NumericLiteral$2,
    OBJECTMEMBER_TYPES: OBJECTMEMBER_TYPES,
    ObjectExpression: ObjectExpression$3,
    ObjectMethod: ObjectMethod$1,
    ObjectPattern: ObjectPattern,
    ObjectProperty: ObjectProperty$1,
    ObjectTypeAnnotation: ObjectTypeAnnotation$1,
    ObjectTypeCallProperty: ObjectTypeCallProperty$1,
    ObjectTypeIndexer: ObjectTypeIndexer$1,
    ObjectTypeInternalSlot: ObjectTypeInternalSlot$1,
    ObjectTypeProperty: ObjectTypeProperty$1,
    ObjectTypeSpreadProperty: ObjectTypeSpreadProperty$1,
    OpaqueType: OpaqueType$1,
    OptionalCallExpression: OptionalCallExpression$1,
    OptionalIndexedAccessType: OptionalIndexedAccessType$2,
    OptionalMemberExpression: OptionalMemberExpression$2,
    PATTERNLIKE_TYPES: PATTERNLIKE_TYPES,
    PATTERN_TYPES: PATTERN_TYPES,
    PLACEHOLDERS: PLACEHOLDERS,
    PLACEHOLDERS_ALIAS: PLACEHOLDERS_ALIAS,
    PLACEHOLDERS_FLIPPED_ALIAS: PLACEHOLDERS_FLIPPED_ALIAS,
    PRIVATE_TYPES: PRIVATE_TYPES,
    PROPERTY_TYPES: PROPERTY_TYPES,
    PUREISH_TYPES: PUREISH_TYPES,
    ParenthesizedExpression: ParenthesizedExpression$2,
    PipelineBareFunction: PipelineBareFunction$1,
    PipelinePrimaryTopicReference: PipelinePrimaryTopicReference$1,
    PipelineTopicExpression: PipelineTopicExpression$1,
    Placeholder: Placeholder$1,
    PrivateName: PrivateName$1,
    Program: Program$1,
    QualifiedTypeIdentifier: QualifiedTypeIdentifier$1,
    RecordExpression: RecordExpression$1,
    RegExpLiteral: RegExpLiteral$2,
    RegexLiteral: RegexLiteral,
    RestElement: RestElement$2,
    RestProperty: RestProperty$1,
    ReturnStatement: ReturnStatement$1,
    SCOPABLE_TYPES: SCOPABLE_TYPES,
    STANDARDIZED_TYPES: STANDARDIZED_TYPES,
    STATEMENT_OR_BLOCK_KEYS: STATEMENT_OR_BLOCK_KEYS$1,
    STATEMENT_TYPES: STATEMENT_TYPES,
    STRING_UNARY_OPERATORS: STRING_UNARY_OPERATORS$1,
    SequenceExpression: SequenceExpression$3,
    SpreadElement: SpreadElement,
    SpreadProperty: SpreadProperty$1,
    StaticBlock: StaticBlock$1,
    StringLiteral: StringLiteral$2,
    StringLiteralTypeAnnotation: StringLiteralTypeAnnotation,
    StringTypeAnnotation: StringTypeAnnotation$1,
    Super: Super$1,
    SwitchCase: SwitchCase$1,
    SwitchStatement: SwitchStatement$1,
    SymbolTypeAnnotation: SymbolTypeAnnotation$1,
    TERMINATORLESS_TYPES: TERMINATORLESS_TYPES,
    TSAnyKeyword: TSAnyKeyword$1,
    TSArrayType: TSArrayType$1,
    TSAsExpression: TSAsExpression$2,
    TSBASETYPE_TYPES: TSBASETYPE_TYPES,
    TSBigIntKeyword: TSBigIntKeyword$1,
    TSBooleanKeyword: TSBooleanKeyword$1,
    TSCallSignatureDeclaration: TSCallSignatureDeclaration$1,
    TSConditionalType: TSConditionalType$2,
    TSConstructSignatureDeclaration: TSConstructSignatureDeclaration$1,
    TSConstructorType: TSConstructorType$1,
    TSDeclareFunction: TSDeclareFunction$1,
    TSDeclareMethod: TSDeclareMethod$1,
    TSENTITYNAME_TYPES: TSENTITYNAME_TYPES,
    TSEnumBody: TSEnumBody$1,
    TSEnumDeclaration: TSEnumDeclaration$1,
    TSEnumMember: TSEnumMember$1,
    TSExportAssignment: TSExportAssignment$1,
    TSExpressionWithTypeArguments: TSExpressionWithTypeArguments,
    TSExternalModuleReference: TSExternalModuleReference$1,
    TSFunctionType: TSFunctionType$2,
    TSImportEqualsDeclaration: TSImportEqualsDeclaration$1,
    TSImportType: TSImportType$1,
    TSIndexSignature: TSIndexSignature$1,
    TSIndexedAccessType: TSIndexedAccessType$1,
    TSInferType: TSInferType$2,
    TSInstantiationExpression: TSInstantiationExpression$2,
    TSInterfaceBody: TSInterfaceBody$1,
    TSInterfaceDeclaration: TSInterfaceDeclaration$1,
    TSIntersectionType: TSIntersectionType$2,
    TSIntrinsicKeyword: TSIntrinsicKeyword$1,
    TSLiteralType: TSLiteralType$1,
    TSMappedType: TSMappedType$1,
    TSMethodSignature: TSMethodSignature$1,
    TSModuleBlock: TSModuleBlock$1,
    TSModuleDeclaration: TSModuleDeclaration$1,
    TSNamedTupleMember: TSNamedTupleMember$1,
    TSNamespaceExportDeclaration: TSNamespaceExportDeclaration$1,
    TSNeverKeyword: TSNeverKeyword$1,
    TSNonNullExpression: TSNonNullExpression$2,
    TSNullKeyword: TSNullKeyword$1,
    TSNumberKeyword: TSNumberKeyword$1,
    TSObjectKeyword: TSObjectKeyword$1,
    TSOptionalType: TSOptionalType$1,
    TSParameterProperty: TSParameterProperty$1,
    TSParenthesizedType: TSParenthesizedType$1,
    TSPropertySignature: TSPropertySignature$1,
    TSQualifiedName: TSQualifiedName$1,
    TSRestType: TSRestType$1,
    TSSatisfiesExpression: TSSatisfiesExpression,
    TSStringKeyword: TSStringKeyword$1,
    TSSymbolKeyword: TSSymbolKeyword$1,
    TSTYPEELEMENT_TYPES: TSTYPEELEMENT_TYPES,
    TSTYPE_TYPES: TSTYPE_TYPES,
    TSTemplateLiteralType: TSTemplateLiteralType$1,
    TSThisType: TSThisType$1,
    TSTupleType: TSTupleType$1,
    TSTypeAliasDeclaration: TSTypeAliasDeclaration$1,
    TSTypeAnnotation: TSTypeAnnotation$1,
    TSTypeAssertion: TSTypeAssertion$1,
    TSTypeLiteral: TSTypeLiteral$1,
    TSTypeOperator: TSTypeOperator$2,
    TSTypeParameter: TSTypeParameter$1,
    TSTypeParameterDeclaration: TSTypeParameterDeclaration,
    TSTypeParameterInstantiation: TSTypeParameterInstantiation$1,
    TSTypePredicate: TSTypePredicate$1,
    TSTypeQuery: TSTypeQuery$1,
    TSTypeReference: TSTypeReference$1,
    TSUndefinedKeyword: TSUndefinedKeyword$1,
    TSUnionType: TSUnionType$2,
    TSUnknownKeyword: TSUnknownKeyword$1,
    TSVoidKeyword: TSVoidKeyword$1,
    TYPES: TYPES$1,
    TYPESCRIPT_TYPES: TYPESCRIPT_TYPES,
    TaggedTemplateExpression: TaggedTemplateExpression$2,
    TemplateElement: TemplateElement$1,
    TemplateLiteral: TemplateLiteral$2,
    ThisExpression: ThisExpression$1,
    ThisTypeAnnotation: ThisTypeAnnotation$1,
    ThrowStatement: ThrowStatement$1,
    TopicReference: TopicReference$1,
    TryStatement: TryStatement$1,
    TupleExpression: TupleExpression$1,
    TupleTypeAnnotation: TupleTypeAnnotation$1,
    TypeAlias: TypeAlias$1,
    TypeAnnotation: TypeAnnotation$1,
    TypeCastExpression: TypeCastExpression$2,
    TypeParameter: TypeParameter$1,
    TypeParameterDeclaration: TypeParameterDeclaration,
    TypeParameterInstantiation: TypeParameterInstantiation$1,
    TypeofTypeAnnotation: TypeofTypeAnnotation$1,
    UNARYLIKE_TYPES: UNARYLIKE_TYPES,
    UNARY_OPERATORS: UNARY_OPERATORS,
    UPDATE_OPERATORS: UPDATE_OPERATORS,
    USERWHITESPACABLE_TYPES: USERWHITESPACABLE_TYPES,
    UnaryExpression: UnaryExpression$2,
    UnionTypeAnnotation: UnionTypeAnnotation$2,
    UpdateExpression: UpdateExpression$3,
    V8IntrinsicIdentifier: V8IntrinsicIdentifier$1,
    VISITOR_KEYS: VISITOR_KEYS$7,
    VariableDeclaration: VariableDeclaration$1,
    VariableDeclarator: VariableDeclarator$2,
    Variance: Variance$1,
    VoidPattern: VoidPattern$1,
    VoidTypeAnnotation: VoidTypeAnnotation$1,
    WHILE_TYPES: WHILE_TYPES,
    WhileStatement: WhileStatement$1,
    WithStatement: WithStatement$1,
    YieldExpression: YieldExpression$2,
    __internal__deprecationWarning: deprecationWarning$1,
    addComment: addComment$2,
    addComments: addComments$1,
    anyTypeAnnotation: anyTypeAnnotation$2,
    appendToMemberExpression: appendToMemberExpression,
    argumentPlaceholder: argumentPlaceholder,
    arrayExpression: arrayExpression$1,
    arrayPattern: arrayPattern,
    arrayTypeAnnotation: arrayTypeAnnotation$1,
    arrowFunctionExpression: arrowFunctionExpression$4,
    assertAccessor: assertAccessor,
    assertAnyTypeAnnotation: assertAnyTypeAnnotation,
    assertArgumentPlaceholder: assertArgumentPlaceholder,
    assertArrayExpression: assertArrayExpression,
    assertArrayPattern: assertArrayPattern,
    assertArrayTypeAnnotation: assertArrayTypeAnnotation,
    assertArrowFunctionExpression: assertArrowFunctionExpression,
    assertAssignmentExpression: assertAssignmentExpression,
    assertAssignmentPattern: assertAssignmentPattern,
    assertAwaitExpression: assertAwaitExpression,
    assertBigIntLiteral: assertBigIntLiteral,
    assertBinary: assertBinary,
    assertBinaryExpression: assertBinaryExpression,
    assertBindExpression: assertBindExpression,
    assertBlock: assertBlock,
    assertBlockParent: assertBlockParent,
    assertBlockStatement: assertBlockStatement,
    assertBooleanLiteral: assertBooleanLiteral,
    assertBooleanLiteralTypeAnnotation: assertBooleanLiteralTypeAnnotation,
    assertBooleanTypeAnnotation: assertBooleanTypeAnnotation,
    assertBreakStatement: assertBreakStatement,
    assertCallExpression: assertCallExpression,
    assertCatchClause: assertCatchClause,
    assertClass: assertClass,
    assertClassAccessorProperty: assertClassAccessorProperty,
    assertClassBody: assertClassBody,
    assertClassDeclaration: assertClassDeclaration,
    assertClassExpression: assertClassExpression,
    assertClassImplements: assertClassImplements,
    assertClassMethod: assertClassMethod,
    assertClassPrivateMethod: assertClassPrivateMethod,
    assertClassPrivateProperty: assertClassPrivateProperty,
    assertClassProperty: assertClassProperty,
    assertCompletionStatement: assertCompletionStatement,
    assertConditional: assertConditional,
    assertConditionalExpression: assertConditionalExpression,
    assertContinueStatement: assertContinueStatement,
    assertDebuggerStatement: assertDebuggerStatement,
    assertDecimalLiteral: assertDecimalLiteral,
    assertDeclaration: assertDeclaration,
    assertDeclareClass: assertDeclareClass,
    assertDeclareExportAllDeclaration: assertDeclareExportAllDeclaration,
    assertDeclareExportDeclaration: assertDeclareExportDeclaration,
    assertDeclareFunction: assertDeclareFunction,
    assertDeclareInterface: assertDeclareInterface,
    assertDeclareModule: assertDeclareModule,
    assertDeclareModuleExports: assertDeclareModuleExports,
    assertDeclareOpaqueType: assertDeclareOpaqueType,
    assertDeclareTypeAlias: assertDeclareTypeAlias,
    assertDeclareVariable: assertDeclareVariable,
    assertDeclaredPredicate: assertDeclaredPredicate,
    assertDecorator: assertDecorator,
    assertDirective: assertDirective,
    assertDirectiveLiteral: assertDirectiveLiteral,
    assertDoExpression: assertDoExpression,
    assertDoWhileStatement: assertDoWhileStatement,
    assertEmptyStatement: assertEmptyStatement,
    assertEmptyTypeAnnotation: assertEmptyTypeAnnotation,
    assertEnumBody: assertEnumBody,
    assertEnumBooleanBody: assertEnumBooleanBody,
    assertEnumBooleanMember: assertEnumBooleanMember,
    assertEnumDeclaration: assertEnumDeclaration,
    assertEnumDefaultedMember: assertEnumDefaultedMember,
    assertEnumMember: assertEnumMember,
    assertEnumNumberBody: assertEnumNumberBody,
    assertEnumNumberMember: assertEnumNumberMember,
    assertEnumStringBody: assertEnumStringBody,
    assertEnumStringMember: assertEnumStringMember,
    assertEnumSymbolBody: assertEnumSymbolBody,
    assertExistsTypeAnnotation: assertExistsTypeAnnotation,
    assertExportAllDeclaration: assertExportAllDeclaration,
    assertExportDeclaration: assertExportDeclaration,
    assertExportDefaultDeclaration: assertExportDefaultDeclaration,
    assertExportDefaultSpecifier: assertExportDefaultSpecifier,
    assertExportNamedDeclaration: assertExportNamedDeclaration,
    assertExportNamespaceSpecifier: assertExportNamespaceSpecifier,
    assertExportSpecifier: assertExportSpecifier$1,
    assertExpression: assertExpression$1,
    assertExpressionStatement: assertExpressionStatement$1,
    assertExpressionWrapper: assertExpressionWrapper,
    assertFile: assertFile,
    assertFlow: assertFlow,
    assertFlowBaseAnnotation: assertFlowBaseAnnotation,
    assertFlowDeclaration: assertFlowDeclaration,
    assertFlowPredicate: assertFlowPredicate,
    assertFlowType: assertFlowType,
    assertFor: assertFor,
    assertForInStatement: assertForInStatement,
    assertForOfStatement: assertForOfStatement,
    assertForStatement: assertForStatement,
    assertForXStatement: assertForXStatement,
    assertFunction: assertFunction$1,
    assertFunctionDeclaration: assertFunctionDeclaration,
    assertFunctionExpression: assertFunctionExpression,
    assertFunctionParameter: assertFunctionParameter,
    assertFunctionParent: assertFunctionParent,
    assertFunctionTypeAnnotation: assertFunctionTypeAnnotation,
    assertFunctionTypeParam: assertFunctionTypeParam,
    assertGenericTypeAnnotation: assertGenericTypeAnnotation,
    assertIdentifier: assertIdentifier,
    assertIfStatement: assertIfStatement,
    assertImmutable: assertImmutable,
    assertImport: assertImport,
    assertImportAttribute: assertImportAttribute,
    assertImportDeclaration: assertImportDeclaration,
    assertImportDefaultSpecifier: assertImportDefaultSpecifier,
    assertImportExpression: assertImportExpression,
    assertImportNamespaceSpecifier: assertImportNamespaceSpecifier,
    assertImportOrExportDeclaration: assertImportOrExportDeclaration,
    assertImportSpecifier: assertImportSpecifier,
    assertIndexedAccessType: assertIndexedAccessType,
    assertInferredPredicate: assertInferredPredicate,
    assertInterfaceDeclaration: assertInterfaceDeclaration,
    assertInterfaceExtends: assertInterfaceExtends,
    assertInterfaceTypeAnnotation: assertInterfaceTypeAnnotation,
    assertInterpreterDirective: assertInterpreterDirective,
    assertIntersectionTypeAnnotation: assertIntersectionTypeAnnotation,
    assertJSX: assertJSX,
    assertJSXAttribute: assertJSXAttribute,
    assertJSXClosingElement: assertJSXClosingElement,
    assertJSXClosingFragment: assertJSXClosingFragment,
    assertJSXElement: assertJSXElement,
    assertJSXEmptyExpression: assertJSXEmptyExpression,
    assertJSXExpressionContainer: assertJSXExpressionContainer,
    assertJSXFragment: assertJSXFragment,
    assertJSXIdentifier: assertJSXIdentifier,
    assertJSXMemberExpression: assertJSXMemberExpression,
    assertJSXNamespacedName: assertJSXNamespacedName,
    assertJSXOpeningElement: assertJSXOpeningElement,
    assertJSXOpeningFragment: assertJSXOpeningFragment,
    assertJSXSpreadAttribute: assertJSXSpreadAttribute,
    assertJSXSpreadChild: assertJSXSpreadChild,
    assertJSXText: assertJSXText,
    assertLVal: assertLVal,
    assertLabeledStatement: assertLabeledStatement,
    assertLiteral: assertLiteral,
    assertLogicalExpression: assertLogicalExpression,
    assertLoop: assertLoop,
    assertMemberExpression: assertMemberExpression,
    assertMetaProperty: assertMetaProperty,
    assertMethod: assertMethod,
    assertMiscellaneous: assertMiscellaneous,
    assertMixedTypeAnnotation: assertMixedTypeAnnotation,
    assertModuleDeclaration: assertModuleDeclaration,
    assertModuleExpression: assertModuleExpression,
    assertModuleSpecifier: assertModuleSpecifier,
    assertNewExpression: assertNewExpression,
    assertNode: assertNode,
    assertNoop: assertNoop,
    assertNullLiteral: assertNullLiteral,
    assertNullLiteralTypeAnnotation: assertNullLiteralTypeAnnotation,
    assertNullableTypeAnnotation: assertNullableTypeAnnotation,
    assertNumberLiteral: assertNumberLiteral,
    assertNumberLiteralTypeAnnotation: assertNumberLiteralTypeAnnotation,
    assertNumberTypeAnnotation: assertNumberTypeAnnotation,
    assertNumericLiteral: assertNumericLiteral,
    assertObjectExpression: assertObjectExpression,
    assertObjectMember: assertObjectMember,
    assertObjectMethod: assertObjectMethod,
    assertObjectPattern: assertObjectPattern,
    assertObjectProperty: assertObjectProperty,
    assertObjectTypeAnnotation: assertObjectTypeAnnotation,
    assertObjectTypeCallProperty: assertObjectTypeCallProperty,
    assertObjectTypeIndexer: assertObjectTypeIndexer,
    assertObjectTypeInternalSlot: assertObjectTypeInternalSlot,
    assertObjectTypeProperty: assertObjectTypeProperty,
    assertObjectTypeSpreadProperty: assertObjectTypeSpreadProperty,
    assertOpaqueType: assertOpaqueType,
    assertOptionalCallExpression: assertOptionalCallExpression,
    assertOptionalIndexedAccessType: assertOptionalIndexedAccessType,
    assertOptionalMemberExpression: assertOptionalMemberExpression,
    assertParenthesizedExpression: assertParenthesizedExpression,
    assertPattern: assertPattern,
    assertPatternLike: assertPatternLike,
    assertPipelineBareFunction: assertPipelineBareFunction,
    assertPipelinePrimaryTopicReference: assertPipelinePrimaryTopicReference,
    assertPipelineTopicExpression: assertPipelineTopicExpression,
    assertPlaceholder: assertPlaceholder,
    assertPrivate: assertPrivate,
    assertPrivateName: assertPrivateName,
    assertProgram: assertProgram,
    assertProperty: assertProperty,
    assertPureish: assertPureish,
    assertQualifiedTypeIdentifier: assertQualifiedTypeIdentifier,
    assertRecordExpression: assertRecordExpression,
    assertRegExpLiteral: assertRegExpLiteral,
    assertRegexLiteral: assertRegexLiteral,
    assertRestElement: assertRestElement,
    assertRestProperty: assertRestProperty,
    assertReturnStatement: assertReturnStatement,
    assertScopable: assertScopable,
    assertSequenceExpression: assertSequenceExpression,
    assertSpreadElement: assertSpreadElement,
    assertSpreadProperty: assertSpreadProperty,
    assertStandardized: assertStandardized,
    assertStatement: assertStatement,
    assertStaticBlock: assertStaticBlock,
    assertStringLiteral: assertStringLiteral,
    assertStringLiteralTypeAnnotation: assertStringLiteralTypeAnnotation,
    assertStringTypeAnnotation: assertStringTypeAnnotation,
    assertSuper: assertSuper,
    assertSwitchCase: assertSwitchCase,
    assertSwitchStatement: assertSwitchStatement,
    assertSymbolTypeAnnotation: assertSymbolTypeAnnotation,
    assertTSAnyKeyword: assertTSAnyKeyword,
    assertTSArrayType: assertTSArrayType,
    assertTSAsExpression: assertTSAsExpression,
    assertTSBaseType: assertTSBaseType,
    assertTSBigIntKeyword: assertTSBigIntKeyword,
    assertTSBooleanKeyword: assertTSBooleanKeyword,
    assertTSCallSignatureDeclaration: assertTSCallSignatureDeclaration,
    assertTSConditionalType: assertTSConditionalType,
    assertTSConstructSignatureDeclaration: assertTSConstructSignatureDeclaration,
    assertTSConstructorType: assertTSConstructorType,
    assertTSDeclareFunction: assertTSDeclareFunction,
    assertTSDeclareMethod: assertTSDeclareMethod,
    assertTSEntityName: assertTSEntityName,
    assertTSEnumBody: assertTSEnumBody,
    assertTSEnumDeclaration: assertTSEnumDeclaration,
    assertTSEnumMember: assertTSEnumMember,
    assertTSExportAssignment: assertTSExportAssignment,
    assertTSExpressionWithTypeArguments: assertTSExpressionWithTypeArguments,
    assertTSExternalModuleReference: assertTSExternalModuleReference,
    assertTSFunctionType: assertTSFunctionType,
    assertTSImportEqualsDeclaration: assertTSImportEqualsDeclaration,
    assertTSImportType: assertTSImportType,
    assertTSIndexSignature: assertTSIndexSignature,
    assertTSIndexedAccessType: assertTSIndexedAccessType,
    assertTSInferType: assertTSInferType,
    assertTSInstantiationExpression: assertTSInstantiationExpression,
    assertTSInterfaceBody: assertTSInterfaceBody,
    assertTSInterfaceDeclaration: assertTSInterfaceDeclaration,
    assertTSIntersectionType: assertTSIntersectionType,
    assertTSIntrinsicKeyword: assertTSIntrinsicKeyword,
    assertTSLiteralType: assertTSLiteralType,
    assertTSMappedType: assertTSMappedType,
    assertTSMethodSignature: assertTSMethodSignature,
    assertTSModuleBlock: assertTSModuleBlock,
    assertTSModuleDeclaration: assertTSModuleDeclaration,
    assertTSNamedTupleMember: assertTSNamedTupleMember,
    assertTSNamespaceExportDeclaration: assertTSNamespaceExportDeclaration,
    assertTSNeverKeyword: assertTSNeverKeyword,
    assertTSNonNullExpression: assertTSNonNullExpression,
    assertTSNullKeyword: assertTSNullKeyword,
    assertTSNumberKeyword: assertTSNumberKeyword,
    assertTSObjectKeyword: assertTSObjectKeyword,
    assertTSOptionalType: assertTSOptionalType,
    assertTSParameterProperty: assertTSParameterProperty,
    assertTSParenthesizedType: assertTSParenthesizedType,
    assertTSPropertySignature: assertTSPropertySignature,
    assertTSQualifiedName: assertTSQualifiedName,
    assertTSRestType: assertTSRestType,
    assertTSSatisfiesExpression: assertTSSatisfiesExpression,
    assertTSStringKeyword: assertTSStringKeyword,
    assertTSSymbolKeyword: assertTSSymbolKeyword,
    assertTSTemplateLiteralType: assertTSTemplateLiteralType,
    assertTSThisType: assertTSThisType,
    assertTSTupleType: assertTSTupleType,
    assertTSType: assertTSType,
    assertTSTypeAliasDeclaration: assertTSTypeAliasDeclaration,
    assertTSTypeAnnotation: assertTSTypeAnnotation,
    assertTSTypeAssertion: assertTSTypeAssertion,
    assertTSTypeElement: assertTSTypeElement,
    assertTSTypeLiteral: assertTSTypeLiteral,
    assertTSTypeOperator: assertTSTypeOperator,
    assertTSTypeParameter: assertTSTypeParameter,
    assertTSTypeParameterDeclaration: assertTSTypeParameterDeclaration,
    assertTSTypeParameterInstantiation: assertTSTypeParameterInstantiation,
    assertTSTypePredicate: assertTSTypePredicate,
    assertTSTypeQuery: assertTSTypeQuery,
    assertTSTypeReference: assertTSTypeReference,
    assertTSUndefinedKeyword: assertTSUndefinedKeyword,
    assertTSUnionType: assertTSUnionType,
    assertTSUnknownKeyword: assertTSUnknownKeyword,
    assertTSVoidKeyword: assertTSVoidKeyword,
    assertTaggedTemplateExpression: assertTaggedTemplateExpression,
    assertTemplateElement: assertTemplateElement,
    assertTemplateLiteral: assertTemplateLiteral,
    assertTerminatorless: assertTerminatorless,
    assertThisExpression: assertThisExpression,
    assertThisTypeAnnotation: assertThisTypeAnnotation,
    assertThrowStatement: assertThrowStatement,
    assertTopicReference: assertTopicReference,
    assertTryStatement: assertTryStatement,
    assertTupleExpression: assertTupleExpression,
    assertTupleTypeAnnotation: assertTupleTypeAnnotation,
    assertTypeAlias: assertTypeAlias,
    assertTypeAnnotation: assertTypeAnnotation,
    assertTypeCastExpression: assertTypeCastExpression,
    assertTypeParameter: assertTypeParameter,
    assertTypeParameterDeclaration: assertTypeParameterDeclaration,
    assertTypeParameterInstantiation: assertTypeParameterInstantiation,
    assertTypeScript: assertTypeScript,
    assertTypeofTypeAnnotation: assertTypeofTypeAnnotation,
    assertUnaryExpression: assertUnaryExpression,
    assertUnaryLike: assertUnaryLike,
    assertUnionTypeAnnotation: assertUnionTypeAnnotation,
    assertUpdateExpression: assertUpdateExpression,
    assertUserWhitespacable: assertUserWhitespacable,
    assertV8IntrinsicIdentifier: assertV8IntrinsicIdentifier,
    assertVariableDeclaration: assertVariableDeclaration,
    assertVariableDeclarator: assertVariableDeclarator,
    assertVariance: assertVariance,
    assertVoidPattern: assertVoidPattern,
    assertVoidTypeAnnotation: assertVoidTypeAnnotation,
    assertWhile: assertWhile,
    assertWhileStatement: assertWhileStatement,
    assertWithStatement: assertWithStatement,
    assertYieldExpression: assertYieldExpression,
    assignmentExpression: assignmentExpression$8,
    assignmentPattern: assignmentPattern,
    awaitExpression: awaitExpression$1,
    bigIntLiteral: bigIntLiteral,
    binaryExpression: binaryExpression$4,
    bindExpression: bindExpression,
    blockStatement: blockStatement$6,
    booleanLiteral: booleanLiteral$2,
    booleanLiteralTypeAnnotation: booleanLiteralTypeAnnotation,
    booleanTypeAnnotation: booleanTypeAnnotation$1,
    breakStatement: breakStatement,
    buildMatchMemberExpression: buildMatchMemberExpression$1,
    buildUndefinedNode: buildUndefinedNode$2,
    callExpression: callExpression$c,
    catchClause: catchClause,
    classAccessorProperty: classAccessorProperty,
    classBody: classBody,
    classDeclaration: classDeclaration,
    classExpression: classExpression,
    classImplements: classImplements,
    classMethod: classMethod,
    classPrivateMethod: classPrivateMethod,
    classPrivateProperty: classPrivateProperty,
    classProperty: classProperty,
    clone: clone,
    cloneDeep: cloneDeep$1,
    cloneDeepWithoutLoc: cloneDeepWithoutLoc,
    cloneNode: cloneNode$e,
    cloneWithoutLoc: cloneWithoutLoc,
    conditionalExpression: conditionalExpression$5,
    continueStatement: continueStatement,
    createFlowUnionType: createFlowUnionType$1,
    createTSUnionType: createTSUnionType$1,
    createTypeAnnotationBasedOnTypeof: createTypeAnnotationBasedOnTypeof$1,
    createUnionTypeAnnotation: createFlowUnionType$1,
    debuggerStatement: debuggerStatement,
    decimalLiteral: decimalLiteral,
    declareClass: declareClass,
    declareExportAllDeclaration: declareExportAllDeclaration,
    declareExportDeclaration: declareExportDeclaration,
    declareFunction: declareFunction,
    declareInterface: declareInterface,
    declareModule: declareModule,
    declareModuleExports: declareModuleExports,
    declareOpaqueType: declareOpaqueType,
    declareTypeAlias: declareTypeAlias,
    declareVariable: declareVariable,
    declaredPredicate: declaredPredicate,
    decorator: decorator,
    directive: directive,
    directiveLiteral: directiveLiteral,
    doExpression: doExpression,
    doWhileStatement: doWhileStatement,
    emptyStatement: emptyStatement$1,
    emptyTypeAnnotation: emptyTypeAnnotation,
    ensureBlock: ensureBlock$1,
    enumBooleanBody: enumBooleanBody,
    enumBooleanMember: enumBooleanMember,
    enumDeclaration: enumDeclaration,
    enumDefaultedMember: enumDefaultedMember,
    enumNumberBody: enumNumberBody,
    enumNumberMember: enumNumberMember,
    enumStringBody: enumStringBody,
    enumStringMember: enumStringMember,
    enumSymbolBody: enumSymbolBody,
    existsTypeAnnotation: existsTypeAnnotation,
    exportAllDeclaration: exportAllDeclaration,
    exportDefaultDeclaration: exportDefaultDeclaration,
    exportDefaultSpecifier: exportDefaultSpecifier,
    exportNamedDeclaration: exportNamedDeclaration$2,
    exportNamespaceSpecifier: exportNamespaceSpecifier,
    exportSpecifier: exportSpecifier$2,
    expressionStatement: expressionStatement$7,
    file: file$1,
    forInStatement: forInStatement,
    forOfStatement: forOfStatement,
    forStatement: forStatement,
    functionDeclaration: functionDeclaration,
    functionExpression: functionExpression$2,
    functionTypeAnnotation: functionTypeAnnotation,
    functionTypeParam: functionTypeParam,
    genericTypeAnnotation: genericTypeAnnotation$1,
    getAssignmentIdentifiers: getAssignmentIdentifiers$2,
    getBindingIdentifiers: getBindingIdentifiers$4,
    getFunctionName: getFunctionName$1,
    getOuterBindingIdentifiers: getOuterBindingIdentifiers$1,
    identifier: identifier$e,
    ifStatement: ifStatement,
    import: _import,
    importAttribute: importAttribute,
    importDeclaration: importDeclaration$1,
    importDefaultSpecifier: importDefaultSpecifier$1,
    importExpression: importExpression,
    importNamespaceSpecifier: importNamespaceSpecifier$1,
    importSpecifier: importSpecifier$2,
    indexedAccessType: indexedAccessType,
    inferredPredicate: inferredPredicate,
    inheritInnerComments: inheritInnerComments,
    inheritLeadingComments: inheritLeadingComments$1,
    inheritTrailingComments: inheritTrailingComments$1,
    inherits: inherits$3,
    inheritsComments: inheritsComments$1,
    interfaceDeclaration: interfaceDeclaration,
    interfaceExtends: interfaceExtends,
    interfaceTypeAnnotation: interfaceTypeAnnotation,
    interpreterDirective: interpreterDirective$1,
    intersectionTypeAnnotation: intersectionTypeAnnotation,
    is: is,
    isAccessor: isAccessor,
    isAnyTypeAnnotation: isAnyTypeAnnotation$1,
    isArgumentPlaceholder: isArgumentPlaceholder,
    isArrayExpression: isArrayExpression$2,
    isArrayPattern: isArrayPattern,
    isArrayTypeAnnotation: isArrayTypeAnnotation$2,
    isArrowFunctionExpression: isArrowFunctionExpression,
    isAssignmentExpression: isAssignmentExpression$2,
    isAssignmentPattern: isAssignmentPattern$3,
    isAwaitExpression: isAwaitExpression,
    isBigIntLiteral: isBigIntLiteral,
    isBinary: isBinary$2,
    isBinaryExpression: isBinaryExpression$1,
    isBindExpression: isBindExpression,
    isBinding: isBinding$1,
    isBlock: isBlock,
    isBlockParent: isBlockParent,
    isBlockScoped: isBlockScoped$2,
    isBlockStatement: isBlockStatement$3,
    isBooleanLiteral: isBooleanLiteral,
    isBooleanLiteralTypeAnnotation: isBooleanLiteralTypeAnnotation,
    isBooleanTypeAnnotation: isBooleanTypeAnnotation$1,
    isBreakStatement: isBreakStatement,
    isCallExpression: isCallExpression$8,
    isCatchClause: isCatchClause,
    isClass: isClass$1,
    isClassAccessorProperty: isClassAccessorProperty,
    isClassBody: isClassBody$2,
    isClassDeclaration: isClassDeclaration$2,
    isClassExpression: isClassExpression,
    isClassImplements: isClassImplements,
    isClassMethod: isClassMethod,
    isClassPrivateMethod: isClassPrivateMethod,
    isClassPrivateProperty: isClassPrivateProperty,
    isClassProperty: isClassProperty,
    isCompletionStatement: isCompletionStatement,
    isConditional: isConditional,
    isConditionalExpression: isConditionalExpression,
    isContinueStatement: isContinueStatement,
    isDebuggerStatement: isDebuggerStatement,
    isDecimalLiteral: isDecimalLiteral,
    isDeclaration: isDeclaration,
    isDeclareClass: isDeclareClass,
    isDeclareExportAllDeclaration: isDeclareExportAllDeclaration,
    isDeclareExportDeclaration: isDeclareExportDeclaration$1,
    isDeclareFunction: isDeclareFunction,
    isDeclareInterface: isDeclareInterface,
    isDeclareModule: isDeclareModule,
    isDeclareModuleExports: isDeclareModuleExports,
    isDeclareOpaqueType: isDeclareOpaqueType,
    isDeclareTypeAlias: isDeclareTypeAlias,
    isDeclareVariable: isDeclareVariable,
    isDeclaredPredicate: isDeclaredPredicate,
    isDecorator: isDecorator$1,
    isDirective: isDirective,
    isDirectiveLiteral: isDirectiveLiteral,
    isDoExpression: isDoExpression,
    isDoWhileStatement: isDoWhileStatement,
    isEmptyStatement: isEmptyStatement$1,
    isEmptyTypeAnnotation: isEmptyTypeAnnotation$1,
    isEnumBody: isEnumBody,
    isEnumBooleanBody: isEnumBooleanBody,
    isEnumBooleanMember: isEnumBooleanMember,
    isEnumDeclaration: isEnumDeclaration,
    isEnumDefaultedMember: isEnumDefaultedMember,
    isEnumMember: isEnumMember,
    isEnumNumberBody: isEnumNumberBody,
    isEnumNumberMember: isEnumNumberMember,
    isEnumStringBody: isEnumStringBody,
    isEnumStringMember: isEnumStringMember,
    isEnumSymbolBody: isEnumSymbolBody,
    isExistsTypeAnnotation: isExistsTypeAnnotation,
    isExportAllDeclaration: isExportAllDeclaration$1,
    isExportDeclaration: isExportDeclaration$2,
    isExportDefaultDeclaration: isExportDefaultDeclaration$2,
    isExportDefaultSpecifier: isExportDefaultSpecifier$1,
    isExportNamedDeclaration: isExportNamedDeclaration$3,
    isExportNamespaceSpecifier: isExportNamespaceSpecifier$1,
    isExportSpecifier: isExportSpecifier,
    isExpression: isExpression$5,
    isExpressionStatement: isExpressionStatement$2,
    isExpressionWrapper: isExpressionWrapper,
    isFile: isFile,
    isFlow: isFlow$1,
    isFlowBaseAnnotation: isFlowBaseAnnotation$1,
    isFlowDeclaration: isFlowDeclaration,
    isFlowPredicate: isFlowPredicate,
    isFlowType: isFlowType$1,
    isFor: isFor$1,
    isForInStatement: isForInStatement,
    isForOfStatement: isForOfStatement$2,
    isForStatement: isForStatement$2,
    isForXStatement: isForXStatement$1,
    isFunction: isFunction$6,
    isFunctionDeclaration: isFunctionDeclaration$2,
    isFunctionExpression: isFunctionExpression,
    isFunctionParameter: isFunctionParameter,
    isFunctionParent: isFunctionParent,
    isFunctionTypeAnnotation: isFunctionTypeAnnotation,
    isFunctionTypeParam: isFunctionTypeParam,
    isGenericTypeAnnotation: isGenericTypeAnnotation$1,
    isIdentifier: isIdentifier$e,
    isIfStatement: isIfStatement$2,
    isImmutable: isImmutable,
    isImport: isImport,
    isImportAttribute: isImportAttribute,
    isImportDeclaration: isImportDeclaration$3,
    isImportDefaultSpecifier: isImportDefaultSpecifier$1,
    isImportExpression: isImportExpression,
    isImportNamespaceSpecifier: isImportNamespaceSpecifier$1,
    isImportOrExportDeclaration: isImportOrExportDeclaration,
    isImportSpecifier: isImportSpecifier$1,
    isIndexedAccessType: isIndexedAccessType$1,
    isInferredPredicate: isInferredPredicate,
    isInterfaceDeclaration: isInterfaceDeclaration,
    isInterfaceExtends: isInterfaceExtends,
    isInterfaceTypeAnnotation: isInterfaceTypeAnnotation,
    isInterpreterDirective: isInterpreterDirective,
    isIntersectionTypeAnnotation: isIntersectionTypeAnnotation,
    isJSX: isJSX,
    isJSXAttribute: isJSXAttribute,
    isJSXClosingElement: isJSXClosingElement,
    isJSXClosingFragment: isJSXClosingFragment,
    isJSXElement: isJSXElement,
    isJSXEmptyExpression: isJSXEmptyExpression,
    isJSXExpressionContainer: isJSXExpressionContainer$1,
    isJSXFragment: isJSXFragment,
    isJSXIdentifier: isJSXIdentifier$3,
    isJSXMemberExpression: isJSXMemberExpression$2,
    isJSXNamespacedName: isJSXNamespacedName$1,
    isJSXOpeningElement: isJSXOpeningElement,
    isJSXOpeningFragment: isJSXOpeningFragment,
    isJSXSpreadAttribute: isJSXSpreadAttribute$1,
    isJSXSpreadChild: isJSXSpreadChild,
    isJSXText: isJSXText,
    isLVal: isLVal,
    isLabeledStatement: isLabeledStatement,
    isLet: isLet,
    isLiteral: isLiteral$4,
    isLogicalExpression: isLogicalExpression,
    isLoop: isLoop$1,
    isMemberExpression: isMemberExpression$7,
    isMetaProperty: isMetaProperty$1,
    isMethod: isMethod$1,
    isMiscellaneous: isMiscellaneous,
    isMixedTypeAnnotation: isMixedTypeAnnotation$1,
    isModuleDeclaration: isModuleDeclaration,
    isModuleExpression: isModuleExpression,
    isModuleSpecifier: isModuleSpecifier$1,
    isNewExpression: isNewExpression$3,
    isNode: isNode,
    isNodesEquivalent: isNodesEquivalent,
    isNoop: isNoop,
    isNullLiteral: isNullLiteral$1,
    isNullLiteralTypeAnnotation: isNullLiteralTypeAnnotation,
    isNullableTypeAnnotation: isNullableTypeAnnotation,
    isNumberLiteral: isNumberLiteral,
    isNumberLiteralTypeAnnotation: isNumberLiteralTypeAnnotation,
    isNumberTypeAnnotation: isNumberTypeAnnotation$1,
    isNumericLiteral: isNumericLiteral,
    isObjectExpression: isObjectExpression$3,
    isObjectMember: isObjectMember,
    isObjectMethod: isObjectMethod,
    isObjectPattern: isObjectPattern$1,
    isObjectProperty: isObjectProperty$2,
    isObjectTypeAnnotation: isObjectTypeAnnotation,
    isObjectTypeCallProperty: isObjectTypeCallProperty,
    isObjectTypeIndexer: isObjectTypeIndexer,
    isObjectTypeInternalSlot: isObjectTypeInternalSlot,
    isObjectTypeProperty: isObjectTypeProperty,
    isObjectTypeSpreadProperty: isObjectTypeSpreadProperty,
    isOpaqueType: isOpaqueType,
    isOptionalCallExpression: isOptionalCallExpression$2,
    isOptionalIndexedAccessType: isOptionalIndexedAccessType,
    isOptionalMemberExpression: isOptionalMemberExpression$3,
    isParenthesizedExpression: isParenthesizedExpression$2,
    isPattern: isPattern$2,
    isPatternLike: isPatternLike,
    isPipelineBareFunction: isPipelineBareFunction,
    isPipelinePrimaryTopicReference: isPipelinePrimaryTopicReference,
    isPipelineTopicExpression: isPipelineTopicExpression,
    isPlaceholder: isPlaceholder$1,
    isPlaceholderType: isPlaceholderType,
    isPrivate: isPrivate,
    isPrivateName: isPrivateName$2,
    isProgram: isProgram$1,
    isProperty: isProperty$1,
    isPureish: isPureish$1,
    isQualifiedTypeIdentifier: isQualifiedTypeIdentifier,
    isRecordExpression: isRecordExpression$1,
    isReferenced: isReferenced$2,
    isRegExpLiteral: isRegExpLiteral$1,
    isRegexLiteral: isRegexLiteral,
    isRestElement: isRestElement$2,
    isRestProperty: isRestProperty$1,
    isReturnStatement: isReturnStatement,
    isScopable: isScopable,
    isScope: isScope$1,
    isSequenceExpression: isSequenceExpression$1,
    isSpecifierDefault: isSpecifierDefault,
    isSpreadElement: isSpreadElement$1,
    isSpreadProperty: isSpreadProperty$1,
    isStandardized: isStandardized,
    isStatement: isStatement$9,
    isStaticBlock: isStaticBlock,
    isStringLiteral: isStringLiteral$5,
    isStringLiteralTypeAnnotation: isStringLiteralTypeAnnotation,
    isStringTypeAnnotation: isStringTypeAnnotation$1,
    isSuper: isSuper$2,
    isSwitchCase: isSwitchCase,
    isSwitchStatement: isSwitchStatement,
    isSymbolTypeAnnotation: isSymbolTypeAnnotation,
    isTSAnyKeyword: isTSAnyKeyword,
    isTSArrayType: isTSArrayType$1,
    isTSAsExpression: isTSAsExpression$1,
    isTSBaseType: isTSBaseType,
    isTSBigIntKeyword: isTSBigIntKeyword,
    isTSBooleanKeyword: isTSBooleanKeyword,
    isTSCallSignatureDeclaration: isTSCallSignatureDeclaration,
    isTSConditionalType: isTSConditionalType,
    isTSConstructSignatureDeclaration: isTSConstructSignatureDeclaration,
    isTSConstructorType: isTSConstructorType,
    isTSDeclareFunction: isTSDeclareFunction,
    isTSDeclareMethod: isTSDeclareMethod,
    isTSEntityName: isTSEntityName,
    isTSEnumBody: isTSEnumBody,
    isTSEnumDeclaration: isTSEnumDeclaration,
    isTSEnumMember: isTSEnumMember$1,
    isTSExportAssignment: isTSExportAssignment,
    isTSExpressionWithTypeArguments: isTSExpressionWithTypeArguments,
    isTSExternalModuleReference: isTSExternalModuleReference,
    isTSFunctionType: isTSFunctionType,
    isTSImportEqualsDeclaration: isTSImportEqualsDeclaration,
    isTSImportType: isTSImportType,
    isTSIndexSignature: isTSIndexSignature,
    isTSIndexedAccessType: isTSIndexedAccessType,
    isTSInferType: isTSInferType,
    isTSInstantiationExpression: isTSInstantiationExpression,
    isTSInterfaceBody: isTSInterfaceBody$1,
    isTSInterfaceDeclaration: isTSInterfaceDeclaration,
    isTSIntersectionType: isTSIntersectionType,
    isTSIntrinsicKeyword: isTSIntrinsicKeyword,
    isTSLiteralType: isTSLiteralType,
    isTSMappedType: isTSMappedType,
    isTSMethodSignature: isTSMethodSignature,
    isTSModuleBlock: isTSModuleBlock,
    isTSModuleDeclaration: isTSModuleDeclaration,
    isTSNamedTupleMember: isTSNamedTupleMember,
    isTSNamespaceExportDeclaration: isTSNamespaceExportDeclaration,
    isTSNeverKeyword: isTSNeverKeyword,
    isTSNonNullExpression: isTSNonNullExpression$1,
    isTSNullKeyword: isTSNullKeyword,
    isTSNumberKeyword: isTSNumberKeyword,
    isTSObjectKeyword: isTSObjectKeyword,
    isTSOptionalType: isTSOptionalType,
    isTSParameterProperty: isTSParameterProperty,
    isTSParenthesizedType: isTSParenthesizedType,
    isTSPropertySignature: isTSPropertySignature,
    isTSQualifiedName: isTSQualifiedName,
    isTSRestType: isTSRestType,
    isTSSatisfiesExpression: isTSSatisfiesExpression$1,
    isTSStringKeyword: isTSStringKeyword,
    isTSSymbolKeyword: isTSSymbolKeyword,
    isTSTemplateLiteralType: isTSTemplateLiteralType,
    isTSThisType: isTSThisType,
    isTSTupleType: isTSTupleType,
    isTSType: isTSType$1,
    isTSTypeAliasDeclaration: isTSTypeAliasDeclaration,
    isTSTypeAnnotation: isTSTypeAnnotation$1,
    isTSTypeAssertion: isTSTypeAssertion$1,
    isTSTypeElement: isTSTypeElement,
    isTSTypeLiteral: isTSTypeLiteral,
    isTSTypeOperator: isTSTypeOperator,
    isTSTypeParameter: isTSTypeParameter,
    isTSTypeParameterDeclaration: isTSTypeParameterDeclaration,
    isTSTypeParameterInstantiation: isTSTypeParameterInstantiation,
    isTSTypePredicate: isTSTypePredicate,
    isTSTypeQuery: isTSTypeQuery,
    isTSTypeReference: isTSTypeReference$1,
    isTSUndefinedKeyword: isTSUndefinedKeyword,
    isTSUnionType: isTSUnionType,
    isTSUnknownKeyword: isTSUnknownKeyword,
    isTSVoidKeyword: isTSVoidKeyword,
    isTaggedTemplateExpression: isTaggedTemplateExpression$1,
    isTemplateElement: isTemplateElement,
    isTemplateLiteral: isTemplateLiteral$1,
    isTerminatorless: isTerminatorless,
    isThisExpression: isThisExpression$2,
    isThisTypeAnnotation: isThisTypeAnnotation,
    isThrowStatement: isThrowStatement,
    isTopicReference: isTopicReference$1,
    isTryStatement: isTryStatement,
    isTupleExpression: isTupleExpression$1,
    isTupleTypeAnnotation: isTupleTypeAnnotation$1,
    isType: isType$2,
    isTypeAlias: isTypeAlias,
    isTypeAnnotation: isTypeAnnotation$1,
    isTypeCastExpression: isTypeCastExpression$1,
    isTypeParameter: isTypeParameter,
    isTypeParameterDeclaration: isTypeParameterDeclaration,
    isTypeParameterInstantiation: isTypeParameterInstantiation,
    isTypeScript: isTypeScript,
    isTypeofTypeAnnotation: isTypeofTypeAnnotation,
    isUnaryExpression: isUnaryExpression$1,
    isUnaryLike: isUnaryLike,
    isUnionTypeAnnotation: isUnionTypeAnnotation$1,
    isUpdateExpression: isUpdateExpression$1,
    isUserWhitespacable: isUserWhitespacable,
    isV8IntrinsicIdentifier: isV8IntrinsicIdentifier,
    isValidES3Identifier: isValidES3Identifier,
    isValidIdentifier: isValidIdentifier$1,
    isVar: isVar$1,
    isVariableDeclaration: isVariableDeclaration$3,
    isVariableDeclarator: isVariableDeclarator,
    isVariance: isVariance,
    isVoidPattern: isVoidPattern,
    isVoidTypeAnnotation: isVoidTypeAnnotation$1,
    isWhile: isWhile,
    isWhileStatement: isWhileStatement,
    isWithStatement: isWithStatement,
    isYieldExpression: isYieldExpression$1,
    jSXAttribute: jsxAttribute,
    jSXClosingElement: jsxClosingElement,
    jSXClosingFragment: jsxClosingFragment,
    jSXElement: jsxElement,
    jSXEmptyExpression: jsxEmptyExpression,
    jSXExpressionContainer: jsxExpressionContainer$1,
    jSXFragment: jsxFragment,
    jSXIdentifier: jsxIdentifier$1,
    jSXMemberExpression: jsxMemberExpression,
    jSXNamespacedName: jsxNamespacedName,
    jSXOpeningElement: jsxOpeningElement,
    jSXOpeningFragment: jsxOpeningFragment,
    jSXSpreadAttribute: jsxSpreadAttribute,
    jSXSpreadChild: jsxSpreadChild,
    jSXText: jsxText,
    jsxAttribute: jsxAttribute,
    jsxClosingElement: jsxClosingElement,
    jsxClosingFragment: jsxClosingFragment,
    jsxElement: jsxElement,
    jsxEmptyExpression: jsxEmptyExpression,
    jsxExpressionContainer: jsxExpressionContainer$1,
    jsxFragment: jsxFragment,
    jsxIdentifier: jsxIdentifier$1,
    jsxMemberExpression: jsxMemberExpression,
    jsxNamespacedName: jsxNamespacedName,
    jsxOpeningElement: jsxOpeningElement,
    jsxOpeningFragment: jsxOpeningFragment,
    jsxSpreadAttribute: jsxSpreadAttribute,
    jsxSpreadChild: jsxSpreadChild,
    jsxText: jsxText,
    labeledStatement: labeledStatement,
    logicalExpression: logicalExpression$2,
    matchesPattern: matchesPattern$2,
    memberExpression: memberExpression$a,
    metaProperty: metaProperty$1,
    mixedTypeAnnotation: mixedTypeAnnotation,
    moduleExpression: moduleExpression,
    newExpression: newExpression,
    noop: noop$1,
    nullLiteral: nullLiteral$2,
    nullLiteralTypeAnnotation: nullLiteralTypeAnnotation$1,
    nullableTypeAnnotation: nullableTypeAnnotation,
    numberLiteral: NumberLiteral$1,
    numberLiteralTypeAnnotation: numberLiteralTypeAnnotation,
    numberTypeAnnotation: numberTypeAnnotation$2,
    numericLiteral: numericLiteral$5,
    objectExpression: objectExpression$3,
    objectMethod: objectMethod,
    objectPattern: objectPattern$1,
    objectProperty: objectProperty$1,
    objectTypeAnnotation: objectTypeAnnotation,
    objectTypeCallProperty: objectTypeCallProperty,
    objectTypeIndexer: objectTypeIndexer,
    objectTypeInternalSlot: objectTypeInternalSlot,
    objectTypeProperty: objectTypeProperty,
    objectTypeSpreadProperty: objectTypeSpreadProperty,
    opaqueType: opaqueType,
    optionalCallExpression: optionalCallExpression$2,
    optionalIndexedAccessType: optionalIndexedAccessType,
    optionalMemberExpression: optionalMemberExpression$2,
    parenthesizedExpression: parenthesizedExpression,
    pipelineBareFunction: pipelineBareFunction,
    pipelinePrimaryTopicReference: pipelinePrimaryTopicReference,
    pipelineTopicExpression: pipelineTopicExpression,
    placeholder: placeholder,
    prependToMemberExpression: prependToMemberExpression,
    privateName: privateName,
    program: program$3,
    qualifiedTypeIdentifier: qualifiedTypeIdentifier,
    react: react$3,
    recordExpression: recordExpression,
    regExpLiteral: regExpLiteral,
    regexLiteral: RegexLiteral$1,
    removeComments: removeComments$1,
    removeProperties: removeProperties$1,
    removePropertiesDeep: removePropertiesDeep$1,
    removeTypeDuplicates: removeTypeDuplicates$1,
    restElement: restElement$2,
    restProperty: RestProperty$2,
    returnStatement: returnStatement$3,
    sequenceExpression: sequenceExpression$6,
    shallowEqual: shallowEqual,
    spreadElement: spreadElement$2,
    spreadProperty: SpreadProperty$2,
    staticBlock: staticBlock,
    stringLiteral: stringLiteral$6,
    stringLiteralTypeAnnotation: stringLiteralTypeAnnotation,
    stringTypeAnnotation: stringTypeAnnotation$2,
    super: _super$1,
    switchCase: switchCase,
    switchStatement: switchStatement,
    symbolTypeAnnotation: symbolTypeAnnotation,
    tSAnyKeyword: tsAnyKeyword,
    tSArrayType: tsArrayType,
    tSAsExpression: tsAsExpression,
    tSBigIntKeyword: tsBigIntKeyword,
    tSBooleanKeyword: tsBooleanKeyword,
    tSCallSignatureDeclaration: tsCallSignatureDeclaration,
    tSConditionalType: tsConditionalType,
    tSConstructSignatureDeclaration: tsConstructSignatureDeclaration,
    tSConstructorType: tsConstructorType,
    tSDeclareFunction: tsDeclareFunction,
    tSDeclareMethod: tsDeclareMethod,
    tSEnumBody: tsEnumBody,
    tSEnumDeclaration: tsEnumDeclaration,
    tSEnumMember: tsEnumMember,
    tSExportAssignment: tsExportAssignment,
    tSExpressionWithTypeArguments: tsExpressionWithTypeArguments,
    tSExternalModuleReference: tsExternalModuleReference,
    tSFunctionType: tsFunctionType,
    tSImportEqualsDeclaration: tsImportEqualsDeclaration,
    tSImportType: tsImportType,
    tSIndexSignature: tsIndexSignature,
    tSIndexedAccessType: tsIndexedAccessType,
    tSInferType: tsInferType,
    tSInstantiationExpression: tsInstantiationExpression,
    tSInterfaceBody: tsInterfaceBody,
    tSInterfaceDeclaration: tsInterfaceDeclaration,
    tSIntersectionType: tsIntersectionType,
    tSIntrinsicKeyword: tsIntrinsicKeyword,
    tSLiteralType: tsLiteralType,
    tSMappedType: tsMappedType,
    tSMethodSignature: tsMethodSignature,
    tSModuleBlock: tsModuleBlock,
    tSModuleDeclaration: tsModuleDeclaration,
    tSNamedTupleMember: tsNamedTupleMember,
    tSNamespaceExportDeclaration: tsNamespaceExportDeclaration,
    tSNeverKeyword: tsNeverKeyword,
    tSNonNullExpression: tsNonNullExpression,
    tSNullKeyword: tsNullKeyword,
    tSNumberKeyword: tsNumberKeyword,
    tSObjectKeyword: tsObjectKeyword,
    tSOptionalType: tsOptionalType,
    tSParameterProperty: tsParameterProperty,
    tSParenthesizedType: tsParenthesizedType,
    tSPropertySignature: tsPropertySignature,
    tSQualifiedName: tsQualifiedName,
    tSRestType: tsRestType,
    tSSatisfiesExpression: tsSatisfiesExpression,
    tSStringKeyword: tsStringKeyword,
    tSSymbolKeyword: tsSymbolKeyword,
    tSTemplateLiteralType: tsTemplateLiteralType,
    tSThisType: tsThisType,
    tSTupleType: tsTupleType,
    tSTypeAliasDeclaration: tsTypeAliasDeclaration,
    tSTypeAnnotation: tsTypeAnnotation,
    tSTypeAssertion: tsTypeAssertion,
    tSTypeLiteral: tsTypeLiteral,
    tSTypeOperator: tsTypeOperator,
    tSTypeParameter: tsTypeParameter,
    tSTypeParameterDeclaration: tsTypeParameterDeclaration,
    tSTypeParameterInstantiation: tsTypeParameterInstantiation,
    tSTypePredicate: tsTypePredicate,
    tSTypeQuery: tsTypeQuery,
    tSTypeReference: tsTypeReference,
    tSUndefinedKeyword: tsUndefinedKeyword,
    tSUnionType: tsUnionType,
    tSUnknownKeyword: tsUnknownKeyword,
    tSVoidKeyword: tsVoidKeyword,
    taggedTemplateExpression: taggedTemplateExpression,
    templateElement: templateElement,
    templateLiteral: templateLiteral,
    thisExpression: thisExpression$5,
    thisTypeAnnotation: thisTypeAnnotation,
    throwStatement: throwStatement,
    toBindingIdentifierName: toBindingIdentifierName$1,
    toBlock: toBlock,
    toComputedKey: toComputedKey$1,
    toExpression: toExpression$1,
    toIdentifier: toIdentifier$1,
    toKeyAlias: toKeyAlias,
    toStatement: toStatement,
    topicReference: topicReference,
    traverse: traverse$2,
    traverseFast: traverseFast$3,
    tryStatement: tryStatement,
    tsAnyKeyword: tsAnyKeyword,
    tsArrayType: tsArrayType,
    tsAsExpression: tsAsExpression,
    tsBigIntKeyword: tsBigIntKeyword,
    tsBooleanKeyword: tsBooleanKeyword,
    tsCallSignatureDeclaration: tsCallSignatureDeclaration,
    tsConditionalType: tsConditionalType,
    tsConstructSignatureDeclaration: tsConstructSignatureDeclaration,
    tsConstructorType: tsConstructorType,
    tsDeclareFunction: tsDeclareFunction,
    tsDeclareMethod: tsDeclareMethod,
    tsEnumBody: tsEnumBody,
    tsEnumDeclaration: tsEnumDeclaration,
    tsEnumMember: tsEnumMember,
    tsExportAssignment: tsExportAssignment,
    tsExpressionWithTypeArguments: tsExpressionWithTypeArguments,
    tsExternalModuleReference: tsExternalModuleReference,
    tsFunctionType: tsFunctionType,
    tsImportEqualsDeclaration: tsImportEqualsDeclaration,
    tsImportType: tsImportType,
    tsIndexSignature: tsIndexSignature,
    tsIndexedAccessType: tsIndexedAccessType,
    tsInferType: tsInferType,
    tsInstantiationExpression: tsInstantiationExpression,
    tsInterfaceBody: tsInterfaceBody,
    tsInterfaceDeclaration: tsInterfaceDeclaration,
    tsIntersectionType: tsIntersectionType,
    tsIntrinsicKeyword: tsIntrinsicKeyword,
    tsLiteralType: tsLiteralType,
    tsMappedType: tsMappedType,
    tsMethodSignature: tsMethodSignature,
    tsModuleBlock: tsModuleBlock,
    tsModuleDeclaration: tsModuleDeclaration,
    tsNamedTupleMember: tsNamedTupleMember,
    tsNamespaceExportDeclaration: tsNamespaceExportDeclaration,
    tsNeverKeyword: tsNeverKeyword,
    tsNonNullExpression: tsNonNullExpression,
    tsNullKeyword: tsNullKeyword,
    tsNumberKeyword: tsNumberKeyword,
    tsObjectKeyword: tsObjectKeyword,
    tsOptionalType: tsOptionalType,
    tsParameterProperty: tsParameterProperty,
    tsParenthesizedType: tsParenthesizedType,
    tsPropertySignature: tsPropertySignature,
    tsQualifiedName: tsQualifiedName,
    tsRestType: tsRestType,
    tsSatisfiesExpression: tsSatisfiesExpression,
    tsStringKeyword: tsStringKeyword,
    tsSymbolKeyword: tsSymbolKeyword,
    tsTemplateLiteralType: tsTemplateLiteralType,
    tsThisType: tsThisType,
    tsTupleType: tsTupleType,
    tsTypeAliasDeclaration: tsTypeAliasDeclaration,
    tsTypeAnnotation: tsTypeAnnotation,
    tsTypeAssertion: tsTypeAssertion,
    tsTypeLiteral: tsTypeLiteral,
    tsTypeOperator: tsTypeOperator,
    tsTypeParameter: tsTypeParameter,
    tsTypeParameterDeclaration: tsTypeParameterDeclaration,
    tsTypeParameterInstantiation: tsTypeParameterInstantiation,
    tsTypePredicate: tsTypePredicate,
    tsTypeQuery: tsTypeQuery,
    tsTypeReference: tsTypeReference,
    tsUndefinedKeyword: tsUndefinedKeyword,
    tsUnionType: tsUnionType,
    tsUnknownKeyword: tsUnknownKeyword,
    tsVoidKeyword: tsVoidKeyword,
    tupleExpression: tupleExpression,
    tupleTypeAnnotation: tupleTypeAnnotation$1,
    typeAlias: typeAlias,
    typeAnnotation: typeAnnotation,
    typeCastExpression: typeCastExpression,
    typeParameter: typeParameter,
    typeParameterDeclaration: typeParameterDeclaration,
    typeParameterInstantiation: typeParameterInstantiation,
    typeofTypeAnnotation: typeofTypeAnnotation,
    unaryExpression: unaryExpression$4,
    unionTypeAnnotation: unionTypeAnnotation$1,
    updateExpression: updateExpression$1,
    v8IntrinsicIdentifier: v8IntrinsicIdentifier,
    validate: validate$6,
    valueToNode: valueToNode,
    variableDeclaration: variableDeclaration$6,
    variableDeclarator: variableDeclarator$6,
    variance: variance,
    voidPattern: voidPattern,
    voidTypeAnnotation: voidTypeAnnotation$3,
    whileStatement: whileStatement,
    withStatement: withStatement,
    yieldExpression: yieldExpression$2
  });

  var assertExpressionStatement = assertExpressionStatement$1;
  function makeStatementFormatter(fn) {
    return {
      code: function code(str) {
        return "/* @babel/template */;\n" + str;
      },
      validate: function validate() {},
      unwrap: function unwrap(ast) {
        return fn(ast.program.body.slice(1));
      }
    };
  }
  var smart$1 = makeStatementFormatter(function (body) {
    if (body.length > 1) {
      return body;
    } else {
      return body[0];
    }
  });
  var statements$1 = makeStatementFormatter(function (body) {
    return body;
  });
  var statement$1 = makeStatementFormatter(function (body) {
    if (body.length === 0) {
      throw new Error("Found nothing to return.");
    }
    if (body.length > 1) {
      throw new Error("Found multiple statements but wanted one");
    }
    return body[0];
  });
  var expression$1 = {
    code: function code(str) {
      return "(\n" + str + "\n)";
    },
    validate: function validate(ast) {
      if (ast.program.body.length > 1) {
        throw new Error("Found multiple statements but wanted one");
      }
      if (expression$1.unwrap(ast).start === 0) {
        throw new Error("Parse result included parens.");
      }
    },
    unwrap: function unwrap(_ref) {
      var program = _ref.program;
      var _program$body = _slicedToArray(program.body, 1),
        stmt = _program$body[0];
      assertExpressionStatement(stmt);
      return stmt.expression;
    }
  };
  var program$2 = {
    code: function code(str) {
      return str;
    },
    validate: function validate() {},
    unwrap: function unwrap(ast) {
      return ast.program;
    }
  };

  var _excluded$4 = ["placeholderWhitelist", "placeholderPattern", "preserveComments", "syntacticPlaceholders"];
  function merge$1(a, b) {
    var _b$placeholderWhiteli = b.placeholderWhitelist,
      placeholderWhitelist = _b$placeholderWhiteli === void 0 ? a.placeholderWhitelist : _b$placeholderWhiteli,
      _b$placeholderPattern = b.placeholderPattern,
      placeholderPattern = _b$placeholderPattern === void 0 ? a.placeholderPattern : _b$placeholderPattern,
      _b$preserveComments = b.preserveComments,
      preserveComments = _b$preserveComments === void 0 ? a.preserveComments : _b$preserveComments,
      _b$syntacticPlacehold = b.syntacticPlaceholders,
      syntacticPlaceholders = _b$syntacticPlacehold === void 0 ? a.syntacticPlaceholders : _b$syntacticPlacehold;
    return {
      parser: Object.assign({}, a.parser, b.parser),
      placeholderWhitelist: placeholderWhitelist,
      placeholderPattern: placeholderPattern,
      preserveComments: preserveComments,
      syntacticPlaceholders: syntacticPlaceholders
    };
  }
  function validate$4(opts) {
    if (opts != null && typeof opts !== "object") {
      throw new Error("Unknown template options.");
    }
    var _ref = opts || {},
      placeholderWhitelist = _ref.placeholderWhitelist,
      placeholderPattern = _ref.placeholderPattern,
      preserveComments = _ref.preserveComments,
      syntacticPlaceholders = _ref.syntacticPlaceholders,
      parser = _objectWithoutPropertiesLoose(_ref, _excluded$4);
    if (placeholderWhitelist != null && !(placeholderWhitelist instanceof Set)) {
      throw new Error("'.placeholderWhitelist' must be a Set, null, or undefined");
    }
    if (placeholderPattern != null && !(placeholderPattern instanceof RegExp) && placeholderPattern !== false) {
      throw new Error("'.placeholderPattern' must be a RegExp, false, null, or undefined");
    }
    if (preserveComments != null && typeof preserveComments !== "boolean") {
      throw new Error("'.preserveComments' must be a boolean, null, or undefined");
    }
    if (syntacticPlaceholders != null && typeof syntacticPlaceholders !== "boolean") {
      throw new Error("'.syntacticPlaceholders' must be a boolean, null, or undefined");
    }
    if (syntacticPlaceholders === true && (placeholderWhitelist != null || placeholderPattern != null)) {
      throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible" + " with '.syntacticPlaceholders: true'");
    }
    return {
      parser: parser,
      placeholderWhitelist: placeholderWhitelist || undefined,
      placeholderPattern: placeholderPattern == null ? undefined : placeholderPattern,
      preserveComments: preserveComments == null ? undefined : preserveComments,
      syntacticPlaceholders: syntacticPlaceholders == null ? undefined : syntacticPlaceholders
    };
  }
  function normalizeReplacements(replacements) {
    if (Array.isArray(replacements)) {
      return replacements.reduce(function (acc, replacement, i) {
        acc["$" + i] = replacement;
        return acc;
      }, {});
    } else if (typeof replacements === "object" || replacements == null) {
      return replacements || undefined;
    }
    throw new Error("Template replacements must be an array, object, null, or undefined");
  }

  var Position = _createClass(function Position(line, col, index) {
    this.line = void 0;
    this.column = void 0;
    this.index = void 0;
    this.line = line;
    this.column = col;
    this.index = index;
  });
  var SourceLocation = _createClass(function SourceLocation(start, end) {
    this.start = void 0;
    this.end = void 0;
    this.filename = void 0;
    this.identifierName = void 0;
    this.start = start;
    this.end = end;
  });
  function createPositionWithColumnOffset(position, columnOffset) {
    var line = position.line,
      column = position.column,
      index = position.index;
    return new Position(line, column + columnOffset, index + columnOffset);
  }

  var code = "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED";
  var ModuleErrors = {
    ImportMetaOutsideModule: {
      message: "import.meta may appear only with 'sourceType: \"module\"'",
      code: code
    },
    ImportOutsideModule: {
      message: "'import' and 'export' may appear only with 'sourceType: \"module\"'",
      code: code
    }
  };

  var NodeDescriptions = {
    ArrayPattern: "array destructuring pattern",
    AssignmentExpression: "assignment expression",
    AssignmentPattern: "assignment expression",
    ArrowFunctionExpression: "arrow function expression",
    ConditionalExpression: "conditional expression",
    CatchClause: "catch clause",
    ForOfStatement: "for-of statement",
    ForInStatement: "for-in statement",
    ForStatement: "for-loop",
    FormalParameters: "function parameter list",
    Identifier: "identifier",
    ImportSpecifier: "import specifier",
    ImportDefaultSpecifier: "import default specifier",
    ImportNamespaceSpecifier: "import namespace specifier",
    ObjectPattern: "object destructuring pattern",
    ParenthesizedExpression: "parenthesized expression",
    RestElement: "rest element",
    UpdateExpression: {
      "true": "prefix operation",
      "false": "postfix operation"
    },
    VariableDeclarator: "variable declaration",
    YieldExpression: "yield expression"
  };
  var toNodeDescription = function toNodeDescription(node) {
    return node.type === "UpdateExpression" ? NodeDescriptions.UpdateExpression["" + node.prefix] : NodeDescriptions[node.type];
  };

  var StandardErrors = {
    AccessorIsGenerator: function AccessorIsGenerator(_ref) {
      var kind = _ref.kind;
      return "A " + kind + "ter cannot be a generator.";
    },
    ArgumentsInClass: "'arguments' is only allowed in functions and class methods.",
    AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.",
    AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.",
    AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.",
    AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.",
    AwaitUsingNotInAsyncContext: "'await using' is only allowed within async functions and at the top levels of modules.",
    AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.",
    BadGetterArity: "A 'get' accessor must not have any formal parameters.",
    BadSetterArity: "A 'set' accessor must have exactly one formal parameter.",
    BadSetterRestParameter: "A 'set' accessor function argument must not be a rest parameter.",
    ConstructorClassField: "Classes may not have a field named 'constructor'.",
    ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.",
    ConstructorIsAccessor: "Class constructor may not be an accessor.",
    ConstructorIsAsync: "Constructor can't be an async function.",
    ConstructorIsGenerator: "Constructor can't be a generator.",
    DeclarationMissingInitializer: function DeclarationMissingInitializer(_ref2) {
      var kind = _ref2.kind;
      return "Missing initializer in " + kind + " declaration.";
    },
    DecoratorArgumentsOutsideParentheses: "Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(decorator)(args)'.",
    DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use the 'export @decorator class {}' syntax.",
    DecoratorsBeforeAfterExport: "Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the same time.",
    DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",
    DecoratorExportClass: "Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use the '@decorator export class {}' syntax.",
    DecoratorSemicolon: "Decorators must not be followed by a semicolon.",
    DecoratorStaticBlock: "Decorators can't be used with a static block.",
    DeferImportRequiresNamespace: 'Only `import defer * as x from "./module"` is valid.',
    DeletePrivateField: "Deleting a private field is not allowed.",
    DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.",
    DuplicateConstructor: "Duplicate constructor in the same class.",
    DuplicateDefaultExport: "Only one default export allowed per module.",
    DuplicateExport: function DuplicateExport(_ref3) {
      var exportName = _ref3.exportName;
      return "`" + exportName + "` has already been exported. Exported identifiers must be unique.";
    },
    DuplicateProto: "Redefinition of __proto__ property.",
    DuplicateRegExpFlags: "Duplicate regular expression flag.",
    ElementAfterRest: "Rest element must be last element.",
    EscapedCharNotAnIdentifier: "Invalid Unicode escape.",
    ExportBindingIsString: function ExportBindingIsString(_ref4) {
      var localName = _ref4.localName,
        exportName = _ref4.exportName;
      return "A string literal cannot be used as an exported binding without `from`.\n- Did you mean `export { '" + localName + "' as '" + exportName + "' } from 'some-module'`?";
    },
    ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.",
    ForInOfLoopInitializer: function ForInOfLoopInitializer(_ref5) {
      var type = _ref5.type;
      return "'" + (type === "ForInStatement" ? "for-in" : "for-of") + "' loop variable declaration may not have an initializer.";
    },
    ForInUsing: "For-in loop may not start with 'using' declaration.",
    ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.",
    ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.",
    GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.",
    IllegalBreakContinue: function IllegalBreakContinue(_ref6) {
      var type = _ref6.type;
      return "Unsyntactic " + (type === "BreakStatement" ? "break" : "continue") + ".";
    },
    IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.",
    IllegalReturn: "'return' outside of function.",
    ImportAttributesUseAssert: "The `assert` keyword in import attributes is deprecated and it has been replaced by the `with` keyword. You can enable the `deprecatedImportAssert` parser plugin to suppress this error.",
    ImportBindingIsString: function ImportBindingIsString(_ref7) {
      var importName = _ref7.importName;
      return "A string literal cannot be used as an imported binding.\n- Did you mean `import { \"" + importName + "\" as foo }`?";
    },
    ImportCallArity: "`import()` requires exactly one or two arguments.",
    ImportCallNotNewExpression: "Cannot use new with import(...).",
    ImportCallSpreadArgument: "`...` is not allowed in `import()`.",
    ImportJSONBindingNotDefault: "A JSON module can only be imported with `default`.",
    ImportReflectionHasAssertion: "`import module x` cannot have assertions.",
    ImportReflectionNotBinding: 'Only `import module x from "./module"` is valid.',
    IncompatibleRegExpUVFlags: "The 'u' and 'v' regular expression flags cannot be enabled at the same time.",
    InvalidBigIntLiteral: "Invalid BigIntLiteral.",
    InvalidCodePoint: "Code point out of bounds.",
    InvalidCoverDiscardElement: "'void' must be followed by an expression when not used in a binding position.",
    InvalidCoverInitializedName: "Invalid shorthand property initializer.",
    InvalidDecimal: "Invalid decimal.",
    InvalidDigit: function InvalidDigit(_ref8) {
      var radix = _ref8.radix;
      return "Expected number in radix " + radix + ".";
    },
    InvalidEscapeSequence: "Bad character escape sequence.",
    InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.",
    InvalidEscapedReservedWord: function InvalidEscapedReservedWord(_ref9) {
      var reservedWord = _ref9.reservedWord;
      return "Escape sequence in keyword " + reservedWord + ".";
    },
    InvalidIdentifier: function InvalidIdentifier(_ref0) {
      var identifierName = _ref0.identifierName;
      return "Invalid identifier " + identifierName + ".";
    },
    InvalidLhs: function InvalidLhs(_ref1) {
      var ancestor = _ref1.ancestor;
      return "Invalid left-hand side in " + toNodeDescription(ancestor) + ".";
    },
    InvalidLhsBinding: function InvalidLhsBinding(_ref10) {
      var ancestor = _ref10.ancestor;
      return "Binding invalid left-hand side in " + toNodeDescription(ancestor) + ".";
    },
    InvalidLhsOptionalChaining: function InvalidLhsOptionalChaining(_ref11) {
      var ancestor = _ref11.ancestor;
      return "Invalid optional chaining in the left-hand side of " + toNodeDescription(ancestor) + ".";
    },
    InvalidNumber: "Invalid number.",
    InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.",
    InvalidOrUnexpectedToken: function InvalidOrUnexpectedToken(_ref12) {
      var unexpected = _ref12.unexpected;
      return "Unexpected character '" + unexpected + "'.";
    },
    InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.",
    InvalidPrivateFieldResolution: function InvalidPrivateFieldResolution(_ref13) {
      var identifierName = _ref13.identifierName;
      return "Private name #" + identifierName + " is not defined.";
    },
    InvalidPropertyBindingPattern: "Binding member expression.",
    InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.",
    InvalidRestAssignmentPattern: "Invalid rest operator's argument.",
    LabelRedeclaration: function LabelRedeclaration(_ref14) {
      var labelName = _ref14.labelName;
      return "Label '" + labelName + "' is already declared.";
    },
    LetInLexicalBinding: "'let' is disallowed as a lexically bound name.",
    LineTerminatorBeforeArrow: "No line break is allowed before '=>'.",
    MalformedRegExpFlags: "Invalid regular expression flag.",
    MissingClassName: "A class name is required.",
    MissingEqInAssignment: "Only '=' operator can be used for specifying default value.",
    MissingSemicolon: "Missing semicolon.",
    MissingPlugin: function MissingPlugin(_ref15) {
      var missingPlugin = _ref15.missingPlugin;
      return "This experimental syntax requires enabling the parser plugin: " + missingPlugin.map(function (name) {
        return JSON.stringify(name);
      }).join(", ") + ".";
    },
    MissingOneOfPlugins: function MissingOneOfPlugins(_ref16) {
      var missingPlugin = _ref16.missingPlugin;
      return "This experimental syntax requires enabling one of the following parser plugin(s): " + missingPlugin.map(function (name) {
        return JSON.stringify(name);
      }).join(", ") + ".";
    },
    MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.",
    MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.",
    ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.",
    ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.",
    ModuleAttributesWithDuplicateKeys: function ModuleAttributesWithDuplicateKeys(_ref17) {
      var key = _ref17.key;
      return "Duplicate key \"" + key + "\" is not allowed in module attributes.";
    },
    ModuleExportNameHasLoneSurrogate: function ModuleExportNameHasLoneSurrogate(_ref18) {
      var surrogateCharCode = _ref18.surrogateCharCode;
      return "An export name cannot include a lone surrogate, found '\\u" + surrogateCharCode.toString(16) + "'.";
    },
    ModuleExportUndefined: function ModuleExportUndefined(_ref19) {
      var localName = _ref19.localName;
      return "Export '" + localName + "' is not defined.";
    },
    MultipleDefaultsInSwitch: "Multiple default clauses.",
    NewlineAfterThrow: "Illegal newline after throw.",
    NoCatchOrFinally: "Missing catch or finally clause.",
    NumberIdentifier: "Identifier directly after number.",
    NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.",
    ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.",
    OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.",
    OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.",
    OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.",
    ParamDupe: "Argument name clash.",
    PatternHasAccessor: "Object pattern can't contain getter or setter.",
    PatternHasMethod: "Object pattern can't contain methods.",
    PrivateInExpectedIn: function PrivateInExpectedIn(_ref20) {
      var identifierName = _ref20.identifierName;
      return "Private names are only allowed in property accesses (`obj.#" + identifierName + "`) or in `in` expressions (`#" + identifierName + " in obj`).";
    },
    PrivateNameRedeclaration: function PrivateNameRedeclaration(_ref21) {
      var identifierName = _ref21.identifierName;
      return "Duplicate private name #" + identifierName + ".";
    },
    RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
    RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
    RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
    RecordNoProto: "'__proto__' is not allowed in Record expressions.",
    RestTrailingComma: "Unexpected trailing comma after rest element.",
    SloppyFunction: "In non-strict mode code, functions can only be declared at top level or inside a block.",
    SloppyFunctionAnnexB: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.",
    SourcePhaseImportRequiresDefault: 'Only `import source x from "./module"` is valid.',
    StaticPrototype: "Classes may not have static property named prototype.",
    SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?",
    SuperPrivateField: "Private fields can't be accessed on super.",
    TrailingDecorator: "Decorators must be attached to a class element.",
    TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
    TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
    TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
    UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.",
    UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.',
    UnexpectedDigitAfterHash: "Unexpected digit after hash token.",
    UnexpectedImportExport: "'import' and 'export' may only appear at the top level.",
    UnexpectedKeyword: function UnexpectedKeyword(_ref22) {
      var keyword = _ref22.keyword;
      return "Unexpected keyword '" + keyword + "'.";
    },
    UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.",
    UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.",
    UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.",
    UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.",
    UnexpectedPrivateField: "Unexpected private name.",
    UnexpectedReservedWord: function UnexpectedReservedWord(_ref23) {
      var reservedWord = _ref23.reservedWord;
      return "Unexpected reserved word '" + reservedWord + "'.";
    },
    UnexpectedSuper: "'super' is only allowed in object methods and classes.",
    UnexpectedToken: function UnexpectedToken(_ref24) {
      var expected = _ref24.expected,
        unexpected = _ref24.unexpected;
      return "Unexpected token" + (unexpected ? " '" + unexpected + "'." : "") + (expected ? ", expected \"" + expected + "\"" : "");
    },
    UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.",
    UnexpectedUsingDeclaration: "Using declaration cannot appear in the top level when source type is `script` or in the bare case statement.",
    UnexpectedVoidPattern: "Unexpected void binding.",
    UnsupportedBind: "Binding should be performed on object property.",
    UnsupportedDecoratorExport: "A decorated export must export a class declaration.",
    UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.",
    UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.",
    UnsupportedMetaProperty: function UnsupportedMetaProperty(_ref25) {
      var target = _ref25.target,
        onlyValidPropertyName = _ref25.onlyValidPropertyName;
      return "The only valid meta property for " + target + " is " + target + "." + onlyValidPropertyName + ".";
    },
    UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.",
    UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.",
    UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).",
    UnterminatedComment: "Unterminated comment.",
    UnterminatedRegExp: "Unterminated regular expression.",
    UnterminatedString: "Unterminated string constant.",
    UnterminatedTemplate: "Unterminated template.",
    UsingDeclarationExport: "Using declaration cannot be exported.",
    UsingDeclarationHasBindingPattern: "Using declaration cannot have destructuring patterns.",
    VarRedeclaration: function VarRedeclaration(_ref26) {
      var identifierName = _ref26.identifierName;
      return "Identifier '" + identifierName + "' has already been declared.";
    },
    VoidPatternCatchClauseParam: "A void binding can not be the catch clause parameter. Use `try { ... } catch { ... }` if you want to discard the caught error.",
    VoidPatternInitializer: "A void binding may not have an initializer.",
    YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.",
    YieldInParameter: "Yield expression is not allowed in formal parameters.",
    YieldNotInGeneratorFunction: "'yield' is only allowed within generator functions.",
    ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0."
  };

  var StrictModeErrors = {
    StrictDelete: "Deleting local variable in strict mode.",
    StrictEvalArguments: function StrictEvalArguments(_ref) {
      var referenceName = _ref.referenceName;
      return "Assigning to '" + referenceName + "' in strict mode.";
    },
    StrictEvalArgumentsBinding: function StrictEvalArgumentsBinding(_ref2) {
      var bindingName = _ref2.bindingName;
      return "Binding '" + bindingName + "' in strict mode.";
    },
    StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.",
    StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.",
    StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.",
    StrictWith: "'with' in strict mode."
  };

  var ParseExpressionErrors = {
    ParseExpressionEmptyInput: "Unexpected parseExpression() input: The input is empty or contains only comments.",
    ParseExpressionExpectsEOF: function ParseExpressionExpectsEOF(_ref) {
      var unexpected = _ref.unexpected;
      return "Unexpected parseExpression() input: The input should contain exactly one expression, but the first expression is followed by the unexpected character `" + String.fromCodePoint(unexpected) + "`.";
    }
  };

  var UnparenthesizedPipeBodyDescriptions = new Set(["ArrowFunctionExpression", "AssignmentExpression", "ConditionalExpression", "YieldExpression"]);
  var PipelineOperatorErrors = Object.assign({
    PipeBodyIsTighter: "Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.",
    PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.',
    PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.",
    PipeTopicUnconfiguredToken: function PipeTopicUnconfiguredToken(_ref) {
      var token = _ref.token;
      return "Invalid topic token " + token + ". In order to use " + token + " as a topic reference, the pipelineOperator plugin must be configured with { \"proposal\": \"hack\", \"topicToken\": \"" + token + "\" }.";
    },
    PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.",
    PipeUnparenthesizedBody: function PipeUnparenthesizedBody(_ref2) {
      var type = _ref2.type;
      return "Hack-style pipe body cannot be an unparenthesized " + toNodeDescription({
        type: type
      }) + "; please wrap it in parentheses.";
    }
  }, {
    PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.',
    PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.",
    PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.",
    PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.",
    PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.",
    PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.'
  });

  var _templateObject$M;
  var _excluded$3 = ["message"];
  function defineHidden(obj, key, value) {
    Object.defineProperty(obj, key, {
      enumerable: false,
      configurable: true,
      value: value
    });
  }
  function toParseErrorConstructor(_ref) {
    var toMessage = _ref.toMessage,
      code = _ref.code,
      reasonCode = _ref.reasonCode,
      syntaxPlugin = _ref.syntaxPlugin;
    var hasMissingPlugin = reasonCode === "MissingPlugin" || reasonCode === "MissingOneOfPlugins";
    {
      var oldReasonCodes = {
        AccessorCannotDeclareThisParameter: "AccesorCannotDeclareThisParameter",
        AccessorCannotHaveTypeParameters: "AccesorCannotHaveTypeParameters",
        ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference: "ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference",
        SetAccessorCannotHaveOptionalParameter: "SetAccesorCannotHaveOptionalParameter",
        SetAccessorCannotHaveRestParameter: "SetAccesorCannotHaveRestParameter",
        SetAccessorCannotHaveReturnType: "SetAccesorCannotHaveReturnType"
      };
      if (oldReasonCodes[reasonCode]) {
        reasonCode = oldReasonCodes[reasonCode];
      }
    }
    return function constructor(loc, details) {
      var error = new SyntaxError();
      error.code = code;
      error.reasonCode = reasonCode;
      error.loc = loc;
      error.pos = loc.index;
      error.syntaxPlugin = syntaxPlugin;
      if (hasMissingPlugin) {
        error.missingPlugin = details.missingPlugin;
      }
      defineHidden(error, "clone", function clone(overrides) {
        var _overrides$loc;
        if (overrides === void 0) {
          overrides = {};
        }
        var _ref2 = (_overrides$loc = overrides.loc) != null ? _overrides$loc : loc,
          line = _ref2.line,
          column = _ref2.column,
          index = _ref2.index;
        return constructor(new Position(line, column, index), Object.assign({}, details, overrides.details));
      });
      defineHidden(error, "details", details);
      Object.defineProperty(error, "message", {
        configurable: true,
        get: function get() {
          var message = toMessage(details) + " (" + loc.line + ":" + loc.column + ")";
          this.message = message;
          return message;
        },
        set: function set(value) {
          Object.defineProperty(this, "message", {
            value: value,
            writable: true
          });
        }
      });
      return error;
    };
  }
  function ParseErrorEnum(argument, syntaxPlugin) {
    if (Array.isArray(argument)) {
      return function (parseErrorTemplates) {
        return ParseErrorEnum(parseErrorTemplates, argument[0]);
      };
    }
    var ParseErrorConstructors = {};
    var _loop = function _loop() {
      var reasonCode = _Object$keys2[_i2];
      var template = argument[reasonCode];
      var _ref3 = typeof template === "string" ? {
          message: function message() {
            return template;
          }
        } : typeof template === "function" ? {
          message: template
        } : template,
        message = _ref3.message,
        rest = _objectWithoutPropertiesLoose(_ref3, _excluded$3);
      var toMessage = typeof message === "string" ? function () {
        return message;
      } : message;
      ParseErrorConstructors[reasonCode] = toParseErrorConstructor(Object.assign({
        code: "BABEL_PARSER_SYNTAX_ERROR",
        reasonCode: reasonCode,
        toMessage: toMessage
      }, syntaxPlugin ? {
        syntaxPlugin: syntaxPlugin
      } : {}, rest));
    };
    for (var _i2 = 0, _Object$keys2 = Object.keys(argument); _i2 < _Object$keys2.length; _i2++) {
      _loop();
    }
    return ParseErrorConstructors;
  }
  var Errors = Object.assign({}, ParseErrorEnum(ModuleErrors), ParseErrorEnum(StandardErrors), ParseErrorEnum(StrictModeErrors), ParseErrorEnum(ParseExpressionErrors), ParseErrorEnum(_templateObject$M || (_templateObject$M = _taggedTemplateLiteralLoose(["pipelineOperator"])))(PipelineOperatorErrors));

  var OptionFlags = {
    AllowAwaitOutsideFunction: 1,
    AllowReturnOutsideFunction: 2,
    AllowNewTargetOutsideFunction: 4,
    AllowImportExportEverywhere: 8,
    AllowSuperOutsideMethod: 16,
    AllowYieldOutsideFunction: 32,
    AllowUndeclaredExports: 64,
    Ranges: 128,
    Tokens: 256,
    CreateImportExpressions: 512,
    CreateParenthesizedExpressions: 1024,
    ErrorRecovery: 2048,
    AttachComment: 4096,
    AnnexB: 8192
  };
  function createDefaultOptions() {
    return {
      sourceType: "script",
      sourceFilename: undefined,
      startIndex: 0,
      startColumn: 0,
      startLine: 1,
      allowAwaitOutsideFunction: false,
      allowReturnOutsideFunction: false,
      allowNewTargetOutsideFunction: false,
      allowImportExportEverywhere: false,
      allowSuperOutsideMethod: false,
      allowUndeclaredExports: false,
      allowYieldOutsideFunction: false,
      plugins: [],
      strictMode: null,
      ranges: false,
      tokens: false,
      createImportExpressions: false,
      createParenthesizedExpressions: false,
      errorRecovery: false,
      attachComment: true,
      annexB: true
    };
  }
  function getOptions(opts) {
    var options = createDefaultOptions();
    if (opts == null) {
      return options;
    }
    if (opts.annexB != null && opts.annexB !== false) {
      throw new Error("The `annexB` option can only be set to `false`.");
    }
    for (var _i2 = 0, _Object$keys2 = Object.keys(options); _i2 < _Object$keys2.length; _i2++) {
      var key = _Object$keys2[_i2];
      if (opts[key] != null) options[key] = opts[key];
    }
    if (options.startLine === 1) {
      if (opts.startIndex == null && options.startColumn > 0) {
        options.startIndex = options.startColumn;
      } else if (opts.startColumn == null && options.startIndex > 0) {
        options.startColumn = options.startIndex;
      }
    } else if (opts.startColumn == null || opts.startIndex == null) {
      if (opts.startIndex != null) {
        throw new Error("With a `startLine > 1` you must also specify `startIndex` and `startColumn`.");
      }
    }
    if (options.sourceType === "commonjs") {
      if (opts.allowAwaitOutsideFunction != null) {
        throw new Error("The `allowAwaitOutsideFunction` option cannot be used with `sourceType: 'commonjs'`.");
      }
      if (opts.allowReturnOutsideFunction != null) {
        throw new Error("`sourceType: 'commonjs'` implies `allowReturnOutsideFunction: true`, please remove the `allowReturnOutsideFunction` option or use `sourceType: 'script'`.");
      }
      if (opts.allowNewTargetOutsideFunction != null) {
        throw new Error("`sourceType: 'commonjs'` implies `allowNewTargetOutsideFunction: true`, please remove the `allowNewTargetOutsideFunction` option or use `sourceType: 'script'`.");
      }
    }
    return options;
  }

  var defineProperty = Object.defineProperty;
  var toUnenumerable = function toUnenumerable(object, key) {
    if (object) {
      defineProperty(object, key, {
        enumerable: false,
        value: object[key]
      });
    }
  };
  function toESTreeLocation(node) {
    toUnenumerable(node.loc.start, "index");
    toUnenumerable(node.loc.end, "index");
    return node;
  }
  var estree = (function (superClass) {
    return function (_superClass) {
      function ESTreeParserMixin() {
        return _superClass.apply(this, arguments) || this;
      }
      _inherits(ESTreeParserMixin, _superClass);
      var _proto = ESTreeParserMixin.prototype;
      _proto.parse = function parse() {
        var file = toESTreeLocation(_superClass.prototype.parse.call(this));
        if (this.optionFlags & OptionFlags.Tokens) {
          file.tokens = file.tokens.map(toESTreeLocation);
        }
        return file;
      };
      _proto.parseRegExpLiteral = function parseRegExpLiteral(_ref) {
        var pattern = _ref.pattern,
          flags = _ref.flags;
        var regex = null;
        try {
          regex = new RegExp(pattern, flags);
        } catch (_) {}
        var node = this.estreeParseLiteral(regex);
        node.regex = {
          pattern: pattern,
          flags: flags
        };
        return node;
      };
      _proto.parseBigIntLiteral = function parseBigIntLiteral(value) {
        var bigInt;
        try {
          bigInt = BigInt(value);
        } catch (_unused) {
          bigInt = null;
        }
        var node = this.estreeParseLiteral(bigInt);
        node.bigint = String(node.value || value);
        return node;
      };
      _proto.parseDecimalLiteral = function parseDecimalLiteral(value) {
        var decimal = null;
        var node = this.estreeParseLiteral(decimal);
        node.decimal = String(node.value || value);
        return node;
      };
      _proto.estreeParseLiteral = function estreeParseLiteral(value) {
        return this.parseLiteral(value, "Literal");
      };
      _proto.parseStringLiteral = function parseStringLiteral(value) {
        return this.estreeParseLiteral(value);
      };
      _proto.parseNumericLiteral = function parseNumericLiteral(value) {
        return this.estreeParseLiteral(value);
      };
      _proto.parseNullLiteral = function parseNullLiteral() {
        return this.estreeParseLiteral(null);
      };
      _proto.parseBooleanLiteral = function parseBooleanLiteral(value) {
        return this.estreeParseLiteral(value);
      };
      _proto.estreeParseChainExpression = function estreeParseChainExpression(node, endLoc) {
        var chain = this.startNodeAtNode(node);
        chain.expression = node;
        return this.finishNodeAt(chain, "ChainExpression", endLoc);
      };
      _proto.directiveToStmt = function directiveToStmt(directive) {
        var expression = directive.value;
        delete directive.value;
        this.castNodeTo(expression, "Literal");
        expression.raw = expression.extra.raw;
        expression.value = expression.extra.expressionValue;
        var stmt = this.castNodeTo(directive, "ExpressionStatement");
        stmt.expression = expression;
        stmt.directive = expression.extra.rawValue;
        delete expression.extra;
        return stmt;
      };
      _proto.fillOptionalPropertiesForTSESLint = function fillOptionalPropertiesForTSESLint(node) {};
      _proto.cloneEstreeStringLiteral = function cloneEstreeStringLiteral(node) {
        var start = node.start,
          end = node.end,
          loc = node.loc,
          range = node.range,
          raw = node.raw,
          value = node.value;
        var cloned = Object.create(node.constructor.prototype);
        cloned.type = "Literal";
        cloned.start = start;
        cloned.end = end;
        cloned.loc = loc;
        cloned.range = range;
        cloned.raw = raw;
        cloned.value = value;
        return cloned;
      };
      _proto.initFunction = function initFunction(node, isAsync) {
        _superClass.prototype.initFunction.call(this, node, isAsync);
        node.expression = false;
      };
      _proto.checkDeclaration = function checkDeclaration(node) {
        if (node != null && this.isObjectProperty(node)) {
          this.checkDeclaration(node.value);
        } else {
          _superClass.prototype.checkDeclaration.call(this, node);
        }
      };
      _proto.getObjectOrClassMethodParams = function getObjectOrClassMethodParams(method) {
        return method.value.params;
      };
      _proto.isValidDirective = function isValidDirective(stmt) {
        var _stmt$expression$extr;
        return stmt.type === "ExpressionStatement" && stmt.expression.type === "Literal" && typeof stmt.expression.value === "string" && !((_stmt$expression$extr = stmt.expression.extra) != null && _stmt$expression$extr.parenthesized);
      };
      _proto.parseBlockBody = function parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {
        var _this = this;
        _superClass.prototype.parseBlockBody.call(this, node, allowDirectives, topLevel, end, afterBlockParse);
        var directiveStatements = node.directives.map(function (d) {
          return _this.directiveToStmt(d);
        });
        node.body = directiveStatements.concat(node.body);
        delete node.directives;
      };
      _proto.parsePrivateName = function parsePrivateName() {
        var node = _superClass.prototype.parsePrivateName.call(this);
        {
          if (!this.getPluginOption("estree", "classFeatures")) {
            return node;
          }
        }
        return this.convertPrivateNameToPrivateIdentifier(node);
      };
      _proto.convertPrivateNameToPrivateIdentifier = function convertPrivateNameToPrivateIdentifier(node) {
        var name = _superClass.prototype.getPrivateNameSV.call(this, node);
        node = node;
        delete node.id;
        node.name = name;
        return this.castNodeTo(node, "PrivateIdentifier");
      };
      _proto.isPrivateName = function isPrivateName(node) {
        {
          if (!this.getPluginOption("estree", "classFeatures")) {
            return _superClass.prototype.isPrivateName.call(this, node);
          }
        }
        return node.type === "PrivateIdentifier";
      };
      _proto.getPrivateNameSV = function getPrivateNameSV(node) {
        {
          if (!this.getPluginOption("estree", "classFeatures")) {
            return _superClass.prototype.getPrivateNameSV.call(this, node);
          }
        }
        return node.name;
      };
      _proto.parseLiteral = function parseLiteral(value, type) {
        var node = _superClass.prototype.parseLiteral.call(this, value, type);
        node.raw = node.extra.raw;
        delete node.extra;
        return node;
      };
      _proto.parseFunctionBody = function parseFunctionBody(node, allowExpression, isMethod) {
        if (isMethod === void 0) {
          isMethod = false;
        }
        _superClass.prototype.parseFunctionBody.call(this, node, allowExpression, isMethod);
        node.expression = node.body.type !== "BlockStatement";
      };
      _proto.parseMethod = function parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope) {
        if (inClassScope === void 0) {
          inClassScope = false;
        }
        var funcNode = this.startNode();
        funcNode.kind = node.kind;
        funcNode = _superClass.prototype.parseMethod.call(this, funcNode, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope);
        delete funcNode.kind;
        var typeParameters = node.typeParameters;
        if (typeParameters) {
          delete node.typeParameters;
          funcNode.typeParameters = typeParameters;
          this.resetStartLocationFromNode(funcNode, typeParameters);
        }
        var valueNode = this.castNodeTo(funcNode, "FunctionExpression");
        node.value = valueNode;
        if (type === "ClassPrivateMethod") {
          node.computed = false;
        }
        if (type === "ObjectMethod") {
          if (node.kind === "method") {
            node.kind = "init";
          }
          node.shorthand = false;
          return this.finishNode(node, "Property");
        } else {
          return this.finishNode(node, "MethodDefinition");
        }
      };
      _proto.nameIsConstructor = function nameIsConstructor(key) {
        if (key.type === "Literal") return key.value === "constructor";
        return _superClass.prototype.nameIsConstructor.call(this, key);
      };
      _proto.parseClassProperty = function parseClassProperty() {
        var _superClass$prototype;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        var propertyNode = (_superClass$prototype = _superClass.prototype.parseClassProperty).call.apply(_superClass$prototype, [this].concat(args));
        {
          if (!this.getPluginOption("estree", "classFeatures")) {
            return propertyNode;
          }
        }
        {
          this.castNodeTo(propertyNode, "PropertyDefinition");
        }
        return propertyNode;
      };
      _proto.parseClassPrivateProperty = function parseClassPrivateProperty() {
        var _superClass$prototype2;
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }
        var propertyNode = (_superClass$prototype2 = _superClass.prototype.parseClassPrivateProperty).call.apply(_superClass$prototype2, [this].concat(args));
        {
          if (!this.getPluginOption("estree", "classFeatures")) {
            return propertyNode;
          }
        }
        {
          this.castNodeTo(propertyNode, "PropertyDefinition");
        }
        propertyNode.computed = false;
        return propertyNode;
      };
      _proto.parseClassAccessorProperty = function parseClassAccessorProperty(node) {
        var accessorPropertyNode = _superClass.prototype.parseClassAccessorProperty.call(this, node);
        {
          if (!this.getPluginOption("estree", "classFeatures")) {
            return accessorPropertyNode;
          }
        }
        if (accessorPropertyNode["abstract"] && this.hasPlugin("typescript")) {
          delete accessorPropertyNode["abstract"];
          this.castNodeTo(accessorPropertyNode, "TSAbstractAccessorProperty");
        } else {
          this.castNodeTo(accessorPropertyNode, "AccessorProperty");
        }
        return accessorPropertyNode;
      };
      _proto.parseObjectProperty = function parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors) {
        var node = _superClass.prototype.parseObjectProperty.call(this, prop, startLoc, isPattern, refExpressionErrors);
        if (node) {
          node.kind = "init";
          this.castNodeTo(node, "Property");
        }
        return node;
      };
      _proto.finishObjectProperty = function finishObjectProperty(node) {
        node.kind = "init";
        return this.finishNode(node, "Property");
      };
      _proto.isValidLVal = function isValidLVal(type, isUnparenthesizedInAssign, binding) {
        return type === "Property" ? "value" : _superClass.prototype.isValidLVal.call(this, type, isUnparenthesizedInAssign, binding);
      };
      _proto.isAssignable = function isAssignable(node, isBinding) {
        if (node != null && this.isObjectProperty(node)) {
          return this.isAssignable(node.value, isBinding);
        }
        return _superClass.prototype.isAssignable.call(this, node, isBinding);
      };
      _proto.toAssignable = function toAssignable(node, isLHS) {
        if (isLHS === void 0) {
          isLHS = false;
        }
        if (node != null && this.isObjectProperty(node)) {
          var key = node.key,
            value = node.value;
          if (this.isPrivateName(key)) {
            this.classScope.usePrivateName(this.getPrivateNameSV(key), key.loc.start);
          }
          this.toAssignable(value, isLHS);
        } else {
          _superClass.prototype.toAssignable.call(this, node, isLHS);
        }
      };
      _proto.toAssignableObjectExpressionProp = function toAssignableObjectExpressionProp(prop, isLast, isLHS) {
        if (prop.type === "Property" && (prop.kind === "get" || prop.kind === "set")) {
          this.raise(Errors.PatternHasAccessor, prop.key);
        } else if (prop.type === "Property" && prop.method) {
          this.raise(Errors.PatternHasMethod, prop.key);
        } else {
          _superClass.prototype.toAssignableObjectExpressionProp.call(this, prop, isLast, isLHS);
        }
      };
      _proto.finishCallExpression = function finishCallExpression(unfinished, optional) {
        var node = _superClass.prototype.finishCallExpression.call(this, unfinished, optional);
        if (node.callee.type === "Import") {
          var _ref2, _ref3;
          this.castNodeTo(node, "ImportExpression");
          node.source = node.arguments[0];
          node.options = (_ref2 = node.arguments[1]) != null ? _ref2 : null;
          node.attributes = (_ref3 = node.arguments[1]) != null ? _ref3 : null;
          delete node.arguments;
          delete node.callee;
        } else if (node.type === "OptionalCallExpression") {
          this.castNodeTo(node, "CallExpression");
        } else {
          node.optional = false;
        }
        return node;
      };
      _proto.toReferencedArguments = function toReferencedArguments(node) {
        if (node.type === "ImportExpression") {
          return;
        }
        _superClass.prototype.toReferencedArguments.call(this, node);
      };
      _proto.parseExport = function parseExport(unfinished, decorators) {
        var exportStartLoc = this.state.lastTokStartLoc;
        var node = _superClass.prototype.parseExport.call(this, unfinished, decorators);
        switch (node.type) {
          case "ExportAllDeclaration":
            node.exported = null;
            break;
          case "ExportNamedDeclaration":
            if (node.specifiers.length === 1 && node.specifiers[0].type === "ExportNamespaceSpecifier") {
              this.castNodeTo(node, "ExportAllDeclaration");
              node.exported = node.specifiers[0].exported;
              delete node.specifiers;
            }
          case "ExportDefaultDeclaration":
            {
              var _declaration$decorato;
              var declaration = node.declaration;
              if ((declaration == null ? void 0 : declaration.type) === "ClassDeclaration" && ((_declaration$decorato = declaration.decorators) == null ? void 0 : _declaration$decorato.length) > 0 && declaration.start === node.start) {
                this.resetStartLocation(node, exportStartLoc);
              }
            }
            break;
        }
        return node;
      };
      _proto.stopParseSubscript = function stopParseSubscript(base, state) {
        var node = _superClass.prototype.stopParseSubscript.call(this, base, state);
        if (state.optionalChainMember) {
          return this.estreeParseChainExpression(node, base.loc.end);
        }
        return node;
      };
      _proto.parseMember = function parseMember(base, startLoc, state, computed, optional) {
        var node = _superClass.prototype.parseMember.call(this, base, startLoc, state, computed, optional);
        if (node.type === "OptionalMemberExpression") {
          this.castNodeTo(node, "MemberExpression");
        } else {
          node.optional = false;
        }
        return node;
      };
      _proto.isOptionalMemberExpression = function isOptionalMemberExpression(node) {
        if (node.type === "ChainExpression") {
          return node.expression.type === "MemberExpression";
        }
        return _superClass.prototype.isOptionalMemberExpression.call(this, node);
      };
      _proto.hasPropertyAsPrivateName = function hasPropertyAsPrivateName(node) {
        if (node.type === "ChainExpression") {
          node = node.expression;
        }
        return _superClass.prototype.hasPropertyAsPrivateName.call(this, node);
      };
      _proto.isObjectProperty = function isObjectProperty(node) {
        return node.type === "Property" && node.kind === "init" && !node.method;
      };
      _proto.isObjectMethod = function isObjectMethod(node) {
        return node.type === "Property" && (node.method || node.kind === "get" || node.kind === "set");
      };
      _proto.castNodeTo = function castNodeTo(node, type) {
        var result = _superClass.prototype.castNodeTo.call(this, node, type);
        this.fillOptionalPropertiesForTSESLint(result);
        return result;
      };
      _proto.cloneIdentifier = function cloneIdentifier(node) {
        var cloned = _superClass.prototype.cloneIdentifier.call(this, node);
        this.fillOptionalPropertiesForTSESLint(cloned);
        return cloned;
      };
      _proto.cloneStringLiteral = function cloneStringLiteral(node) {
        if (node.type === "Literal") {
          return this.cloneEstreeStringLiteral(node);
        }
        return _superClass.prototype.cloneStringLiteral.call(this, node);
      };
      _proto.finishNodeAt = function finishNodeAt(node, type, endLoc) {
        return toESTreeLocation(_superClass.prototype.finishNodeAt.call(this, node, type, endLoc));
      };
      _proto.finishNode = function finishNode(node, type) {
        var result = _superClass.prototype.finishNode.call(this, node, type);
        this.fillOptionalPropertiesForTSESLint(result);
        return result;
      };
      _proto.resetStartLocation = function resetStartLocation(node, startLoc) {
        _superClass.prototype.resetStartLocation.call(this, node, startLoc);
        toESTreeLocation(node);
      };
      _proto.resetEndLocation = function resetEndLocation(node, endLoc) {
        if (endLoc === void 0) {
          endLoc = this.state.lastTokEndLoc;
        }
        _superClass.prototype.resetEndLocation.call(this, node, endLoc);
        toESTreeLocation(node);
      };
      return _createClass(ESTreeParserMixin);
    }(superClass);
  });

  var TokContext = _createClass(function TokContext(token, preserveSpace) {
    this.token = void 0;
    this.preserveSpace = void 0;
    this.token = token;
    this.preserveSpace = !!preserveSpace;
  });
  var types = {
    brace: new TokContext("{"),
    j_oTag: new TokContext("<tag"),
    j_cTag: new TokContext("</tag"),
    j_expr: new TokContext("<tag>...</tag>", true)
  };
  {
    types.template = new TokContext("`", true);
  }

  var beforeExpr = true;
  var startsExpr = true;
  var isLoop = true;
  var isAssign = true;
  var prefix = true;
  var postfix = true;
  var ExportedTokenType = _createClass(function ExportedTokenType(label, conf) {
    if (conf === void 0) {
      conf = {};
    }
    this.label = void 0;
    this.keyword = void 0;
    this.beforeExpr = void 0;
    this.startsExpr = void 0;
    this.rightAssociative = void 0;
    this.isLoop = void 0;
    this.isAssign = void 0;
    this.prefix = void 0;
    this.postfix = void 0;
    this.binop = void 0;
    this.label = label;
    this.keyword = conf.keyword;
    this.beforeExpr = !!conf.beforeExpr;
    this.startsExpr = !!conf.startsExpr;
    this.rightAssociative = !!conf.rightAssociative;
    this.isLoop = !!conf.isLoop;
    this.isAssign = !!conf.isAssign;
    this.prefix = !!conf.prefix;
    this.postfix = !!conf.postfix;
    this.binop = conf.binop != null ? conf.binop : null;
    {
      this.updateContext = null;
    }
  });
  var keywords = new Map();
  function createKeyword(name, options) {
    if (options === void 0) {
      options = {};
    }
    options.keyword = name;
    var token = createToken(name, options);
    keywords.set(name, token);
    return token;
  }
  function createBinop(name, binop) {
    return createToken(name, {
      beforeExpr: beforeExpr,
      binop: binop
    });
  }
  var tokenTypeCounter = -1;
  var tokenTypes = [];
  var tokenLabels = [];
  var tokenBinops = [];
  var tokenBeforeExprs = [];
  var tokenStartsExprs = [];
  var tokenPrefixes = [];
  function createToken(name, options) {
    var _options$binop, _options$beforeExpr, _options$startsExpr, _options$prefix;
    if (options === void 0) {
      options = {};
    }
    ++tokenTypeCounter;
    tokenLabels.push(name);
    tokenBinops.push((_options$binop = options.binop) != null ? _options$binop : -1);
    tokenBeforeExprs.push((_options$beforeExpr = options.beforeExpr) != null ? _options$beforeExpr : false);
    tokenStartsExprs.push((_options$startsExpr = options.startsExpr) != null ? _options$startsExpr : false);
    tokenPrefixes.push((_options$prefix = options.prefix) != null ? _options$prefix : false);
    tokenTypes.push(new ExportedTokenType(name, options));
    return tokenTypeCounter;
  }
  function createKeywordLike(name, options) {
    var _options$binop2, _options$beforeExpr2, _options$startsExpr2, _options$prefix2;
    if (options === void 0) {
      options = {};
    }
    ++tokenTypeCounter;
    keywords.set(name, tokenTypeCounter);
    tokenLabels.push(name);
    tokenBinops.push((_options$binop2 = options.binop) != null ? _options$binop2 : -1);
    tokenBeforeExprs.push((_options$beforeExpr2 = options.beforeExpr) != null ? _options$beforeExpr2 : false);
    tokenStartsExprs.push((_options$startsExpr2 = options.startsExpr) != null ? _options$startsExpr2 : false);
    tokenPrefixes.push((_options$prefix2 = options.prefix) != null ? _options$prefix2 : false);
    tokenTypes.push(new ExportedTokenType("name", options));
    return tokenTypeCounter;
  }
  var tt = {
    bracketL: createToken("[", {
      beforeExpr: beforeExpr,
      startsExpr: startsExpr
    }),
    bracketHashL: createToken("#[", {
      beforeExpr: beforeExpr,
      startsExpr: startsExpr
    }),
    bracketBarL: createToken("[|", {
      beforeExpr: beforeExpr,
      startsExpr: startsExpr
    }),
    bracketR: createToken("]"),
    bracketBarR: createToken("|]"),
    braceL: createToken("{", {
      beforeExpr: beforeExpr,
      startsExpr: startsExpr
    }),
    braceBarL: createToken("{|", {
      beforeExpr: beforeExpr,
      startsExpr: startsExpr
    }),
    braceHashL: createToken("#{", {
      beforeExpr: beforeExpr,
      startsExpr: startsExpr
    }),
    braceR: createToken("}"),
    braceBarR: createToken("|}"),
    parenL: createToken("(", {
      beforeExpr: beforeExpr,
      startsExpr: startsExpr
    }),
    parenR: createToken(")"),
    comma: createToken(",", {
      beforeExpr: beforeExpr
    }),
    semi: createToken(";", {
      beforeExpr: beforeExpr
    }),
    colon: createToken(":", {
      beforeExpr: beforeExpr
    }),
    doubleColon: createToken("::", {
      beforeExpr: beforeExpr
    }),
    dot: createToken("."),
    question: createToken("?", {
      beforeExpr: beforeExpr
    }),
    questionDot: createToken("?."),
    arrow: createToken("=>", {
      beforeExpr: beforeExpr
    }),
    template: createToken("template"),
    ellipsis: createToken("...", {
      beforeExpr: beforeExpr
    }),
    backQuote: createToken("`", {
      startsExpr: startsExpr
    }),
    dollarBraceL: createToken("${", {
      beforeExpr: beforeExpr,
      startsExpr: startsExpr
    }),
    templateTail: createToken("...`", {
      startsExpr: startsExpr
    }),
    templateNonTail: createToken("...${", {
      beforeExpr: beforeExpr,
      startsExpr: startsExpr
    }),
    at: createToken("@"),
    hash: createToken("#", {
      startsExpr: startsExpr
    }),
    interpreterDirective: createToken("#!..."),
    eq: createToken("=", {
      beforeExpr: beforeExpr,
      isAssign: isAssign
    }),
    assign: createToken("_=", {
      beforeExpr: beforeExpr,
      isAssign: isAssign
    }),
    slashAssign: createToken("_=", {
      beforeExpr: beforeExpr,
      isAssign: isAssign
    }),
    xorAssign: createToken("_=", {
      beforeExpr: beforeExpr,
      isAssign: isAssign
    }),
    moduloAssign: createToken("_=", {
      beforeExpr: beforeExpr,
      isAssign: isAssign
    }),
    incDec: createToken("++/--", {
      prefix: prefix,
      postfix: postfix,
      startsExpr: startsExpr
    }),
    bang: createToken("!", {
      beforeExpr: beforeExpr,
      prefix: prefix,
      startsExpr: startsExpr
    }),
    tilde: createToken("~", {
      beforeExpr: beforeExpr,
      prefix: prefix,
      startsExpr: startsExpr
    }),
    doubleCaret: createToken("^^", {
      startsExpr: startsExpr
    }),
    doubleAt: createToken("@@", {
      startsExpr: startsExpr
    }),
    pipeline: createBinop("|>", 0),
    nullishCoalescing: createBinop("??", 1),
    logicalOR: createBinop("||", 1),
    logicalAND: createBinop("&&", 2),
    bitwiseOR: createBinop("|", 3),
    bitwiseXOR: createBinop("^", 4),
    bitwiseAND: createBinop("&", 5),
    equality: createBinop("==/!=/===/!==", 6),
    lt: createBinop("</>/<=/>=", 7),
    gt: createBinop("</>/<=/>=", 7),
    relational: createBinop("</>/<=/>=", 7),
    bitShift: createBinop("<</>>/>>>", 8),
    bitShiftL: createBinop("<</>>/>>>", 8),
    bitShiftR: createBinop("<</>>/>>>", 8),
    plusMin: createToken("+/-", {
      beforeExpr: beforeExpr,
      binop: 9,
      prefix: prefix,
      startsExpr: startsExpr
    }),
    modulo: createToken("%", {
      binop: 10,
      startsExpr: startsExpr
    }),
    star: createToken("*", {
      binop: 10
    }),
    slash: createBinop("/", 10),
    exponent: createToken("**", {
      beforeExpr: beforeExpr,
      binop: 11,
      rightAssociative: true
    }),
    _in: createKeyword("in", {
      beforeExpr: beforeExpr,
      binop: 7
    }),
    _instanceof: createKeyword("instanceof", {
      beforeExpr: beforeExpr,
      binop: 7
    }),
    _break: createKeyword("break"),
    _case: createKeyword("case", {
      beforeExpr: beforeExpr
    }),
    _catch: createKeyword("catch"),
    _continue: createKeyword("continue"),
    _debugger: createKeyword("debugger"),
    _default: createKeyword("default", {
      beforeExpr: beforeExpr
    }),
    _else: createKeyword("else", {
      beforeExpr: beforeExpr
    }),
    _finally: createKeyword("finally"),
    _function: createKeyword("function", {
      startsExpr: startsExpr
    }),
    _if: createKeyword("if"),
    _return: createKeyword("return", {
      beforeExpr: beforeExpr
    }),
    _switch: createKeyword("switch"),
    _throw: createKeyword("throw", {
      beforeExpr: beforeExpr,
      prefix: prefix,
      startsExpr: startsExpr
    }),
    _try: createKeyword("try"),
    _var: createKeyword("var"),
    _const: createKeyword("const"),
    _with: createKeyword("with"),
    _new: createKeyword("new", {
      beforeExpr: beforeExpr,
      startsExpr: startsExpr
    }),
    _this: createKeyword("this", {
      startsExpr: startsExpr
    }),
    _super: createKeyword("super", {
      startsExpr: startsExpr
    }),
    _class: createKeyword("class", {
      startsExpr: startsExpr
    }),
    _extends: createKeyword("extends", {
      beforeExpr: beforeExpr
    }),
    _export: createKeyword("export"),
    _import: createKeyword("import", {
      startsExpr: startsExpr
    }),
    _null: createKeyword("null", {
      startsExpr: startsExpr
    }),
    _true: createKeyword("true", {
      startsExpr: startsExpr
    }),
    _false: createKeyword("false", {
      startsExpr: startsExpr
    }),
    _typeof: createKeyword("typeof", {
      beforeExpr: beforeExpr,
      prefix: prefix,
      startsExpr: startsExpr
    }),
    _void: createKeyword("void", {
      beforeExpr: beforeExpr,
      prefix: prefix,
      startsExpr: startsExpr
    }),
    _delete: createKeyword("delete", {
      beforeExpr: beforeExpr,
      prefix: prefix,
      startsExpr: startsExpr
    }),
    _do: createKeyword("do", {
      isLoop: isLoop,
      beforeExpr: beforeExpr
    }),
    _for: createKeyword("for", {
      isLoop: isLoop
    }),
    _while: createKeyword("while", {
      isLoop: isLoop
    }),
    _as: createKeywordLike("as", {
      startsExpr: startsExpr
    }),
    _assert: createKeywordLike("assert", {
      startsExpr: startsExpr
    }),
    _async: createKeywordLike("async", {
      startsExpr: startsExpr
    }),
    _await: createKeywordLike("await", {
      startsExpr: startsExpr
    }),
    _defer: createKeywordLike("defer", {
      startsExpr: startsExpr
    }),
    _from: createKeywordLike("from", {
      startsExpr: startsExpr
    }),
    _get: createKeywordLike("get", {
      startsExpr: startsExpr
    }),
    _let: createKeywordLike("let", {
      startsExpr: startsExpr
    }),
    _meta: createKeywordLike("meta", {
      startsExpr: startsExpr
    }),
    _of: createKeywordLike("of", {
      startsExpr: startsExpr
    }),
    _sent: createKeywordLike("sent", {
      startsExpr: startsExpr
    }),
    _set: createKeywordLike("set", {
      startsExpr: startsExpr
    }),
    _source: createKeywordLike("source", {
      startsExpr: startsExpr
    }),
    _static: createKeywordLike("static", {
      startsExpr: startsExpr
    }),
    _using: createKeywordLike("using", {
      startsExpr: startsExpr
    }),
    _yield: createKeywordLike("yield", {
      startsExpr: startsExpr
    }),
    _asserts: createKeywordLike("asserts", {
      startsExpr: startsExpr
    }),
    _checks: createKeywordLike("checks", {
      startsExpr: startsExpr
    }),
    _exports: createKeywordLike("exports", {
      startsExpr: startsExpr
    }),
    _global: createKeywordLike("global", {
      startsExpr: startsExpr
    }),
    _implements: createKeywordLike("implements", {
      startsExpr: startsExpr
    }),
    _intrinsic: createKeywordLike("intrinsic", {
      startsExpr: startsExpr
    }),
    _infer: createKeywordLike("infer", {
      startsExpr: startsExpr
    }),
    _is: createKeywordLike("is", {
      startsExpr: startsExpr
    }),
    _mixins: createKeywordLike("mixins", {
      startsExpr: startsExpr
    }),
    _proto: createKeywordLike("proto", {
      startsExpr: startsExpr
    }),
    _require: createKeywordLike("require", {
      startsExpr: startsExpr
    }),
    _satisfies: createKeywordLike("satisfies", {
      startsExpr: startsExpr
    }),
    _keyof: createKeywordLike("keyof", {
      startsExpr: startsExpr
    }),
    _readonly: createKeywordLike("readonly", {
      startsExpr: startsExpr
    }),
    _unique: createKeywordLike("unique", {
      startsExpr: startsExpr
    }),
    _abstract: createKeywordLike("abstract", {
      startsExpr: startsExpr
    }),
    _declare: createKeywordLike("declare", {
      startsExpr: startsExpr
    }),
    _enum: createKeywordLike("enum", {
      startsExpr: startsExpr
    }),
    _module: createKeywordLike("module", {
      startsExpr: startsExpr
    }),
    _namespace: createKeywordLike("namespace", {
      startsExpr: startsExpr
    }),
    _interface: createKeywordLike("interface", {
      startsExpr: startsExpr
    }),
    _type: createKeywordLike("type", {
      startsExpr: startsExpr
    }),
    _opaque: createKeywordLike("opaque", {
      startsExpr: startsExpr
    }),
    name: createToken("name", {
      startsExpr: startsExpr
    }),
    placeholder: createToken("%%", {
      startsExpr: startsExpr
    }),
    string: createToken("string", {
      startsExpr: startsExpr
    }),
    num: createToken("num", {
      startsExpr: startsExpr
    }),
    bigint: createToken("bigint", {
      startsExpr: startsExpr
    }),
    decimal: createToken("decimal", {
      startsExpr: startsExpr
    }),
    regexp: createToken("regexp", {
      startsExpr: startsExpr
    }),
    privateName: createToken("#name", {
      startsExpr: startsExpr
    }),
    eof: createToken("eof"),
    jsxName: createToken("jsxName"),
    jsxText: createToken("jsxText", {
      beforeExpr: beforeExpr
    }),
    jsxTagStart: createToken("jsxTagStart", {
      startsExpr: startsExpr
    }),
    jsxTagEnd: createToken("jsxTagEnd")
  };
  function tokenIsIdentifier(token) {
    return token >= 93 && token <= 133;
  }
  function tokenKeywordOrIdentifierIsKeyword(token) {
    return token <= 92;
  }
  function tokenIsKeywordOrIdentifier(token) {
    return token >= 58 && token <= 133;
  }
  function tokenIsLiteralPropertyName(token) {
    return token >= 58 && token <= 137;
  }
  function tokenComesBeforeExpression(token) {
    return tokenBeforeExprs[token];
  }
  function tokenCanStartExpression(token) {
    return tokenStartsExprs[token];
  }
  function tokenIsAssignment(token) {
    return token >= 29 && token <= 33;
  }
  function tokenIsFlowInterfaceOrTypeOrOpaque(token) {
    return token >= 129 && token <= 131;
  }
  function tokenIsLoop(token) {
    return token >= 90 && token <= 92;
  }
  function tokenIsKeyword(token) {
    return token >= 58 && token <= 92;
  }
  function tokenIsOperator(token) {
    return token >= 39 && token <= 59;
  }
  function tokenIsPostfix(token) {
    return token === 34;
  }
  function tokenIsPrefix(token) {
    return tokenPrefixes[token];
  }
  function tokenIsTSTypeOperator(token) {
    return token >= 121 && token <= 123;
  }
  function tokenIsTSDeclarationStart(token) {
    return token >= 124 && token <= 130;
  }
  function tokenLabelName(token) {
    return tokenLabels[token];
  }
  function tokenOperatorPrecedence(token) {
    return tokenBinops[token];
  }
  function tokenIsRightAssociative(token) {
    return token === 57;
  }
  function tokenIsTemplate(token) {
    return token >= 24 && token <= 25;
  }
  function getExportedToken(token) {
    return tokenTypes[token];
  }
  {
    tokenTypes[8].updateContext = function (context) {
      context.pop();
    };
    tokenTypes[5].updateContext = tokenTypes[7].updateContext = tokenTypes[23].updateContext = function (context) {
      context.push(types.brace);
    };
    tokenTypes[22].updateContext = function (context) {
      if (context[context.length - 1] === types.template) {
        context.pop();
      } else {
        context.push(types.template);
      }
    };
    tokenTypes[143].updateContext = function (context) {
      context.push(types.j_expr, types.j_oTag);
    };
  }

  function isIteratorStart(current, next, next2) {
    return current === 64 && next === 64 && isIdentifierStart(next2);
  }
  var reservedWordLikeSet = new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete", "implements", "interface", "let", "package", "private", "protected", "public", "static", "yield", "eval", "arguments", "enum", "await"]);
  function canBeReservedWord(word) {
    return reservedWordLikeSet.has(word);
  }

  var ScopeFlag = {
    OTHER: 0,
    PROGRAM: 1,
    FUNCTION_BASE: 2,
    ARROW: 4,
    SIMPLE_CATCH: 8,
    SUPER: 16,
    DIRECT_SUPER: 32,
    CLASS_BASE: 64,
    STATIC_BLOCK: 128,
    SWITCH: 256,
    NEW_TARGET: 512,
    TS_MODULE: 1024,
    FUNCTION: 514,
    CLASS: 576,
    VAR: 1667
  };
  var BindingFlag = {
    KIND_VALUE: 1,
    KIND_TYPE: 2,
    SCOPE_VAR: 4,
    SCOPE_LEXICAL: 8,
    SCOPE_FUNCTION: 16,
    SCOPE_OUTSIDE: 32,
    FLAG_NONE: 64,
    FLAG_CLASS: 128,
    FLAG_TS_ENUM: 256,
    FLAG_TS_CONST_ENUM: 512,
    FLAG_TS_EXPORT_ONLY: 1024,
    FLAG_FLOW_DECLARE_FN: 2048,
    FLAG_TS_IMPORT: 4096,
    FLAG_NO_LET_IN_LEXICAL: 8192,
    TYPE_CLASS: 8331,
    TYPE_LEXICAL: 8201,
    TYPE_CATCH_PARAM: 9,
    TYPE_VAR: 5,
    TYPE_FUNCTION: 17,
    TYPE_TS_INTERFACE: 130,
    TYPE_TS_TYPE: 2,
    TYPE_TS_ENUM: 8459,
    TYPE_TS_AMBIENT: 1024,
    TYPE_NONE: 64,
    TYPE_OUTSIDE: 65,
    TYPE_TS_CONST_ENUM: 8971,
    TYPE_TS_NAMESPACE: 1024,
    TYPE_TS_TYPE_IMPORT: 4098,
    TYPE_TS_VALUE_IMPORT: 4096,
    TYPE_FLOW_DECLARE_FN: 2048
  };
  var ClassElementType = {
    OTHER: 0,
    FLAG_STATIC: 4,
    KIND_GETTER: 2,
    KIND_SETTER: 1,
    KIND_ACCESSOR: 3,
    STATIC_GETTER: 6,
    STATIC_SETTER: 5,
    INSTANCE_GETTER: 2,
    INSTANCE_SETTER: 1
  };

  var NameType = {
    Var: 1,
    Lexical: 2,
    Function: 4
  };
  var Scope$2 = _createClass(function Scope(flags) {
    this.flags = 0;
    this.names = new Map();
    this.firstLexicalName = "";
    this.flags = flags;
  });
  var ScopeHandler = function () {
    function ScopeHandler(parser, inModule) {
      this.parser = void 0;
      this.scopeStack = [];
      this.inModule = void 0;
      this.undefinedExports = new Map();
      this.parser = parser;
      this.inModule = inModule;
    }
    var _proto = ScopeHandler.prototype;
    _proto.createScope = function createScope(flags) {
      return new Scope$2(flags);
    };
    _proto.enter = function enter(flags) {
      this.scopeStack.push(this.createScope(flags));
    };
    _proto.exit = function exit() {
      var scope = this.scopeStack.pop();
      return scope.flags;
    };
    _proto.treatFunctionsAsVarInScope = function treatFunctionsAsVarInScope(scope) {
      return !!(scope.flags & (ScopeFlag.FUNCTION_BASE | ScopeFlag.STATIC_BLOCK) || !this.parser.inModule && scope.flags & ScopeFlag.PROGRAM);
    };
    _proto.declareName = function declareName(name, bindingType, loc) {
      var scope = this.currentScope();
      if (bindingType & BindingFlag.SCOPE_LEXICAL || bindingType & BindingFlag.SCOPE_FUNCTION) {
        this.checkRedeclarationInScope(scope, name, bindingType, loc);
        var type = scope.names.get(name) || 0;
        if (bindingType & BindingFlag.SCOPE_FUNCTION) {
          type = type | NameType.Function;
        } else {
          if (!scope.firstLexicalName) {
            scope.firstLexicalName = name;
          }
          type = type | NameType.Lexical;
        }
        scope.names.set(name, type);
        if (bindingType & BindingFlag.SCOPE_LEXICAL) {
          this.maybeExportDefined(scope, name);
        }
      } else if (bindingType & BindingFlag.SCOPE_VAR) {
        for (var i = this.scopeStack.length - 1; i >= 0; --i) {
          scope = this.scopeStack[i];
          this.checkRedeclarationInScope(scope, name, bindingType, loc);
          scope.names.set(name, (scope.names.get(name) || 0) | NameType.Var);
          this.maybeExportDefined(scope, name);
          if (scope.flags & ScopeFlag.VAR) break;
        }
      }
      if (this.parser.inModule && scope.flags & ScopeFlag.PROGRAM) {
        this.undefinedExports["delete"](name);
      }
    };
    _proto.maybeExportDefined = function maybeExportDefined(scope, name) {
      if (this.parser.inModule && scope.flags & ScopeFlag.PROGRAM) {
        this.undefinedExports["delete"](name);
      }
    };
    _proto.checkRedeclarationInScope = function checkRedeclarationInScope(scope, name, bindingType, loc) {
      if (this.isRedeclaredInScope(scope, name, bindingType)) {
        this.parser.raise(Errors.VarRedeclaration, loc, {
          identifierName: name
        });
      }
    };
    _proto.isRedeclaredInScope = function isRedeclaredInScope(scope, name, bindingType) {
      if (!(bindingType & BindingFlag.KIND_VALUE)) return false;
      if (bindingType & BindingFlag.SCOPE_LEXICAL) {
        return scope.names.has(name);
      }
      var type = scope.names.get(name);
      if (bindingType & BindingFlag.SCOPE_FUNCTION) {
        return (type & NameType.Lexical) > 0 || !this.treatFunctionsAsVarInScope(scope) && (type & NameType.Var) > 0;
      }
      return (type & NameType.Lexical) > 0 && !(scope.flags & ScopeFlag.SIMPLE_CATCH && scope.firstLexicalName === name) || !this.treatFunctionsAsVarInScope(scope) && (type & NameType.Function) > 0;
    };
    _proto.checkLocalExport = function checkLocalExport(id) {
      var name = id.name;
      var topLevelScope = this.scopeStack[0];
      if (!topLevelScope.names.has(name)) {
        this.undefinedExports.set(name, id.loc.start);
      }
    };
    _proto.currentScope = function currentScope() {
      return this.scopeStack[this.scopeStack.length - 1];
    };
    _proto.currentVarScopeFlags = function currentVarScopeFlags() {
      for (var i = this.scopeStack.length - 1;; i--) {
        var flags = this.scopeStack[i].flags;
        if (flags & ScopeFlag.VAR) {
          return flags;
        }
      }
    };
    _proto.currentThisScopeFlags = function currentThisScopeFlags() {
      for (var i = this.scopeStack.length - 1;; i--) {
        var flags = this.scopeStack[i].flags;
        if (flags & (ScopeFlag.VAR | ScopeFlag.CLASS_BASE) && !(flags & ScopeFlag.ARROW)) {
          return flags;
        }
      }
    };
    return _createClass(ScopeHandler, [{
      key: "inTopLevel",
      get: function get() {
        return (this.currentScope().flags & ScopeFlag.PROGRAM) > 0;
      }
    }, {
      key: "inFunction",
      get: function get() {
        return (this.currentVarScopeFlags() & ScopeFlag.FUNCTION_BASE) > 0;
      }
    }, {
      key: "allowSuper",
      get: function get() {
        return (this.currentThisScopeFlags() & ScopeFlag.SUPER) > 0;
      }
    }, {
      key: "allowDirectSuper",
      get: function get() {
        return (this.currentThisScopeFlags() & ScopeFlag.DIRECT_SUPER) > 0;
      }
    }, {
      key: "allowNewTarget",
      get: function get() {
        return (this.currentThisScopeFlags() & ScopeFlag.NEW_TARGET) > 0;
      }
    }, {
      key: "inClass",
      get: function get() {
        return (this.currentThisScopeFlags() & ScopeFlag.CLASS_BASE) > 0;
      }
    }, {
      key: "inClassAndNotInNonArrowFunction",
      get: function get() {
        var flags = this.currentThisScopeFlags();
        return (flags & ScopeFlag.CLASS_BASE) > 0 && (flags & ScopeFlag.FUNCTION_BASE) === 0;
      }
    }, {
      key: "inStaticBlock",
      get: function get() {
        for (var i = this.scopeStack.length - 1;; i--) {
          var flags = this.scopeStack[i].flags;
          if (flags & ScopeFlag.STATIC_BLOCK) {
            return true;
          }
          if (flags & (ScopeFlag.VAR | ScopeFlag.CLASS_BASE)) {
            return false;
          }
        }
      }
    }, {
      key: "inNonArrowFunction",
      get: function get() {
        return (this.currentThisScopeFlags() & ScopeFlag.FUNCTION_BASE) > 0;
      }
    }, {
      key: "inBareCaseStatement",
      get: function get() {
        return (this.currentScope().flags & ScopeFlag.SWITCH) > 0;
      }
    }, {
      key: "treatFunctionsAsVar",
      get: function get() {
        return this.treatFunctionsAsVarInScope(this.currentScope());
      }
    }]);
  }();

  var FlowScope = function (_Scope) {
    function FlowScope() {
      var _this;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _Scope.call.apply(_Scope, [this].concat(args)) || this;
      _this.declareFunctions = new Set();
      return _this;
    }
    _inherits(FlowScope, _Scope);
    return _createClass(FlowScope);
  }(Scope$2);
  var FlowScopeHandler = function (_ScopeHandler) {
    function FlowScopeHandler() {
      return _ScopeHandler.apply(this, arguments) || this;
    }
    _inherits(FlowScopeHandler, _ScopeHandler);
    var _proto = FlowScopeHandler.prototype;
    _proto.createScope = function createScope(flags) {
      return new FlowScope(flags);
    };
    _proto.declareName = function declareName(name, bindingType, loc) {
      var scope = this.currentScope();
      if (bindingType & BindingFlag.FLAG_FLOW_DECLARE_FN) {
        this.checkRedeclarationInScope(scope, name, bindingType, loc);
        this.maybeExportDefined(scope, name);
        scope.declareFunctions.add(name);
        return;
      }
      _ScopeHandler.prototype.declareName.call(this, name, bindingType, loc);
    };
    _proto.isRedeclaredInScope = function isRedeclaredInScope(scope, name, bindingType) {
      if (_ScopeHandler.prototype.isRedeclaredInScope.call(this, scope, name, bindingType)) return true;
      if (bindingType & BindingFlag.FLAG_FLOW_DECLARE_FN && !scope.declareFunctions.has(name)) {
        var type = scope.names.get(name);
        return (type & NameType.Function) > 0 || (type & NameType.Lexical) > 0;
      }
      return false;
    };
    _proto.checkLocalExport = function checkLocalExport(id) {
      if (!this.scopeStack[0].declareFunctions.has(id.name)) {
        _ScopeHandler.prototype.checkLocalExport.call(this, id);
      }
    };
    return _createClass(FlowScopeHandler);
  }(ScopeHandler);

  var _templateObject$L;
  var reservedTypes = new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "static", "string", "true", "typeof", "void"]);
  var FlowErrors = ParseErrorEnum(_templateObject$L || (_templateObject$L = _taggedTemplateLiteralLoose(["flow"])))({
    AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.",
    AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.",
    AssignReservedType: function AssignReservedType(_ref) {
      var reservedType = _ref.reservedType;
      return "Cannot overwrite reserved type " + reservedType + ".";
    },
    DeclareClassElement: "The `declare` modifier can only appear on class fields.",
    DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.",
    DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.",
    EnumBooleanMemberNotInitialized: function EnumBooleanMemberNotInitialized(_ref2) {
      var memberName = _ref2.memberName,
        enumName = _ref2.enumName;
      return "Boolean enum members need to be initialized. Use either `" + memberName + " = true,` or `" + memberName + " = false,` in enum `" + enumName + "`.";
    },
    EnumDuplicateMemberName: function EnumDuplicateMemberName(_ref3) {
      var memberName = _ref3.memberName,
        enumName = _ref3.enumName;
      return "Enum member names need to be unique, but the name `" + memberName + "` has already been used before in enum `" + enumName + "`.";
    },
    EnumInconsistentMemberValues: function EnumInconsistentMemberValues(_ref4) {
      var enumName = _ref4.enumName;
      return "Enum `" + enumName + "` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.";
    },
    EnumInvalidExplicitType: function EnumInvalidExplicitType(_ref5) {
      var invalidEnumType = _ref5.invalidEnumType,
        enumName = _ref5.enumName;
      return "Enum type `" + invalidEnumType + "` is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `" + enumName + "`.";
    },
    EnumInvalidExplicitTypeUnknownSupplied: function EnumInvalidExplicitTypeUnknownSupplied(_ref6) {
      var enumName = _ref6.enumName;
      return "Supplied enum type is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `" + enumName + "`.";
    },
    EnumInvalidMemberInitializerPrimaryType: function EnumInvalidMemberInitializerPrimaryType(_ref7) {
      var enumName = _ref7.enumName,
        memberName = _ref7.memberName,
        explicitType = _ref7.explicitType;
      return "Enum `" + enumName + "` has type `" + explicitType + "`, so the initializer of `" + memberName + "` needs to be a " + explicitType + " literal.";
    },
    EnumInvalidMemberInitializerSymbolType: function EnumInvalidMemberInitializerSymbolType(_ref8) {
      var enumName = _ref8.enumName,
        memberName = _ref8.memberName;
      return "Symbol enum members cannot be initialized. Use `" + memberName + ",` in enum `" + enumName + "`.";
    },
    EnumInvalidMemberInitializerUnknownType: function EnumInvalidMemberInitializerUnknownType(_ref9) {
      var enumName = _ref9.enumName,
        memberName = _ref9.memberName;
      return "The enum member initializer for `" + memberName + "` needs to be a literal (either a boolean, number, or string) in enum `" + enumName + "`.";
    },
    EnumInvalidMemberName: function EnumInvalidMemberName(_ref0) {
      var enumName = _ref0.enumName,
        memberName = _ref0.memberName,
        suggestion = _ref0.suggestion;
      return "Enum member names cannot start with lowercase 'a' through 'z'. Instead of using `" + memberName + "`, consider using `" + suggestion + "`, in enum `" + enumName + "`.";
    },
    EnumNumberMemberNotInitialized: function EnumNumberMemberNotInitialized(_ref1) {
      var enumName = _ref1.enumName,
        memberName = _ref1.memberName;
      return "Number enum members need to be initialized, e.g. `" + memberName + " = 1` in enum `" + enumName + "`.";
    },
    EnumStringMemberInconsistentlyInitialized: function EnumStringMemberInconsistentlyInitialized(_ref10) {
      var enumName = _ref10.enumName;
      return "String enum members need to consistently either all use initializers, or use no initializers, in enum `" + enumName + "`.";
    },
    GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.",
    ImportReflectionHasImportType: "An `import module` declaration can not use `type` or `typeof` keyword.",
    ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.",
    InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.",
    InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.",
    InexactVariance: "Explicit inexact syntax cannot have variance.",
    InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.",
    MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.",
    NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.",
    NestedFlowComment: "Cannot have a flow comment inside another flow comment.",
    PatternIsOptional: Object.assign({
      message: "A binding pattern parameter cannot be optional in an implementation signature."
    }, {
      reasonCode: "OptionalBindingPattern"
    }),
    SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.",
    SpreadVariance: "Spread properties cannot have variance.",
    ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.",
    ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.",
    ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.",
    ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.",
    ThisParamNoDefault: "The `this` parameter may not have a default value.",
    TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
    TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.",
    UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.",
    UnexpectedReservedType: function UnexpectedReservedType(_ref11) {
      var reservedType = _ref11.reservedType;
      return "Unexpected reserved type " + reservedType + ".";
    },
    UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.",
    UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.",
    UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.",
    UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".',
    UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.",
    UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.",
    UnsupportedDeclareExportKind: function UnsupportedDeclareExportKind(_ref12) {
      var unsupportedExportKind = _ref12.unsupportedExportKind,
        suggestion = _ref12.suggestion;
      return "`declare export " + unsupportedExportKind + "` is not supported. Use `" + suggestion + "` instead.";
    },
    UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.",
    UnterminatedFlowComment: "Unterminated flow-comment."
  });
  function isEsModuleType(bodyElement) {
    return bodyElement.type === "DeclareExportAllDeclaration" || bodyElement.type === "DeclareExportDeclaration" && (!bodyElement.declaration || bodyElement.declaration.type !== "TypeAlias" && bodyElement.declaration.type !== "InterfaceDeclaration");
  }
  function hasTypeImportKind(node) {
    return node.importKind === "type" || node.importKind === "typeof";
  }
  var exportSuggestions = {
    "const": "declare export var",
    "let": "declare export var",
    type: "export type",
    "interface": "export interface"
  };
  function partition(list, test) {
    var list1 = [];
    var list2 = [];
    for (var i = 0; i < list.length; i++) {
      (test(list[i], i, list) ? list1 : list2).push(list[i]);
    }
    return [list1, list2];
  }
  var FLOW_PRAGMA_REGEX = /\*?\s*@((?:no)?flow)\b/;
  var flow = (function (superClass) {
    return function (_superClass) {
      function FlowParserMixin() {
        var _this2;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this2 = _superClass.call.apply(_superClass, [this].concat(args)) || this;
        _this2.flowPragma = undefined;
        return _this2;
      }
      _inherits(FlowParserMixin, _superClass);
      var _proto = FlowParserMixin.prototype;
      _proto.getScopeHandler = function getScopeHandler() {
        return FlowScopeHandler;
      };
      _proto.shouldParseTypes = function shouldParseTypes() {
        return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
      };
      _proto.finishToken = function finishToken(type, val) {
        if (type !== 134 && type !== 13 && type !== 28) {
          if (this.flowPragma === undefined) {
            this.flowPragma = null;
          }
        }
        _superClass.prototype.finishToken.call(this, type, val);
      };
      _proto.addComment = function addComment(comment) {
        if (this.flowPragma === undefined) {
          var matches = FLOW_PRAGMA_REGEX.exec(comment.value);
          if (!matches) ; else if (matches[1] === "flow") {
            this.flowPragma = "flow";
          } else if (matches[1] === "noflow") {
            this.flowPragma = "noflow";
          } else {
            throw new Error("Unexpected flow pragma");
          }
        }
        _superClass.prototype.addComment.call(this, comment);
      };
      _proto.flowParseTypeInitialiser = function flowParseTypeInitialiser(tok) {
        var oldInType = this.state.inType;
        this.state.inType = true;
        this.expect(tok || 14);
        var type = this.flowParseType();
        this.state.inType = oldInType;
        return type;
      };
      _proto.flowParsePredicate = function flowParsePredicate() {
        var node = this.startNode();
        var moduloLoc = this.state.startLoc;
        this.next();
        this.expectContextual(110);
        if (this.state.lastTokStartLoc.index > moduloLoc.index + 1) {
          this.raise(FlowErrors.UnexpectedSpaceBetweenModuloChecks, moduloLoc);
        }
        if (this.eat(10)) {
          node.value = _superClass.prototype.parseExpression.call(this);
          this.expect(11);
          return this.finishNode(node, "DeclaredPredicate");
        } else {
          return this.finishNode(node, "InferredPredicate");
        }
      };
      _proto.flowParseTypeAndPredicateInitialiser = function flowParseTypeAndPredicateInitialiser() {
        var oldInType = this.state.inType;
        this.state.inType = true;
        this.expect(14);
        var type = null;
        var predicate = null;
        if (this.match(54)) {
          this.state.inType = oldInType;
          predicate = this.flowParsePredicate();
        } else {
          type = this.flowParseType();
          this.state.inType = oldInType;
          if (this.match(54)) {
            predicate = this.flowParsePredicate();
          }
        }
        return [type, predicate];
      };
      _proto.flowParseDeclareClass = function flowParseDeclareClass(node) {
        this.next();
        this.flowParseInterfaceish(node, true);
        return this.finishNode(node, "DeclareClass");
      };
      _proto.flowParseDeclareFunction = function flowParseDeclareFunction(node) {
        this.next();
        var id = node.id = this.parseIdentifier();
        var typeNode = this.startNode();
        var typeContainer = this.startNode();
        if (this.match(47)) {
          typeNode.typeParameters = this.flowParseTypeParameterDeclaration();
        } else {
          typeNode.typeParameters = null;
        }
        this.expect(10);
        var tmp = this.flowParseFunctionTypeParams();
        typeNode.params = tmp.params;
        typeNode.rest = tmp.rest;
        typeNode["this"] = tmp._this;
        this.expect(11);
        var _this$flowParseTypeAn = this.flowParseTypeAndPredicateInitialiser();
        typeNode.returnType = _this$flowParseTypeAn[0];
        node.predicate = _this$flowParseTypeAn[1];
        typeContainer.typeAnnotation = this.finishNode(typeNode, "FunctionTypeAnnotation");
        id.typeAnnotation = this.finishNode(typeContainer, "TypeAnnotation");
        this.resetEndLocation(id);
        this.semicolon();
        this.scope.declareName(node.id.name, BindingFlag.TYPE_FLOW_DECLARE_FN, node.id.loc.start);
        return this.finishNode(node, "DeclareFunction");
      };
      _proto.flowParseDeclare = function flowParseDeclare(node, insideModule) {
        if (this.match(80)) {
          return this.flowParseDeclareClass(node);
        } else if (this.match(68)) {
          return this.flowParseDeclareFunction(node);
        } else if (this.match(74)) {
          return this.flowParseDeclareVariable(node);
        } else if (this.eatContextual(127)) {
          if (this.match(16)) {
            return this.flowParseDeclareModuleExports(node);
          } else {
            if (insideModule) {
              this.raise(FlowErrors.NestedDeclareModule, this.state.lastTokStartLoc);
            }
            return this.flowParseDeclareModule(node);
          }
        } else if (this.isContextual(130)) {
          return this.flowParseDeclareTypeAlias(node);
        } else if (this.isContextual(131)) {
          return this.flowParseDeclareOpaqueType(node);
        } else if (this.isContextual(129)) {
          return this.flowParseDeclareInterface(node);
        } else if (this.match(82)) {
          return this.flowParseDeclareExportDeclaration(node, insideModule);
        } else {
          this.unexpected();
        }
      };
      _proto.flowParseDeclareVariable = function flowParseDeclareVariable(node) {
        this.next();
        node.id = this.flowParseTypeAnnotatableIdentifier(true);
        this.scope.declareName(node.id.name, BindingFlag.TYPE_VAR, node.id.loc.start);
        this.semicolon();
        return this.finishNode(node, "DeclareVariable");
      };
      _proto.flowParseDeclareModule = function flowParseDeclareModule(node) {
        var _this3 = this;
        this.scope.enter(ScopeFlag.OTHER);
        if (this.match(134)) {
          node.id = _superClass.prototype.parseExprAtom.call(this);
        } else {
          node.id = this.parseIdentifier();
        }
        var bodyNode = node.body = this.startNode();
        var body = bodyNode.body = [];
        this.expect(5);
        while (!this.match(8)) {
          var _bodyNode = this.startNode();
          if (this.match(83)) {
            this.next();
            if (!this.isContextual(130) && !this.match(87)) {
              this.raise(FlowErrors.InvalidNonTypeImportInDeclareModule, this.state.lastTokStartLoc);
            }
            _superClass.prototype.parseImport.call(this, _bodyNode);
          } else {
            this.expectContextual(125, FlowErrors.UnsupportedStatementInDeclareModule);
            _bodyNode = this.flowParseDeclare(_bodyNode, true);
          }
          body.push(_bodyNode);
        }
        this.scope.exit();
        this.expect(8);
        this.finishNode(bodyNode, "BlockStatement");
        var kind = null;
        var hasModuleExport = false;
        body.forEach(function (bodyElement) {
          if (isEsModuleType(bodyElement)) {
            if (kind === "CommonJS") {
              _this3.raise(FlowErrors.AmbiguousDeclareModuleKind, bodyElement);
            }
            kind = "ES";
          } else if (bodyElement.type === "DeclareModuleExports") {
            if (hasModuleExport) {
              _this3.raise(FlowErrors.DuplicateDeclareModuleExports, bodyElement);
            }
            if (kind === "ES") {
              _this3.raise(FlowErrors.AmbiguousDeclareModuleKind, bodyElement);
            }
            kind = "CommonJS";
            hasModuleExport = true;
          }
        });
        node.kind = kind || "CommonJS";
        return this.finishNode(node, "DeclareModule");
      };
      _proto.flowParseDeclareExportDeclaration = function flowParseDeclareExportDeclaration(node, insideModule) {
        this.expect(82);
        if (this.eat(65)) {
          if (this.match(68) || this.match(80)) {
            node.declaration = this.flowParseDeclare(this.startNode());
          } else {
            node.declaration = this.flowParseType();
            this.semicolon();
          }
          node["default"] = true;
          return this.finishNode(node, "DeclareExportDeclaration");
        } else {
          if (this.match(75) || this.isLet() || (this.isContextual(130) || this.isContextual(129)) && !insideModule) {
            var label = this.state.value;
            throw this.raise(FlowErrors.UnsupportedDeclareExportKind, this.state.startLoc, {
              unsupportedExportKind: label,
              suggestion: exportSuggestions[label]
            });
          }
          if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(131)) {
            node.declaration = this.flowParseDeclare(this.startNode());
            node["default"] = false;
            return this.finishNode(node, "DeclareExportDeclaration");
          } else if (this.match(55) || this.match(5) || this.isContextual(129) || this.isContextual(130) || this.isContextual(131)) {
            node = this.parseExport(node, null);
            if (node.type === "ExportNamedDeclaration") {
              node["default"] = false;
              delete node.exportKind;
              return this.castNodeTo(node, "DeclareExportDeclaration");
            } else {
              return this.castNodeTo(node, "DeclareExportAllDeclaration");
            }
          }
        }
        this.unexpected();
      };
      _proto.flowParseDeclareModuleExports = function flowParseDeclareModuleExports(node) {
        this.next();
        this.expectContextual(111);
        node.typeAnnotation = this.flowParseTypeAnnotation();
        this.semicolon();
        return this.finishNode(node, "DeclareModuleExports");
      };
      _proto.flowParseDeclareTypeAlias = function flowParseDeclareTypeAlias(node) {
        this.next();
        var finished = this.flowParseTypeAlias(node);
        this.castNodeTo(finished, "DeclareTypeAlias");
        return finished;
      };
      _proto.flowParseDeclareOpaqueType = function flowParseDeclareOpaqueType(node) {
        this.next();
        var finished = this.flowParseOpaqueType(node, true);
        this.castNodeTo(finished, "DeclareOpaqueType");
        return finished;
      };
      _proto.flowParseDeclareInterface = function flowParseDeclareInterface(node) {
        this.next();
        this.flowParseInterfaceish(node, false);
        return this.finishNode(node, "DeclareInterface");
      };
      _proto.flowParseInterfaceish = function flowParseInterfaceish(node, isClass) {
        node.id = this.flowParseRestrictedIdentifier(!isClass, true);
        this.scope.declareName(node.id.name, isClass ? BindingFlag.TYPE_FUNCTION : BindingFlag.TYPE_LEXICAL, node.id.loc.start);
        if (this.match(47)) {
          node.typeParameters = this.flowParseTypeParameterDeclaration();
        } else {
          node.typeParameters = null;
        }
        node["extends"] = [];
        if (this.eat(81)) {
          do {
            node["extends"].push(this.flowParseInterfaceExtends());
          } while (!isClass && this.eat(12));
        }
        if (isClass) {
          node["implements"] = [];
          node.mixins = [];
          if (this.eatContextual(117)) {
            do {
              node.mixins.push(this.flowParseInterfaceExtends());
            } while (this.eat(12));
          }
          if (this.eatContextual(113)) {
            do {
              node["implements"].push(this.flowParseInterfaceExtends());
            } while (this.eat(12));
          }
        }
        node.body = this.flowParseObjectType({
          allowStatic: isClass,
          allowExact: false,
          allowSpread: false,
          allowProto: isClass,
          allowInexact: false
        });
      };
      _proto.flowParseInterfaceExtends = function flowParseInterfaceExtends() {
        var node = this.startNode();
        node.id = this.flowParseQualifiedTypeIdentifier();
        if (this.match(47)) {
          node.typeParameters = this.flowParseTypeParameterInstantiation();
        } else {
          node.typeParameters = null;
        }
        return this.finishNode(node, "InterfaceExtends");
      };
      _proto.flowParseInterface = function flowParseInterface(node) {
        this.flowParseInterfaceish(node, false);
        return this.finishNode(node, "InterfaceDeclaration");
      };
      _proto.checkNotUnderscore = function checkNotUnderscore(word) {
        if (word === "_") {
          this.raise(FlowErrors.UnexpectedReservedUnderscore, this.state.startLoc);
        }
      };
      _proto.checkReservedType = function checkReservedType(word, startLoc, declaration) {
        if (!reservedTypes.has(word)) return;
        this.raise(declaration ? FlowErrors.AssignReservedType : FlowErrors.UnexpectedReservedType, startLoc, {
          reservedType: word
        });
      };
      _proto.flowParseRestrictedIdentifier = function flowParseRestrictedIdentifier(liberal, declaration) {
        this.checkReservedType(this.state.value, this.state.startLoc, declaration);
        return this.parseIdentifier(liberal);
      };
      _proto.flowParseTypeAlias = function flowParseTypeAlias(node) {
        node.id = this.flowParseRestrictedIdentifier(false, true);
        this.scope.declareName(node.id.name, BindingFlag.TYPE_LEXICAL, node.id.loc.start);
        if (this.match(47)) {
          node.typeParameters = this.flowParseTypeParameterDeclaration();
        } else {
          node.typeParameters = null;
        }
        node.right = this.flowParseTypeInitialiser(29);
        this.semicolon();
        return this.finishNode(node, "TypeAlias");
      };
      _proto.flowParseOpaqueType = function flowParseOpaqueType(node, declare) {
        this.expectContextual(130);
        node.id = this.flowParseRestrictedIdentifier(true, true);
        this.scope.declareName(node.id.name, BindingFlag.TYPE_LEXICAL, node.id.loc.start);
        if (this.match(47)) {
          node.typeParameters = this.flowParseTypeParameterDeclaration();
        } else {
          node.typeParameters = null;
        }
        node.supertype = null;
        if (this.match(14)) {
          node.supertype = this.flowParseTypeInitialiser(14);
        }
        node.impltype = null;
        if (!declare) {
          node.impltype = this.flowParseTypeInitialiser(29);
        }
        this.semicolon();
        return this.finishNode(node, "OpaqueType");
      };
      _proto.flowParseTypeParameter = function flowParseTypeParameter(requireDefault) {
        if (requireDefault === void 0) {
          requireDefault = false;
        }
        var nodeStartLoc = this.state.startLoc;
        var node = this.startNode();
        var variance = this.flowParseVariance();
        var ident = this.flowParseTypeAnnotatableIdentifier();
        node.name = ident.name;
        node.variance = variance;
        node.bound = ident.typeAnnotation;
        if (this.match(29)) {
          this.eat(29);
          node["default"] = this.flowParseType();
        } else {
          if (requireDefault) {
            this.raise(FlowErrors.MissingTypeParamDefault, nodeStartLoc);
          }
        }
        return this.finishNode(node, "TypeParameter");
      };
      _proto.flowParseTypeParameterDeclaration = function flowParseTypeParameterDeclaration() {
        var oldInType = this.state.inType;
        var node = this.startNode();
        node.params = [];
        this.state.inType = true;
        if (this.match(47) || this.match(143)) {
          this.next();
        } else {
          this.unexpected();
        }
        var defaultRequired = false;
        do {
          var typeParameter = this.flowParseTypeParameter(defaultRequired);
          node.params.push(typeParameter);
          if (typeParameter["default"]) {
            defaultRequired = true;
          }
          if (!this.match(48)) {
            this.expect(12);
          }
        } while (!this.match(48));
        this.expect(48);
        this.state.inType = oldInType;
        return this.finishNode(node, "TypeParameterDeclaration");
      };
      _proto.flowInTopLevelContext = function flowInTopLevelContext(cb) {
        if (this.curContext() !== types.brace) {
          var oldContext = this.state.context;
          this.state.context = [oldContext[0]];
          try {
            return cb();
          } finally {
            this.state.context = oldContext;
          }
        } else {
          return cb();
        }
      };
      _proto.flowParseTypeParameterInstantiationInExpression = function flowParseTypeParameterInstantiationInExpression() {
        if (this.reScan_lt() !== 47) return;
        return this.flowParseTypeParameterInstantiation();
      };
      _proto.flowParseTypeParameterInstantiation = function flowParseTypeParameterInstantiation() {
        var _this4 = this;
        var node = this.startNode();
        var oldInType = this.state.inType;
        this.state.inType = true;
        node.params = [];
        this.flowInTopLevelContext(function () {
          _this4.expect(47);
          var oldNoAnonFunctionType = _this4.state.noAnonFunctionType;
          _this4.state.noAnonFunctionType = false;
          while (!_this4.match(48)) {
            node.params.push(_this4.flowParseType());
            if (!_this4.match(48)) {
              _this4.expect(12);
            }
          }
          _this4.state.noAnonFunctionType = oldNoAnonFunctionType;
        });
        this.state.inType = oldInType;
        if (!this.state.inType && this.curContext() === types.brace) {
          this.reScan_lt_gt();
        }
        this.expect(48);
        return this.finishNode(node, "TypeParameterInstantiation");
      };
      _proto.flowParseTypeParameterInstantiationCallOrNew = function flowParseTypeParameterInstantiationCallOrNew() {
        if (this.reScan_lt() !== 47) return;
        var node = this.startNode();
        var oldInType = this.state.inType;
        node.params = [];
        this.state.inType = true;
        this.expect(47);
        while (!this.match(48)) {
          node.params.push(this.flowParseTypeOrImplicitInstantiation());
          if (!this.match(48)) {
            this.expect(12);
          }
        }
        this.expect(48);
        this.state.inType = oldInType;
        return this.finishNode(node, "TypeParameterInstantiation");
      };
      _proto.flowParseInterfaceType = function flowParseInterfaceType() {
        var node = this.startNode();
        this.expectContextual(129);
        node["extends"] = [];
        if (this.eat(81)) {
          do {
            node["extends"].push(this.flowParseInterfaceExtends());
          } while (this.eat(12));
        }
        node.body = this.flowParseObjectType({
          allowStatic: false,
          allowExact: false,
          allowSpread: false,
          allowProto: false,
          allowInexact: false
        });
        return this.finishNode(node, "InterfaceTypeAnnotation");
      };
      _proto.flowParseObjectPropertyKey = function flowParseObjectPropertyKey() {
        return this.match(135) || this.match(134) ? _superClass.prototype.parseExprAtom.call(this) : this.parseIdentifier(true);
      };
      _proto.flowParseObjectTypeIndexer = function flowParseObjectTypeIndexer(node, isStatic, variance) {
        node["static"] = isStatic;
        if (this.lookahead().type === 14) {
          node.id = this.flowParseObjectPropertyKey();
          node.key = this.flowParseTypeInitialiser();
        } else {
          node.id = null;
          node.key = this.flowParseType();
        }
        this.expect(3);
        node.value = this.flowParseTypeInitialiser();
        node.variance = variance;
        return this.finishNode(node, "ObjectTypeIndexer");
      };
      _proto.flowParseObjectTypeInternalSlot = function flowParseObjectTypeInternalSlot(node, isStatic) {
        node["static"] = isStatic;
        node.id = this.flowParseObjectPropertyKey();
        this.expect(3);
        this.expect(3);
        if (this.match(47) || this.match(10)) {
          node.method = true;
          node.optional = false;
          node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.loc.start));
        } else {
          node.method = false;
          if (this.eat(17)) {
            node.optional = true;
          }
          node.value = this.flowParseTypeInitialiser();
        }
        return this.finishNode(node, "ObjectTypeInternalSlot");
      };
      _proto.flowParseObjectTypeMethodish = function flowParseObjectTypeMethodish(node) {
        node.params = [];
        node.rest = null;
        node.typeParameters = null;
        node["this"] = null;
        if (this.match(47)) {
          node.typeParameters = this.flowParseTypeParameterDeclaration();
        }
        this.expect(10);
        if (this.match(78)) {
          node["this"] = this.flowParseFunctionTypeParam(true);
          node["this"].name = null;
          if (!this.match(11)) {
            this.expect(12);
          }
        }
        while (!this.match(11) && !this.match(21)) {
          node.params.push(this.flowParseFunctionTypeParam(false));
          if (!this.match(11)) {
            this.expect(12);
          }
        }
        if (this.eat(21)) {
          node.rest = this.flowParseFunctionTypeParam(false);
        }
        this.expect(11);
        node.returnType = this.flowParseTypeInitialiser();
        return this.finishNode(node, "FunctionTypeAnnotation");
      };
      _proto.flowParseObjectTypeCallProperty = function flowParseObjectTypeCallProperty(node, isStatic) {
        var valueNode = this.startNode();
        node["static"] = isStatic;
        node.value = this.flowParseObjectTypeMethodish(valueNode);
        return this.finishNode(node, "ObjectTypeCallProperty");
      };
      _proto.flowParseObjectType = function flowParseObjectType(_ref13) {
        var allowStatic = _ref13.allowStatic,
          allowExact = _ref13.allowExact,
          allowSpread = _ref13.allowSpread,
          allowProto = _ref13.allowProto,
          allowInexact = _ref13.allowInexact;
        var oldInType = this.state.inType;
        this.state.inType = true;
        var nodeStart = this.startNode();
        nodeStart.callProperties = [];
        nodeStart.properties = [];
        nodeStart.indexers = [];
        nodeStart.internalSlots = [];
        var endDelim;
        var exact;
        var inexact = false;
        if (allowExact && this.match(6)) {
          this.expect(6);
          endDelim = 9;
          exact = true;
        } else {
          this.expect(5);
          endDelim = 8;
          exact = false;
        }
        nodeStart.exact = exact;
        while (!this.match(endDelim)) {
          var isStatic = false;
          var protoStartLoc = null;
          var inexactStartLoc = null;
          var node = this.startNode();
          if (allowProto && this.isContextual(118)) {
            var lookahead = this.lookahead();
            if (lookahead.type !== 14 && lookahead.type !== 17) {
              this.next();
              protoStartLoc = this.state.startLoc;
              allowStatic = false;
            }
          }
          if (allowStatic && this.isContextual(106)) {
            var _lookahead = this.lookahead();
            if (_lookahead.type !== 14 && _lookahead.type !== 17) {
              this.next();
              isStatic = true;
            }
          }
          var variance = this.flowParseVariance();
          if (this.eat(0)) {
            if (protoStartLoc != null) {
              this.unexpected(protoStartLoc);
            }
            if (this.eat(0)) {
              if (variance) {
                this.unexpected(variance.loc.start);
              }
              nodeStart.internalSlots.push(this.flowParseObjectTypeInternalSlot(node, isStatic));
            } else {
              nodeStart.indexers.push(this.flowParseObjectTypeIndexer(node, isStatic, variance));
            }
          } else if (this.match(10) || this.match(47)) {
            if (protoStartLoc != null) {
              this.unexpected(protoStartLoc);
            }
            if (variance) {
              this.unexpected(variance.loc.start);
            }
            nodeStart.callProperties.push(this.flowParseObjectTypeCallProperty(node, isStatic));
          } else {
            var kind = "init";
            if (this.isContextual(99) || this.isContextual(104)) {
              var _lookahead2 = this.lookahead();
              if (tokenIsLiteralPropertyName(_lookahead2.type)) {
                kind = this.state.value;
                this.next();
              }
            }
            var propOrInexact = this.flowParseObjectTypeProperty(node, isStatic, protoStartLoc, variance, kind, allowSpread, allowInexact != null ? allowInexact : !exact);
            if (propOrInexact === null) {
              inexact = true;
              inexactStartLoc = this.state.lastTokStartLoc;
            } else {
              nodeStart.properties.push(propOrInexact);
            }
          }
          this.flowObjectTypeSemicolon();
          if (inexactStartLoc && !this.match(8) && !this.match(9)) {
            this.raise(FlowErrors.UnexpectedExplicitInexactInObject, inexactStartLoc);
          }
        }
        this.expect(endDelim);
        if (allowSpread) {
          nodeStart.inexact = inexact;
        }
        var out = this.finishNode(nodeStart, "ObjectTypeAnnotation");
        this.state.inType = oldInType;
        return out;
      };
      _proto.flowParseObjectTypeProperty = function flowParseObjectTypeProperty(node, isStatic, protoStartLoc, variance, kind, allowSpread, allowInexact) {
        if (this.eat(21)) {
          var isInexactToken = this.match(12) || this.match(13) || this.match(8) || this.match(9);
          if (isInexactToken) {
            if (!allowSpread) {
              this.raise(FlowErrors.InexactInsideNonObject, this.state.lastTokStartLoc);
            } else if (!allowInexact) {
              this.raise(FlowErrors.InexactInsideExact, this.state.lastTokStartLoc);
            }
            if (variance) {
              this.raise(FlowErrors.InexactVariance, variance);
            }
            return null;
          }
          if (!allowSpread) {
            this.raise(FlowErrors.UnexpectedSpreadType, this.state.lastTokStartLoc);
          }
          if (protoStartLoc != null) {
            this.unexpected(protoStartLoc);
          }
          if (variance) {
            this.raise(FlowErrors.SpreadVariance, variance);
          }
          node.argument = this.flowParseType();
          return this.finishNode(node, "ObjectTypeSpreadProperty");
        } else {
          node.key = this.flowParseObjectPropertyKey();
          node["static"] = isStatic;
          node.proto = protoStartLoc != null;
          node.kind = kind;
          var optional = false;
          if (this.match(47) || this.match(10)) {
            node.method = true;
            if (protoStartLoc != null) {
              this.unexpected(protoStartLoc);
            }
            if (variance) {
              this.unexpected(variance.loc.start);
            }
            node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.loc.start));
            if (kind === "get" || kind === "set") {
              this.flowCheckGetterSetterParams(node);
            }
            if (!allowSpread && node.key.name === "constructor" && node.value["this"]) {
              this.raise(FlowErrors.ThisParamBannedInConstructor, node.value["this"]);
            }
          } else {
            if (kind !== "init") this.unexpected();
            node.method = false;
            if (this.eat(17)) {
              optional = true;
            }
            node.value = this.flowParseTypeInitialiser();
            node.variance = variance;
          }
          node.optional = optional;
          return this.finishNode(node, "ObjectTypeProperty");
        }
      };
      _proto.flowCheckGetterSetterParams = function flowCheckGetterSetterParams(property) {
        var paramCount = property.kind === "get" ? 0 : 1;
        var length = property.value.params.length + (property.value.rest ? 1 : 0);
        if (property.value["this"]) {
          this.raise(property.kind === "get" ? FlowErrors.GetterMayNotHaveThisParam : FlowErrors.SetterMayNotHaveThisParam, property.value["this"]);
        }
        if (length !== paramCount) {
          this.raise(property.kind === "get" ? Errors.BadGetterArity : Errors.BadSetterArity, property);
        }
        if (property.kind === "set" && property.value.rest) {
          this.raise(Errors.BadSetterRestParameter, property);
        }
      };
      _proto.flowObjectTypeSemicolon = function flowObjectTypeSemicolon() {
        if (!this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9)) {
          this.unexpected();
        }
      };
      _proto.flowParseQualifiedTypeIdentifier = function flowParseQualifiedTypeIdentifier(startLoc, id) {
        startLoc != null ? startLoc : startLoc = this.state.startLoc;
        var node = id || this.flowParseRestrictedIdentifier(true);
        while (this.eat(16)) {
          var node2 = this.startNodeAt(startLoc);
          node2.qualification = node;
          node2.id = this.flowParseRestrictedIdentifier(true);
          node = this.finishNode(node2, "QualifiedTypeIdentifier");
        }
        return node;
      };
      _proto.flowParseGenericType = function flowParseGenericType(startLoc, id) {
        var node = this.startNodeAt(startLoc);
        node.typeParameters = null;
        node.id = this.flowParseQualifiedTypeIdentifier(startLoc, id);
        if (this.match(47)) {
          node.typeParameters = this.flowParseTypeParameterInstantiation();
        }
        return this.finishNode(node, "GenericTypeAnnotation");
      };
      _proto.flowParseTypeofType = function flowParseTypeofType() {
        var node = this.startNode();
        this.expect(87);
        node.argument = this.flowParsePrimaryType();
        return this.finishNode(node, "TypeofTypeAnnotation");
      };
      _proto.flowParseTupleType = function flowParseTupleType() {
        var node = this.startNode();
        node.types = [];
        this.expect(0);
        while (this.state.pos < this.length && !this.match(3)) {
          node.types.push(this.flowParseType());
          if (this.match(3)) break;
          this.expect(12);
        }
        this.expect(3);
        return this.finishNode(node, "TupleTypeAnnotation");
      };
      _proto.flowParseFunctionTypeParam = function flowParseFunctionTypeParam(first) {
        var name = null;
        var optional = false;
        var typeAnnotation = null;
        var node = this.startNode();
        var lh = this.lookahead();
        var isThis = this.state.type === 78;
        if (lh.type === 14 || lh.type === 17) {
          if (isThis && !first) {
            this.raise(FlowErrors.ThisParamMustBeFirst, node);
          }
          name = this.parseIdentifier(isThis);
          if (this.eat(17)) {
            optional = true;
            if (isThis) {
              this.raise(FlowErrors.ThisParamMayNotBeOptional, node);
            }
          }
          typeAnnotation = this.flowParseTypeInitialiser();
        } else {
          typeAnnotation = this.flowParseType();
        }
        node.name = name;
        node.optional = optional;
        node.typeAnnotation = typeAnnotation;
        return this.finishNode(node, "FunctionTypeParam");
      };
      _proto.reinterpretTypeAsFunctionTypeParam = function reinterpretTypeAsFunctionTypeParam(type) {
        var node = this.startNodeAt(type.loc.start);
        node.name = null;
        node.optional = false;
        node.typeAnnotation = type;
        return this.finishNode(node, "FunctionTypeParam");
      };
      _proto.flowParseFunctionTypeParams = function flowParseFunctionTypeParams(params) {
        if (params === void 0) {
          params = [];
        }
        var rest = null;
        var _this = null;
        if (this.match(78)) {
          _this = this.flowParseFunctionTypeParam(true);
          _this.name = null;
          if (!this.match(11)) {
            this.expect(12);
          }
        }
        while (!this.match(11) && !this.match(21)) {
          params.push(this.flowParseFunctionTypeParam(false));
          if (!this.match(11)) {
            this.expect(12);
          }
        }
        if (this.eat(21)) {
          rest = this.flowParseFunctionTypeParam(false);
        }
        return {
          params: params,
          rest: rest,
          _this: _this
        };
      };
      _proto.flowIdentToTypeAnnotation = function flowIdentToTypeAnnotation(startLoc, node, id) {
        switch (id.name) {
          case "any":
            return this.finishNode(node, "AnyTypeAnnotation");
          case "bool":
          case "boolean":
            return this.finishNode(node, "BooleanTypeAnnotation");
          case "mixed":
            return this.finishNode(node, "MixedTypeAnnotation");
          case "empty":
            return this.finishNode(node, "EmptyTypeAnnotation");
          case "number":
            return this.finishNode(node, "NumberTypeAnnotation");
          case "string":
            return this.finishNode(node, "StringTypeAnnotation");
          case "symbol":
            return this.finishNode(node, "SymbolTypeAnnotation");
          default:
            this.checkNotUnderscore(id.name);
            return this.flowParseGenericType(startLoc, id);
        }
      };
      _proto.flowParsePrimaryType = function flowParsePrimaryType() {
        var startLoc = this.state.startLoc;
        var node = this.startNode();
        var tmp;
        var type;
        var isGroupedType = false;
        var oldNoAnonFunctionType = this.state.noAnonFunctionType;
        switch (this.state.type) {
          case 5:
            return this.flowParseObjectType({
              allowStatic: false,
              allowExact: false,
              allowSpread: true,
              allowProto: false,
              allowInexact: true
            });
          case 6:
            return this.flowParseObjectType({
              allowStatic: false,
              allowExact: true,
              allowSpread: true,
              allowProto: false,
              allowInexact: false
            });
          case 0:
            this.state.noAnonFunctionType = false;
            type = this.flowParseTupleType();
            this.state.noAnonFunctionType = oldNoAnonFunctionType;
            return type;
          case 47:
            {
              var _node = this.startNode();
              _node.typeParameters = this.flowParseTypeParameterDeclaration();
              this.expect(10);
              tmp = this.flowParseFunctionTypeParams();
              _node.params = tmp.params;
              _node.rest = tmp.rest;
              _node["this"] = tmp._this;
              this.expect(11);
              this.expect(19);
              _node.returnType = this.flowParseType();
              return this.finishNode(_node, "FunctionTypeAnnotation");
            }
          case 10:
            {
              var _node2 = this.startNode();
              this.next();
              if (!this.match(11) && !this.match(21)) {
                if (tokenIsIdentifier(this.state.type) || this.match(78)) {
                  var token = this.lookahead().type;
                  isGroupedType = token !== 17 && token !== 14;
                } else {
                  isGroupedType = true;
                }
              }
              if (isGroupedType) {
                this.state.noAnonFunctionType = false;
                type = this.flowParseType();
                this.state.noAnonFunctionType = oldNoAnonFunctionType;
                if (this.state.noAnonFunctionType || !(this.match(12) || this.match(11) && this.lookahead().type === 19)) {
                  this.expect(11);
                  return type;
                } else {
                  this.eat(12);
                }
              }
              if (type) {
                tmp = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(type)]);
              } else {
                tmp = this.flowParseFunctionTypeParams();
              }
              _node2.params = tmp.params;
              _node2.rest = tmp.rest;
              _node2["this"] = tmp._this;
              this.expect(11);
              this.expect(19);
              _node2.returnType = this.flowParseType();
              _node2.typeParameters = null;
              return this.finishNode(_node2, "FunctionTypeAnnotation");
            }
          case 134:
            return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
          case 85:
          case 86:
            node.value = this.match(85);
            this.next();
            return this.finishNode(node, "BooleanLiteralTypeAnnotation");
          case 53:
            if (this.state.value === "-") {
              this.next();
              if (this.match(135)) {
                return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", node);
              }
              if (this.match(136)) {
                return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", node);
              }
              throw this.raise(FlowErrors.UnexpectedSubtractionOperand, this.state.startLoc);
            }
            this.unexpected();
            return;
          case 135:
            return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
          case 136:
            return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
          case 88:
            this.next();
            return this.finishNode(node, "VoidTypeAnnotation");
          case 84:
            this.next();
            return this.finishNode(node, "NullLiteralTypeAnnotation");
          case 78:
            this.next();
            return this.finishNode(node, "ThisTypeAnnotation");
          case 55:
            this.next();
            return this.finishNode(node, "ExistsTypeAnnotation");
          case 87:
            return this.flowParseTypeofType();
          default:
            if (tokenIsKeyword(this.state.type)) {
              var label = tokenLabelName(this.state.type);
              this.next();
              return _superClass.prototype.createIdentifier.call(this, node, label);
            } else if (tokenIsIdentifier(this.state.type)) {
              if (this.isContextual(129)) {
                return this.flowParseInterfaceType();
              }
              return this.flowIdentToTypeAnnotation(startLoc, node, this.parseIdentifier());
            }
        }
        this.unexpected();
      };
      _proto.flowParsePostfixType = function flowParsePostfixType() {
        var startLoc = this.state.startLoc;
        var type = this.flowParsePrimaryType();
        var seenOptionalIndexedAccess = false;
        while ((this.match(0) || this.match(18)) && !this.canInsertSemicolon()) {
          var node = this.startNodeAt(startLoc);
          var optional = this.eat(18);
          seenOptionalIndexedAccess = seenOptionalIndexedAccess || optional;
          this.expect(0);
          if (!optional && this.match(3)) {
            node.elementType = type;
            this.next();
            type = this.finishNode(node, "ArrayTypeAnnotation");
          } else {
            node.objectType = type;
            node.indexType = this.flowParseType();
            this.expect(3);
            if (seenOptionalIndexedAccess) {
              node.optional = optional;
              type = this.finishNode(node, "OptionalIndexedAccessType");
            } else {
              type = this.finishNode(node, "IndexedAccessType");
            }
          }
        }
        return type;
      };
      _proto.flowParsePrefixType = function flowParsePrefixType() {
        var node = this.startNode();
        if (this.eat(17)) {
          node.typeAnnotation = this.flowParsePrefixType();
          return this.finishNode(node, "NullableTypeAnnotation");
        } else {
          return this.flowParsePostfixType();
        }
      };
      _proto.flowParseAnonFunctionWithoutParens = function flowParseAnonFunctionWithoutParens() {
        var param = this.flowParsePrefixType();
        if (!this.state.noAnonFunctionType && this.eat(19)) {
          var node = this.startNodeAt(param.loc.start);
          node.params = [this.reinterpretTypeAsFunctionTypeParam(param)];
          node.rest = null;
          node["this"] = null;
          node.returnType = this.flowParseType();
          node.typeParameters = null;
          return this.finishNode(node, "FunctionTypeAnnotation");
        }
        return param;
      };
      _proto.flowParseIntersectionType = function flowParseIntersectionType() {
        var node = this.startNode();
        this.eat(45);
        var type = this.flowParseAnonFunctionWithoutParens();
        node.types = [type];
        while (this.eat(45)) {
          node.types.push(this.flowParseAnonFunctionWithoutParens());
        }
        return node.types.length === 1 ? type : this.finishNode(node, "IntersectionTypeAnnotation");
      };
      _proto.flowParseUnionType = function flowParseUnionType() {
        var node = this.startNode();
        this.eat(43);
        var type = this.flowParseIntersectionType();
        node.types = [type];
        while (this.eat(43)) {
          node.types.push(this.flowParseIntersectionType());
        }
        return node.types.length === 1 ? type : this.finishNode(node, "UnionTypeAnnotation");
      };
      _proto.flowParseType = function flowParseType() {
        var oldInType = this.state.inType;
        this.state.inType = true;
        var type = this.flowParseUnionType();
        this.state.inType = oldInType;
        return type;
      };
      _proto.flowParseTypeOrImplicitInstantiation = function flowParseTypeOrImplicitInstantiation() {
        if (this.state.type === 132 && this.state.value === "_") {
          var startLoc = this.state.startLoc;
          var node = this.parseIdentifier();
          return this.flowParseGenericType(startLoc, node);
        } else {
          return this.flowParseType();
        }
      };
      _proto.flowParseTypeAnnotation = function flowParseTypeAnnotation() {
        var node = this.startNode();
        node.typeAnnotation = this.flowParseTypeInitialiser();
        return this.finishNode(node, "TypeAnnotation");
      };
      _proto.flowParseTypeAnnotatableIdentifier = function flowParseTypeAnnotatableIdentifier(allowPrimitiveOverride) {
        var ident = allowPrimitiveOverride ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
        if (this.match(14)) {
          ident.typeAnnotation = this.flowParseTypeAnnotation();
          this.resetEndLocation(ident);
        }
        return ident;
      };
      _proto.typeCastToParameter = function typeCastToParameter(node) {
        node.expression.typeAnnotation = node.typeAnnotation;
        this.resetEndLocation(node.expression, node.typeAnnotation.loc.end);
        return node.expression;
      };
      _proto.flowParseVariance = function flowParseVariance() {
        var variance = null;
        if (this.match(53)) {
          variance = this.startNode();
          if (this.state.value === "+") {
            variance.kind = "plus";
          } else {
            variance.kind = "minus";
          }
          this.next();
          return this.finishNode(variance, "Variance");
        }
        return variance;
      };
      _proto.parseFunctionBody = function parseFunctionBody(node, allowExpressionBody, isMethod) {
        var _this5 = this;
        if (isMethod === void 0) {
          isMethod = false;
        }
        if (allowExpressionBody) {
          this.forwardNoArrowParamsConversionAt(node, function () {
            return _superClass.prototype.parseFunctionBody.call(_this5, node, true, isMethod);
          });
          return;
        }
        _superClass.prototype.parseFunctionBody.call(this, node, false, isMethod);
      };
      _proto.parseFunctionBodyAndFinish = function parseFunctionBodyAndFinish(node, type, isMethod) {
        if (isMethod === void 0) {
          isMethod = false;
        }
        if (this.match(14)) {
          var typeNode = this.startNode();
          var _this$flowParseTypeAn2 = this.flowParseTypeAndPredicateInitialiser();
          typeNode.typeAnnotation = _this$flowParseTypeAn2[0];
          node.predicate = _this$flowParseTypeAn2[1];
          node.returnType = typeNode.typeAnnotation ? this.finishNode(typeNode, "TypeAnnotation") : null;
        }
        return _superClass.prototype.parseFunctionBodyAndFinish.call(this, node, type, isMethod);
      };
      _proto.parseStatementLike = function parseStatementLike(flags) {
        if (this.state.strict && this.isContextual(129)) {
          var lookahead = this.lookahead();
          if (tokenIsKeywordOrIdentifier(lookahead.type)) {
            var node = this.startNode();
            this.next();
            return this.flowParseInterface(node);
          }
        } else if (this.isContextual(126)) {
          var _node3 = this.startNode();
          this.next();
          return this.flowParseEnumDeclaration(_node3);
        }
        var stmt = _superClass.prototype.parseStatementLike.call(this, flags);
        if (this.flowPragma === undefined && !this.isValidDirective(stmt)) {
          this.flowPragma = null;
        }
        return stmt;
      };
      _proto.parseExpressionStatement = function parseExpressionStatement(node, expr, decorators) {
        if (expr.type === "Identifier") {
          if (expr.name === "declare") {
            if (this.match(80) || tokenIsIdentifier(this.state.type) || this.match(68) || this.match(74) || this.match(82)) {
              return this.flowParseDeclare(node);
            }
          } else if (tokenIsIdentifier(this.state.type)) {
            if (expr.name === "interface") {
              return this.flowParseInterface(node);
            } else if (expr.name === "type") {
              return this.flowParseTypeAlias(node);
            } else if (expr.name === "opaque") {
              return this.flowParseOpaqueType(node, false);
            }
          }
        }
        return _superClass.prototype.parseExpressionStatement.call(this, node, expr, decorators);
      };
      _proto.shouldParseExportDeclaration = function shouldParseExportDeclaration() {
        var type = this.state.type;
        if (type === 126 || tokenIsFlowInterfaceOrTypeOrOpaque(type)) {
          return !this.state.containsEsc;
        }
        return _superClass.prototype.shouldParseExportDeclaration.call(this);
      };
      _proto.isExportDefaultSpecifier = function isExportDefaultSpecifier() {
        var type = this.state.type;
        if (type === 126 || tokenIsFlowInterfaceOrTypeOrOpaque(type)) {
          return this.state.containsEsc;
        }
        return _superClass.prototype.isExportDefaultSpecifier.call(this);
      };
      _proto.parseExportDefaultExpression = function parseExportDefaultExpression() {
        if (this.isContextual(126)) {
          var node = this.startNode();
          this.next();
          return this.flowParseEnumDeclaration(node);
        }
        return _superClass.prototype.parseExportDefaultExpression.call(this);
      };
      _proto.parseConditional = function parseConditional(expr, startLoc, refExpressionErrors) {
        var _this6 = this;
        if (!this.match(17)) return expr;
        if (this.state.maybeInArrowParameters) {
          var nextCh = this.lookaheadCharCode();
          if (nextCh === 44 || nextCh === 61 || nextCh === 58 || nextCh === 41) {
            this.setOptionalParametersError(refExpressionErrors);
            return expr;
          }
        }
        this.expect(17);
        var state = this.state.clone();
        var originalNoArrowAt = this.state.noArrowAt;
        var node = this.startNodeAt(startLoc);
        var _this$tryParseConditi = this.tryParseConditionalConsequent(),
          consequent = _this$tryParseConditi.consequent,
          failed = _this$tryParseConditi.failed;
        var _this$getArrowLikeExp = this.getArrowLikeExpressions(consequent),
          valid = _this$getArrowLikeExp[0],
          invalid = _this$getArrowLikeExp[1];
        if (failed || invalid.length > 0) {
          var noArrowAt = [].concat(originalNoArrowAt);
          if (invalid.length > 0) {
            this.state = state;
            this.state.noArrowAt = noArrowAt;
            for (var i = 0; i < invalid.length; i++) {
              noArrowAt.push(invalid[i].start);
            }
            var _this$tryParseConditi2 = this.tryParseConditionalConsequent();
            consequent = _this$tryParseConditi2.consequent;
            failed = _this$tryParseConditi2.failed;
            var _this$getArrowLikeExp2 = this.getArrowLikeExpressions(consequent);
            valid = _this$getArrowLikeExp2[0];
            invalid = _this$getArrowLikeExp2[1];
          }
          if (failed && valid.length > 1) {
            this.raise(FlowErrors.AmbiguousConditionalArrow, state.startLoc);
          }
          if (failed && valid.length === 1) {
            this.state = state;
            noArrowAt.push(valid[0].start);
            this.state.noArrowAt = noArrowAt;
            var _this$tryParseConditi3 = this.tryParseConditionalConsequent();
            consequent = _this$tryParseConditi3.consequent;
            failed = _this$tryParseConditi3.failed;
          }
        }
        this.getArrowLikeExpressions(consequent, true);
        this.state.noArrowAt = originalNoArrowAt;
        this.expect(14);
        node.test = expr;
        node.consequent = consequent;
        node.alternate = this.forwardNoArrowParamsConversionAt(node, function () {
          return _this6.parseMaybeAssign(undefined, undefined);
        });
        return this.finishNode(node, "ConditionalExpression");
      };
      _proto.tryParseConditionalConsequent = function tryParseConditionalConsequent() {
        this.state.noArrowParamsConversionAt.push(this.state.start);
        var consequent = this.parseMaybeAssignAllowIn();
        var failed = !this.match(14);
        this.state.noArrowParamsConversionAt.pop();
        return {
          consequent: consequent,
          failed: failed
        };
      };
      _proto.getArrowLikeExpressions = function getArrowLikeExpressions(node, disallowInvalid) {
        var _this7 = this;
        var stack = [node];
        var arrows = [];
        while (stack.length !== 0) {
          var _node4 = stack.pop();
          if (_node4.type === "ArrowFunctionExpression" && _node4.body.type !== "BlockStatement") {
            if (_node4.typeParameters || !_node4.returnType) {
              this.finishArrowValidation(_node4);
            } else {
              arrows.push(_node4);
            }
            stack.push(_node4.body);
          } else if (_node4.type === "ConditionalExpression") {
            stack.push(_node4.consequent);
            stack.push(_node4.alternate);
          }
        }
        if (disallowInvalid) {
          arrows.forEach(function (node) {
            return _this7.finishArrowValidation(node);
          });
          return [arrows, []];
        }
        return partition(arrows, function (node) {
          return node.params.every(function (param) {
            return _this7.isAssignable(param, true);
          });
        });
      };
      _proto.finishArrowValidation = function finishArrowValidation(node) {
        var _node$extra;
        this.toAssignableList(node.params, (_node$extra = node.extra) == null ? void 0 : _node$extra.trailingCommaLoc, false);
        this.scope.enter(ScopeFlag.FUNCTION | ScopeFlag.ARROW);
        _superClass.prototype.checkParams.call(this, node, false, true);
        this.scope.exit();
      };
      _proto.forwardNoArrowParamsConversionAt = function forwardNoArrowParamsConversionAt(node, parse) {
        var result;
        if (this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(node.start))) {
          this.state.noArrowParamsConversionAt.push(this.state.start);
          result = parse();
          this.state.noArrowParamsConversionAt.pop();
        } else {
          result = parse();
        }
        return result;
      };
      _proto.parseParenItem = function parseParenItem(node, startLoc) {
        var newNode = _superClass.prototype.parseParenItem.call(this, node, startLoc);
        if (this.eat(17)) {
          newNode.optional = true;
          this.resetEndLocation(node);
        }
        if (this.match(14)) {
          var typeCastNode = this.startNodeAt(startLoc);
          typeCastNode.expression = newNode;
          typeCastNode.typeAnnotation = this.flowParseTypeAnnotation();
          return this.finishNode(typeCastNode, "TypeCastExpression");
        }
        return newNode;
      };
      _proto.assertModuleNodeAllowed = function assertModuleNodeAllowed(node) {
        if (node.type === "ImportDeclaration" && (node.importKind === "type" || node.importKind === "typeof") || node.type === "ExportNamedDeclaration" && node.exportKind === "type" || node.type === "ExportAllDeclaration" && node.exportKind === "type") {
          return;
        }
        _superClass.prototype.assertModuleNodeAllowed.call(this, node);
      };
      _proto.parseExportDeclaration = function parseExportDeclaration(node) {
        if (this.isContextual(130)) {
          node.exportKind = "type";
          var declarationNode = this.startNode();
          this.next();
          if (this.match(5)) {
            node.specifiers = this.parseExportSpecifiers(true);
            _superClass.prototype.parseExportFrom.call(this, node);
            return null;
          } else {
            return this.flowParseTypeAlias(declarationNode);
          }
        } else if (this.isContextual(131)) {
          node.exportKind = "type";
          var _declarationNode = this.startNode();
          this.next();
          return this.flowParseOpaqueType(_declarationNode, false);
        } else if (this.isContextual(129)) {
          node.exportKind = "type";
          var _declarationNode2 = this.startNode();
          this.next();
          return this.flowParseInterface(_declarationNode2);
        } else if (this.isContextual(126)) {
          node.exportKind = "value";
          var _declarationNode3 = this.startNode();
          this.next();
          return this.flowParseEnumDeclaration(_declarationNode3);
        } else {
          return _superClass.prototype.parseExportDeclaration.call(this, node);
        }
      };
      _proto.eatExportStar = function eatExportStar(node) {
        if (_superClass.prototype.eatExportStar.call(this, node)) return true;
        if (this.isContextual(130) && this.lookahead().type === 55) {
          node.exportKind = "type";
          this.next();
          this.next();
          return true;
        }
        return false;
      };
      _proto.maybeParseExportNamespaceSpecifier = function maybeParseExportNamespaceSpecifier(node) {
        var startLoc = this.state.startLoc;
        var hasNamespace = _superClass.prototype.maybeParseExportNamespaceSpecifier.call(this, node);
        if (hasNamespace && node.exportKind === "type") {
          this.unexpected(startLoc);
        }
        return hasNamespace;
      };
      _proto.parseClassId = function parseClassId(node, isStatement, optionalId) {
        _superClass.prototype.parseClassId.call(this, node, isStatement, optionalId);
        if (this.match(47)) {
          node.typeParameters = this.flowParseTypeParameterDeclaration();
        }
      };
      _proto.parseClassMember = function parseClassMember(classBody, member, state) {
        var startLoc = this.state.startLoc;
        if (this.isContextual(125)) {
          if (_superClass.prototype.parseClassMemberFromModifier.call(this, classBody, member)) {
            return;
          }
          member.declare = true;
        }
        _superClass.prototype.parseClassMember.call(this, classBody, member, state);
        if (member.declare) {
          if (member.type !== "ClassProperty" && member.type !== "ClassPrivateProperty" && member.type !== "PropertyDefinition") {
            this.raise(FlowErrors.DeclareClassElement, startLoc);
          } else if (member.value) {
            this.raise(FlowErrors.DeclareClassFieldInitializer, member.value);
          }
        }
      };
      _proto.isIterator = function isIterator(word) {
        return word === "iterator" || word === "asyncIterator";
      };
      _proto.readIterator = function readIterator() {
        var word = _superClass.prototype.readWord1.call(this);
        var fullWord = "@@" + word;
        if (!this.isIterator(word) || !this.state.inType) {
          this.raise(Errors.InvalidIdentifier, this.state.curPosition(), {
            identifierName: fullWord
          });
        }
        this.finishToken(132, fullWord);
      };
      _proto.getTokenFromCode = function getTokenFromCode(code) {
        var next = this.input.charCodeAt(this.state.pos + 1);
        if (code === 123 && next === 124) {
          this.finishOp(6, 2);
        } else if (this.state.inType && (code === 62 || code === 60)) {
          this.finishOp(code === 62 ? 48 : 47, 1);
        } else if (this.state.inType && code === 63) {
          if (next === 46) {
            this.finishOp(18, 2);
          } else {
            this.finishOp(17, 1);
          }
        } else if (isIteratorStart(code, next, this.input.charCodeAt(this.state.pos + 2))) {
          this.state.pos += 2;
          this.readIterator();
        } else {
          _superClass.prototype.getTokenFromCode.call(this, code);
        }
      };
      _proto.isAssignable = function isAssignable(node, isBinding) {
        if (node.type === "TypeCastExpression") {
          return this.isAssignable(node.expression, isBinding);
        } else {
          return _superClass.prototype.isAssignable.call(this, node, isBinding);
        }
      };
      _proto.toAssignable = function toAssignable(node, isLHS) {
        if (isLHS === void 0) {
          isLHS = false;
        }
        if (!isLHS && node.type === "AssignmentExpression" && node.left.type === "TypeCastExpression") {
          node.left = this.typeCastToParameter(node.left);
        }
        _superClass.prototype.toAssignable.call(this, node, isLHS);
      };
      _proto.toAssignableList = function toAssignableList(exprList, trailingCommaLoc, isLHS) {
        for (var i = 0; i < exprList.length; i++) {
          var expr = exprList[i];
          if ((expr == null ? void 0 : expr.type) === "TypeCastExpression") {
            exprList[i] = this.typeCastToParameter(expr);
          }
        }
        _superClass.prototype.toAssignableList.call(this, exprList, trailingCommaLoc, isLHS);
      };
      _proto.toReferencedList = function toReferencedList(exprList, isParenthesizedExpr) {
        for (var i = 0; i < exprList.length; i++) {
          var _expr$extra;
          var expr = exprList[i];
          if (expr && expr.type === "TypeCastExpression" && !((_expr$extra = expr.extra) != null && _expr$extra.parenthesized) && (exprList.length > 1 || !isParenthesizedExpr)) {
            this.raise(FlowErrors.TypeCastInPattern, expr.typeAnnotation);
          }
        }
        return exprList;
      };
      _proto.parseArrayLike = function parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
        var node = _superClass.prototype.parseArrayLike.call(this, close, canBePattern, isTuple, refExpressionErrors);
        if (canBePattern && !this.state.maybeInArrowParameters) {
          this.toReferencedList(node.elements);
        }
        return node;
      };
      _proto.isValidLVal = function isValidLVal(type, isParenthesized, binding) {
        return type === "TypeCastExpression" || _superClass.prototype.isValidLVal.call(this, type, isParenthesized, binding);
      };
      _proto.parseClassProperty = function parseClassProperty(node) {
        if (this.match(14)) {
          node.typeAnnotation = this.flowParseTypeAnnotation();
        }
        return _superClass.prototype.parseClassProperty.call(this, node);
      };
      _proto.parseClassPrivateProperty = function parseClassPrivateProperty(node) {
        if (this.match(14)) {
          node.typeAnnotation = this.flowParseTypeAnnotation();
        }
        return _superClass.prototype.parseClassPrivateProperty.call(this, node);
      };
      _proto.isClassMethod = function isClassMethod() {
        return this.match(47) || _superClass.prototype.isClassMethod.call(this);
      };
      _proto.isClassProperty = function isClassProperty() {
        return this.match(14) || _superClass.prototype.isClassProperty.call(this);
      };
      _proto.isNonstaticConstructor = function isNonstaticConstructor(method) {
        return !this.match(14) && _superClass.prototype.isNonstaticConstructor.call(this, method);
      };
      _proto.pushClassMethod = function pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
        if (method.variance) {
          this.unexpected(method.variance.loc.start);
        }
        delete method.variance;
        if (this.match(47)) {
          method.typeParameters = this.flowParseTypeParameterDeclaration();
        }
        _superClass.prototype.pushClassMethod.call(this, classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);
        if (method.params && isConstructor) {
          var params = method.params;
          if (params.length > 0 && this.isThisParam(params[0])) {
            this.raise(FlowErrors.ThisParamBannedInConstructor, method);
          }
        } else if (method.type === "MethodDefinition" && isConstructor && method.value.params) {
          var _params = method.value.params;
          if (_params.length > 0 && this.isThisParam(_params[0])) {
            this.raise(FlowErrors.ThisParamBannedInConstructor, method);
          }
        }
      };
      _proto.pushClassPrivateMethod = function pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
        if (method.variance) {
          this.unexpected(method.variance.loc.start);
        }
        delete method.variance;
        if (this.match(47)) {
          method.typeParameters = this.flowParseTypeParameterDeclaration();
        }
        _superClass.prototype.pushClassPrivateMethod.call(this, classBody, method, isGenerator, isAsync);
      };
      _proto.parseClassSuper = function parseClassSuper(node) {
        _superClass.prototype.parseClassSuper.call(this, node);
        if (node.superClass && (this.match(47) || this.match(51))) {
          {
            node.superTypeParameters = this.flowParseTypeParameterInstantiationInExpression();
          }
        }
        if (this.isContextual(113)) {
          this.next();
          var implemented = node["implements"] = [];
          do {
            var _node5 = this.startNode();
            _node5.id = this.flowParseRestrictedIdentifier(true);
            if (this.match(47)) {
              _node5.typeParameters = this.flowParseTypeParameterInstantiation();
            } else {
              _node5.typeParameters = null;
            }
            implemented.push(this.finishNode(_node5, "ClassImplements"));
          } while (this.eat(12));
        }
      };
      _proto.checkGetterSetterParams = function checkGetterSetterParams(method) {
        _superClass.prototype.checkGetterSetterParams.call(this, method);
        var params = this.getObjectOrClassMethodParams(method);
        if (params.length > 0) {
          var param = params[0];
          if (this.isThisParam(param) && method.kind === "get") {
            this.raise(FlowErrors.GetterMayNotHaveThisParam, param);
          } else if (this.isThisParam(param)) {
            this.raise(FlowErrors.SetterMayNotHaveThisParam, param);
          }
        }
      };
      _proto.parsePropertyNamePrefixOperator = function parsePropertyNamePrefixOperator(node) {
        node.variance = this.flowParseVariance();
      };
      _proto.parseObjPropValue = function parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
        if (prop.variance) {
          this.unexpected(prop.variance.loc.start);
        }
        delete prop.variance;
        var typeParameters;
        if (this.match(47) && !isAccessor) {
          typeParameters = this.flowParseTypeParameterDeclaration();
          if (!this.match(10)) this.unexpected();
        }
        var result = _superClass.prototype.parseObjPropValue.call(this, prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);
        if (typeParameters) {
          (result.value || result).typeParameters = typeParameters;
        }
        return result;
      };
      _proto.parseFunctionParamType = function parseFunctionParamType(param) {
        if (this.eat(17)) {
          if (param.type !== "Identifier") {
            this.raise(FlowErrors.PatternIsOptional, param);
          }
          if (this.isThisParam(param)) {
            this.raise(FlowErrors.ThisParamMayNotBeOptional, param);
          }
          param.optional = true;
        }
        if (this.match(14)) {
          param.typeAnnotation = this.flowParseTypeAnnotation();
        } else if (this.isThisParam(param)) {
          this.raise(FlowErrors.ThisParamAnnotationRequired, param);
        }
        if (this.match(29) && this.isThisParam(param)) {
          this.raise(FlowErrors.ThisParamNoDefault, param);
        }
        this.resetEndLocation(param);
        return param;
      };
      _proto.parseMaybeDefault = function parseMaybeDefault(startLoc, left) {
        var node = _superClass.prototype.parseMaybeDefault.call(this, startLoc, left);
        if (node.type === "AssignmentPattern" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {
          this.raise(FlowErrors.TypeBeforeInitializer, node.typeAnnotation);
        }
        return node;
      };
      _proto.checkImportReflection = function checkImportReflection(node) {
        _superClass.prototype.checkImportReflection.call(this, node);
        if (node.module && node.importKind !== "value") {
          this.raise(FlowErrors.ImportReflectionHasImportType, node.specifiers[0].loc.start);
        }
      };
      _proto.parseImportSpecifierLocal = function parseImportSpecifierLocal(node, specifier, type) {
        specifier.local = hasTypeImportKind(node) ? this.flowParseRestrictedIdentifier(true, true) : this.parseIdentifier();
        node.specifiers.push(this.finishImportSpecifier(specifier, type));
      };
      _proto.isPotentialImportPhase = function isPotentialImportPhase(isExport) {
        if (_superClass.prototype.isPotentialImportPhase.call(this, isExport)) return true;
        if (this.isContextual(130)) {
          if (!isExport) return true;
          var ch = this.lookaheadCharCode();
          return ch === 123 || ch === 42;
        }
        return !isExport && this.isContextual(87);
      };
      _proto.applyImportPhase = function applyImportPhase(node, isExport, phase, loc) {
        _superClass.prototype.applyImportPhase.call(this, node, isExport, phase, loc);
        if (isExport) {
          if (!phase && this.match(65)) {
            return;
          }
          node.exportKind = phase === "type" ? phase : "value";
        } else {
          if (phase === "type" && this.match(55)) this.unexpected();
          node.importKind = phase === "type" || phase === "typeof" ? phase : "value";
        }
      };
      _proto.parseImportSpecifier = function parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {
        var firstIdent = specifier.imported;
        var specifierTypeKind = null;
        if (firstIdent.type === "Identifier") {
          if (firstIdent.name === "type") {
            specifierTypeKind = "type";
          } else if (firstIdent.name === "typeof") {
            specifierTypeKind = "typeof";
          }
        }
        var isBinding = false;
        if (this.isContextual(93) && !this.isLookaheadContextual("as")) {
          var as_ident = this.parseIdentifier(true);
          if (specifierTypeKind !== null && !tokenIsKeywordOrIdentifier(this.state.type)) {
            specifier.imported = as_ident;
            specifier.importKind = specifierTypeKind;
            specifier.local = this.cloneIdentifier(as_ident);
          } else {
            specifier.imported = firstIdent;
            specifier.importKind = null;
            specifier.local = this.parseIdentifier();
          }
        } else {
          if (specifierTypeKind !== null && tokenIsKeywordOrIdentifier(this.state.type)) {
            specifier.imported = this.parseIdentifier(true);
            specifier.importKind = specifierTypeKind;
          } else {
            if (importedIsString) {
              throw this.raise(Errors.ImportBindingIsString, specifier, {
                importName: firstIdent.value
              });
            }
            specifier.imported = firstIdent;
            specifier.importKind = null;
          }
          if (this.eatContextual(93)) {
            specifier.local = this.parseIdentifier();
          } else {
            isBinding = true;
            specifier.local = this.cloneIdentifier(specifier.imported);
          }
        }
        var specifierIsTypeImport = hasTypeImportKind(specifier);
        if (isInTypeOnlyImport && specifierIsTypeImport) {
          this.raise(FlowErrors.ImportTypeShorthandOnlyInPureImport, specifier);
        }
        if (isInTypeOnlyImport || specifierIsTypeImport) {
          this.checkReservedType(specifier.local.name, specifier.local.loc.start, true);
        }
        if (isBinding && !isInTypeOnlyImport && !specifierIsTypeImport) {
          this.checkReservedWord(specifier.local.name, specifier.loc.start, true, true);
        }
        return this.finishImportSpecifier(specifier, "ImportSpecifier");
      };
      _proto.parseBindingAtom = function parseBindingAtom() {
        switch (this.state.type) {
          case 78:
            return this.parseIdentifier(true);
          default:
            return _superClass.prototype.parseBindingAtom.call(this);
        }
      };
      _proto.parseFunctionParams = function parseFunctionParams(node, isConstructor) {
        var kind = node.kind;
        if (kind !== "get" && kind !== "set" && this.match(47)) {
          node.typeParameters = this.flowParseTypeParameterDeclaration();
        }
        _superClass.prototype.parseFunctionParams.call(this, node, isConstructor);
      };
      _proto.parseVarId = function parseVarId(decl, kind) {
        _superClass.prototype.parseVarId.call(this, decl, kind);
        if (this.match(14)) {
          decl.id.typeAnnotation = this.flowParseTypeAnnotation();
          this.resetEndLocation(decl.id);
        }
      };
      _proto.parseAsyncArrowFromCallExpression = function parseAsyncArrowFromCallExpression(node, call) {
        if (this.match(14)) {
          var oldNoAnonFunctionType = this.state.noAnonFunctionType;
          this.state.noAnonFunctionType = true;
          node.returnType = this.flowParseTypeAnnotation();
          this.state.noAnonFunctionType = oldNoAnonFunctionType;
        }
        return _superClass.prototype.parseAsyncArrowFromCallExpression.call(this, node, call);
      };
      _proto.shouldParseAsyncArrow = function shouldParseAsyncArrow() {
        return this.match(14) || _superClass.prototype.shouldParseAsyncArrow.call(this);
      };
      _proto.parseMaybeAssign = function parseMaybeAssign(refExpressionErrors, afterLeftParse) {
        var _this8 = this,
          _jsx;
        var state = null;
        var jsx;
        if (this.hasPlugin("jsx") && (this.match(143) || this.match(47))) {
          state = this.state.clone();
          jsx = this.tryParse(function () {
            return _superClass.prototype.parseMaybeAssign.call(_this8, refExpressionErrors, afterLeftParse);
          }, state);
          if (!jsx.error) return jsx.node;
          var context = this.state.context;
          var currentContext = context[context.length - 1];
          if (currentContext === types.j_oTag || currentContext === types.j_expr) {
            context.pop();
          }
        }
        if ((_jsx = jsx) != null && _jsx.error || this.match(47)) {
          var _jsx2, _jsx3;
          state = state || this.state.clone();
          var typeParameters;
          var arrow = this.tryParse(function (abort) {
            var _arrowExpression$extr;
            typeParameters = _this8.flowParseTypeParameterDeclaration();
            var arrowExpression = _this8.forwardNoArrowParamsConversionAt(typeParameters, function () {
              var result = _superClass.prototype.parseMaybeAssign.call(_this8, refExpressionErrors, afterLeftParse);
              _this8.resetStartLocationFromNode(result, typeParameters);
              return result;
            });
            if ((_arrowExpression$extr = arrowExpression.extra) != null && _arrowExpression$extr.parenthesized) abort();
            var expr = _this8.maybeUnwrapTypeCastExpression(arrowExpression);
            if (expr.type !== "ArrowFunctionExpression") abort();
            expr.typeParameters = typeParameters;
            _this8.resetStartLocationFromNode(expr, typeParameters);
            return arrowExpression;
          }, state);
          var arrowExpression = null;
          if (arrow.node && this.maybeUnwrapTypeCastExpression(arrow.node).type === "ArrowFunctionExpression") {
            if (!arrow.error && !arrow.aborted) {
              if (arrow.node.async) {
                this.raise(FlowErrors.UnexpectedTypeParameterBeforeAsyncArrowFunction, typeParameters);
              }
              return arrow.node;
            }
            arrowExpression = arrow.node;
          }
          if ((_jsx2 = jsx) != null && _jsx2.node) {
            this.state = jsx.failState;
            return jsx.node;
          }
          if (arrowExpression) {
            this.state = arrow.failState;
            return arrowExpression;
          }
          if ((_jsx3 = jsx) != null && _jsx3.thrown) throw jsx.error;
          if (arrow.thrown) throw arrow.error;
          throw this.raise(FlowErrors.UnexpectedTokenAfterTypeParameter, typeParameters);
        }
        return _superClass.prototype.parseMaybeAssign.call(this, refExpressionErrors, afterLeftParse);
      };
      _proto.parseArrow = function parseArrow(node) {
        var _this9 = this;
        if (this.match(14)) {
          var result = this.tryParse(function () {
            var oldNoAnonFunctionType = _this9.state.noAnonFunctionType;
            _this9.state.noAnonFunctionType = true;
            var typeNode = _this9.startNode();
            var _this9$flowParseTypeA = _this9.flowParseTypeAndPredicateInitialiser();
            typeNode.typeAnnotation = _this9$flowParseTypeA[0];
            node.predicate = _this9$flowParseTypeA[1];
            _this9.state.noAnonFunctionType = oldNoAnonFunctionType;
            if (_this9.canInsertSemicolon()) _this9.unexpected();
            if (!_this9.match(19)) _this9.unexpected();
            return typeNode;
          });
          if (result.thrown) return null;
          if (result.error) this.state = result.failState;
          node.returnType = result.node.typeAnnotation ? this.finishNode(result.node, "TypeAnnotation") : null;
        }
        return _superClass.prototype.parseArrow.call(this, node);
      };
      _proto.shouldParseArrow = function shouldParseArrow(params) {
        return this.match(14) || _superClass.prototype.shouldParseArrow.call(this, params);
      };
      _proto.setArrowFunctionParameters = function setArrowFunctionParameters(node, params) {
        if (this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(node.start))) {
          node.params = params;
        } else {
          _superClass.prototype.setArrowFunctionParameters.call(this, node, params);
        }
      };
      _proto.checkParams = function checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged) {
        if (strictModeChanged === void 0) {
          strictModeChanged = true;
        }
        if (isArrowFunction && this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(node.start))) {
          return;
        }
        for (var i = 0; i < node.params.length; i++) {
          if (this.isThisParam(node.params[i]) && i > 0) {
            this.raise(FlowErrors.ThisParamMustBeFirst, node.params[i]);
          }
        }
        _superClass.prototype.checkParams.call(this, node, allowDuplicates, isArrowFunction, strictModeChanged);
      };
      _proto.parseParenAndDistinguishExpression = function parseParenAndDistinguishExpression(canBeArrow) {
        return _superClass.prototype.parseParenAndDistinguishExpression.call(this, canBeArrow && !this.state.noArrowAt.includes(this.sourceToOffsetPos(this.state.start)));
      };
      _proto.parseSubscripts = function parseSubscripts(base, startLoc, noCalls) {
        var _this0 = this;
        if (base.type === "Identifier" && base.name === "async" && this.state.noArrowAt.includes(startLoc.index)) {
          this.next();
          var node = this.startNodeAt(startLoc);
          node.callee = base;
          node.arguments = _superClass.prototype.parseCallExpressionArguments.call(this);
          base = this.finishNode(node, "CallExpression");
        } else if (base.type === "Identifier" && base.name === "async" && this.match(47)) {
          var state = this.state.clone();
          var arrow = this.tryParse(function (abort) {
            return _this0.parseAsyncArrowWithTypeParameters(startLoc) || abort();
          }, state);
          if (!arrow.error && !arrow.aborted) return arrow.node;
          var result = this.tryParse(function () {
            return _superClass.prototype.parseSubscripts.call(_this0, base, startLoc, noCalls);
          }, state);
          if (result.node && !result.error) return result.node;
          if (arrow.node) {
            this.state = arrow.failState;
            return arrow.node;
          }
          if (result.node) {
            this.state = result.failState;
            return result.node;
          }
          throw arrow.error || result.error;
        }
        return _superClass.prototype.parseSubscripts.call(this, base, startLoc, noCalls);
      };
      _proto.parseSubscript = function parseSubscript(base, startLoc, noCalls, subscriptState) {
        var _this1 = this;
        if (this.match(18) && this.isLookaheadToken_lt()) {
          subscriptState.optionalChainMember = true;
          if (noCalls) {
            subscriptState.stop = true;
            return base;
          }
          this.next();
          var node = this.startNodeAt(startLoc);
          node.callee = base;
          node.typeArguments = this.flowParseTypeParameterInstantiationInExpression();
          this.expect(10);
          node.arguments = this.parseCallExpressionArguments();
          node.optional = true;
          return this.finishCallExpression(node, true);
        } else if (!noCalls && this.shouldParseTypes() && (this.match(47) || this.match(51))) {
          var _node6 = this.startNodeAt(startLoc);
          _node6.callee = base;
          var result = this.tryParse(function () {
            _node6.typeArguments = _this1.flowParseTypeParameterInstantiationCallOrNew();
            _this1.expect(10);
            _node6.arguments = _superClass.prototype.parseCallExpressionArguments.call(_this1);
            if (subscriptState.optionalChainMember) {
              _node6.optional = false;
            }
            return _this1.finishCallExpression(_node6, subscriptState.optionalChainMember);
          });
          if (result.node) {
            if (result.error) this.state = result.failState;
            return result.node;
          }
        }
        return _superClass.prototype.parseSubscript.call(this, base, startLoc, noCalls, subscriptState);
      };
      _proto.parseNewCallee = function parseNewCallee(node) {
        var _this10 = this;
        _superClass.prototype.parseNewCallee.call(this, node);
        var targs = null;
        if (this.shouldParseTypes() && this.match(47)) {
          targs = this.tryParse(function () {
            return _this10.flowParseTypeParameterInstantiationCallOrNew();
          }).node;
        }
        node.typeArguments = targs;
      };
      _proto.parseAsyncArrowWithTypeParameters = function parseAsyncArrowWithTypeParameters(startLoc) {
        var node = this.startNodeAt(startLoc);
        this.parseFunctionParams(node, false);
        if (!this.parseArrow(node)) return;
        return _superClass.prototype.parseArrowExpression.call(this, node, undefined, true);
      };
      _proto.readToken_mult_modulo = function readToken_mult_modulo(code) {
        var next = this.input.charCodeAt(this.state.pos + 1);
        if (code === 42 && next === 47 && this.state.hasFlowComment) {
          this.state.hasFlowComment = false;
          this.state.pos += 2;
          this.nextToken();
          return;
        }
        _superClass.prototype.readToken_mult_modulo.call(this, code);
      };
      _proto.readToken_pipe_amp = function readToken_pipe_amp(code) {
        var next = this.input.charCodeAt(this.state.pos + 1);
        if (code === 124 && next === 125) {
          this.finishOp(9, 2);
          return;
        }
        _superClass.prototype.readToken_pipe_amp.call(this, code);
      };
      _proto.parseTopLevel = function parseTopLevel(file, program) {
        var fileNode = _superClass.prototype.parseTopLevel.call(this, file, program);
        if (this.state.hasFlowComment) {
          this.raise(FlowErrors.UnterminatedFlowComment, this.state.curPosition());
        }
        return fileNode;
      };
      _proto.skipBlockComment = function skipBlockComment() {
        if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
          if (this.state.hasFlowComment) {
            throw this.raise(FlowErrors.NestedFlowComment, this.state.startLoc);
          }
          this.hasFlowCommentCompletion();
          var commentSkip = this.skipFlowComment();
          if (commentSkip) {
            this.state.pos += commentSkip;
            this.state.hasFlowComment = true;
          }
          return;
        }
        return _superClass.prototype.skipBlockComment.call(this, this.state.hasFlowComment ? "*-/" : "*/");
      };
      _proto.skipFlowComment = function skipFlowComment() {
        var pos = this.state.pos;
        var shiftToFirstNonWhiteSpace = 2;
        while ([32, 9].includes(this.input.charCodeAt(pos + shiftToFirstNonWhiteSpace))) {
          shiftToFirstNonWhiteSpace++;
        }
        var ch2 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos);
        var ch3 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos + 1);
        if (ch2 === 58 && ch3 === 58) {
          return shiftToFirstNonWhiteSpace + 2;
        }
        if (this.input.slice(shiftToFirstNonWhiteSpace + pos, shiftToFirstNonWhiteSpace + pos + 12) === "flow-include") {
          return shiftToFirstNonWhiteSpace + 12;
        }
        if (ch2 === 58 && ch3 !== 58) {
          return shiftToFirstNonWhiteSpace;
        }
        return false;
      };
      _proto.hasFlowCommentCompletion = function hasFlowCommentCompletion() {
        var end = this.input.indexOf("*/", this.state.pos);
        if (end === -1) {
          throw this.raise(Errors.UnterminatedComment, this.state.curPosition());
        }
      };
      _proto.flowEnumErrorBooleanMemberNotInitialized = function flowEnumErrorBooleanMemberNotInitialized(loc, _ref14) {
        var enumName = _ref14.enumName,
          memberName = _ref14.memberName;
        this.raise(FlowErrors.EnumBooleanMemberNotInitialized, loc, {
          memberName: memberName,
          enumName: enumName
        });
      };
      _proto.flowEnumErrorInvalidMemberInitializer = function flowEnumErrorInvalidMemberInitializer(loc, enumContext) {
        return this.raise(!enumContext.explicitType ? FlowErrors.EnumInvalidMemberInitializerUnknownType : enumContext.explicitType === "symbol" ? FlowErrors.EnumInvalidMemberInitializerSymbolType : FlowErrors.EnumInvalidMemberInitializerPrimaryType, loc, enumContext);
      };
      _proto.flowEnumErrorNumberMemberNotInitialized = function flowEnumErrorNumberMemberNotInitialized(loc, details) {
        this.raise(FlowErrors.EnumNumberMemberNotInitialized, loc, details);
      };
      _proto.flowEnumErrorStringMemberInconsistentlyInitialized = function flowEnumErrorStringMemberInconsistentlyInitialized(node, details) {
        this.raise(FlowErrors.EnumStringMemberInconsistentlyInitialized, node, details);
      };
      _proto.flowEnumMemberInit = function flowEnumMemberInit() {
        var _this11 = this;
        var startLoc = this.state.startLoc;
        var endOfInit = function endOfInit() {
          return _this11.match(12) || _this11.match(8);
        };
        switch (this.state.type) {
          case 135:
            {
              var literal = this.parseNumericLiteral(this.state.value);
              if (endOfInit()) {
                return {
                  type: "number",
                  loc: literal.loc.start,
                  value: literal
                };
              }
              return {
                type: "invalid",
                loc: startLoc
              };
            }
          case 134:
            {
              var _literal = this.parseStringLiteral(this.state.value);
              if (endOfInit()) {
                return {
                  type: "string",
                  loc: _literal.loc.start,
                  value: _literal
                };
              }
              return {
                type: "invalid",
                loc: startLoc
              };
            }
          case 85:
          case 86:
            {
              var _literal2 = this.parseBooleanLiteral(this.match(85));
              if (endOfInit()) {
                return {
                  type: "boolean",
                  loc: _literal2.loc.start,
                  value: _literal2
                };
              }
              return {
                type: "invalid",
                loc: startLoc
              };
            }
          default:
            return {
              type: "invalid",
              loc: startLoc
            };
        }
      };
      _proto.flowEnumMemberRaw = function flowEnumMemberRaw() {
        var loc = this.state.startLoc;
        var id = this.parseIdentifier(true);
        var init = this.eat(29) ? this.flowEnumMemberInit() : {
          type: "none",
          loc: loc
        };
        return {
          id: id,
          init: init
        };
      };
      _proto.flowEnumCheckExplicitTypeMismatch = function flowEnumCheckExplicitTypeMismatch(loc, context, expectedType) {
        var explicitType = context.explicitType;
        if (explicitType === null) {
          return;
        }
        if (explicitType !== expectedType) {
          this.flowEnumErrorInvalidMemberInitializer(loc, context);
        }
      };
      _proto.flowEnumMembers = function flowEnumMembers(_ref15) {
        var enumName = _ref15.enumName,
          explicitType = _ref15.explicitType;
        var seenNames = new Set();
        var members = {
          booleanMembers: [],
          numberMembers: [],
          stringMembers: [],
          defaultedMembers: []
        };
        var hasUnknownMembers = false;
        while (!this.match(8)) {
          if (this.eat(21)) {
            hasUnknownMembers = true;
            break;
          }
          var memberNode = this.startNode();
          var _this$flowEnumMemberR = this.flowEnumMemberRaw(),
            id = _this$flowEnumMemberR.id,
            init = _this$flowEnumMemberR.init;
          var memberName = id.name;
          if (memberName === "") {
            continue;
          }
          if (/^[a-z]/.test(memberName)) {
            this.raise(FlowErrors.EnumInvalidMemberName, id, {
              memberName: memberName,
              suggestion: memberName[0].toUpperCase() + memberName.slice(1),
              enumName: enumName
            });
          }
          if (seenNames.has(memberName)) {
            this.raise(FlowErrors.EnumDuplicateMemberName, id, {
              memberName: memberName,
              enumName: enumName
            });
          }
          seenNames.add(memberName);
          var context = {
            enumName: enumName,
            explicitType: explicitType,
            memberName: memberName
          };
          memberNode.id = id;
          switch (init.type) {
            case "boolean":
              {
                this.flowEnumCheckExplicitTypeMismatch(init.loc, context, "boolean");
                memberNode.init = init.value;
                members.booleanMembers.push(this.finishNode(memberNode, "EnumBooleanMember"));
                break;
              }
            case "number":
              {
                this.flowEnumCheckExplicitTypeMismatch(init.loc, context, "number");
                memberNode.init = init.value;
                members.numberMembers.push(this.finishNode(memberNode, "EnumNumberMember"));
                break;
              }
            case "string":
              {
                this.flowEnumCheckExplicitTypeMismatch(init.loc, context, "string");
                memberNode.init = init.value;
                members.stringMembers.push(this.finishNode(memberNode, "EnumStringMember"));
                break;
              }
            case "invalid":
              {
                throw this.flowEnumErrorInvalidMemberInitializer(init.loc, context);
              }
            case "none":
              {
                switch (explicitType) {
                  case "boolean":
                    this.flowEnumErrorBooleanMemberNotInitialized(init.loc, context);
                    break;
                  case "number":
                    this.flowEnumErrorNumberMemberNotInitialized(init.loc, context);
                    break;
                  default:
                    members.defaultedMembers.push(this.finishNode(memberNode, "EnumDefaultedMember"));
                }
              }
          }
          if (!this.match(8)) {
            this.expect(12);
          }
        }
        return {
          members: members,
          hasUnknownMembers: hasUnknownMembers
        };
      };
      _proto.flowEnumStringMembers = function flowEnumStringMembers(initializedMembers, defaultedMembers, _ref16) {
        var enumName = _ref16.enumName;
        if (initializedMembers.length === 0) {
          return defaultedMembers;
        } else if (defaultedMembers.length === 0) {
          return initializedMembers;
        } else if (defaultedMembers.length > initializedMembers.length) {
          for (var _i2 = 0; _i2 < initializedMembers.length; _i2++) {
            var member = initializedMembers[_i2];
            this.flowEnumErrorStringMemberInconsistentlyInitialized(member, {
              enumName: enumName
            });
          }
          return defaultedMembers;
        } else {
          for (var _i4 = 0; _i4 < defaultedMembers.length; _i4++) {
            var _member = defaultedMembers[_i4];
            this.flowEnumErrorStringMemberInconsistentlyInitialized(_member, {
              enumName: enumName
            });
          }
          return initializedMembers;
        }
      };
      _proto.flowEnumParseExplicitType = function flowEnumParseExplicitType(_ref17) {
        var enumName = _ref17.enumName;
        if (!this.eatContextual(102)) return null;
        if (!tokenIsIdentifier(this.state.type)) {
          throw this.raise(FlowErrors.EnumInvalidExplicitTypeUnknownSupplied, this.state.startLoc, {
            enumName: enumName
          });
        }
        var value = this.state.value;
        this.next();
        if (value !== "boolean" && value !== "number" && value !== "string" && value !== "symbol") {
          this.raise(FlowErrors.EnumInvalidExplicitType, this.state.startLoc, {
            enumName: enumName,
            invalidEnumType: value
          });
        }
        return value;
      };
      _proto.flowEnumBody = function flowEnumBody(node, id) {
        var _this12 = this;
        var enumName = id.name;
        var nameLoc = id.loc.start;
        var explicitType = this.flowEnumParseExplicitType({
          enumName: enumName
        });
        this.expect(5);
        var _this$flowEnumMembers = this.flowEnumMembers({
            enumName: enumName,
            explicitType: explicitType
          }),
          members = _this$flowEnumMembers.members,
          hasUnknownMembers = _this$flowEnumMembers.hasUnknownMembers;
        node.hasUnknownMembers = hasUnknownMembers;
        switch (explicitType) {
          case "boolean":
            node.explicitType = true;
            node.members = members.booleanMembers;
            this.expect(8);
            return this.finishNode(node, "EnumBooleanBody");
          case "number":
            node.explicitType = true;
            node.members = members.numberMembers;
            this.expect(8);
            return this.finishNode(node, "EnumNumberBody");
          case "string":
            node.explicitType = true;
            node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {
              enumName: enumName
            });
            this.expect(8);
            return this.finishNode(node, "EnumStringBody");
          case "symbol":
            node.members = members.defaultedMembers;
            this.expect(8);
            return this.finishNode(node, "EnumSymbolBody");
          default:
            {
              var empty = function empty() {
                node.members = [];
                _this12.expect(8);
                return _this12.finishNode(node, "EnumStringBody");
              };
              node.explicitType = false;
              var boolsLen = members.booleanMembers.length;
              var numsLen = members.numberMembers.length;
              var strsLen = members.stringMembers.length;
              var defaultedLen = members.defaultedMembers.length;
              if (!boolsLen && !numsLen && !strsLen && !defaultedLen) {
                return empty();
              } else if (!boolsLen && !numsLen) {
                node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {
                  enumName: enumName
                });
                this.expect(8);
                return this.finishNode(node, "EnumStringBody");
              } else if (!numsLen && !strsLen && boolsLen >= defaultedLen) {
                for (var _i6 = 0, _members$defaultedMem2 = members.defaultedMembers; _i6 < _members$defaultedMem2.length; _i6++) {
                  var member = _members$defaultedMem2[_i6];
                  this.flowEnumErrorBooleanMemberNotInitialized(member.loc.start, {
                    enumName: enumName,
                    memberName: member.id.name
                  });
                }
                node.members = members.booleanMembers;
                this.expect(8);
                return this.finishNode(node, "EnumBooleanBody");
              } else if (!boolsLen && !strsLen && numsLen >= defaultedLen) {
                for (var _i8 = 0, _members$defaultedMem4 = members.defaultedMembers; _i8 < _members$defaultedMem4.length; _i8++) {
                  var _member2 = _members$defaultedMem4[_i8];
                  this.flowEnumErrorNumberMemberNotInitialized(_member2.loc.start, {
                    enumName: enumName,
                    memberName: _member2.id.name
                  });
                }
                node.members = members.numberMembers;
                this.expect(8);
                return this.finishNode(node, "EnumNumberBody");
              } else {
                this.raise(FlowErrors.EnumInconsistentMemberValues, nameLoc, {
                  enumName: enumName
                });
                return empty();
              }
            }
        }
      };
      _proto.flowParseEnumDeclaration = function flowParseEnumDeclaration(node) {
        var id = this.parseIdentifier();
        node.id = id;
        node.body = this.flowEnumBody(this.startNode(), id);
        return this.finishNode(node, "EnumDeclaration");
      };
      _proto.jsxParseOpeningElementAfterName = function jsxParseOpeningElementAfterName(node) {
        if (this.shouldParseTypes()) {
          if (this.match(47) || this.match(51)) {
            node.typeArguments = this.flowParseTypeParameterInstantiationInExpression();
          }
        }
        return _superClass.prototype.jsxParseOpeningElementAfterName.call(this, node);
      };
      _proto.isLookaheadToken_lt = function isLookaheadToken_lt() {
        var next = this.nextTokenStart();
        if (this.input.charCodeAt(next) === 60) {
          var afterNext = this.input.charCodeAt(next + 1);
          return afterNext !== 60 && afterNext !== 61;
        }
        return false;
      };
      _proto.reScan_lt_gt = function reScan_lt_gt() {
        var type = this.state.type;
        if (type === 47) {
          this.state.pos -= 1;
          this.readToken_lt();
        } else if (type === 48) {
          this.state.pos -= 1;
          this.readToken_gt();
        }
      };
      _proto.reScan_lt = function reScan_lt() {
        var type = this.state.type;
        if (type === 51) {
          this.state.pos -= 2;
          this.finishOp(47, 1);
          return 47;
        }
        return type;
      };
      _proto.maybeUnwrapTypeCastExpression = function maybeUnwrapTypeCastExpression(node) {
        return node.type === "TypeCastExpression" ? node.expression : node;
      };
      return _createClass(FlowParserMixin);
    }(superClass);
  });

  var entities = {
    __proto__: null,
    quot: "\"",
    amp: "&",
    apos: "'",
    lt: "<",
    gt: ">",
    nbsp: "\xA0",
    iexcl: "\xA1",
    cent: "\xA2",
    pound: "\xA3",
    curren: "\xA4",
    yen: "\xA5",
    brvbar: "\xA6",
    sect: "\xA7",
    uml: "\xA8",
    copy: "\xA9",
    ordf: "\xAA",
    laquo: "\xAB",
    not: "\xAC",
    shy: "\xAD",
    reg: "\xAE",
    macr: "\xAF",
    deg: "\xB0",
    plusmn: "\xB1",
    sup2: "\xB2",
    sup3: "\xB3",
    acute: "\xB4",
    micro: "\xB5",
    para: "\xB6",
    middot: "\xB7",
    cedil: "\xB8",
    sup1: "\xB9",
    ordm: "\xBA",
    raquo: "\xBB",
    frac14: "\xBC",
    frac12: "\xBD",
    frac34: "\xBE",
    iquest: "\xBF",
    Agrave: "\xC0",
    Aacute: "\xC1",
    Acirc: "\xC2",
    Atilde: "\xC3",
    Auml: "\xC4",
    Aring: "\xC5",
    AElig: "\xC6",
    Ccedil: "\xC7",
    Egrave: "\xC8",
    Eacute: "\xC9",
    Ecirc: "\xCA",
    Euml: "\xCB",
    Igrave: "\xCC",
    Iacute: "\xCD",
    Icirc: "\xCE",
    Iuml: "\xCF",
    ETH: "\xD0",
    Ntilde: "\xD1",
    Ograve: "\xD2",
    Oacute: "\xD3",
    Ocirc: "\xD4",
    Otilde: "\xD5",
    Ouml: "\xD6",
    times: "\xD7",
    Oslash: "\xD8",
    Ugrave: "\xD9",
    Uacute: "\xDA",
    Ucirc: "\xDB",
    Uuml: "\xDC",
    Yacute: "\xDD",
    THORN: "\xDE",
    szlig: "\xDF",
    agrave: "\xE0",
    aacute: "\xE1",
    acirc: "\xE2",
    atilde: "\xE3",
    auml: "\xE4",
    aring: "\xE5",
    aelig: "\xE6",
    ccedil: "\xE7",
    egrave: "\xE8",
    eacute: "\xE9",
    ecirc: "\xEA",
    euml: "\xEB",
    igrave: "\xEC",
    iacute: "\xED",
    icirc: "\xEE",
    iuml: "\xEF",
    eth: "\xF0",
    ntilde: "\xF1",
    ograve: "\xF2",
    oacute: "\xF3",
    ocirc: "\xF4",
    otilde: "\xF5",
    ouml: "\xF6",
    divide: "\xF7",
    oslash: "\xF8",
    ugrave: "\xF9",
    uacute: "\xFA",
    ucirc: "\xFB",
    uuml: "\xFC",
    yacute: "\xFD",
    thorn: "\xFE",
    yuml: "\xFF",
    OElig: "\u0152",
    oelig: "\u0153",
    Scaron: "\u0160",
    scaron: "\u0161",
    Yuml: "\u0178",
    fnof: "\u0192",
    circ: "\u02C6",
    tilde: "\u02DC",
    Alpha: "\u0391",
    Beta: "\u0392",
    Gamma: "\u0393",
    Delta: "\u0394",
    Epsilon: "\u0395",
    Zeta: "\u0396",
    Eta: "\u0397",
    Theta: "\u0398",
    Iota: "\u0399",
    Kappa: "\u039A",
    Lambda: "\u039B",
    Mu: "\u039C",
    Nu: "\u039D",
    Xi: "\u039E",
    Omicron: "\u039F",
    Pi: "\u03A0",
    Rho: "\u03A1",
    Sigma: "\u03A3",
    Tau: "\u03A4",
    Upsilon: "\u03A5",
    Phi: "\u03A6",
    Chi: "\u03A7",
    Psi: "\u03A8",
    Omega: "\u03A9",
    alpha: "\u03B1",
    beta: "\u03B2",
    gamma: "\u03B3",
    delta: "\u03B4",
    epsilon: "\u03B5",
    zeta: "\u03B6",
    eta: "\u03B7",
    theta: "\u03B8",
    iota: "\u03B9",
    kappa: "\u03BA",
    lambda: "\u03BB",
    mu: "\u03BC",
    nu: "\u03BD",
    xi: "\u03BE",
    omicron: "\u03BF",
    pi: "\u03C0",
    rho: "\u03C1",
    sigmaf: "\u03C2",
    sigma: "\u03C3",
    tau: "\u03C4",
    upsilon: "\u03C5",
    phi: "\u03C6",
    chi: "\u03C7",
    psi: "\u03C8",
    omega: "\u03C9",
    thetasym: "\u03D1",
    upsih: "\u03D2",
    piv: "\u03D6",
    ensp: "\u2002",
    emsp: "\u2003",
    thinsp: "\u2009",
    zwnj: "\u200C",
    zwj: "\u200D",
    lrm: "\u200E",
    rlm: "\u200F",
    ndash: "\u2013",
    mdash: "\u2014",
    lsquo: "\u2018",
    rsquo: "\u2019",
    sbquo: "\u201A",
    ldquo: "\u201C",
    rdquo: "\u201D",
    bdquo: "\u201E",
    dagger: "\u2020",
    Dagger: "\u2021",
    bull: "\u2022",
    hellip: "\u2026",
    permil: "\u2030",
    prime: "\u2032",
    Prime: "\u2033",
    lsaquo: "\u2039",
    rsaquo: "\u203A",
    oline: "\u203E",
    frasl: "\u2044",
    euro: "\u20AC",
    image: "\u2111",
    weierp: "\u2118",
    real: "\u211C",
    trade: "\u2122",
    alefsym: "\u2135",
    larr: "\u2190",
    uarr: "\u2191",
    rarr: "\u2192",
    darr: "\u2193",
    harr: "\u2194",
    crarr: "\u21B5",
    lArr: "\u21D0",
    uArr: "\u21D1",
    rArr: "\u21D2",
    dArr: "\u21D3",
    hArr: "\u21D4",
    forall: "\u2200",
    part: "\u2202",
    exist: "\u2203",
    empty: "\u2205",
    nabla: "\u2207",
    isin: "\u2208",
    notin: "\u2209",
    ni: "\u220B",
    prod: "\u220F",
    sum: "\u2211",
    minus: "\u2212",
    lowast: "\u2217",
    radic: "\u221A",
    prop: "\u221D",
    infin: "\u221E",
    ang: "\u2220",
    and: "\u2227",
    or: "\u2228",
    cap: "\u2229",
    cup: "\u222A",
    "int": "\u222B",
    there4: "\u2234",
    sim: "\u223C",
    cong: "\u2245",
    asymp: "\u2248",
    ne: "\u2260",
    equiv: "\u2261",
    le: "\u2264",
    ge: "\u2265",
    sub: "\u2282",
    sup: "\u2283",
    nsub: "\u2284",
    sube: "\u2286",
    supe: "\u2287",
    oplus: "\u2295",
    otimes: "\u2297",
    perp: "\u22A5",
    sdot: "\u22C5",
    lceil: "\u2308",
    rceil: "\u2309",
    lfloor: "\u230A",
    rfloor: "\u230B",
    lang: "\u2329",
    rang: "\u232A",
    loz: "\u25CA",
    spades: "\u2660",
    clubs: "\u2663",
    hearts: "\u2665",
    diams: "\u2666"
  };

  var lineBreak = /\r\n|[\r\n\u2028\u2029]/;
  var lineBreakG = new RegExp(lineBreak.source, "g");
  function isNewLine(code) {
    switch (code) {
      case 10:
      case 13:
      case 8232:
      case 8233:
        return true;
      default:
        return false;
    }
  }
  function hasNewLine(input, start, end) {
    for (var i = start; i < end; i++) {
      if (isNewLine(input.charCodeAt(i))) {
        return true;
      }
    }
    return false;
  }
  var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
  var skipWhiteSpaceInLine = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/g;
  function isWhitespace(code) {
    switch (code) {
      case 0x0009:
      case 0x000b:
      case 0x000c:
      case 32:
      case 160:
      case 5760:
      case 0x2000:
      case 0x2001:
      case 0x2002:
      case 0x2003:
      case 0x2004:
      case 0x2005:
      case 0x2006:
      case 0x2007:
      case 0x2008:
      case 0x2009:
      case 0x200a:
      case 0x202f:
      case 0x205f:
      case 0x3000:
      case 0xfeff:
        return true;
      default:
        return false;
    }
  }

  var _templateObject$K;
  var JsxErrors = ParseErrorEnum(_templateObject$K || (_templateObject$K = _taggedTemplateLiteralLoose(["jsx"])))({
    AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.",
    MissingClosingTagElement: function MissingClosingTagElement(_ref) {
      var openingTagName = _ref.openingTagName;
      return "Expected corresponding JSX closing tag for <" + openingTagName + ">.";
    },
    MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.",
    UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?",
    UnexpectedToken: function UnexpectedToken(_ref2) {
      var unexpected = _ref2.unexpected,
        HTMLEntity = _ref2.HTMLEntity;
      return "Unexpected token `" + unexpected + "`. Did you mean `" + HTMLEntity + "` or `{'" + unexpected + "'}`?";
    },
    UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.",
    UnterminatedJsxContent: "Unterminated JSX contents.",
    UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?"
  });
  function isFragment(object) {
    return object ? object.type === "JSXOpeningFragment" || object.type === "JSXClosingFragment" : false;
  }
  function getQualifiedJSXName(object) {
    if (object.type === "JSXIdentifier") {
      return object.name;
    }
    if (object.type === "JSXNamespacedName") {
      return object.namespace.name + ":" + object.name.name;
    }
    if (object.type === "JSXMemberExpression") {
      return getQualifiedJSXName(object.object) + "." + getQualifiedJSXName(object.property);
    }
    throw new Error("Node had unexpected type: " + object.type);
  }
  var jsx = (function (superClass) {
    return function (_superClass) {
      function JSXParserMixin() {
        return _superClass.apply(this, arguments) || this;
      }
      _inherits(JSXParserMixin, _superClass);
      var _proto = JSXParserMixin.prototype;
      _proto.jsxReadToken = function jsxReadToken() {
        var out = "";
        var chunkStart = this.state.pos;
        for (;;) {
          if (this.state.pos >= this.length) {
            throw this.raise(JsxErrors.UnterminatedJsxContent, this.state.startLoc);
          }
          var ch = this.input.charCodeAt(this.state.pos);
          switch (ch) {
            case 60:
            case 123:
              if (this.state.pos === this.state.start) {
                if (ch === 60 && this.state.canStartJSXElement) {
                  ++this.state.pos;
                  this.finishToken(143);
                } else {
                  _superClass.prototype.getTokenFromCode.call(this, ch);
                }
                return;
              }
              out += this.input.slice(chunkStart, this.state.pos);
              this.finishToken(142, out);
              return;
            case 38:
              out += this.input.slice(chunkStart, this.state.pos);
              out += this.jsxReadEntity();
              chunkStart = this.state.pos;
              break;
            case 62:
            case 125:
            default:
              if (isNewLine(ch)) {
                out += this.input.slice(chunkStart, this.state.pos);
                out += this.jsxReadNewLine(true);
                chunkStart = this.state.pos;
              } else {
                ++this.state.pos;
              }
          }
        }
      };
      _proto.jsxReadNewLine = function jsxReadNewLine(normalizeCRLF) {
        var ch = this.input.charCodeAt(this.state.pos);
        var out;
        ++this.state.pos;
        if (ch === 13 && this.input.charCodeAt(this.state.pos) === 10) {
          ++this.state.pos;
          out = normalizeCRLF ? "\n" : "\r\n";
        } else {
          out = String.fromCharCode(ch);
        }
        ++this.state.curLine;
        this.state.lineStart = this.state.pos;
        return out;
      };
      _proto.jsxReadString = function jsxReadString(quote) {
        var out = "";
        var chunkStart = ++this.state.pos;
        for (;;) {
          if (this.state.pos >= this.length) {
            throw this.raise(Errors.UnterminatedString, this.state.startLoc);
          }
          var ch = this.input.charCodeAt(this.state.pos);
          if (ch === quote) break;
          if (ch === 38) {
            out += this.input.slice(chunkStart, this.state.pos);
            out += this.jsxReadEntity();
            chunkStart = this.state.pos;
          } else if (isNewLine(ch)) {
            out += this.input.slice(chunkStart, this.state.pos);
            out += this.jsxReadNewLine(false);
            chunkStart = this.state.pos;
          } else {
            ++this.state.pos;
          }
        }
        out += this.input.slice(chunkStart, this.state.pos++);
        this.finishToken(134, out);
      };
      _proto.jsxReadEntity = function jsxReadEntity() {
        var startPos = ++this.state.pos;
        if (this.codePointAtPos(this.state.pos) === 35) {
          ++this.state.pos;
          var radix = 10;
          if (this.codePointAtPos(this.state.pos) === 120) {
            radix = 16;
            ++this.state.pos;
          }
          var codePoint = this.readInt(radix, undefined, false, "bail");
          if (codePoint !== null && this.codePointAtPos(this.state.pos) === 59) {
            ++this.state.pos;
            return String.fromCodePoint(codePoint);
          }
        } else {
          var count = 0;
          var semi = false;
          while (count++ < 10 && this.state.pos < this.length && !(semi = this.codePointAtPos(this.state.pos) === 59)) {
            ++this.state.pos;
          }
          if (semi) {
            var desc = this.input.slice(startPos, this.state.pos);
            var entity = entities[desc];
            ++this.state.pos;
            if (entity) {
              return entity;
            }
          }
        }
        this.state.pos = startPos;
        return "&";
      };
      _proto.jsxReadWord = function jsxReadWord() {
        var ch;
        var start = this.state.pos;
        do {
          ch = this.input.charCodeAt(++this.state.pos);
        } while (isIdentifierChar(ch) || ch === 45);
        this.finishToken(141, this.input.slice(start, this.state.pos));
      };
      _proto.jsxParseIdentifier = function jsxParseIdentifier() {
        var node = this.startNode();
        if (this.match(141)) {
          node.name = this.state.value;
        } else if (tokenIsKeyword(this.state.type)) {
          node.name = tokenLabelName(this.state.type);
        } else {
          this.unexpected();
        }
        this.next();
        return this.finishNode(node, "JSXIdentifier");
      };
      _proto.jsxParseNamespacedName = function jsxParseNamespacedName() {
        var startLoc = this.state.startLoc;
        var name = this.jsxParseIdentifier();
        if (!this.eat(14)) return name;
        var node = this.startNodeAt(startLoc);
        node.namespace = name;
        node.name = this.jsxParseIdentifier();
        return this.finishNode(node, "JSXNamespacedName");
      };
      _proto.jsxParseElementName = function jsxParseElementName() {
        var startLoc = this.state.startLoc;
        var node = this.jsxParseNamespacedName();
        if (node.type === "JSXNamespacedName") {
          return node;
        }
        while (this.eat(16)) {
          var newNode = this.startNodeAt(startLoc);
          newNode.object = node;
          newNode.property = this.jsxParseIdentifier();
          node = this.finishNode(newNode, "JSXMemberExpression");
        }
        return node;
      };
      _proto.jsxParseAttributeValue = function jsxParseAttributeValue() {
        var node;
        switch (this.state.type) {
          case 5:
            node = this.startNode();
            this.setContext(types.brace);
            this.next();
            node = this.jsxParseExpressionContainer(node, types.j_oTag);
            if (node.expression.type === "JSXEmptyExpression") {
              this.raise(JsxErrors.AttributeIsEmpty, node);
            }
            return node;
          case 143:
          case 134:
            return this.parseExprAtom();
          default:
            throw this.raise(JsxErrors.UnsupportedJsxValue, this.state.startLoc);
        }
      };
      _proto.jsxParseEmptyExpression = function jsxParseEmptyExpression() {
        var node = this.startNodeAt(this.state.lastTokEndLoc);
        return this.finishNodeAt(node, "JSXEmptyExpression", this.state.startLoc);
      };
      _proto.jsxParseSpreadChild = function jsxParseSpreadChild(node) {
        this.next();
        node.expression = this.parseExpression();
        this.setContext(types.j_expr);
        this.state.canStartJSXElement = true;
        this.expect(8);
        return this.finishNode(node, "JSXSpreadChild");
      };
      _proto.jsxParseExpressionContainer = function jsxParseExpressionContainer(node, previousContext) {
        if (this.match(8)) {
          node.expression = this.jsxParseEmptyExpression();
        } else {
          var expression = this.parseExpression();
          node.expression = expression;
        }
        this.setContext(previousContext);
        this.state.canStartJSXElement = true;
        this.expect(8);
        return this.finishNode(node, "JSXExpressionContainer");
      };
      _proto.jsxParseAttribute = function jsxParseAttribute() {
        var node = this.startNode();
        if (this.match(5)) {
          this.setContext(types.brace);
          this.next();
          this.expect(21);
          node.argument = this.parseMaybeAssignAllowIn();
          this.setContext(types.j_oTag);
          this.state.canStartJSXElement = true;
          this.expect(8);
          return this.finishNode(node, "JSXSpreadAttribute");
        }
        node.name = this.jsxParseNamespacedName();
        node.value = this.eat(29) ? this.jsxParseAttributeValue() : null;
        return this.finishNode(node, "JSXAttribute");
      };
      _proto.jsxParseOpeningElementAt = function jsxParseOpeningElementAt(startLoc) {
        var node = this.startNodeAt(startLoc);
        if (this.eat(144)) {
          return this.finishNode(node, "JSXOpeningFragment");
        }
        node.name = this.jsxParseElementName();
        return this.jsxParseOpeningElementAfterName(node);
      };
      _proto.jsxParseOpeningElementAfterName = function jsxParseOpeningElementAfterName(node) {
        var attributes = [];
        while (!this.match(56) && !this.match(144)) {
          attributes.push(this.jsxParseAttribute());
        }
        node.attributes = attributes;
        node.selfClosing = this.eat(56);
        this.expect(144);
        return this.finishNode(node, "JSXOpeningElement");
      };
      _proto.jsxParseClosingElementAt = function jsxParseClosingElementAt(startLoc) {
        var node = this.startNodeAt(startLoc);
        if (this.eat(144)) {
          return this.finishNode(node, "JSXClosingFragment");
        }
        node.name = this.jsxParseElementName();
        this.expect(144);
        return this.finishNode(node, "JSXClosingElement");
      };
      _proto.jsxParseElementAt = function jsxParseElementAt(startLoc) {
        var node = this.startNodeAt(startLoc);
        var children = [];
        var openingElement = this.jsxParseOpeningElementAt(startLoc);
        var closingElement = null;
        if (!openingElement.selfClosing) {
          contents: for (;;) {
            switch (this.state.type) {
              case 143:
                startLoc = this.state.startLoc;
                this.next();
                if (this.eat(56)) {
                  closingElement = this.jsxParseClosingElementAt(startLoc);
                  break contents;
                }
                children.push(this.jsxParseElementAt(startLoc));
                break;
              case 142:
                children.push(this.parseLiteral(this.state.value, "JSXText"));
                break;
              case 5:
                {
                  var _node = this.startNode();
                  this.setContext(types.brace);
                  this.next();
                  if (this.match(21)) {
                    children.push(this.jsxParseSpreadChild(_node));
                  } else {
                    children.push(this.jsxParseExpressionContainer(_node, types.j_expr));
                  }
                  break;
                }
              default:
                this.unexpected();
            }
          }
          if (isFragment(openingElement) && !isFragment(closingElement) && closingElement !== null) {
            this.raise(JsxErrors.MissingClosingTagFragment, closingElement);
          } else if (!isFragment(openingElement) && isFragment(closingElement)) {
            this.raise(JsxErrors.MissingClosingTagElement, closingElement, {
              openingTagName: getQualifiedJSXName(openingElement.name)
            });
          } else if (!isFragment(openingElement) && !isFragment(closingElement)) {
            if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {
              this.raise(JsxErrors.MissingClosingTagElement, closingElement, {
                openingTagName: getQualifiedJSXName(openingElement.name)
              });
            }
          }
        }
        if (isFragment(openingElement)) {
          node.openingFragment = openingElement;
          node.closingFragment = closingElement;
        } else {
          node.openingElement = openingElement;
          node.closingElement = closingElement;
        }
        node.children = children;
        if (this.match(47)) {
          throw this.raise(JsxErrors.UnwrappedAdjacentJSXElements, this.state.startLoc);
        }
        return isFragment(openingElement) ? this.finishNode(node, "JSXFragment") : this.finishNode(node, "JSXElement");
      };
      _proto.jsxParseElement = function jsxParseElement() {
        var startLoc = this.state.startLoc;
        this.next();
        return this.jsxParseElementAt(startLoc);
      };
      _proto.setContext = function setContext(newContext) {
        var context = this.state.context;
        context[context.length - 1] = newContext;
      };
      _proto.parseExprAtom = function parseExprAtom(refExpressionErrors) {
        if (this.match(143)) {
          return this.jsxParseElement();
        } else if (this.match(47) && this.input.charCodeAt(this.state.pos) !== 33) {
          this.replaceToken(143);
          return this.jsxParseElement();
        } else {
          return _superClass.prototype.parseExprAtom.call(this, refExpressionErrors);
        }
      };
      _proto.skipSpace = function skipSpace() {
        var curContext = this.curContext();
        if (!curContext.preserveSpace) _superClass.prototype.skipSpace.call(this);
      };
      _proto.getTokenFromCode = function getTokenFromCode(code) {
        var context = this.curContext();
        if (context === types.j_expr) {
          this.jsxReadToken();
          return;
        }
        if (context === types.j_oTag || context === types.j_cTag) {
          if (isIdentifierStart(code)) {
            this.jsxReadWord();
            return;
          }
          if (code === 62) {
            ++this.state.pos;
            this.finishToken(144);
            return;
          }
          if ((code === 34 || code === 39) && context === types.j_oTag) {
            this.jsxReadString(code);
            return;
          }
        }
        if (code === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33) {
          ++this.state.pos;
          this.finishToken(143);
          return;
        }
        _superClass.prototype.getTokenFromCode.call(this, code);
      };
      _proto.updateContext = function updateContext(prevType) {
        var _this$state = this.state,
          context = _this$state.context,
          type = _this$state.type;
        if (type === 56 && prevType === 143) {
          context.splice(-2, 2, types.j_cTag);
          this.state.canStartJSXElement = false;
        } else if (type === 143) {
          context.push(types.j_oTag);
        } else if (type === 144) {
          var out = context[context.length - 1];
          if (out === types.j_oTag && prevType === 56 || out === types.j_cTag) {
            context.pop();
            this.state.canStartJSXElement = context[context.length - 1] === types.j_expr;
          } else {
            this.setContext(types.j_expr);
            this.state.canStartJSXElement = true;
          }
        } else {
          this.state.canStartJSXElement = tokenComesBeforeExpression(type);
        }
      };
      return _createClass(JSXParserMixin);
    }(superClass);
  });

  var TypeScriptScope = function (_Scope) {
    function TypeScriptScope() {
      var _this;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _Scope.call.apply(_Scope, [this].concat(args)) || this;
      _this.tsNames = new Map();
      return _this;
    }
    _inherits(TypeScriptScope, _Scope);
    return _createClass(TypeScriptScope);
  }(Scope$2);
  var TypeScriptScopeHandler = function (_ScopeHandler) {
    function TypeScriptScopeHandler() {
      var _this2;
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      _this2 = _ScopeHandler.call.apply(_ScopeHandler, [this].concat(args)) || this;
      _this2.importsStack = [];
      return _this2;
    }
    _inherits(TypeScriptScopeHandler, _ScopeHandler);
    var _proto = TypeScriptScopeHandler.prototype;
    _proto.createScope = function createScope(flags) {
      this.importsStack.push(new Set());
      return new TypeScriptScope(flags);
    };
    _proto.enter = function enter(flags) {
      if (flags === ScopeFlag.TS_MODULE) {
        this.importsStack.push(new Set());
      }
      _ScopeHandler.prototype.enter.call(this, flags);
    };
    _proto.exit = function exit() {
      var flags = _ScopeHandler.prototype.exit.call(this);
      if (flags === ScopeFlag.TS_MODULE) {
        this.importsStack.pop();
      }
      return flags;
    };
    _proto.hasImport = function hasImport(name, allowShadow) {
      var len = this.importsStack.length;
      if (this.importsStack[len - 1].has(name)) {
        return true;
      }
      if (!allowShadow && len > 1) {
        for (var i = 0; i < len - 1; i++) {
          if (this.importsStack[i].has(name)) return true;
        }
      }
      return false;
    };
    _proto.declareName = function declareName(name, bindingType, loc) {
      if (bindingType & BindingFlag.FLAG_TS_IMPORT) {
        if (this.hasImport(name, true)) {
          this.parser.raise(Errors.VarRedeclaration, loc, {
            identifierName: name
          });
        }
        this.importsStack[this.importsStack.length - 1].add(name);
        return;
      }
      var scope = this.currentScope();
      var type = scope.tsNames.get(name) || 0;
      if (bindingType & BindingFlag.FLAG_TS_EXPORT_ONLY) {
        this.maybeExportDefined(scope, name);
        scope.tsNames.set(name, type | 16);
        return;
      }
      _ScopeHandler.prototype.declareName.call(this, name, bindingType, loc);
      if (bindingType & BindingFlag.KIND_TYPE) {
        if (!(bindingType & BindingFlag.KIND_VALUE)) {
          this.checkRedeclarationInScope(scope, name, bindingType, loc);
          this.maybeExportDefined(scope, name);
        }
        type = type | 1;
      }
      if (bindingType & BindingFlag.FLAG_TS_ENUM) {
        type = type | 2;
      }
      if (bindingType & BindingFlag.FLAG_TS_CONST_ENUM) {
        type = type | 4;
      }
      if (bindingType & BindingFlag.FLAG_CLASS) {
        type = type | 8;
      }
      if (type) scope.tsNames.set(name, type);
    };
    _proto.isRedeclaredInScope = function isRedeclaredInScope(scope, name, bindingType) {
      var type = scope.tsNames.get(name);
      if ((type & 2) > 0) {
        if (bindingType & BindingFlag.FLAG_TS_ENUM) {
          var isConst = !!(bindingType & BindingFlag.FLAG_TS_CONST_ENUM);
          var wasConst = (type & 4) > 0;
          return isConst !== wasConst;
        }
        return true;
      }
      if (bindingType & BindingFlag.FLAG_CLASS && (type & 8) > 0) {
        if (scope.names.get(name) & NameType.Lexical) {
          return !!(bindingType & BindingFlag.KIND_VALUE);
        } else {
          return false;
        }
      }
      if (bindingType & BindingFlag.KIND_TYPE && (type & 1) > 0) {
        return true;
      }
      return _ScopeHandler.prototype.isRedeclaredInScope.call(this, scope, name, bindingType);
    };
    _proto.checkLocalExport = function checkLocalExport(id) {
      var name = id.name;
      if (this.hasImport(name)) return;
      var len = this.scopeStack.length;
      for (var i = len - 1; i >= 0; i--) {
        var scope = this.scopeStack[i];
        var type = scope.tsNames.get(name);
        if ((type & 1) > 0 || (type & 16) > 0) {
          return;
        }
      }
      _ScopeHandler.prototype.checkLocalExport.call(this, id);
    };
    return _createClass(TypeScriptScopeHandler);
  }(ScopeHandler);

  var ParamKind = {
    PARAM: 0,
    PARAM_YIELD: 1,
    PARAM_AWAIT: 2,
    PARAM_RETURN: 4,
    PARAM_IN: 8
  };
  var ProductionParameterHandler = function () {
    function ProductionParameterHandler() {
      this.stacks = [];
    }
    var _proto = ProductionParameterHandler.prototype;
    _proto.enter = function enter(flags) {
      this.stacks.push(flags);
    };
    _proto.exit = function exit() {
      this.stacks.pop();
    };
    _proto.currentFlags = function currentFlags() {
      return this.stacks[this.stacks.length - 1];
    };
    return _createClass(ProductionParameterHandler, [{
      key: "hasAwait",
      get: function get() {
        return (this.currentFlags() & ParamKind.PARAM_AWAIT) > 0;
      }
    }, {
      key: "hasYield",
      get: function get() {
        return (this.currentFlags() & ParamKind.PARAM_YIELD) > 0;
      }
    }, {
      key: "hasReturn",
      get: function get() {
        return (this.currentFlags() & ParamKind.PARAM_RETURN) > 0;
      }
    }, {
      key: "hasIn",
      get: function get() {
        return (this.currentFlags() & ParamKind.PARAM_IN) > 0;
      }
    }]);
  }();
  function functionFlags(isAsync, isGenerator) {
    return (isAsync ? ParamKind.PARAM_AWAIT : 0) | (isGenerator ? ParamKind.PARAM_YIELD : 0);
  }

  var BaseParser = function () {
    function BaseParser() {
      this.sawUnambiguousESM = false;
      this.ambiguousScriptDifferentAst = false;
    }
    var _proto = BaseParser.prototype;
    _proto.sourceToOffsetPos = function sourceToOffsetPos(sourcePos) {
      return sourcePos + this.startIndex;
    };
    _proto.offsetToSourcePos = function offsetToSourcePos(offsetPos) {
      return offsetPos - this.startIndex;
    };
    _proto.hasPlugin = function hasPlugin(pluginConfig) {
      if (typeof pluginConfig === "string") {
        return this.plugins.has(pluginConfig);
      } else {
        var pluginName = pluginConfig[0],
          pluginOptions = pluginConfig[1];
        if (!this.hasPlugin(pluginName)) {
          return false;
        }
        var actualOptions = this.plugins.get(pluginName);
        for (var _i2 = 0, _Object$keys2 = Object.keys(pluginOptions); _i2 < _Object$keys2.length; _i2++) {
          var key = _Object$keys2[_i2];
          if ((actualOptions == null ? void 0 : actualOptions[key]) !== pluginOptions[key]) {
            return false;
          }
        }
        return true;
      }
    };
    _proto.getPluginOption = function getPluginOption(plugin, name) {
      var _this$plugins$get;
      return (_this$plugins$get = this.plugins.get(plugin)) == null ? void 0 : _this$plugins$get[name];
    };
    return _createClass(BaseParser);
  }();

  function setTrailingComments(node, comments) {
    if (node.trailingComments === undefined) {
      node.trailingComments = comments;
    } else {
      var _node$trailingComment;
      (_node$trailingComment = node.trailingComments).unshift.apply(_node$trailingComment, comments);
    }
  }
  function setLeadingComments(node, comments) {
    if (node.leadingComments === undefined) {
      node.leadingComments = comments;
    } else {
      var _node$leadingComments;
      (_node$leadingComments = node.leadingComments).unshift.apply(_node$leadingComments, comments);
    }
  }
  function setInnerComments(node, comments) {
    if (node.innerComments === undefined) {
      node.innerComments = comments;
    } else {
      var _node$innerComments;
      (_node$innerComments = node.innerComments).unshift.apply(_node$innerComments, comments);
    }
  }
  function adjustInnerComments(node, elements, commentWS) {
    var lastElement = null;
    var i = elements.length;
    while (lastElement === null && i > 0) {
      lastElement = elements[--i];
    }
    if (lastElement === null || lastElement.start > commentWS.start) {
      setInnerComments(node, commentWS.comments);
    } else {
      setTrailingComments(lastElement, commentWS.comments);
    }
  }
  var CommentsParser = function (_BaseParser) {
    function CommentsParser() {
      return _BaseParser.apply(this, arguments) || this;
    }
    _inherits(CommentsParser, _BaseParser);
    var _proto = CommentsParser.prototype;
    _proto.addComment = function addComment(comment) {
      if (this.filename) comment.loc.filename = this.filename;
      var commentsLen = this.state.commentsLen;
      if (this.comments.length !== commentsLen) {
        this.comments.length = commentsLen;
      }
      this.comments.push(comment);
      this.state.commentsLen++;
    };
    _proto.processComment = function processComment(node) {
      var commentStack = this.state.commentStack;
      var commentStackLength = commentStack.length;
      if (commentStackLength === 0) return;
      var i = commentStackLength - 1;
      var lastCommentWS = commentStack[i];
      if (lastCommentWS.start === node.end) {
        lastCommentWS.leadingNode = node;
        i--;
      }
      var nodeStart = node.start;
      for (; i >= 0; i--) {
        var commentWS = commentStack[i];
        var commentEnd = commentWS.end;
        if (commentEnd > nodeStart) {
          commentWS.containingNode = node;
          this.finalizeComment(commentWS);
          commentStack.splice(i, 1);
        } else {
          if (commentEnd === nodeStart) {
            commentWS.trailingNode = node;
          }
          break;
        }
      }
    };
    _proto.finalizeComment = function finalizeComment(commentWS) {
      var _node$options;
      var comments = commentWS.comments;
      if (commentWS.leadingNode !== null || commentWS.trailingNode !== null) {
        if (commentWS.leadingNode !== null) {
          setTrailingComments(commentWS.leadingNode, comments);
        }
        if (commentWS.trailingNode !== null) {
          setLeadingComments(commentWS.trailingNode, comments);
        }
      } else {
        var node = commentWS.containingNode,
          commentStart = commentWS.start;
        if (this.input.charCodeAt(this.offsetToSourcePos(commentStart) - 1) === 44) {
          switch (node.type) {
            case "ObjectExpression":
            case "ObjectPattern":
            case "RecordExpression":
              adjustInnerComments(node, node.properties, commentWS);
              break;
            case "CallExpression":
            case "OptionalCallExpression":
              adjustInnerComments(node, node.arguments, commentWS);
              break;
            case "ImportExpression":
              adjustInnerComments(node, [node.source, (_node$options = node.options) != null ? _node$options : null], commentWS);
              break;
            case "FunctionDeclaration":
            case "FunctionExpression":
            case "ArrowFunctionExpression":
            case "ObjectMethod":
            case "ClassMethod":
            case "ClassPrivateMethod":
              adjustInnerComments(node, node.params, commentWS);
              break;
            case "ArrayExpression":
            case "ArrayPattern":
            case "TupleExpression":
              adjustInnerComments(node, node.elements, commentWS);
              break;
            case "ExportNamedDeclaration":
            case "ImportDeclaration":
              adjustInnerComments(node, node.specifiers, commentWS);
              break;
            case "TSEnumDeclaration":
              {
                adjustInnerComments(node, node.members, commentWS);
              }
              break;
            case "TSEnumBody":
              adjustInnerComments(node, node.members, commentWS);
              break;
            default:
              {
                setInnerComments(node, comments);
              }
          }
        } else {
          setInnerComments(node, comments);
        }
      }
    };
    _proto.finalizeRemainingComments = function finalizeRemainingComments() {
      var commentStack = this.state.commentStack;
      for (var i = commentStack.length - 1; i >= 0; i--) {
        this.finalizeComment(commentStack[i]);
      }
      this.state.commentStack = [];
    };
    _proto.resetPreviousNodeTrailingComments = function resetPreviousNodeTrailingComments(node) {
      var commentStack = this.state.commentStack;
      var length = commentStack.length;
      if (length === 0) return;
      var commentWS = commentStack[length - 1];
      if (commentWS.leadingNode === node) {
        commentWS.leadingNode = null;
      }
    };
    _proto.takeSurroundingComments = function takeSurroundingComments(node, start, end) {
      var commentStack = this.state.commentStack;
      var commentStackLength = commentStack.length;
      if (commentStackLength === 0) return;
      var i = commentStackLength - 1;
      for (; i >= 0; i--) {
        var commentWS = commentStack[i];
        var commentEnd = commentWS.end;
        var commentStart = commentWS.start;
        if (commentStart === end) {
          commentWS.leadingNode = node;
        } else if (commentEnd === start) {
          commentWS.trailingNode = node;
        } else if (commentEnd < start) {
          break;
        }
      }
    };
    return _createClass(CommentsParser);
  }(BaseParser);

  var LoopLabelKind = {
    Loop: 1,
    Switch: 2
  };
  var State = function () {
    function State() {
      this.flags = 1024;
      this.startIndex = void 0;
      this.curLine = void 0;
      this.lineStart = void 0;
      this.startLoc = void 0;
      this.endLoc = void 0;
      this.errors = [];
      this.potentialArrowAt = -1;
      this.noArrowAt = [];
      this.noArrowParamsConversionAt = [];
      this.topicContext = {
        maxNumOfResolvableTopics: 0,
        maxTopicIndex: null
      };
      this.labels = [];
      this.commentsLen = 0;
      this.commentStack = [];
      this.pos = 0;
      this.type = 140;
      this.value = null;
      this.start = 0;
      this.end = 0;
      this.lastTokEndLoc = null;
      this.lastTokStartLoc = null;
      this.context = [types.brace];
      this.firstInvalidTemplateEscapePos = null;
      this.strictErrors = new Map();
      this.tokensLength = 0;
    }
    var _proto = State.prototype;
    _proto.init = function init(_ref) {
      var strictMode = _ref.strictMode,
        sourceType = _ref.sourceType,
        startIndex = _ref.startIndex,
        startLine = _ref.startLine,
        startColumn = _ref.startColumn;
      this.strict = strictMode === false ? false : strictMode === true ? true : sourceType === "module";
      this.startIndex = startIndex;
      this.curLine = startLine;
      this.lineStart = -startColumn;
      this.startLoc = this.endLoc = new Position(startLine, startColumn, startIndex);
    };
    _proto.curPosition = function curPosition() {
      return new Position(this.curLine, this.pos - this.lineStart, this.pos + this.startIndex);
    };
    _proto.clone = function clone() {
      var state = new State();
      state.flags = this.flags;
      state.startIndex = this.startIndex;
      state.curLine = this.curLine;
      state.lineStart = this.lineStart;
      state.startLoc = this.startLoc;
      state.endLoc = this.endLoc;
      state.errors = this.errors.slice();
      state.potentialArrowAt = this.potentialArrowAt;
      state.noArrowAt = this.noArrowAt.slice();
      state.noArrowParamsConversionAt = this.noArrowParamsConversionAt.slice();
      state.topicContext = this.topicContext;
      state.labels = this.labels.slice();
      state.commentsLen = this.commentsLen;
      state.commentStack = this.commentStack.slice();
      state.pos = this.pos;
      state.type = this.type;
      state.value = this.value;
      state.start = this.start;
      state.end = this.end;
      state.lastTokEndLoc = this.lastTokEndLoc;
      state.lastTokStartLoc = this.lastTokStartLoc;
      state.context = this.context.slice();
      state.firstInvalidTemplateEscapePos = this.firstInvalidTemplateEscapePos;
      state.strictErrors = this.strictErrors;
      state.tokensLength = this.tokensLength;
      return state;
    };
    return _createClass(State, [{
      key: "strict",
      get: function get() {
        return (this.flags & 1) > 0;
      },
      set: function set(v) {
        if (v) this.flags |= 1;else this.flags &= -2;
      }
    }, {
      key: "maybeInArrowParameters",
      get: function get() {
        return (this.flags & 2) > 0;
      },
      set: function set(v) {
        if (v) this.flags |= 2;else this.flags &= -3;
      }
    }, {
      key: "inType",
      get: function get() {
        return (this.flags & 4) > 0;
      },
      set: function set(v) {
        if (v) this.flags |= 4;else this.flags &= -5;
      }
    }, {
      key: "noAnonFunctionType",
      get: function get() {
        return (this.flags & 8) > 0;
      },
      set: function set(v) {
        if (v) this.flags |= 8;else this.flags &= -9;
      }
    }, {
      key: "hasFlowComment",
      get: function get() {
        return (this.flags & 16) > 0;
      },
      set: function set(v) {
        if (v) this.flags |= 16;else this.flags &= -17;
      }
    }, {
      key: "isAmbientContext",
      get: function get() {
        return (this.flags & 32) > 0;
      },
      set: function set(v) {
        if (v) this.flags |= 32;else this.flags &= -33;
      }
    }, {
      key: "inAbstractClass",
      get: function get() {
        return (this.flags & 64) > 0;
      },
      set: function set(v) {
        if (v) this.flags |= 64;else this.flags &= -65;
      }
    }, {
      key: "inDisallowConditionalTypesContext",
      get: function get() {
        return (this.flags & 128) > 0;
      },
      set: function set(v) {
        if (v) this.flags |= 128;else this.flags &= -129;
      }
    }, {
      key: "soloAwait",
      get: function get() {
        return (this.flags & 256) > 0;
      },
      set: function set(v) {
        if (v) this.flags |= 256;else this.flags &= -257;
      }
    }, {
      key: "inFSharpPipelineDirectBody",
      get: function get() {
        return (this.flags & 512) > 0;
      },
      set: function set(v) {
        if (v) this.flags |= 512;else this.flags &= -513;
      }
    }, {
      key: "canStartJSXElement",
      get: function get() {
        return (this.flags & 1024) > 0;
      },
      set: function set(v) {
        if (v) this.flags |= 1024;else this.flags &= -1025;
      }
    }, {
      key: "containsEsc",
      get: function get() {
        return (this.flags & 2048) > 0;
      },
      set: function set(v) {
        if (v) this.flags |= 2048;else this.flags &= -2049;
      }
    }, {
      key: "hasTopLevelAwait",
      get: function get() {
        return (this.flags & 4096) > 0;
      },
      set: function set(v) {
        if (v) this.flags |= 4096;else this.flags &= -4097;
      }
    }]);
  }();

  function buildPosition(pos, lineStart, curLine) {
    return new Position(curLine, pos - lineStart, pos);
  }
  var VALID_REGEX_FLAGS = new Set([103, 109, 115, 105, 121, 117, 100, 118]);
  var Token = _createClass(function Token(state) {
    var startIndex = state.startIndex || 0;
    this.type = state.type;
    this.value = state.value;
    this.start = startIndex + state.start;
    this.end = startIndex + state.end;
    this.loc = new SourceLocation(state.startLoc, state.endLoc);
  });
  var Tokenizer = function (_CommentsParser) {
    function Tokenizer(options, input) {
      var _this;
      _this = _CommentsParser.call(this) || this;
      _this.isLookahead = void 0;
      _this.tokens = [];
      _this.errorHandlers_readInt = {
        invalidDigit: function invalidDigit(pos, lineStart, curLine, radix) {
          if (!(_this.optionFlags & OptionFlags.ErrorRecovery)) return false;
          _this.raise(Errors.InvalidDigit, buildPosition(pos, lineStart, curLine), {
            radix: radix
          });
          return true;
        },
        numericSeparatorInEscapeSequence: _this.errorBuilder(Errors.NumericSeparatorInEscapeSequence),
        unexpectedNumericSeparator: _this.errorBuilder(Errors.UnexpectedNumericSeparator)
      };
      _this.errorHandlers_readCodePoint = Object.assign({}, _this.errorHandlers_readInt, {
        invalidEscapeSequence: _this.errorBuilder(Errors.InvalidEscapeSequence),
        invalidCodePoint: _this.errorBuilder(Errors.InvalidCodePoint)
      });
      _this.errorHandlers_readStringContents_string = Object.assign({}, _this.errorHandlers_readCodePoint, {
        strictNumericEscape: function strictNumericEscape(pos, lineStart, curLine) {
          _this.recordStrictModeErrors(Errors.StrictNumericEscape, buildPosition(pos, lineStart, curLine));
        },
        unterminated: function unterminated(pos, lineStart, curLine) {
          throw _this.raise(Errors.UnterminatedString, buildPosition(pos - 1, lineStart, curLine));
        }
      });
      _this.errorHandlers_readStringContents_template = Object.assign({}, _this.errorHandlers_readCodePoint, {
        strictNumericEscape: _this.errorBuilder(Errors.StrictNumericEscape),
        unterminated: function unterminated(pos, lineStart, curLine) {
          throw _this.raise(Errors.UnterminatedTemplate, buildPosition(pos, lineStart, curLine));
        }
      });
      _this.state = new State();
      _this.state.init(options);
      _this.input = input;
      _this.length = input.length;
      _this.comments = [];
      _this.isLookahead = false;
      return _this;
    }
    _inherits(Tokenizer, _CommentsParser);
    var _proto = Tokenizer.prototype;
    _proto.pushToken = function pushToken(token) {
      this.tokens.length = this.state.tokensLength;
      this.tokens.push(token);
      ++this.state.tokensLength;
    };
    _proto.next = function next() {
      this.checkKeywordEscapes();
      if (this.optionFlags & OptionFlags.Tokens) {
        this.pushToken(new Token(this.state));
      }
      this.state.lastTokEndLoc = this.state.endLoc;
      this.state.lastTokStartLoc = this.state.startLoc;
      this.nextToken();
    };
    _proto.eat = function eat(type) {
      if (this.match(type)) {
        this.next();
        return true;
      } else {
        return false;
      }
    };
    _proto.match = function match(type) {
      return this.state.type === type;
    };
    _proto.createLookaheadState = function createLookaheadState(state) {
      return {
        pos: state.pos,
        value: null,
        type: state.type,
        start: state.start,
        end: state.end,
        context: [this.curContext()],
        inType: state.inType,
        startLoc: state.startLoc,
        lastTokEndLoc: state.lastTokEndLoc,
        curLine: state.curLine,
        lineStart: state.lineStart,
        curPosition: state.curPosition
      };
    };
    _proto.lookahead = function lookahead() {
      var old = this.state;
      this.state = this.createLookaheadState(old);
      this.isLookahead = true;
      this.nextToken();
      this.isLookahead = false;
      var curr = this.state;
      this.state = old;
      return curr;
    };
    _proto.nextTokenStart = function nextTokenStart() {
      return this.nextTokenStartSince(this.state.pos);
    };
    _proto.nextTokenStartSince = function nextTokenStartSince(pos) {
      skipWhiteSpace.lastIndex = pos;
      return skipWhiteSpace.test(this.input) ? skipWhiteSpace.lastIndex : pos;
    };
    _proto.lookaheadCharCode = function lookaheadCharCode() {
      return this.lookaheadCharCodeSince(this.state.pos);
    };
    _proto.lookaheadCharCodeSince = function lookaheadCharCodeSince(pos) {
      return this.input.charCodeAt(this.nextTokenStartSince(pos));
    };
    _proto.nextTokenInLineStart = function nextTokenInLineStart() {
      return this.nextTokenInLineStartSince(this.state.pos);
    };
    _proto.nextTokenInLineStartSince = function nextTokenInLineStartSince(pos) {
      skipWhiteSpaceInLine.lastIndex = pos;
      return skipWhiteSpaceInLine.test(this.input) ? skipWhiteSpaceInLine.lastIndex : pos;
    };
    _proto.lookaheadInLineCharCode = function lookaheadInLineCharCode() {
      return this.input.charCodeAt(this.nextTokenInLineStart());
    };
    _proto.codePointAtPos = function codePointAtPos(pos) {
      var cp = this.input.charCodeAt(pos);
      if ((cp & 0xfc00) === 0xd800 && ++pos < this.input.length) {
        var trail = this.input.charCodeAt(pos);
        if ((trail & 0xfc00) === 0xdc00) {
          cp = 0x10000 + ((cp & 0x3ff) << 10) + (trail & 0x3ff);
        }
      }
      return cp;
    };
    _proto.setStrict = function setStrict(strict) {
      var _this2 = this;
      this.state.strict = strict;
      if (strict) {
        this.state.strictErrors.forEach(function (_ref) {
          var toParseError = _ref[0],
            at = _ref[1];
          return _this2.raise(toParseError, at);
        });
        this.state.strictErrors.clear();
      }
    };
    _proto.curContext = function curContext() {
      return this.state.context[this.state.context.length - 1];
    };
    _proto.nextToken = function nextToken() {
      this.skipSpace();
      this.state.start = this.state.pos;
      if (!this.isLookahead) this.state.startLoc = this.state.curPosition();
      if (this.state.pos >= this.length) {
        this.finishToken(140);
        return;
      }
      this.getTokenFromCode(this.codePointAtPos(this.state.pos));
    };
    _proto.skipBlockComment = function skipBlockComment(commentEnd) {
      var startLoc;
      if (!this.isLookahead) startLoc = this.state.curPosition();
      var start = this.state.pos;
      var end = this.input.indexOf(commentEnd, start + 2);
      if (end === -1) {
        throw this.raise(Errors.UnterminatedComment, this.state.curPosition());
      }
      this.state.pos = end + commentEnd.length;
      lineBreakG.lastIndex = start + 2;
      while (lineBreakG.test(this.input) && lineBreakG.lastIndex <= end) {
        ++this.state.curLine;
        this.state.lineStart = lineBreakG.lastIndex;
      }
      if (this.isLookahead) return;
      var comment = {
        type: "CommentBlock",
        value: this.input.slice(start + 2, end),
        start: this.sourceToOffsetPos(start),
        end: this.sourceToOffsetPos(end + commentEnd.length),
        loc: new SourceLocation(startLoc, this.state.curPosition())
      };
      if (this.optionFlags & OptionFlags.Tokens) this.pushToken(comment);
      return comment;
    };
    _proto.skipLineComment = function skipLineComment(startSkip) {
      var start = this.state.pos;
      var startLoc;
      if (!this.isLookahead) startLoc = this.state.curPosition();
      var ch = this.input.charCodeAt(this.state.pos += startSkip);
      if (this.state.pos < this.length) {
        while (!isNewLine(ch) && ++this.state.pos < this.length) {
          ch = this.input.charCodeAt(this.state.pos);
        }
      }
      if (this.isLookahead) return;
      var end = this.state.pos;
      var value = this.input.slice(start + startSkip, end);
      var comment = {
        type: "CommentLine",
        value: value,
        start: this.sourceToOffsetPos(start),
        end: this.sourceToOffsetPos(end),
        loc: new SourceLocation(startLoc, this.state.curPosition())
      };
      if (this.optionFlags & OptionFlags.Tokens) this.pushToken(comment);
      return comment;
    };
    _proto.skipSpace = function skipSpace() {
      var spaceStart = this.state.pos;
      var comments = this.optionFlags & OptionFlags.AttachComment ? [] : null;
      loop: while (this.state.pos < this.length) {
        var ch = this.input.charCodeAt(this.state.pos);
        switch (ch) {
          case 32:
          case 160:
          case 9:
            ++this.state.pos;
            break;
          case 13:
            if (this.input.charCodeAt(this.state.pos + 1) === 10) {
              ++this.state.pos;
            }
          case 10:
          case 8232:
          case 8233:
            ++this.state.pos;
            ++this.state.curLine;
            this.state.lineStart = this.state.pos;
            break;
          case 47:
            switch (this.input.charCodeAt(this.state.pos + 1)) {
              case 42:
                {
                  var comment = this.skipBlockComment("*/");
                  if (comment !== undefined) {
                    this.addComment(comment);
                    comments == null || comments.push(comment);
                  }
                  break;
                }
              case 47:
                {
                  var _comment = this.skipLineComment(2);
                  if (_comment !== undefined) {
                    this.addComment(_comment);
                    comments == null || comments.push(_comment);
                  }
                  break;
                }
              default:
                break loop;
            }
            break;
          default:
            if (isWhitespace(ch)) {
              ++this.state.pos;
            } else if (ch === 45 && !this.inModule && this.optionFlags & OptionFlags.AnnexB) {
              var pos = this.state.pos;
              if (this.input.charCodeAt(pos + 1) === 45 && this.input.charCodeAt(pos + 2) === 62 && (spaceStart === 0 || this.state.lineStart > spaceStart)) {
                var _comment2 = this.skipLineComment(3);
                if (_comment2 !== undefined) {
                  this.addComment(_comment2);
                  comments == null || comments.push(_comment2);
                }
              } else {
                break loop;
              }
            } else if (ch === 60 && !this.inModule && this.optionFlags & OptionFlags.AnnexB) {
              var _pos = this.state.pos;
              if (this.input.charCodeAt(_pos + 1) === 33 && this.input.charCodeAt(_pos + 2) === 45 && this.input.charCodeAt(_pos + 3) === 45) {
                var _comment3 = this.skipLineComment(4);
                if (_comment3 !== undefined) {
                  this.addComment(_comment3);
                  comments == null || comments.push(_comment3);
                }
              } else {
                break loop;
              }
            } else {
              break loop;
            }
        }
      }
      if ((comments == null ? void 0 : comments.length) > 0) {
        var end = this.state.pos;
        var commentWhitespace = {
          start: this.sourceToOffsetPos(spaceStart),
          end: this.sourceToOffsetPos(end),
          comments: comments,
          leadingNode: null,
          trailingNode: null,
          containingNode: null
        };
        this.state.commentStack.push(commentWhitespace);
      }
    };
    _proto.finishToken = function finishToken(type, val) {
      this.state.end = this.state.pos;
      this.state.endLoc = this.state.curPosition();
      var prevType = this.state.type;
      this.state.type = type;
      this.state.value = val;
      if (!this.isLookahead) {
        this.updateContext(prevType);
      }
    };
    _proto.replaceToken = function replaceToken(type) {
      this.state.type = type;
      this.updateContext();
    };
    _proto.readToken_numberSign = function readToken_numberSign() {
      if (this.state.pos === 0 && this.readToken_interpreter()) {
        return;
      }
      var nextPos = this.state.pos + 1;
      var next = this.codePointAtPos(nextPos);
      if (next >= 48 && next <= 57) {
        throw this.raise(Errors.UnexpectedDigitAfterHash, this.state.curPosition());
      }
      if (next === 123 || next === 91 && this.hasPlugin("recordAndTuple")) {
        this.expectPlugin("recordAndTuple");
        if (this.getPluginOption("recordAndTuple", "syntaxType") === "bar") {
          throw this.raise(next === 123 ? Errors.RecordExpressionHashIncorrectStartSyntaxType : Errors.TupleExpressionHashIncorrectStartSyntaxType, this.state.curPosition());
        }
        this.state.pos += 2;
        if (next === 123) {
          this.finishToken(7);
        } else {
          this.finishToken(1);
        }
      } else if (isIdentifierStart(next)) {
        ++this.state.pos;
        this.finishToken(139, this.readWord1(next));
      } else if (next === 92) {
        ++this.state.pos;
        this.finishToken(139, this.readWord1());
      } else {
        this.finishOp(27, 1);
      }
    };
    _proto.readToken_dot = function readToken_dot() {
      var next = this.input.charCodeAt(this.state.pos + 1);
      if (next >= 48 && next <= 57) {
        this.readNumber(true);
        return;
      }
      if (next === 46 && this.input.charCodeAt(this.state.pos + 2) === 46) {
        this.state.pos += 3;
        this.finishToken(21);
      } else {
        ++this.state.pos;
        this.finishToken(16);
      }
    };
    _proto.readToken_slash = function readToken_slash() {
      var next = this.input.charCodeAt(this.state.pos + 1);
      if (next === 61) {
        this.finishOp(31, 2);
      } else {
        this.finishOp(56, 1);
      }
    };
    _proto.readToken_interpreter = function readToken_interpreter() {
      if (this.state.pos !== 0 || this.length < 2) return false;
      var ch = this.input.charCodeAt(this.state.pos + 1);
      if (ch !== 33) return false;
      var start = this.state.pos;
      this.state.pos += 1;
      while (!isNewLine(ch) && ++this.state.pos < this.length) {
        ch = this.input.charCodeAt(this.state.pos);
      }
      var value = this.input.slice(start + 2, this.state.pos);
      this.finishToken(28, value);
      return true;
    };
    _proto.readToken_mult_modulo = function readToken_mult_modulo(code) {
      var type = code === 42 ? 55 : 54;
      var width = 1;
      var next = this.input.charCodeAt(this.state.pos + 1);
      if (code === 42 && next === 42) {
        width++;
        next = this.input.charCodeAt(this.state.pos + 2);
        type = 57;
      }
      if (next === 61 && !this.state.inType) {
        width++;
        type = code === 37 ? 33 : 30;
      }
      this.finishOp(type, width);
    };
    _proto.readToken_pipe_amp = function readToken_pipe_amp(code) {
      var next = this.input.charCodeAt(this.state.pos + 1);
      if (next === code) {
        if (this.input.charCodeAt(this.state.pos + 2) === 61) {
          this.finishOp(30, 3);
        } else {
          this.finishOp(code === 124 ? 41 : 42, 2);
        }
        return;
      }
      if (code === 124) {
        if (next === 62) {
          this.finishOp(39, 2);
          return;
        }
        if (this.hasPlugin("recordAndTuple") && next === 125) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
            throw this.raise(Errors.RecordExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
          }
          this.state.pos += 2;
          this.finishToken(9);
          return;
        }
        if (this.hasPlugin("recordAndTuple") && next === 93) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
            throw this.raise(Errors.TupleExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
          }
          this.state.pos += 2;
          this.finishToken(4);
          return;
        }
      }
      if (next === 61) {
        this.finishOp(30, 2);
        return;
      }
      this.finishOp(code === 124 ? 43 : 45, 1);
    };
    _proto.readToken_caret = function readToken_caret() {
      var next = this.input.charCodeAt(this.state.pos + 1);
      if (next === 61 && !this.state.inType) {
        this.finishOp(32, 2);
      } else if (next === 94 && this.hasPlugin(["pipelineOperator", {
        proposal: "hack",
        topicToken: "^^"
      }])) {
        this.finishOp(37, 2);
        var lookaheadCh = this.input.codePointAt(this.state.pos);
        if (lookaheadCh === 94) {
          this.unexpected();
        }
      } else {
        this.finishOp(44, 1);
      }
    };
    _proto.readToken_atSign = function readToken_atSign() {
      var next = this.input.charCodeAt(this.state.pos + 1);
      if (next === 64 && this.hasPlugin(["pipelineOperator", {
        proposal: "hack",
        topicToken: "@@"
      }])) {
        this.finishOp(38, 2);
      } else {
        this.finishOp(26, 1);
      }
    };
    _proto.readToken_plus_min = function readToken_plus_min(code) {
      var next = this.input.charCodeAt(this.state.pos + 1);
      if (next === code) {
        this.finishOp(34, 2);
        return;
      }
      if (next === 61) {
        this.finishOp(30, 2);
      } else {
        this.finishOp(53, 1);
      }
    };
    _proto.readToken_lt = function readToken_lt() {
      var pos = this.state.pos;
      var next = this.input.charCodeAt(pos + 1);
      if (next === 60) {
        if (this.input.charCodeAt(pos + 2) === 61) {
          this.finishOp(30, 3);
          return;
        }
        this.finishOp(51, 2);
        return;
      }
      if (next === 61) {
        this.finishOp(49, 2);
        return;
      }
      this.finishOp(47, 1);
    };
    _proto.readToken_gt = function readToken_gt() {
      var pos = this.state.pos;
      var next = this.input.charCodeAt(pos + 1);
      if (next === 62) {
        var size = this.input.charCodeAt(pos + 2) === 62 ? 3 : 2;
        if (this.input.charCodeAt(pos + size) === 61) {
          this.finishOp(30, size + 1);
          return;
        }
        this.finishOp(52, size);
        return;
      }
      if (next === 61) {
        this.finishOp(49, 2);
        return;
      }
      this.finishOp(48, 1);
    };
    _proto.readToken_eq_excl = function readToken_eq_excl(code) {
      var next = this.input.charCodeAt(this.state.pos + 1);
      if (next === 61) {
        this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
        return;
      }
      if (code === 61 && next === 62) {
        this.state.pos += 2;
        this.finishToken(19);
        return;
      }
      this.finishOp(code === 61 ? 29 : 35, 1);
    };
    _proto.readToken_question = function readToken_question() {
      var next = this.input.charCodeAt(this.state.pos + 1);
      var next2 = this.input.charCodeAt(this.state.pos + 2);
      if (next === 63) {
        if (next2 === 61) {
          this.finishOp(30, 3);
        } else {
          this.finishOp(40, 2);
        }
      } else if (next === 46 && !(next2 >= 48 && next2 <= 57)) {
        this.state.pos += 2;
        this.finishToken(18);
      } else {
        ++this.state.pos;
        this.finishToken(17);
      }
    };
    _proto.getTokenFromCode = function getTokenFromCode(code) {
      switch (code) {
        case 46:
          this.readToken_dot();
          return;
        case 40:
          ++this.state.pos;
          this.finishToken(10);
          return;
        case 41:
          ++this.state.pos;
          this.finishToken(11);
          return;
        case 59:
          ++this.state.pos;
          this.finishToken(13);
          return;
        case 44:
          ++this.state.pos;
          this.finishToken(12);
          return;
        case 91:
          if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
              throw this.raise(Errors.TupleExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
            }
            this.state.pos += 2;
            this.finishToken(2);
          } else {
            ++this.state.pos;
            this.finishToken(0);
          }
          return;
        case 93:
          ++this.state.pos;
          this.finishToken(3);
          return;
        case 123:
          if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
              throw this.raise(Errors.RecordExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
            }
            this.state.pos += 2;
            this.finishToken(6);
          } else {
            ++this.state.pos;
            this.finishToken(5);
          }
          return;
        case 125:
          ++this.state.pos;
          this.finishToken(8);
          return;
        case 58:
          if (this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58) {
            this.finishOp(15, 2);
          } else {
            ++this.state.pos;
            this.finishToken(14);
          }
          return;
        case 63:
          this.readToken_question();
          return;
        case 96:
          this.readTemplateToken();
          return;
        case 48:
          {
            var next = this.input.charCodeAt(this.state.pos + 1);
            if (next === 120 || next === 88) {
              this.readRadixNumber(16);
              return;
            }
            if (next === 111 || next === 79) {
              this.readRadixNumber(8);
              return;
            }
            if (next === 98 || next === 66) {
              this.readRadixNumber(2);
              return;
            }
          }
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
          this.readNumber(false);
          return;
        case 34:
        case 39:
          this.readString(code);
          return;
        case 47:
          this.readToken_slash();
          return;
        case 37:
        case 42:
          this.readToken_mult_modulo(code);
          return;
        case 124:
        case 38:
          this.readToken_pipe_amp(code);
          return;
        case 94:
          this.readToken_caret();
          return;
        case 43:
        case 45:
          this.readToken_plus_min(code);
          return;
        case 60:
          this.readToken_lt();
          return;
        case 62:
          this.readToken_gt();
          return;
        case 61:
        case 33:
          this.readToken_eq_excl(code);
          return;
        case 126:
          this.finishOp(36, 1);
          return;
        case 64:
          this.readToken_atSign();
          return;
        case 35:
          this.readToken_numberSign();
          return;
        case 92:
          this.readWord();
          return;
        default:
          if (isIdentifierStart(code)) {
            this.readWord(code);
            return;
          }
      }
      throw this.raise(Errors.InvalidOrUnexpectedToken, this.state.curPosition(), {
        unexpected: String.fromCodePoint(code)
      });
    };
    _proto.finishOp = function finishOp(type, size) {
      var str = this.input.slice(this.state.pos, this.state.pos + size);
      this.state.pos += size;
      this.finishToken(type, str);
    };
    _proto.readRegexp = function readRegexp() {
      var startLoc = this.state.startLoc;
      var start = this.state.start + 1;
      var escaped, inClass;
      var pos = this.state.pos;
      for (;; ++pos) {
        if (pos >= this.length) {
          throw this.raise(Errors.UnterminatedRegExp, createPositionWithColumnOffset(startLoc, 1));
        }
        var ch = this.input.charCodeAt(pos);
        if (isNewLine(ch)) {
          throw this.raise(Errors.UnterminatedRegExp, createPositionWithColumnOffset(startLoc, 1));
        }
        if (escaped) {
          escaped = false;
        } else {
          if (ch === 91) {
            inClass = true;
          } else if (ch === 93 && inClass) {
            inClass = false;
          } else if (ch === 47 && !inClass) {
            break;
          }
          escaped = ch === 92;
        }
      }
      var content = this.input.slice(start, pos);
      ++pos;
      var mods = "";
      var nextPos = function nextPos() {
        return (createPositionWithColumnOffset(startLoc, pos + 2 - start)
        );
      };
      while (pos < this.length) {
        var cp = this.codePointAtPos(pos);
        var _char = String.fromCharCode(cp);
        if (VALID_REGEX_FLAGS.has(cp)) {
          if (cp === 118) {
            if (mods.includes("u")) {
              this.raise(Errors.IncompatibleRegExpUVFlags, nextPos());
            }
          } else if (cp === 117) {
            if (mods.includes("v")) {
              this.raise(Errors.IncompatibleRegExpUVFlags, nextPos());
            }
          }
          if (mods.includes(_char)) {
            this.raise(Errors.DuplicateRegExpFlags, nextPos());
          }
        } else if (isIdentifierChar(cp) || cp === 92) {
          this.raise(Errors.MalformedRegExpFlags, nextPos());
        } else {
          break;
        }
        ++pos;
        mods += _char;
      }
      this.state.pos = pos;
      this.finishToken(138, {
        pattern: content,
        flags: mods
      });
    };
    _proto.readInt = function readInt$1(radix, len, forceLen, allowNumSeparator) {
      if (forceLen === void 0) {
        forceLen = false;
      }
      if (allowNumSeparator === void 0) {
        allowNumSeparator = true;
      }
      var _readInt2 = readInt(this.input, this.state.pos, this.state.lineStart, this.state.curLine, radix, len, forceLen, allowNumSeparator, this.errorHandlers_readInt, false),
        n = _readInt2.n,
        pos = _readInt2.pos;
      this.state.pos = pos;
      return n;
    };
    _proto.readRadixNumber = function readRadixNumber(radix) {
      var start = this.state.pos;
      var startLoc = this.state.curPosition();
      var isBigInt = false;
      this.state.pos += 2;
      var val = this.readInt(radix);
      if (val == null) {
        this.raise(Errors.InvalidDigit, createPositionWithColumnOffset(startLoc, 2), {
          radix: radix
        });
      }
      var next = this.input.charCodeAt(this.state.pos);
      if (next === 110) {
        ++this.state.pos;
        isBigInt = true;
      } else if (next === 109) {
        throw this.raise(Errors.InvalidDecimal, startLoc);
      }
      if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {
        throw this.raise(Errors.NumberIdentifier, this.state.curPosition());
      }
      if (isBigInt) {
        var str = this.input.slice(start, this.state.pos).replace(/[_n]/g, "");
        this.finishToken(136, str);
        return;
      }
      this.finishToken(135, val);
    };
    _proto.readNumber = function readNumber(startsWithDot) {
      var start = this.state.pos;
      var startLoc = this.state.curPosition();
      var isFloat = false;
      var isBigInt = false;
      var hasExponent = false;
      var isOctal = false;
      if (!startsWithDot && this.readInt(10) === null) {
        this.raise(Errors.InvalidNumber, this.state.curPosition());
      }
      var hasLeadingZero = this.state.pos - start >= 2 && this.input.charCodeAt(start) === 48;
      if (hasLeadingZero) {
        var integer = this.input.slice(start, this.state.pos);
        this.recordStrictModeErrors(Errors.StrictOctalLiteral, startLoc);
        if (!this.state.strict) {
          var underscorePos = integer.indexOf("_");
          if (underscorePos > 0) {
            this.raise(Errors.ZeroDigitNumericSeparator, createPositionWithColumnOffset(startLoc, underscorePos));
          }
        }
        isOctal = hasLeadingZero && !/[89]/.test(integer);
      }
      var next = this.input.charCodeAt(this.state.pos);
      if (next === 46 && !isOctal) {
        ++this.state.pos;
        this.readInt(10);
        isFloat = true;
        next = this.input.charCodeAt(this.state.pos);
      }
      if ((next === 69 || next === 101) && !isOctal) {
        next = this.input.charCodeAt(++this.state.pos);
        if (next === 43 || next === 45) {
          ++this.state.pos;
        }
        if (this.readInt(10) === null) {
          this.raise(Errors.InvalidOrMissingExponent, startLoc);
        }
        isFloat = true;
        hasExponent = true;
        next = this.input.charCodeAt(this.state.pos);
      }
      if (next === 110) {
        if (isFloat || hasLeadingZero) {
          this.raise(Errors.InvalidBigIntLiteral, startLoc);
        }
        ++this.state.pos;
        isBigInt = true;
      }
      if (next === 109) {
        this.expectPlugin("decimal", this.state.curPosition());
        if (hasExponent || hasLeadingZero) {
          this.raise(Errors.InvalidDecimal, startLoc);
        }
        ++this.state.pos;
        var isDecimal = true;
      }
      if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {
        throw this.raise(Errors.NumberIdentifier, this.state.curPosition());
      }
      var str = this.input.slice(start, this.state.pos).replace(/[_mn]/g, "");
      if (isBigInt) {
        this.finishToken(136, str);
        return;
      }
      if (isDecimal) {
        this.finishToken(137, str);
        return;
      }
      var val = isOctal ? parseInt(str, 8) : parseFloat(str);
      this.finishToken(135, val);
    };
    _proto.readCodePoint = function readCodePoint$1(throwOnInvalid) {
      var _readCodePoint2 = readCodePoint(this.input, this.state.pos, this.state.lineStart, this.state.curLine, throwOnInvalid, this.errorHandlers_readCodePoint),
        code = _readCodePoint2.code,
        pos = _readCodePoint2.pos;
      this.state.pos = pos;
      return code;
    };
    _proto.readString = function readString(quote) {
      var _readStringContents = readStringContents(quote === 34 ? "double" : "single", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string),
        str = _readStringContents.str,
        pos = _readStringContents.pos,
        curLine = _readStringContents.curLine,
        lineStart = _readStringContents.lineStart;
      this.state.pos = pos + 1;
      this.state.lineStart = lineStart;
      this.state.curLine = curLine;
      this.finishToken(134, str);
    };
    _proto.readTemplateContinuation = function readTemplateContinuation() {
      if (!this.match(8)) {
        this.unexpected(null, 8);
      }
      this.state.pos--;
      this.readTemplateToken();
    };
    _proto.readTemplateToken = function readTemplateToken() {
      var opening = this.input[this.state.pos];
      var _readStringContents2 = readStringContents("template", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template),
        str = _readStringContents2.str,
        firstInvalidLoc = _readStringContents2.firstInvalidLoc,
        pos = _readStringContents2.pos,
        curLine = _readStringContents2.curLine,
        lineStart = _readStringContents2.lineStart;
      this.state.pos = pos + 1;
      this.state.lineStart = lineStart;
      this.state.curLine = curLine;
      if (firstInvalidLoc) {
        this.state.firstInvalidTemplateEscapePos = new Position(firstInvalidLoc.curLine, firstInvalidLoc.pos - firstInvalidLoc.lineStart, this.sourceToOffsetPos(firstInvalidLoc.pos));
      }
      if (this.input.codePointAt(pos) === 96) {
        this.finishToken(24, firstInvalidLoc ? null : opening + str + "`");
      } else {
        this.state.pos++;
        this.finishToken(25, firstInvalidLoc ? null : opening + str + "${");
      }
    };
    _proto.recordStrictModeErrors = function recordStrictModeErrors(toParseError, at) {
      var index = at.index;
      if (this.state.strict && !this.state.strictErrors.has(index)) {
        this.raise(toParseError, at);
      } else {
        this.state.strictErrors.set(index, [toParseError, at]);
      }
    };
    _proto.readWord1 = function readWord1(firstCode) {
      this.state.containsEsc = false;
      var word = "";
      var start = this.state.pos;
      var chunkStart = this.state.pos;
      if (firstCode !== undefined) {
        this.state.pos += firstCode <= 0xffff ? 1 : 2;
      }
      while (this.state.pos < this.length) {
        var ch = this.codePointAtPos(this.state.pos);
        if (isIdentifierChar(ch)) {
          this.state.pos += ch <= 0xffff ? 1 : 2;
        } else if (ch === 92) {
          this.state.containsEsc = true;
          word += this.input.slice(chunkStart, this.state.pos);
          var escStart = this.state.curPosition();
          var identifierCheck = this.state.pos === start ? isIdentifierStart : isIdentifierChar;
          if (this.input.charCodeAt(++this.state.pos) !== 117) {
            this.raise(Errors.MissingUnicodeEscape, this.state.curPosition());
            chunkStart = this.state.pos - 1;
            continue;
          }
          ++this.state.pos;
          var esc = this.readCodePoint(true);
          if (esc !== null) {
            if (!identifierCheck(esc)) {
              this.raise(Errors.EscapedCharNotAnIdentifier, escStart);
            }
            word += String.fromCodePoint(esc);
          }
          chunkStart = this.state.pos;
        } else {
          break;
        }
      }
      return word + this.input.slice(chunkStart, this.state.pos);
    };
    _proto.readWord = function readWord(firstCode) {
      var word = this.readWord1(firstCode);
      var type = keywords.get(word);
      if (type !== undefined) {
        this.finishToken(type, tokenLabelName(type));
      } else {
        this.finishToken(132, word);
      }
    };
    _proto.checkKeywordEscapes = function checkKeywordEscapes() {
      var type = this.state.type;
      if (tokenIsKeyword(type) && this.state.containsEsc) {
        this.raise(Errors.InvalidEscapedReservedWord, this.state.startLoc, {
          reservedWord: tokenLabelName(type)
        });
      }
    };
    _proto.raise = function raise(toParseError, at, details) {
      if (details === void 0) {
        details = {};
      }
      var loc = at instanceof Position ? at : at.loc.start;
      var error = toParseError(loc, details);
      if (!(this.optionFlags & OptionFlags.ErrorRecovery)) throw error;
      if (!this.isLookahead) this.state.errors.push(error);
      return error;
    };
    _proto.raiseOverwrite = function raiseOverwrite(toParseError, at, details) {
      if (details === void 0) {
        details = {};
      }
      var loc = at instanceof Position ? at : at.loc.start;
      var pos = loc.index;
      var errors = this.state.errors;
      for (var i = errors.length - 1; i >= 0; i--) {
        var error = errors[i];
        if (error.loc.index === pos) {
          return errors[i] = toParseError(loc, details);
        }
        if (error.loc.index < pos) break;
      }
      return this.raise(toParseError, at, details);
    };
    _proto.updateContext = function updateContext(prevType) {};
    _proto.unexpected = function unexpected(loc, type) {
      throw this.raise(Errors.UnexpectedToken, loc != null ? loc : this.state.startLoc, {
        expected: type ? tokenLabelName(type) : null
      });
    };
    _proto.expectPlugin = function expectPlugin(pluginName, loc) {
      if (this.hasPlugin(pluginName)) {
        return true;
      }
      throw this.raise(Errors.MissingPlugin, loc != null ? loc : this.state.startLoc, {
        missingPlugin: [pluginName]
      });
    };
    _proto.expectOnePlugin = function expectOnePlugin(pluginNames) {
      var _this3 = this;
      if (!pluginNames.some(function (name) {
        return _this3.hasPlugin(name);
      })) {
        throw this.raise(Errors.MissingOneOfPlugins, this.state.startLoc, {
          missingPlugin: pluginNames
        });
      }
    };
    _proto.errorBuilder = function errorBuilder(error) {
      var _this4 = this;
      return function (pos, lineStart, curLine) {
        _this4.raise(error, buildPosition(pos, lineStart, curLine));
      };
    };
    return _createClass(Tokenizer);
  }(CommentsParser);

  var ClassScope = _createClass(function ClassScope() {
    this.privateNames = new Set();
    this.loneAccessors = new Map();
    this.undefinedPrivateNames = new Map();
  });
  var ClassScopeHandler = function () {
    function ClassScopeHandler(parser) {
      this.parser = void 0;
      this.stack = [];
      this.undefinedPrivateNames = new Map();
      this.parser = parser;
    }
    var _proto = ClassScopeHandler.prototype;
    _proto.current = function current() {
      return this.stack[this.stack.length - 1];
    };
    _proto.enter = function enter() {
      this.stack.push(new ClassScope());
    };
    _proto.exit = function exit() {
      var oldClassScope = this.stack.pop();
      var current = this.current();
      for (var _i2 = 0, _Array$from2 = Array.from(oldClassScope.undefinedPrivateNames); _i2 < _Array$from2.length; _i2++) {
        var _Array$from2$_i = _Array$from2[_i2],
          name = _Array$from2$_i[0],
          loc = _Array$from2$_i[1];
        if (current) {
          if (!current.undefinedPrivateNames.has(name)) {
            current.undefinedPrivateNames.set(name, loc);
          }
        } else {
          this.parser.raise(Errors.InvalidPrivateFieldResolution, loc, {
            identifierName: name
          });
        }
      }
    };
    _proto.declarePrivateName = function declarePrivateName(name, elementType, loc) {
      var _this$current = this.current(),
        privateNames = _this$current.privateNames,
        loneAccessors = _this$current.loneAccessors,
        undefinedPrivateNames = _this$current.undefinedPrivateNames;
      var redefined = privateNames.has(name);
      if (elementType & ClassElementType.KIND_ACCESSOR) {
        var accessor = redefined && loneAccessors.get(name);
        if (accessor) {
          var oldStatic = accessor & ClassElementType.FLAG_STATIC;
          var newStatic = elementType & ClassElementType.FLAG_STATIC;
          var oldKind = accessor & ClassElementType.KIND_ACCESSOR;
          var newKind = elementType & ClassElementType.KIND_ACCESSOR;
          redefined = oldKind === newKind || oldStatic !== newStatic;
          if (!redefined) loneAccessors["delete"](name);
        } else if (!redefined) {
          loneAccessors.set(name, elementType);
        }
      }
      if (redefined) {
        this.parser.raise(Errors.PrivateNameRedeclaration, loc, {
          identifierName: name
        });
      }
      privateNames.add(name);
      undefinedPrivateNames["delete"](name);
    };
    _proto.usePrivateName = function usePrivateName(name, loc) {
      var classScope;
      for (var _i4 = 0, _this$stack2 = this.stack; _i4 < _this$stack2.length; _i4++) {
        classScope = _this$stack2[_i4];
        if (classScope.privateNames.has(name)) return;
      }
      if (classScope) {
        classScope.undefinedPrivateNames.set(name, loc);
      } else {
        this.parser.raise(Errors.InvalidPrivateFieldResolution, loc, {
          identifierName: name
        });
      }
    };
    return _createClass(ClassScopeHandler);
  }();

  var ExpressionScope = function () {
    function ExpressionScope(type) {
      if (type === void 0) {
        type = 0;
      }
      this.type = type;
    }
    var _proto = ExpressionScope.prototype;
    _proto.canBeArrowParameterDeclaration = function canBeArrowParameterDeclaration() {
      return this.type === 2 || this.type === 1;
    };
    _proto.isCertainlyParameterDeclaration = function isCertainlyParameterDeclaration() {
      return this.type === 3;
    };
    return _createClass(ExpressionScope);
  }();
  var ArrowHeadParsingScope = function (_ExpressionScope) {
    function ArrowHeadParsingScope(type) {
      var _this;
      _this = _ExpressionScope.call(this, type) || this;
      _this.declarationErrors = new Map();
      return _this;
    }
    _inherits(ArrowHeadParsingScope, _ExpressionScope);
    var _proto2 = ArrowHeadParsingScope.prototype;
    _proto2.recordDeclarationError = function recordDeclarationError(ParsingErrorClass, at) {
      var index = at.index;
      this.declarationErrors.set(index, [ParsingErrorClass, at]);
    };
    _proto2.clearDeclarationError = function clearDeclarationError(index) {
      this.declarationErrors["delete"](index);
    };
    _proto2.iterateErrors = function iterateErrors(iterator) {
      this.declarationErrors.forEach(iterator);
    };
    return _createClass(ArrowHeadParsingScope);
  }(ExpressionScope);
  var ExpressionScopeHandler = function () {
    function ExpressionScopeHandler(parser) {
      this.parser = void 0;
      this.stack = [new ExpressionScope()];
      this.parser = parser;
    }
    var _proto3 = ExpressionScopeHandler.prototype;
    _proto3.enter = function enter(scope) {
      this.stack.push(scope);
    };
    _proto3.exit = function exit() {
      this.stack.pop();
    };
    _proto3.recordParameterInitializerError = function recordParameterInitializerError(toParseError, node) {
      var origin = node.loc.start;
      var stack = this.stack;
      var i = stack.length - 1;
      var scope = stack[i];
      while (!scope.isCertainlyParameterDeclaration()) {
        if (scope.canBeArrowParameterDeclaration()) {
          scope.recordDeclarationError(toParseError, origin);
        } else {
          return;
        }
        scope = stack[--i];
      }
      this.parser.raise(toParseError, origin);
    };
    _proto3.recordArrowParameterBindingError = function recordArrowParameterBindingError(error, node) {
      var stack = this.stack;
      var scope = stack[stack.length - 1];
      var origin = node.loc.start;
      if (scope.isCertainlyParameterDeclaration()) {
        this.parser.raise(error, origin);
      } else if (scope.canBeArrowParameterDeclaration()) {
        scope.recordDeclarationError(error, origin);
      } else {
        return;
      }
    };
    _proto3.recordAsyncArrowParametersError = function recordAsyncArrowParametersError(at) {
      var stack = this.stack;
      var i = stack.length - 1;
      var scope = stack[i];
      while (scope.canBeArrowParameterDeclaration()) {
        if (scope.type === 2) {
          scope.recordDeclarationError(Errors.AwaitBindingIdentifier, at);
        }
        scope = stack[--i];
      }
    };
    _proto3.validateAsPattern = function validateAsPattern() {
      var _this2 = this;
      var stack = this.stack;
      var currentScope = stack[stack.length - 1];
      if (!currentScope.canBeArrowParameterDeclaration()) return;
      currentScope.iterateErrors(function (_ref) {
        var toParseError = _ref[0],
          loc = _ref[1];
        _this2.parser.raise(toParseError, loc);
        var i = stack.length - 2;
        var scope = stack[i];
        while (scope.canBeArrowParameterDeclaration()) {
          scope.clearDeclarationError(loc.index);
          scope = stack[--i];
        }
      });
    };
    return _createClass(ExpressionScopeHandler);
  }();
  function newParameterDeclarationScope() {
    return new ExpressionScope(3);
  }
  function newArrowHeadScope() {
    return new ArrowHeadParsingScope(1);
  }
  function newAsyncArrowScope() {
    return new ArrowHeadParsingScope(2);
  }
  function newExpressionScope() {
    return new ExpressionScope();
  }

  var UtilParser = function (_Tokenizer) {
    function UtilParser() {
      return _Tokenizer.apply(this, arguments) || this;
    }
    _inherits(UtilParser, _Tokenizer);
    var _proto = UtilParser.prototype;
    _proto.addExtra = function addExtra(node, key, value, enumerable) {
      if (enumerable === void 0) {
        enumerable = true;
      }
      if (!node) return;
      var extra = node.extra;
      if (extra == null) {
        extra = {};
        node.extra = extra;
      }
      if (enumerable) {
        extra[key] = value;
      } else {
        Object.defineProperty(extra, key, {
          enumerable: enumerable,
          value: value
        });
      }
    };
    _proto.isContextual = function isContextual(token) {
      return this.state.type === token && !this.state.containsEsc;
    };
    _proto.isUnparsedContextual = function isUnparsedContextual(nameStart, name) {
      if (this.input.startsWith(name, nameStart)) {
        var nextCh = this.input.charCodeAt(nameStart + name.length);
        return !(isIdentifierChar(nextCh) || (nextCh & 0xfc00) === 0xd800);
      }
      return false;
    };
    _proto.isLookaheadContextual = function isLookaheadContextual(name) {
      var next = this.nextTokenStart();
      return this.isUnparsedContextual(next, name);
    };
    _proto.eatContextual = function eatContextual(token) {
      if (this.isContextual(token)) {
        this.next();
        return true;
      }
      return false;
    };
    _proto.expectContextual = function expectContextual(token, toParseError) {
      if (!this.eatContextual(token)) {
        if (toParseError != null) {
          throw this.raise(toParseError, this.state.startLoc);
        }
        this.unexpected(null, token);
      }
    };
    _proto.canInsertSemicolon = function canInsertSemicolon() {
      return this.match(140) || this.match(8) || this.hasPrecedingLineBreak();
    };
    _proto.hasPrecedingLineBreak = function hasPrecedingLineBreak() {
      return hasNewLine(this.input, this.offsetToSourcePos(this.state.lastTokEndLoc.index), this.state.start);
    };
    _proto.hasFollowingLineBreak = function hasFollowingLineBreak() {
      return hasNewLine(this.input, this.state.end, this.nextTokenStart());
    };
    _proto.isLineTerminator = function isLineTerminator() {
      return this.eat(13) || this.canInsertSemicolon();
    };
    _proto.semicolon = function semicolon(allowAsi) {
      if (allowAsi === void 0) {
        allowAsi = true;
      }
      if (allowAsi ? this.isLineTerminator() : this.eat(13)) return;
      this.raise(Errors.MissingSemicolon, this.state.lastTokEndLoc);
    };
    _proto.expect = function expect(type, loc) {
      if (!this.eat(type)) {
        this.unexpected(loc, type);
      }
    };
    _proto.tryParse = function tryParse(fn, oldState) {
      if (oldState === void 0) {
        oldState = this.state.clone();
      }
      var abortSignal = {
        node: null
      };
      try {
        var node = fn(function (node) {
          if (node === void 0) {
            node = null;
          }
          abortSignal.node = node;
          throw abortSignal;
        });
        if (this.state.errors.length > oldState.errors.length) {
          var failState = this.state;
          this.state = oldState;
          this.state.tokensLength = failState.tokensLength;
          return {
            node: node,
            error: failState.errors[oldState.errors.length],
            thrown: false,
            aborted: false,
            failState: failState
          };
        }
        return {
          node: node,
          error: null,
          thrown: false,
          aborted: false,
          failState: null
        };
      } catch (error) {
        var _failState = this.state;
        this.state = oldState;
        if (error instanceof SyntaxError) {
          return {
            node: null,
            error: error,
            thrown: true,
            aborted: false,
            failState: _failState
          };
        }
        if (error === abortSignal) {
          return {
            node: abortSignal.node,
            error: null,
            thrown: false,
            aborted: true,
            failState: _failState
          };
        }
        throw error;
      }
    };
    _proto.checkExpressionErrors = function checkExpressionErrors(refExpressionErrors, andThrow) {
      if (!refExpressionErrors) return false;
      var shorthandAssignLoc = refExpressionErrors.shorthandAssignLoc,
        doubleProtoLoc = refExpressionErrors.doubleProtoLoc,
        privateKeyLoc = refExpressionErrors.privateKeyLoc,
        optionalParametersLoc = refExpressionErrors.optionalParametersLoc,
        voidPatternLoc = refExpressionErrors.voidPatternLoc;
      var hasErrors = !!shorthandAssignLoc || !!doubleProtoLoc || !!optionalParametersLoc || !!privateKeyLoc || !!voidPatternLoc;
      if (!andThrow) {
        return hasErrors;
      }
      if (shorthandAssignLoc != null) {
        this.raise(Errors.InvalidCoverInitializedName, shorthandAssignLoc);
      }
      if (doubleProtoLoc != null) {
        this.raise(Errors.DuplicateProto, doubleProtoLoc);
      }
      if (privateKeyLoc != null) {
        this.raise(Errors.UnexpectedPrivateField, privateKeyLoc);
      }
      if (optionalParametersLoc != null) {
        this.unexpected(optionalParametersLoc);
      }
      if (voidPatternLoc != null) {
        this.raise(Errors.InvalidCoverDiscardElement, voidPatternLoc);
      }
    };
    _proto.isLiteralPropertyName = function isLiteralPropertyName() {
      return tokenIsLiteralPropertyName(this.state.type);
    };
    _proto.isPrivateName = function isPrivateName(node) {
      return node.type === "PrivateName";
    };
    _proto.getPrivateNameSV = function getPrivateNameSV(node) {
      return node.id.name;
    };
    _proto.hasPropertyAsPrivateName = function hasPropertyAsPrivateName(node) {
      return (node.type === "MemberExpression" || node.type === "OptionalMemberExpression") && this.isPrivateName(node.property);
    };
    _proto.isObjectProperty = function isObjectProperty(node) {
      return node.type === "ObjectProperty";
    };
    _proto.isObjectMethod = function isObjectMethod(node) {
      return node.type === "ObjectMethod";
    };
    _proto.initializeScopes = function initializeScopes(inModule) {
      var _this = this;
      if (inModule === void 0) {
        inModule = this.options.sourceType === "module";
      }
      var oldLabels = this.state.labels;
      this.state.labels = [];
      var oldExportedIdentifiers = this.exportedIdentifiers;
      this.exportedIdentifiers = new Set();
      var oldInModule = this.inModule;
      this.inModule = inModule;
      var oldScope = this.scope;
      var ScopeHandler = this.getScopeHandler();
      this.scope = new ScopeHandler(this, inModule);
      var oldProdParam = this.prodParam;
      this.prodParam = new ProductionParameterHandler();
      var oldClassScope = this.classScope;
      this.classScope = new ClassScopeHandler(this);
      var oldExpressionScope = this.expressionScope;
      this.expressionScope = new ExpressionScopeHandler(this);
      return function () {
        _this.state.labels = oldLabels;
        _this.exportedIdentifiers = oldExportedIdentifiers;
        _this.inModule = oldInModule;
        _this.scope = oldScope;
        _this.prodParam = oldProdParam;
        _this.classScope = oldClassScope;
        _this.expressionScope = oldExpressionScope;
      };
    };
    _proto.enterInitialScopes = function enterInitialScopes() {
      var paramFlags = ParamKind.PARAM;
      if (this.inModule || this.optionFlags & OptionFlags.AllowAwaitOutsideFunction) {
        paramFlags |= ParamKind.PARAM_AWAIT;
      }
      if (this.optionFlags & OptionFlags.AllowYieldOutsideFunction) {
        paramFlags |= ParamKind.PARAM_YIELD;
      }
      var isCommonJS = !this.inModule && this.options.sourceType === "commonjs";
      if (isCommonJS || this.optionFlags & OptionFlags.AllowReturnOutsideFunction) {
        paramFlags |= ParamKind.PARAM_RETURN;
      }
      this.prodParam.enter(paramFlags);
      var scopeFlags = isCommonJS ? ScopeFlag.FUNCTION : ScopeFlag.PROGRAM;
      if (this.optionFlags & OptionFlags.AllowNewTargetOutsideFunction) {
        scopeFlags |= ScopeFlag.NEW_TARGET;
      }
      this.scope.enter(scopeFlags);
    };
    _proto.checkDestructuringPrivate = function checkDestructuringPrivate(refExpressionErrors) {
      var privateKeyLoc = refExpressionErrors.privateKeyLoc;
      if (privateKeyLoc !== null) {
        this.expectPlugin("destructuringPrivate", privateKeyLoc);
      }
    };
    return _createClass(UtilParser);
  }(Tokenizer);
  var ExpressionErrors = _createClass(function ExpressionErrors() {
    this.shorthandAssignLoc = null;
    this.doubleProtoLoc = null;
    this.privateKeyLoc = null;
    this.optionalParametersLoc = null;
    this.voidPatternLoc = null;
  });

  var Node = _createClass(function Node(parser, pos, loc) {
    this.type = "";
    this.start = pos;
    this.end = 0;
    this.loc = new SourceLocation(loc);
    if ((parser == null ? void 0 : parser.optionFlags) & OptionFlags.Ranges) this.range = [pos, 0];
    if (parser != null && parser.filename) this.loc.filename = parser.filename;
  });
  var NodePrototype = Node.prototype;
  {
    NodePrototype.__clone = function () {
      var newNode = new Node(undefined, this.start, this.loc.start);
      var keys = Object.keys(this);
      for (var i = 0, length = keys.length; i < length; i++) {
        var key = keys[i];
        if (key !== "leadingComments" && key !== "trailingComments" && key !== "innerComments") {
          newNode[key] = this[key];
        }
      }
      return newNode;
    };
  }
  var NodeUtils = function (_UtilParser) {
    function NodeUtils() {
      return _UtilParser.apply(this, arguments) || this;
    }
    _inherits(NodeUtils, _UtilParser);
    var _proto = NodeUtils.prototype;
    _proto.startNode = function startNode() {
      var loc = this.state.startLoc;
      return new Node(this, loc.index, loc);
    };
    _proto.startNodeAt = function startNodeAt(loc) {
      return new Node(this, loc.index, loc);
    };
    _proto.startNodeAtNode = function startNodeAtNode(type) {
      return this.startNodeAt(type.loc.start);
    };
    _proto.finishNode = function finishNode(node, type) {
      return this.finishNodeAt(node, type, this.state.lastTokEndLoc);
    };
    _proto.finishNodeAt = function finishNodeAt(node, type, endLoc) {
      node.type = type;
      node.end = endLoc.index;
      node.loc.end = endLoc;
      if (this.optionFlags & OptionFlags.Ranges) node.range[1] = endLoc.index;
      if (this.optionFlags & OptionFlags.AttachComment) {
        this.processComment(node);
      }
      return node;
    };
    _proto.resetStartLocation = function resetStartLocation(node, startLoc) {
      node.start = startLoc.index;
      node.loc.start = startLoc;
      if (this.optionFlags & OptionFlags.Ranges) node.range[0] = startLoc.index;
    };
    _proto.resetEndLocation = function resetEndLocation(node, endLoc) {
      if (endLoc === void 0) {
        endLoc = this.state.lastTokEndLoc;
      }
      node.end = endLoc.index;
      node.loc.end = endLoc;
      if (this.optionFlags & OptionFlags.Ranges) node.range[1] = endLoc.index;
    };
    _proto.resetStartLocationFromNode = function resetStartLocationFromNode(node, locationNode) {
      this.resetStartLocation(node, locationNode.loc.start);
    };
    _proto.castNodeTo = function castNodeTo(node, type) {
      node.type = type;
      return node;
    };
    _proto.cloneIdentifier = function cloneIdentifier(node) {
      var type = node.type,
        start = node.start,
        end = node.end,
        loc = node.loc,
        range = node.range,
        name = node.name;
      var cloned = Object.create(NodePrototype);
      cloned.type = type;
      cloned.start = start;
      cloned.end = end;
      cloned.loc = loc;
      cloned.range = range;
      cloned.name = name;
      if (node.extra) cloned.extra = node.extra;
      return cloned;
    };
    _proto.cloneStringLiteral = function cloneStringLiteral(node) {
      var type = node.type,
        start = node.start,
        end = node.end,
        loc = node.loc,
        range = node.range,
        extra = node.extra;
      var cloned = Object.create(NodePrototype);
      cloned.type = type;
      cloned.start = start;
      cloned.end = end;
      cloned.loc = loc;
      cloned.range = range;
      cloned.extra = extra;
      cloned.value = node.value;
      return cloned;
    };
    return _createClass(NodeUtils);
  }(UtilParser);

  var _unwrapParenthesizedExpression = function unwrapParenthesizedExpression(node) {
    return node.type === "ParenthesizedExpression" ? _unwrapParenthesizedExpression(node.expression) : node;
  };
  var ParseBindingListFlags = {
    ALLOW_EMPTY: 1,
    IS_FUNCTION_PARAMS: 2,
    IS_CONSTRUCTOR_PARAMS: 4
  };
  var LValParser = function (_NodeUtils) {
    function LValParser() {
      return _NodeUtils.apply(this, arguments) || this;
    }
    _inherits(LValParser, _NodeUtils);
    var _proto = LValParser.prototype;
    _proto.toAssignable = function toAssignable(node, isLHS) {
      var _node$extra, _node$extra3;
      if (isLHS === void 0) {
        isLHS = false;
      }
      var parenthesized = undefined;
      if (node.type === "ParenthesizedExpression" || (_node$extra = node.extra) != null && _node$extra.parenthesized) {
        parenthesized = _unwrapParenthesizedExpression(node);
        if (isLHS) {
          if (parenthesized.type === "Identifier") {
            this.expressionScope.recordArrowParameterBindingError(Errors.InvalidParenthesizedAssignment, node);
          } else if (parenthesized.type !== "MemberExpression" && !this.isOptionalMemberExpression(parenthesized)) {
            this.raise(Errors.InvalidParenthesizedAssignment, node);
          }
        } else {
          this.raise(Errors.InvalidParenthesizedAssignment, node);
        }
      }
      switch (node.type) {
        case "Identifier":
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "RestElement":
        case "VoidPattern":
          break;
        case "ObjectExpression":
          this.castNodeTo(node, "ObjectPattern");
          for (var i = 0, length = node.properties.length, last = length - 1; i < length; i++) {
            var _node$extra2;
            var _prop = node.properties[i];
            var isLast = i === last;
            this.toAssignableObjectExpressionProp(_prop, isLast, isLHS);
            if (isLast && _prop.type === "RestElement" && (_node$extra2 = node.extra) != null && _node$extra2.trailingCommaLoc) {
              this.raise(Errors.RestTrailingComma, node.extra.trailingCommaLoc);
            }
          }
          break;
        case "ObjectProperty":
          {
            var key = node.key,
              value = node.value;
            if (this.isPrivateName(key)) {
              this.classScope.usePrivateName(this.getPrivateNameSV(key), key.loc.start);
            }
            this.toAssignable(value, isLHS);
            break;
          }
        case "SpreadElement":
          {
            throw new Error("Internal @babel/parser error (this is a bug, please report it)." + " SpreadElement should be converted by .toAssignable's caller.");
          }
        case "ArrayExpression":
          this.castNodeTo(node, "ArrayPattern");
          this.toAssignableList(node.elements, (_node$extra3 = node.extra) == null ? void 0 : _node$extra3.trailingCommaLoc, isLHS);
          break;
        case "AssignmentExpression":
          if (node.operator !== "=") {
            this.raise(Errors.MissingEqInAssignment, node.left.loc.end);
          }
          this.castNodeTo(node, "AssignmentPattern");
          delete node.operator;
          if (node.left.type === "VoidPattern") {
            this.raise(Errors.VoidPatternInitializer, node.left);
          }
          this.toAssignable(node.left, isLHS);
          break;
        case "ParenthesizedExpression":
          this.toAssignable(parenthesized, isLHS);
          break;
      }
    };
    _proto.toAssignableObjectExpressionProp = function toAssignableObjectExpressionProp(prop, isLast, isLHS) {
      if (prop.type === "ObjectMethod") {
        this.raise(prop.kind === "get" || prop.kind === "set" ? Errors.PatternHasAccessor : Errors.PatternHasMethod, prop.key);
      } else if (prop.type === "SpreadElement") {
        this.castNodeTo(prop, "RestElement");
        var arg = prop.argument;
        this.checkToRestConversion(arg, false);
        this.toAssignable(arg, isLHS);
        if (!isLast) {
          this.raise(Errors.RestTrailingComma, prop);
        }
      } else {
        this.toAssignable(prop, isLHS);
      }
    };
    _proto.toAssignableList = function toAssignableList(exprList, trailingCommaLoc, isLHS) {
      var end = exprList.length - 1;
      for (var i = 0; i <= end; i++) {
        var elt = exprList[i];
        if (!elt) continue;
        this.toAssignableListItem(exprList, i, isLHS);
        if (elt.type === "RestElement") {
          if (i < end) {
            this.raise(Errors.RestTrailingComma, elt);
          } else if (trailingCommaLoc) {
            this.raise(Errors.RestTrailingComma, trailingCommaLoc);
          }
        }
      }
    };
    _proto.toAssignableListItem = function toAssignableListItem(exprList, index, isLHS) {
      var node = exprList[index];
      if (node.type === "SpreadElement") {
        this.castNodeTo(node, "RestElement");
        var arg = node.argument;
        this.checkToRestConversion(arg, true);
        this.toAssignable(arg, isLHS);
      } else {
        this.toAssignable(node, isLHS);
      }
    };
    _proto.isAssignable = function isAssignable(node, isBinding) {
      var _this = this;
      switch (node.type) {
        case "Identifier":
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "RestElement":
        case "VoidPattern":
          return true;
        case "ObjectExpression":
          {
            var last = node.properties.length - 1;
            return node.properties.every(function (prop, i) {
              return prop.type !== "ObjectMethod" && (i === last || prop.type !== "SpreadElement") && _this.isAssignable(prop);
            });
          }
        case "ObjectProperty":
          return this.isAssignable(node.value);
        case "SpreadElement":
          return this.isAssignable(node.argument);
        case "ArrayExpression":
          return node.elements.every(function (element) {
            return element === null || _this.isAssignable(element);
          });
        case "AssignmentExpression":
          return node.operator === "=";
        case "ParenthesizedExpression":
          return this.isAssignable(node.expression);
        case "MemberExpression":
        case "OptionalMemberExpression":
          return !isBinding;
        default:
          return false;
      }
    };
    _proto.toReferencedList = function toReferencedList(exprList, isParenthesizedExpr) {
      return exprList;
    };
    _proto.toReferencedListDeep = function toReferencedListDeep(exprList, isParenthesizedExpr) {
      this.toReferencedList(exprList, isParenthesizedExpr);
      for (var _i2 = 0; _i2 < exprList.length; _i2++) {
        var expr = exprList[_i2];
        if ((expr == null ? void 0 : expr.type) === "ArrayExpression") {
          this.toReferencedListDeep(expr.elements);
        }
      }
    };
    _proto.parseSpread = function parseSpread(refExpressionErrors) {
      var node = this.startNode();
      this.next();
      node.argument = this.parseMaybeAssignAllowIn(refExpressionErrors, undefined);
      return this.finishNode(node, "SpreadElement");
    };
    _proto.parseRestBinding = function parseRestBinding() {
      var node = this.startNode();
      this.next();
      var argument = this.parseBindingAtom();
      if (argument.type === "VoidPattern") {
        this.raise(Errors.UnexpectedVoidPattern, argument);
      }
      node.argument = argument;
      return this.finishNode(node, "RestElement");
    };
    _proto.parseBindingAtom = function parseBindingAtom() {
      switch (this.state.type) {
        case 0:
          {
            var node = this.startNode();
            this.next();
            node.elements = this.parseBindingList(3, 93, ParseBindingListFlags.ALLOW_EMPTY);
            return this.finishNode(node, "ArrayPattern");
          }
        case 5:
          return this.parseObjectLike(8, true);
        case 88:
          return this.parseVoidPattern(null);
      }
      return this.parseIdentifier();
    };
    _proto.parseBindingList = function parseBindingList(close, closeCharCode, flags) {
      var allowEmpty = flags & ParseBindingListFlags.ALLOW_EMPTY;
      var elts = [];
      var first = true;
      while (!this.eat(close)) {
        if (first) {
          first = false;
        } else {
          this.expect(12);
        }
        if (allowEmpty && this.match(12)) {
          elts.push(null);
        } else if (this.eat(close)) {
          break;
        } else if (this.match(21)) {
          var rest = this.parseRestBinding();
          if (this.hasPlugin("flow") || flags & ParseBindingListFlags.IS_FUNCTION_PARAMS) {
            rest = this.parseFunctionParamType(rest);
          }
          elts.push(rest);
          if (!this.checkCommaAfterRest(closeCharCode)) {
            this.expect(close);
            break;
          }
        } else {
          var decorators = [];
          if (flags & ParseBindingListFlags.IS_FUNCTION_PARAMS) {
            if (this.match(26) && this.hasPlugin("decorators")) {
              this.raise(Errors.UnsupportedParameterDecorator, this.state.startLoc);
            }
            while (this.match(26)) {
              decorators.push(this.parseDecorator());
            }
          }
          elts.push(this.parseBindingElement(flags, decorators));
        }
      }
      return elts;
    };
    _proto.parseBindingRestProperty = function parseBindingRestProperty(prop) {
      this.next();
      if (this.hasPlugin("discardBinding") && this.match(88)) {
        prop.argument = this.parseVoidPattern(null);
        this.raise(Errors.UnexpectedVoidPattern, prop.argument);
      } else {
        prop.argument = this.parseIdentifier();
      }
      this.checkCommaAfterRest(125);
      return this.finishNode(prop, "RestElement");
    };
    _proto.parseBindingProperty = function parseBindingProperty() {
      var _this$state = this.state,
        type = _this$state.type,
        startLoc = _this$state.startLoc;
      if (type === 21) {
        return this.parseBindingRestProperty(this.startNode());
      }
      var prop = this.startNode();
      if (type === 139) {
        this.expectPlugin("destructuringPrivate", startLoc);
        this.classScope.usePrivateName(this.state.value, startLoc);
        prop.key = this.parsePrivateName();
      } else {
        this.parsePropertyName(prop);
      }
      prop.method = false;
      return this.parseObjPropValue(prop, startLoc, false, false, true, false);
    };
    _proto.parseBindingElement = function parseBindingElement(flags, decorators) {
      var left = this.parseMaybeDefault();
      if (this.hasPlugin("flow") || flags & ParseBindingListFlags.IS_FUNCTION_PARAMS) {
        this.parseFunctionParamType(left);
      }
      if (decorators.length) {
        left.decorators = decorators;
        this.resetStartLocationFromNode(left, decorators[0]);
      }
      var elt = this.parseMaybeDefault(left.loc.start, left);
      return elt;
    };
    _proto.parseFunctionParamType = function parseFunctionParamType(param) {
      return param;
    };
    _proto.parseMaybeDefault = function parseMaybeDefault(startLoc, left) {
      startLoc != null ? startLoc : startLoc = this.state.startLoc;
      left = left != null ? left : this.parseBindingAtom();
      if (!this.eat(29)) return left;
      var node = this.startNodeAt(startLoc);
      if (left.type === "VoidPattern") {
        this.raise(Errors.VoidPatternInitializer, left);
      }
      node.left = left;
      node.right = this.parseMaybeAssignAllowIn();
      return this.finishNode(node, "AssignmentPattern");
    };
    _proto.isValidLVal = function isValidLVal(type, isUnparenthesizedInAssign, binding) {
      switch (type) {
        case "AssignmentPattern":
          return "left";
        case "RestElement":
          return "argument";
        case "ObjectProperty":
          return "value";
        case "ParenthesizedExpression":
          return "expression";
        case "ArrayPattern":
          return "elements";
        case "ObjectPattern":
          return "properties";
        case "VoidPattern":
          return true;
      }
      return false;
    };
    _proto.isOptionalMemberExpression = function isOptionalMemberExpression(expression) {
      return expression.type === "OptionalMemberExpression";
    };
    _proto.checkLVal = function checkLVal(expression, ancestor, binding, checkClashes, strictModeChanged, hasParenthesizedAncestor) {
      var _expression$extra;
      if (binding === void 0) {
        binding = BindingFlag.TYPE_NONE;
      }
      if (checkClashes === void 0) {
        checkClashes = false;
      }
      if (strictModeChanged === void 0) {
        strictModeChanged = false;
      }
      if (hasParenthesizedAncestor === void 0) {
        hasParenthesizedAncestor = false;
      }
      var type = expression.type;
      if (this.isObjectMethod(expression)) return;
      var isOptionalMemberExpression = this.isOptionalMemberExpression(expression);
      if (isOptionalMemberExpression || type === "MemberExpression") {
        if (isOptionalMemberExpression) {
          this.expectPlugin("optionalChainingAssign", expression.loc.start);
          if (ancestor.type !== "AssignmentExpression") {
            this.raise(Errors.InvalidLhsOptionalChaining, expression, {
              ancestor: ancestor
            });
          }
        }
        if (binding !== BindingFlag.TYPE_NONE) {
          this.raise(Errors.InvalidPropertyBindingPattern, expression);
        }
        return;
      }
      if (type === "Identifier") {
        this.checkIdentifier(expression, binding, strictModeChanged);
        var name = expression.name;
        if (checkClashes) {
          if (checkClashes.has(name)) {
            this.raise(Errors.ParamDupe, expression);
          } else {
            checkClashes.add(name);
          }
        }
        return;
      } else if (type === "VoidPattern" && ancestor.type === "CatchClause") {
        this.raise(Errors.VoidPatternCatchClauseParam, expression);
      }
      var validity = this.isValidLVal(type, !(hasParenthesizedAncestor || (_expression$extra = expression.extra) != null && _expression$extra.parenthesized) && ancestor.type === "AssignmentExpression", binding);
      if (validity === true) return;
      if (validity === false) {
        var ParseErrorClass = binding === BindingFlag.TYPE_NONE ? Errors.InvalidLhs : Errors.InvalidLhsBinding;
        this.raise(ParseErrorClass, expression, {
          ancestor: ancestor
        });
        return;
      }
      var key, isParenthesizedExpression;
      if (typeof validity === "string") {
        key = validity;
        isParenthesizedExpression = type === "ParenthesizedExpression";
      } else {
        key = validity[0];
        isParenthesizedExpression = validity[1];
      }
      var nextAncestor = type === "ArrayPattern" || type === "ObjectPattern" ? {
        type: type
      } : ancestor;
      var val = expression[key];
      if (Array.isArray(val)) {
        for (var _i4 = 0; _i4 < val.length; _i4++) {
          var child = val[_i4];
          if (child) {
            this.checkLVal(child, nextAncestor, binding, checkClashes, strictModeChanged, isParenthesizedExpression);
          }
        }
      } else if (val) {
        this.checkLVal(val, nextAncestor, binding, checkClashes, strictModeChanged, isParenthesizedExpression);
      }
    };
    _proto.checkIdentifier = function checkIdentifier(at, bindingType, strictModeChanged) {
      if (strictModeChanged === void 0) {
        strictModeChanged = false;
      }
      if (this.state.strict && (strictModeChanged ? isStrictBindReservedWord(at.name, this.inModule) : isStrictBindOnlyReservedWord(at.name))) {
        if (bindingType === BindingFlag.TYPE_NONE) {
          this.raise(Errors.StrictEvalArguments, at, {
            referenceName: at.name
          });
        } else {
          this.raise(Errors.StrictEvalArgumentsBinding, at, {
            bindingName: at.name
          });
        }
      }
      if (bindingType & BindingFlag.FLAG_NO_LET_IN_LEXICAL && at.name === "let") {
        this.raise(Errors.LetInLexicalBinding, at);
      }
      if (!(bindingType & BindingFlag.TYPE_NONE)) {
        this.declareNameFromIdentifier(at, bindingType);
      }
    };
    _proto.declareNameFromIdentifier = function declareNameFromIdentifier(identifier, binding) {
      this.scope.declareName(identifier.name, binding, identifier.loc.start);
    };
    _proto.checkToRestConversion = function checkToRestConversion(node, allowPattern) {
      switch (node.type) {
        case "ParenthesizedExpression":
          this.checkToRestConversion(node.expression, allowPattern);
          break;
        case "Identifier":
        case "MemberExpression":
          break;
        case "ArrayExpression":
        case "ObjectExpression":
          if (allowPattern) break;
        default:
          this.raise(Errors.InvalidRestAssignmentPattern, node);
      }
    };
    _proto.checkCommaAfterRest = function checkCommaAfterRest(close) {
      if (!this.match(12)) {
        return false;
      }
      this.raise(this.lookaheadCharCode() === close ? Errors.RestTrailingComma : Errors.ElementAfterRest, this.state.startLoc);
      return true;
    };
    return _createClass(LValParser);
  }(NodeUtils);

  var _templateObject$J;
  function nonNull(x) {
    if (x == null) {
      throw new Error("Unexpected " + x + " value.");
    }
    return x;
  }
  function assert$1(x) {
    if (!x) {
      throw new Error("Assert fail");
    }
  }
  var TSErrors = ParseErrorEnum(_templateObject$J || (_templateObject$J = _taggedTemplateLiteralLoose(["typescript"])))({
    AbstractMethodHasImplementation: function AbstractMethodHasImplementation(_ref) {
      var methodName = _ref.methodName;
      return "Method '" + methodName + "' cannot have an implementation because it is marked abstract.";
    },
    AbstractPropertyHasInitializer: function AbstractPropertyHasInitializer(_ref2) {
      var propertyName = _ref2.propertyName;
      return "Property '" + propertyName + "' cannot have an initializer because it is marked abstract.";
    },
    AccessorCannotBeOptional: "An 'accessor' property cannot be declared optional.",
    AccessorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.",
    AccessorCannotHaveTypeParameters: "An accessor cannot have type parameters.",
    ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.",
    ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.",
    ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference: "A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.",
    ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.",
    DeclareAccessor: function DeclareAccessor(_ref3) {
      var kind = _ref3.kind;
      return "'declare' is not allowed in " + kind + "ters.";
    },
    DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.",
    DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.",
    DuplicateAccessibilityModifier: function DuplicateAccessibilityModifier(_ref4) {
      var modifier = _ref4.modifier;
      return "Accessibility modifier already seen: '" + modifier + "'.";
    },
    DuplicateModifier: function DuplicateModifier(_ref5) {
      var modifier = _ref5.modifier;
      return "Duplicate modifier: '" + modifier + "'.";
    },
    EmptyHeritageClauseType: function EmptyHeritageClauseType(_ref6) {
      var token = _ref6.token;
      return "'" + token + "' list cannot be empty.";
    },
    EmptyTypeArguments: "Type argument list cannot be empty.",
    EmptyTypeParameters: "Type parameter list cannot be empty.",
    ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.",
    ImportAliasHasImportType: "An import alias can not use 'import type'.",
    ImportReflectionHasImportType: "An `import module` declaration can not use `type` modifier",
    IncompatibleModifiers: function IncompatibleModifiers(_ref7) {
      var modifiers = _ref7.modifiers;
      return "'" + modifiers[0] + "' modifier cannot be used with '" + modifiers[1] + "' modifier.";
    },
    IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.",
    IndexSignatureHasAccessibility: function IndexSignatureHasAccessibility(_ref8) {
      var modifier = _ref8.modifier;
      return "Index signatures cannot have an accessibility modifier ('" + modifier + "').";
    },
    IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.",
    IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.",
    IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.",
    InitializerNotAllowedInAmbientContext: "Initializers are not allowed in ambient contexts.",
    InvalidHeritageClauseType: function InvalidHeritageClauseType(_ref9) {
      var token = _ref9.token;
      return "'" + token + "' list can only include identifiers or qualified-names with optional type arguments.";
    },
    InvalidModifierOnAwaitUsingDeclaration: function InvalidModifierOnAwaitUsingDeclaration(modifier) {
      return "'" + modifier + "' modifier cannot appear on an await using declaration.";
    },
    InvalidModifierOnTypeMember: function InvalidModifierOnTypeMember(_ref0) {
      var modifier = _ref0.modifier;
      return "'" + modifier + "' modifier cannot appear on a type member.";
    },
    InvalidModifierOnTypeParameter: function InvalidModifierOnTypeParameter(_ref1) {
      var modifier = _ref1.modifier;
      return "'" + modifier + "' modifier cannot appear on a type parameter.";
    },
    InvalidModifierOnTypeParameterPositions: function InvalidModifierOnTypeParameterPositions(_ref10) {
      var modifier = _ref10.modifier;
      return "'" + modifier + "' modifier can only appear on a type parameter of a class, interface or type alias.";
    },
    InvalidModifierOnUsingDeclaration: function InvalidModifierOnUsingDeclaration(modifier) {
      return "'" + modifier + "' modifier cannot appear on a using declaration.";
    },
    InvalidModifiersOrder: function InvalidModifiersOrder(_ref11) {
      var orderedModifiers = _ref11.orderedModifiers;
      return "'" + orderedModifiers[0] + "' modifier must precede '" + orderedModifiers[1] + "' modifier.";
    },
    InvalidPropertyAccessAfterInstantiationExpression: "Invalid property access after an instantiation expression. " + "You can either wrap the instantiation expression in parentheses, or delete the type arguments.",
    InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.",
    MissingInterfaceName: "'interface' declarations must be followed by an identifier.",
    NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.",
    NonClassMethodPropertyHasAbstractModifier: "'abstract' modifier can only appear on a class, method, or property declaration.",
    OptionalTypeBeforeRequired: "A required element cannot follow an optional element.",
    OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.",
    PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.",
    PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.",
    PrivateElementHasAccessibility: function PrivateElementHasAccessibility(_ref12) {
      var modifier = _ref12.modifier;
      return "Private elements cannot have an accessibility modifier ('" + modifier + "').";
    },
    ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.",
    ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.",
    ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.",
    SetAccessorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.",
    SetAccessorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.",
    SetAccessorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.",
    SingleTypeParameterWithoutTrailingComma: function SingleTypeParameterWithoutTrailingComma(_ref13) {
      var typeParameterName = _ref13.typeParameterName;
      return "Single type parameter " + typeParameterName + " should have a trailing comma. Example usage: <" + typeParameterName + ",>.";
    },
    StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.",
    TupleOptionalAfterType: "A labeled tuple optional element must be declared using a question mark after the name and before the colon (`name?: type`), rather than after the type (`name: type?`).",
    TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
    TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.",
    TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.",
    TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.",
    UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.",
    UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.",
    UnexpectedTypeAnnotation: "Did not expect a type annotation here.",
    UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.",
    UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.",
    UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.",
    UnsupportedSignatureParameterKind: function UnsupportedSignatureParameterKind(_ref14) {
      var type = _ref14.type;
      return "Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got " + type + ".";
    },
    UsingDeclarationInAmbientContext: function UsingDeclarationInAmbientContext(kind) {
      return "'" + kind + "' declarations are not allowed in ambient contexts.";
    }
  });
  function keywordTypeFromName(value) {
    switch (value) {
      case "any":
        return "TSAnyKeyword";
      case "boolean":
        return "TSBooleanKeyword";
      case "bigint":
        return "TSBigIntKeyword";
      case "never":
        return "TSNeverKeyword";
      case "number":
        return "TSNumberKeyword";
      case "object":
        return "TSObjectKeyword";
      case "string":
        return "TSStringKeyword";
      case "symbol":
        return "TSSymbolKeyword";
      case "undefined":
        return "TSUndefinedKeyword";
      case "unknown":
        return "TSUnknownKeyword";
      default:
        return undefined;
    }
  }
  function tsIsAccessModifier(modifier) {
    return modifier === "private" || modifier === "public" || modifier === "protected";
  }
  function tsIsVarianceAnnotations(modifier) {
    return modifier === "in" || modifier === "out";
  }
  var tsParseEntityNameFlags = {
    NONE: 0,
    ALLOW_RESERVED_WORDS: 1,
    LEADING_THIS_AS_IDENTIFIER: 2
  };
  var typescript = (function (superClass) {
    return function (_superClass) {
      function TypeScriptParserMixin() {
        var _this;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _superClass.call.apply(_superClass, [this].concat(args)) || this;
        _this.tsParseInOutModifiers = _this.tsParseModifiers.bind(_this, {
          allowedModifiers: ["in", "out"],
          disallowedModifiers: ["const", "public", "private", "protected", "readonly", "declare", "abstract", "override"],
          errorTemplate: TSErrors.InvalidModifierOnTypeParameter
        });
        _this.tsParseConstModifier = _this.tsParseModifiers.bind(_this, {
          allowedModifiers: ["const"],
          disallowedModifiers: ["in", "out"],
          errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions
        });
        _this.tsParseInOutConstModifiers = _this.tsParseModifiers.bind(_this, {
          allowedModifiers: ["in", "out", "const"],
          disallowedModifiers: ["public", "private", "protected", "readonly", "declare", "abstract", "override"],
          errorTemplate: TSErrors.InvalidModifierOnTypeParameter
        });
        return _this;
      }
      _inherits(TypeScriptParserMixin, _superClass);
      var _proto = TypeScriptParserMixin.prototype;
      _proto.getScopeHandler = function getScopeHandler() {
        return TypeScriptScopeHandler;
      };
      _proto.tsIsIdentifier = function tsIsIdentifier() {
        return tokenIsIdentifier(this.state.type);
      };
      _proto.tsTokenCanFollowModifier = function tsTokenCanFollowModifier() {
        return this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(139) || this.isLiteralPropertyName();
      };
      _proto.tsNextTokenOnSameLineAndCanFollowModifier = function tsNextTokenOnSameLineAndCanFollowModifier() {
        this.next();
        if (this.hasPrecedingLineBreak()) {
          return false;
        }
        return this.tsTokenCanFollowModifier();
      };
      _proto.tsNextTokenCanFollowModifier = function tsNextTokenCanFollowModifier() {
        if (this.match(106)) {
          this.next();
          return this.tsTokenCanFollowModifier();
        }
        return this.tsNextTokenOnSameLineAndCanFollowModifier();
      };
      _proto.tsParseModifier = function tsParseModifier(allowedModifiers, stopOnStartOfClassStaticBlock, hasSeenStaticModifier) {
        if (!tokenIsIdentifier(this.state.type) && this.state.type !== 58 && this.state.type !== 75) {
          return undefined;
        }
        var modifier = this.state.value;
        if (allowedModifiers.includes(modifier)) {
          if (hasSeenStaticModifier && this.match(106)) {
            return undefined;
          }
          if (stopOnStartOfClassStaticBlock && this.tsIsStartOfStaticBlocks()) {
            return undefined;
          }
          if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) {
            return modifier;
          }
        }
        return undefined;
      };
      _proto.tsParseModifiers = function tsParseModifiers(_ref15, modified) {
        var _this2 = this;
        var allowedModifiers = _ref15.allowedModifiers,
          disallowedModifiers = _ref15.disallowedModifiers,
          stopOnStartOfClassStaticBlock = _ref15.stopOnStartOfClassStaticBlock,
          _ref15$errorTemplate = _ref15.errorTemplate,
          errorTemplate = _ref15$errorTemplate === void 0 ? TSErrors.InvalidModifierOnTypeMember : _ref15$errorTemplate;
        var enforceOrder = function enforceOrder(loc, modifier, before, after) {
          if (modifier === before && modified[after]) {
            _this2.raise(TSErrors.InvalidModifiersOrder, loc, {
              orderedModifiers: [before, after]
            });
          }
        };
        var incompatible = function incompatible(loc, modifier, mod1, mod2) {
          if (modified[mod1] && modifier === mod2 || modified[mod2] && modifier === mod1) {
            _this2.raise(TSErrors.IncompatibleModifiers, loc, {
              modifiers: [mod1, mod2]
            });
          }
        };
        for (;;) {
          var startLoc = this.state.startLoc;
          var modifier = this.tsParseModifier(allowedModifiers.concat(disallowedModifiers != null ? disallowedModifiers : []), stopOnStartOfClassStaticBlock, modified["static"]);
          if (!modifier) break;
          if (tsIsAccessModifier(modifier)) {
            if (modified.accessibility) {
              this.raise(TSErrors.DuplicateAccessibilityModifier, startLoc, {
                modifier: modifier
              });
            } else {
              enforceOrder(startLoc, modifier, modifier, "override");
              enforceOrder(startLoc, modifier, modifier, "static");
              enforceOrder(startLoc, modifier, modifier, "readonly");
              modified.accessibility = modifier;
            }
          } else if (tsIsVarianceAnnotations(modifier)) {
            if (modified[modifier]) {
              this.raise(TSErrors.DuplicateModifier, startLoc, {
                modifier: modifier
              });
            }
            modified[modifier] = true;
            enforceOrder(startLoc, modifier, "in", "out");
          } else {
            if (hasOwnProperty.call(modified, modifier)) {
              this.raise(TSErrors.DuplicateModifier, startLoc, {
                modifier: modifier
              });
            } else {
              enforceOrder(startLoc, modifier, "static", "readonly");
              enforceOrder(startLoc, modifier, "static", "override");
              enforceOrder(startLoc, modifier, "override", "readonly");
              enforceOrder(startLoc, modifier, "abstract", "override");
              incompatible(startLoc, modifier, "declare", "override");
              incompatible(startLoc, modifier, "static", "abstract");
            }
            modified[modifier] = true;
          }
          if (disallowedModifiers != null && disallowedModifiers.includes(modifier)) {
            this.raise(errorTemplate, startLoc, {
              modifier: modifier
            });
          }
        }
      };
      _proto.tsIsListTerminator = function tsIsListTerminator(kind) {
        switch (kind) {
          case "EnumMembers":
          case "TypeMembers":
            return this.match(8);
          case "HeritageClauseElement":
            return this.match(5);
          case "TupleElementTypes":
            return this.match(3);
          case "TypeParametersOrArguments":
            return this.match(48);
        }
      };
      _proto.tsParseList = function tsParseList(kind, parseElement) {
        var result = [];
        while (!this.tsIsListTerminator(kind)) {
          result.push(parseElement());
        }
        return result;
      };
      _proto.tsParseDelimitedList = function tsParseDelimitedList(kind, parseElement, refTrailingCommaPos) {
        return nonNull(this.tsParseDelimitedListWorker(kind, parseElement, true, refTrailingCommaPos));
      };
      _proto.tsParseDelimitedListWorker = function tsParseDelimitedListWorker(kind, parseElement, expectSuccess, refTrailingCommaPos) {
        var result = [];
        var trailingCommaPos = -1;
        for (;;) {
          if (this.tsIsListTerminator(kind)) {
            break;
          }
          trailingCommaPos = -1;
          var element = parseElement();
          if (element == null) {
            return undefined;
          }
          result.push(element);
          if (this.eat(12)) {
            trailingCommaPos = this.state.lastTokStartLoc.index;
            continue;
          }
          if (this.tsIsListTerminator(kind)) {
            break;
          }
          if (expectSuccess) {
            this.expect(12);
          }
          return undefined;
        }
        if (refTrailingCommaPos) {
          refTrailingCommaPos.value = trailingCommaPos;
        }
        return result;
      };
      _proto.tsParseBracketedList = function tsParseBracketedList(kind, parseElement, bracket, skipFirstToken, refTrailingCommaPos) {
        if (!skipFirstToken) {
          if (bracket) {
            this.expect(0);
          } else {
            this.expect(47);
          }
        }
        var result = this.tsParseDelimitedList(kind, parseElement, refTrailingCommaPos);
        if (bracket) {
          this.expect(3);
        } else {
          this.expect(48);
        }
        return result;
      };
      _proto.tsParseImportType = function tsParseImportType() {
        var node = this.startNode();
        this.expect(83);
        this.expect(10);
        if (!this.match(134)) {
          this.raise(TSErrors.UnsupportedImportTypeArgument, this.state.startLoc);
          {
            node.argument = _superClass.prototype.parseExprAtom.call(this);
          }
        } else {
          {
            node.argument = this.parseStringLiteral(this.state.value);
          }
        }
        if (this.eat(12)) {
          node.options = this.tsParseImportTypeOptions();
        } else {
          node.options = null;
        }
        this.expect(11);
        if (this.eat(16)) {
          node.qualifier = this.tsParseEntityName(tsParseEntityNameFlags.ALLOW_RESERVED_WORDS | tsParseEntityNameFlags.LEADING_THIS_AS_IDENTIFIER);
        }
        if (this.match(47)) {
          {
            node.typeParameters = this.tsParseTypeArguments();
          }
        }
        return this.finishNode(node, "TSImportType");
      };
      _proto.tsParseImportTypeOptions = function tsParseImportTypeOptions() {
        var node = this.startNode();
        this.expect(5);
        var withProperty = this.startNode();
        if (this.isContextual(76)) {
          withProperty.method = false;
          withProperty.key = this.parseIdentifier(true);
          withProperty.computed = false;
          withProperty.shorthand = false;
        } else {
          this.unexpected(null, 76);
        }
        this.expect(14);
        withProperty.value = this.tsParseImportTypeWithPropertyValue();
        node.properties = [this.finishObjectProperty(withProperty)];
        this.expect(8);
        return this.finishNode(node, "ObjectExpression");
      };
      _proto.tsParseImportTypeWithPropertyValue = function tsParseImportTypeWithPropertyValue() {
        var node = this.startNode();
        var properties = [];
        this.expect(5);
        while (!this.match(8)) {
          var type = this.state.type;
          if (tokenIsIdentifier(type) || type === 134) {
            properties.push(_superClass.prototype.parsePropertyDefinition.call(this, null));
          } else {
            this.unexpected();
          }
          this.eat(12);
        }
        node.properties = properties;
        this.next();
        return this.finishNode(node, "ObjectExpression");
      };
      _proto.tsParseEntityName = function tsParseEntityName(flags) {
        var entity;
        if (flags & tsParseEntityNameFlags.ALLOW_RESERVED_WORDS && this.match(78)) {
          if (flags & tsParseEntityNameFlags.LEADING_THIS_AS_IDENTIFIER) {
            entity = this.parseIdentifier(true);
          } else {
            var node = this.startNode();
            this.next();
            entity = this.finishNode(node, "ThisExpression");
          }
        } else {
          entity = this.parseIdentifier(!!(flags & tsParseEntityNameFlags.ALLOW_RESERVED_WORDS));
        }
        while (this.eat(16)) {
          var _node = this.startNodeAtNode(entity);
          _node.left = entity;
          _node.right = this.parseIdentifier(!!(flags & tsParseEntityNameFlags.ALLOW_RESERVED_WORDS));
          entity = this.finishNode(_node, "TSQualifiedName");
        }
        return entity;
      };
      _proto.tsParseTypeReference = function tsParseTypeReference() {
        var node = this.startNode();
        node.typeName = this.tsParseEntityName(tsParseEntityNameFlags.ALLOW_RESERVED_WORDS);
        if (!this.hasPrecedingLineBreak() && this.match(47)) {
          {
            node.typeParameters = this.tsParseTypeArguments();
          }
        }
        return this.finishNode(node, "TSTypeReference");
      };
      _proto.tsParseThisTypePredicate = function tsParseThisTypePredicate(lhs) {
        this.next();
        var node = this.startNodeAtNode(lhs);
        node.parameterName = lhs;
        node.typeAnnotation = this.tsParseTypeAnnotation(false);
        node.asserts = false;
        return this.finishNode(node, "TSTypePredicate");
      };
      _proto.tsParseThisTypeNode = function tsParseThisTypeNode() {
        var node = this.startNode();
        this.next();
        return this.finishNode(node, "TSThisType");
      };
      _proto.tsParseTypeQuery = function tsParseTypeQuery() {
        var node = this.startNode();
        this.expect(87);
        if (this.match(83)) {
          node.exprName = this.tsParseImportType();
        } else {
          {
            node.exprName = this.tsParseEntityName(tsParseEntityNameFlags.ALLOW_RESERVED_WORDS | tsParseEntityNameFlags.LEADING_THIS_AS_IDENTIFIER);
          }
        }
        if (!this.hasPrecedingLineBreak() && this.match(47)) {
          {
            node.typeParameters = this.tsParseTypeArguments();
          }
        }
        return this.finishNode(node, "TSTypeQuery");
      };
      _proto.tsParseTypeParameter = function tsParseTypeParameter(parseModifiers) {
        var node = this.startNode();
        parseModifiers(node);
        node.name = this.tsParseTypeParameterName();
        node.constraint = this.tsEatThenParseType(81);
        node["default"] = this.tsEatThenParseType(29);
        return this.finishNode(node, "TSTypeParameter");
      };
      _proto.tsTryParseTypeParameters = function tsTryParseTypeParameters(parseModifiers) {
        if (this.match(47)) {
          return this.tsParseTypeParameters(parseModifiers);
        }
      };
      _proto.tsParseTypeParameters = function tsParseTypeParameters(parseModifiers) {
        var node = this.startNode();
        if (this.match(47) || this.match(143)) {
          this.next();
        } else {
          this.unexpected();
        }
        var refTrailingCommaPos = {
          value: -1
        };
        node.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this, parseModifiers), false, true, refTrailingCommaPos);
        if (node.params.length === 0) {
          this.raise(TSErrors.EmptyTypeParameters, node);
        }
        if (refTrailingCommaPos.value !== -1) {
          this.addExtra(node, "trailingComma", refTrailingCommaPos.value);
        }
        return this.finishNode(node, "TSTypeParameterDeclaration");
      };
      _proto.tsFillSignature = function tsFillSignature(returnToken, signature) {
        var returnTokenRequired = returnToken === 19;
        var paramsKey = "parameters";
        var returnTypeKey = "typeAnnotation";
        signature.typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
        this.expect(10);
        signature[paramsKey] = this.tsParseBindingListForSignature();
        if (returnTokenRequired) {
          signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
        } else if (this.match(returnToken)) {
          signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
        }
      };
      _proto.tsParseBindingListForSignature = function tsParseBindingListForSignature() {
        var list = _superClass.prototype.parseBindingList.call(this, 11, 41, ParseBindingListFlags.IS_FUNCTION_PARAMS);
        for (var _i2 = 0; _i2 < list.length; _i2++) {
          var pattern = list[_i2];
          var type = pattern.type;
          if (type === "AssignmentPattern" || type === "TSParameterProperty") {
            this.raise(TSErrors.UnsupportedSignatureParameterKind, pattern, {
              type: type
            });
          }
        }
        return list;
      };
      _proto.tsParseTypeMemberSemicolon = function tsParseTypeMemberSemicolon() {
        if (!this.eat(12) && !this.isLineTerminator()) {
          this.expect(13);
        }
      };
      _proto.tsParseSignatureMember = function tsParseSignatureMember(kind, node) {
        this.tsFillSignature(14, node);
        this.tsParseTypeMemberSemicolon();
        return this.finishNode(node, kind);
      };
      _proto.tsIsUnambiguouslyIndexSignature = function tsIsUnambiguouslyIndexSignature() {
        this.next();
        if (tokenIsIdentifier(this.state.type)) {
          this.next();
          return this.match(14);
        }
        return false;
      };
      _proto.tsTryParseIndexSignature = function tsTryParseIndexSignature(node) {
        if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))) {
          return;
        }
        this.expect(0);
        var id = this.parseIdentifier();
        id.typeAnnotation = this.tsParseTypeAnnotation();
        this.resetEndLocation(id);
        this.expect(3);
        node.parameters = [id];
        var type = this.tsTryParseTypeAnnotation();
        if (type) node.typeAnnotation = type;
        this.tsParseTypeMemberSemicolon();
        return this.finishNode(node, "TSIndexSignature");
      };
      _proto.tsParsePropertyOrMethodSignature = function tsParsePropertyOrMethodSignature(node, readonly) {
        if (this.eat(17)) node.optional = true;
        if (this.match(10) || this.match(47)) {
          if (readonly) {
            this.raise(TSErrors.ReadonlyForMethodSignature, node);
          }
          var method = node;
          if (method.kind && this.match(47)) {
            this.raise(TSErrors.AccessorCannotHaveTypeParameters, this.state.curPosition());
          }
          this.tsFillSignature(14, method);
          this.tsParseTypeMemberSemicolon();
          var paramsKey = "parameters";
          var returnTypeKey = "typeAnnotation";
          if (method.kind === "get") {
            if (method[paramsKey].length > 0) {
              this.raise(Errors.BadGetterArity, this.state.curPosition());
              if (this.isThisParam(method[paramsKey][0])) {
                this.raise(TSErrors.AccessorCannotDeclareThisParameter, this.state.curPosition());
              }
            }
          } else if (method.kind === "set") {
            if (method[paramsKey].length !== 1) {
              this.raise(Errors.BadSetterArity, this.state.curPosition());
            } else {
              var firstParameter = method[paramsKey][0];
              if (this.isThisParam(firstParameter)) {
                this.raise(TSErrors.AccessorCannotDeclareThisParameter, this.state.curPosition());
              }
              if (firstParameter.type === "Identifier" && firstParameter.optional) {
                this.raise(TSErrors.SetAccessorCannotHaveOptionalParameter, this.state.curPosition());
              }
              if (firstParameter.type === "RestElement") {
                this.raise(TSErrors.SetAccessorCannotHaveRestParameter, this.state.curPosition());
              }
            }
            if (method[returnTypeKey]) {
              this.raise(TSErrors.SetAccessorCannotHaveReturnType, method[returnTypeKey]);
            }
          } else {
            method.kind = "method";
          }
          return this.finishNode(method, "TSMethodSignature");
        } else {
          var property = node;
          if (readonly) property.readonly = true;
          var type = this.tsTryParseTypeAnnotation();
          if (type) property.typeAnnotation = type;
          this.tsParseTypeMemberSemicolon();
          return this.finishNode(property, "TSPropertySignature");
        }
      };
      _proto.tsParseTypeMember = function tsParseTypeMember() {
        var node = this.startNode();
        if (this.match(10) || this.match(47)) {
          return this.tsParseSignatureMember("TSCallSignatureDeclaration", node);
        }
        if (this.match(77)) {
          var id = this.startNode();
          this.next();
          if (this.match(10) || this.match(47)) {
            return this.tsParseSignatureMember("TSConstructSignatureDeclaration", node);
          } else {
            node.key = this.createIdentifier(id, "new");
            return this.tsParsePropertyOrMethodSignature(node, false);
          }
        }
        this.tsParseModifiers({
          allowedModifiers: ["readonly"],
          disallowedModifiers: ["declare", "abstract", "private", "protected", "public", "static", "override"]
        }, node);
        var idx = this.tsTryParseIndexSignature(node);
        if (idx) {
          return idx;
        }
        _superClass.prototype.parsePropertyName.call(this, node);
        if (!node.computed && node.key.type === "Identifier" && (node.key.name === "get" || node.key.name === "set") && this.tsTokenCanFollowModifier()) {
          node.kind = node.key.name;
          _superClass.prototype.parsePropertyName.call(this, node);
          if (!this.match(10) && !this.match(47)) {
            this.unexpected(null, 10);
          }
        }
        return this.tsParsePropertyOrMethodSignature(node, !!node.readonly);
      };
      _proto.tsParseTypeLiteral = function tsParseTypeLiteral() {
        var node = this.startNode();
        node.members = this.tsParseObjectTypeMembers();
        return this.finishNode(node, "TSTypeLiteral");
      };
      _proto.tsParseObjectTypeMembers = function tsParseObjectTypeMembers() {
        this.expect(5);
        var members = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
        this.expect(8);
        return members;
      };
      _proto.tsIsStartOfMappedType = function tsIsStartOfMappedType() {
        this.next();
        if (this.eat(53)) {
          return this.isContextual(122);
        }
        if (this.isContextual(122)) {
          this.next();
        }
        if (!this.match(0)) {
          return false;
        }
        this.next();
        if (!this.tsIsIdentifier()) {
          return false;
        }
        this.next();
        return this.match(58);
      };
      _proto.tsParseMappedType = function tsParseMappedType() {
        var node = this.startNode();
        this.expect(5);
        if (this.match(53)) {
          node.readonly = this.state.value;
          this.next();
          this.expectContextual(122);
        } else if (this.eatContextual(122)) {
          node.readonly = true;
        }
        this.expect(0);
        {
          var typeParameter = this.startNode();
          typeParameter.name = this.tsParseTypeParameterName();
          typeParameter.constraint = this.tsExpectThenParseType(58);
          node.typeParameter = this.finishNode(typeParameter, "TSTypeParameter");
        }
        node.nameType = this.eatContextual(93) ? this.tsParseType() : null;
        this.expect(3);
        if (this.match(53)) {
          node.optional = this.state.value;
          this.next();
          this.expect(17);
        } else if (this.eat(17)) {
          node.optional = true;
        }
        node.typeAnnotation = this.tsTryParseType();
        this.semicolon();
        this.expect(8);
        return this.finishNode(node, "TSMappedType");
      };
      _proto.tsParseTupleType = function tsParseTupleType() {
        var _this3 = this;
        var node = this.startNode();
        node.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), true, false);
        var seenOptionalElement = false;
        node.elementTypes.forEach(function (elementNode) {
          var type = elementNode.type;
          if (seenOptionalElement && type !== "TSRestType" && type !== "TSOptionalType" && !(type === "TSNamedTupleMember" && elementNode.optional)) {
            _this3.raise(TSErrors.OptionalTypeBeforeRequired, elementNode);
          }
          seenOptionalElement || (seenOptionalElement = type === "TSNamedTupleMember" && elementNode.optional || type === "TSOptionalType");
        });
        return this.finishNode(node, "TSTupleType");
      };
      _proto.tsParseTupleElementType = function tsParseTupleElementType() {
        var restStartLoc = this.state.startLoc;
        var rest = this.eat(21);
        var startLoc = this.state.startLoc;
        var labeled;
        var label;
        var optional;
        var type;
        var isWord = tokenIsKeywordOrIdentifier(this.state.type);
        var chAfterWord = isWord ? this.lookaheadCharCode() : null;
        if (chAfterWord === 58) {
          labeled = true;
          optional = false;
          label = this.parseIdentifier(true);
          this.expect(14);
          type = this.tsParseType();
        } else if (chAfterWord === 63) {
          optional = true;
          var wordName = this.state.value;
          var typeOrLabel = this.tsParseNonArrayType();
          if (this.lookaheadCharCode() === 58) {
            labeled = true;
            label = this.createIdentifier(this.startNodeAt(startLoc), wordName);
            this.expect(17);
            this.expect(14);
            type = this.tsParseType();
          } else {
            labeled = false;
            type = typeOrLabel;
            this.expect(17);
          }
        } else {
          type = this.tsParseType();
          optional = this.eat(17);
          labeled = this.eat(14);
        }
        if (labeled) {
          var labeledNode;
          if (label) {
            labeledNode = this.startNodeAt(startLoc);
            labeledNode.optional = optional;
            labeledNode.label = label;
            labeledNode.elementType = type;
            if (this.eat(17)) {
              labeledNode.optional = true;
              this.raise(TSErrors.TupleOptionalAfterType, this.state.lastTokStartLoc);
            }
          } else {
            labeledNode = this.startNodeAt(startLoc);
            labeledNode.optional = optional;
            this.raise(TSErrors.InvalidTupleMemberLabel, type);
            labeledNode.label = type;
            labeledNode.elementType = this.tsParseType();
          }
          type = this.finishNode(labeledNode, "TSNamedTupleMember");
        } else if (optional) {
          var optionalTypeNode = this.startNodeAt(startLoc);
          optionalTypeNode.typeAnnotation = type;
          type = this.finishNode(optionalTypeNode, "TSOptionalType");
        }
        if (rest) {
          var restNode = this.startNodeAt(restStartLoc);
          restNode.typeAnnotation = type;
          type = this.finishNode(restNode, "TSRestType");
        }
        return type;
      };
      _proto.tsParseParenthesizedType = function tsParseParenthesizedType() {
        var node = this.startNode();
        this.expect(10);
        node.typeAnnotation = this.tsParseType();
        this.expect(11);
        return this.finishNode(node, "TSParenthesizedType");
      };
      _proto.tsParseFunctionOrConstructorType = function tsParseFunctionOrConstructorType(type, _abstract) {
        var _this4 = this;
        var node = this.startNode();
        if (type === "TSConstructorType") {
          node["abstract"] = !!_abstract;
          if (_abstract) this.next();
          this.next();
        }
        this.tsInAllowConditionalTypesContext(function () {
          return _this4.tsFillSignature(19, node);
        });
        return this.finishNode(node, type);
      };
      _proto.tsParseLiteralTypeNode = function tsParseLiteralTypeNode() {
        var node = this.startNode();
        switch (this.state.type) {
          case 135:
          case 136:
          case 134:
          case 85:
          case 86:
            node.literal = _superClass.prototype.parseExprAtom.call(this);
            break;
          default:
            this.unexpected();
        }
        return this.finishNode(node, "TSLiteralType");
      };
      _proto.tsParseTemplateLiteralType = function tsParseTemplateLiteralType() {
        {
          var node = this.startNode();
          node.literal = _superClass.prototype.parseTemplate.call(this, false);
          return this.finishNode(node, "TSLiteralType");
        }
      };
      _proto.parseTemplateSubstitution = function parseTemplateSubstitution() {
        if (this.state.inType) return this.tsParseType();
        return _superClass.prototype.parseTemplateSubstitution.call(this);
      };
      _proto.tsParseThisTypeOrThisTypePredicate = function tsParseThisTypeOrThisTypePredicate() {
        var thisKeyword = this.tsParseThisTypeNode();
        if (this.isContextual(116) && !this.hasPrecedingLineBreak()) {
          return this.tsParseThisTypePredicate(thisKeyword);
        } else {
          return thisKeyword;
        }
      };
      _proto.tsParseNonArrayType = function tsParseNonArrayType() {
        switch (this.state.type) {
          case 134:
          case 135:
          case 136:
          case 85:
          case 86:
            return this.tsParseLiteralTypeNode();
          case 53:
            if (this.state.value === "-") {
              var node = this.startNode();
              var nextToken = this.lookahead();
              if (nextToken.type !== 135 && nextToken.type !== 136) {
                this.unexpected();
              }
              node.literal = this.parseMaybeUnary();
              return this.finishNode(node, "TSLiteralType");
            }
            break;
          case 78:
            return this.tsParseThisTypeOrThisTypePredicate();
          case 87:
            return this.tsParseTypeQuery();
          case 83:
            return this.tsParseImportType();
          case 5:
            return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
          case 0:
            return this.tsParseTupleType();
          case 10:
            return this.tsParseParenthesizedType();
          case 25:
          case 24:
            return this.tsParseTemplateLiteralType();
          default:
            {
              var type = this.state.type;
              if (tokenIsIdentifier(type) || type === 88 || type === 84) {
                var nodeType = type === 88 ? "TSVoidKeyword" : type === 84 ? "TSNullKeyword" : keywordTypeFromName(this.state.value);
                if (nodeType !== undefined && this.lookaheadCharCode() !== 46) {
                  var _node2 = this.startNode();
                  this.next();
                  return this.finishNode(_node2, nodeType);
                }
                return this.tsParseTypeReference();
              }
            }
        }
        this.unexpected();
      };
      _proto.tsParseArrayTypeOrHigher = function tsParseArrayTypeOrHigher() {
        var startLoc = this.state.startLoc;
        var type = this.tsParseNonArrayType();
        while (!this.hasPrecedingLineBreak() && this.eat(0)) {
          if (this.match(3)) {
            var node = this.startNodeAt(startLoc);
            node.elementType = type;
            this.expect(3);
            type = this.finishNode(node, "TSArrayType");
          } else {
            var _node3 = this.startNodeAt(startLoc);
            _node3.objectType = type;
            _node3.indexType = this.tsParseType();
            this.expect(3);
            type = this.finishNode(_node3, "TSIndexedAccessType");
          }
        }
        return type;
      };
      _proto.tsParseTypeOperator = function tsParseTypeOperator() {
        var node = this.startNode();
        var operator = this.state.value;
        this.next();
        node.operator = operator;
        node.typeAnnotation = this.tsParseTypeOperatorOrHigher();
        if (operator === "readonly") {
          this.tsCheckTypeAnnotationForReadOnly(node);
        }
        return this.finishNode(node, "TSTypeOperator");
      };
      _proto.tsCheckTypeAnnotationForReadOnly = function tsCheckTypeAnnotationForReadOnly(node) {
        switch (node.typeAnnotation.type) {
          case "TSTupleType":
          case "TSArrayType":
            return;
          default:
            this.raise(TSErrors.UnexpectedReadonly, node);
        }
      };
      _proto.tsParseInferType = function tsParseInferType() {
        var _this5 = this;
        var node = this.startNode();
        this.expectContextual(115);
        var typeParameter = this.startNode();
        typeParameter.name = this.tsParseTypeParameterName();
        typeParameter.constraint = this.tsTryParse(function () {
          return _this5.tsParseConstraintForInferType();
        });
        node.typeParameter = this.finishNode(typeParameter, "TSTypeParameter");
        return this.finishNode(node, "TSInferType");
      };
      _proto.tsParseConstraintForInferType = function tsParseConstraintForInferType() {
        var _this6 = this;
        if (this.eat(81)) {
          var constraint = this.tsInDisallowConditionalTypesContext(function () {
            return _this6.tsParseType();
          });
          if (this.state.inDisallowConditionalTypesContext || !this.match(17)) {
            return constraint;
          }
        }
      };
      _proto.tsParseTypeOperatorOrHigher = function tsParseTypeOperatorOrHigher() {
        var _this7 = this;
        var isTypeOperator = tokenIsTSTypeOperator(this.state.type) && !this.state.containsEsc;
        return isTypeOperator ? this.tsParseTypeOperator() : this.isContextual(115) ? this.tsParseInferType() : this.tsInAllowConditionalTypesContext(function () {
          return _this7.tsParseArrayTypeOrHigher();
        });
      };
      _proto.tsParseUnionOrIntersectionType = function tsParseUnionOrIntersectionType(kind, parseConstituentType, operator) {
        var node = this.startNode();
        var hasLeadingOperator = this.eat(operator);
        var types = [];
        do {
          types.push(parseConstituentType());
        } while (this.eat(operator));
        if (types.length === 1 && !hasLeadingOperator) {
          return types[0];
        }
        node.types = types;
        return this.finishNode(node, kind);
      };
      _proto.tsParseIntersectionTypeOrHigher = function tsParseIntersectionTypeOrHigher() {
        return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), 45);
      };
      _proto.tsParseUnionTypeOrHigher = function tsParseUnionTypeOrHigher() {
        return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), 43);
      };
      _proto.tsIsStartOfFunctionType = function tsIsStartOfFunctionType() {
        if (this.match(47)) {
          return true;
        }
        return this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
      };
      _proto.tsSkipParameterStart = function tsSkipParameterStart() {
        if (tokenIsIdentifier(this.state.type) || this.match(78)) {
          this.next();
          return true;
        }
        if (this.match(5)) {
          var errors = this.state.errors;
          var previousErrorCount = errors.length;
          try {
            this.parseObjectLike(8, true);
            return errors.length === previousErrorCount;
          } catch (_unused) {
            return false;
          }
        }
        if (this.match(0)) {
          this.next();
          var _errors = this.state.errors;
          var _previousErrorCount = _errors.length;
          try {
            _superClass.prototype.parseBindingList.call(this, 3, 93, ParseBindingListFlags.ALLOW_EMPTY);
            return _errors.length === _previousErrorCount;
          } catch (_unused2) {
            return false;
          }
        }
        return false;
      };
      _proto.tsIsUnambiguouslyStartOfFunctionType = function tsIsUnambiguouslyStartOfFunctionType() {
        this.next();
        if (this.match(11) || this.match(21)) {
          return true;
        }
        if (this.tsSkipParameterStart()) {
          if (this.match(14) || this.match(12) || this.match(17) || this.match(29)) {
            return true;
          }
          if (this.match(11)) {
            this.next();
            if (this.match(19)) {
              return true;
            }
          }
        }
        return false;
      };
      _proto.tsParseTypeOrTypePredicateAnnotation = function tsParseTypeOrTypePredicateAnnotation(returnToken) {
        var _this8 = this;
        return this.tsInType(function () {
          var t = _this8.startNode();
          _this8.expect(returnToken);
          var node = _this8.startNode();
          var asserts = !!_this8.tsTryParse(_this8.tsParseTypePredicateAsserts.bind(_this8));
          if (asserts && _this8.match(78)) {
            var thisTypePredicate = _this8.tsParseThisTypeOrThisTypePredicate();
            if (thisTypePredicate.type === "TSThisType") {
              node.parameterName = thisTypePredicate;
              node.asserts = true;
              node.typeAnnotation = null;
              thisTypePredicate = _this8.finishNode(node, "TSTypePredicate");
            } else {
              _this8.resetStartLocationFromNode(thisTypePredicate, node);
              thisTypePredicate.asserts = true;
            }
            t.typeAnnotation = thisTypePredicate;
            return _this8.finishNode(t, "TSTypeAnnotation");
          }
          var typePredicateVariable = _this8.tsIsIdentifier() && _this8.tsTryParse(_this8.tsParseTypePredicatePrefix.bind(_this8));
          if (!typePredicateVariable) {
            if (!asserts) {
              return _this8.tsParseTypeAnnotation(false, t);
            }
            node.parameterName = _this8.parseIdentifier();
            node.asserts = asserts;
            node.typeAnnotation = null;
            t.typeAnnotation = _this8.finishNode(node, "TSTypePredicate");
            return _this8.finishNode(t, "TSTypeAnnotation");
          }
          var type = _this8.tsParseTypeAnnotation(false);
          node.parameterName = typePredicateVariable;
          node.typeAnnotation = type;
          node.asserts = asserts;
          t.typeAnnotation = _this8.finishNode(node, "TSTypePredicate");
          return _this8.finishNode(t, "TSTypeAnnotation");
        });
      };
      _proto.tsTryParseTypeOrTypePredicateAnnotation = function tsTryParseTypeOrTypePredicateAnnotation() {
        if (this.match(14)) {
          return this.tsParseTypeOrTypePredicateAnnotation(14);
        }
      };
      _proto.tsTryParseTypeAnnotation = function tsTryParseTypeAnnotation() {
        if (this.match(14)) {
          return this.tsParseTypeAnnotation();
        }
      };
      _proto.tsTryParseType = function tsTryParseType() {
        return this.tsEatThenParseType(14);
      };
      _proto.tsParseTypePredicatePrefix = function tsParseTypePredicatePrefix() {
        var id = this.parseIdentifier();
        if (this.isContextual(116) && !this.hasPrecedingLineBreak()) {
          this.next();
          return id;
        }
      };
      _proto.tsParseTypePredicateAsserts = function tsParseTypePredicateAsserts() {
        if (this.state.type !== 109) {
          return false;
        }
        var containsEsc = this.state.containsEsc;
        this.next();
        if (!tokenIsIdentifier(this.state.type) && !this.match(78)) {
          return false;
        }
        if (containsEsc) {
          this.raise(Errors.InvalidEscapedReservedWord, this.state.lastTokStartLoc, {
            reservedWord: "asserts"
          });
        }
        return true;
      };
      _proto.tsParseTypeAnnotation = function tsParseTypeAnnotation(eatColon, t) {
        var _this9 = this;
        if (eatColon === void 0) {
          eatColon = true;
        }
        if (t === void 0) {
          t = this.startNode();
        }
        this.tsInType(function () {
          if (eatColon) _this9.expect(14);
          t.typeAnnotation = _this9.tsParseType();
        });
        return this.finishNode(t, "TSTypeAnnotation");
      };
      _proto.tsParseType = function tsParseType() {
        var _this0 = this;
        assert$1(this.state.inType);
        var type = this.tsParseNonConditionalType();
        if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81)) {
          return type;
        }
        var node = this.startNodeAtNode(type);
        node.checkType = type;
        node.extendsType = this.tsInDisallowConditionalTypesContext(function () {
          return _this0.tsParseNonConditionalType();
        });
        this.expect(17);
        node.trueType = this.tsInAllowConditionalTypesContext(function () {
          return _this0.tsParseType();
        });
        this.expect(14);
        node.falseType = this.tsInAllowConditionalTypesContext(function () {
          return _this0.tsParseType();
        });
        return this.finishNode(node, "TSConditionalType");
      };
      _proto.isAbstractConstructorSignature = function isAbstractConstructorSignature() {
        return this.isContextual(124) && this.isLookaheadContextual("new");
      };
      _proto.tsParseNonConditionalType = function tsParseNonConditionalType() {
        if (this.tsIsStartOfFunctionType()) {
          return this.tsParseFunctionOrConstructorType("TSFunctionType");
        }
        if (this.match(77)) {
          return this.tsParseFunctionOrConstructorType("TSConstructorType");
        } else if (this.isAbstractConstructorSignature()) {
          return this.tsParseFunctionOrConstructorType("TSConstructorType", true);
        }
        return this.tsParseUnionTypeOrHigher();
      };
      _proto.tsParseTypeAssertion = function tsParseTypeAssertion() {
        var _this1 = this;
        if (this.getPluginOption("typescript", "disallowAmbiguousJSXLike")) {
          this.raise(TSErrors.ReservedTypeAssertion, this.state.startLoc);
        }
        var node = this.startNode();
        node.typeAnnotation = this.tsInType(function () {
          _this1.next();
          return _this1.match(75) ? _this1.tsParseTypeReference() : _this1.tsParseType();
        });
        this.expect(48);
        node.expression = this.parseMaybeUnary();
        return this.finishNode(node, "TSTypeAssertion");
      };
      _proto.tsParseHeritageClause = function tsParseHeritageClause(token) {
        var _this10 = this;
        var originalStartLoc = this.state.startLoc;
        var delimitedList = this.tsParseDelimitedList("HeritageClauseElement", function () {
          {
            var node = _this10.startNode();
            node.expression = _this10.tsParseEntityName(tsParseEntityNameFlags.ALLOW_RESERVED_WORDS | tsParseEntityNameFlags.LEADING_THIS_AS_IDENTIFIER);
            if (_this10.match(47)) {
              node.typeParameters = _this10.tsParseTypeArguments();
            }
            return _this10.finishNode(node, "TSExpressionWithTypeArguments");
          }
        });
        if (!delimitedList.length) {
          this.raise(TSErrors.EmptyHeritageClauseType, originalStartLoc, {
            token: token
          });
        }
        return delimitedList;
      };
      _proto.tsParseInterfaceDeclaration = function tsParseInterfaceDeclaration(node, properties) {
        if (properties === void 0) {
          properties = {};
        }
        if (this.hasFollowingLineBreak()) return null;
        this.expectContextual(129);
        if (properties.declare) node.declare = true;
        if (tokenIsIdentifier(this.state.type)) {
          node.id = this.parseIdentifier();
          this.checkIdentifier(node.id, BindingFlag.TYPE_TS_INTERFACE);
        } else {
          node.id = null;
          this.raise(TSErrors.MissingInterfaceName, this.state.startLoc);
        }
        node.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
        if (this.eat(81)) {
          node["extends"] = this.tsParseHeritageClause("extends");
        }
        var body = this.startNode();
        body.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this));
        node.body = this.finishNode(body, "TSInterfaceBody");
        return this.finishNode(node, "TSInterfaceDeclaration");
      };
      _proto.tsParseTypeAliasDeclaration = function tsParseTypeAliasDeclaration(node) {
        var _this11 = this;
        node.id = this.parseIdentifier();
        this.checkIdentifier(node.id, BindingFlag.TYPE_TS_TYPE);
        node.typeAnnotation = this.tsInType(function () {
          node.typeParameters = _this11.tsTryParseTypeParameters(_this11.tsParseInOutModifiers);
          _this11.expect(29);
          if (_this11.isContextual(114) && _this11.lookaheadCharCode() !== 46) {
            var _node4 = _this11.startNode();
            _this11.next();
            return _this11.finishNode(_node4, "TSIntrinsicKeyword");
          }
          return _this11.tsParseType();
        });
        this.semicolon();
        return this.finishNode(node, "TSTypeAliasDeclaration");
      };
      _proto.tsInTopLevelContext = function tsInTopLevelContext(cb) {
        if (this.curContext() !== types.brace) {
          var oldContext = this.state.context;
          this.state.context = [oldContext[0]];
          try {
            return cb();
          } finally {
            this.state.context = oldContext;
          }
        } else {
          return cb();
        }
      };
      _proto.tsInType = function tsInType(cb) {
        var oldInType = this.state.inType;
        this.state.inType = true;
        try {
          return cb();
        } finally {
          this.state.inType = oldInType;
        }
      };
      _proto.tsInDisallowConditionalTypesContext = function tsInDisallowConditionalTypesContext(cb) {
        var oldInDisallowConditionalTypesContext = this.state.inDisallowConditionalTypesContext;
        this.state.inDisallowConditionalTypesContext = true;
        try {
          return cb();
        } finally {
          this.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
        }
      };
      _proto.tsInAllowConditionalTypesContext = function tsInAllowConditionalTypesContext(cb) {
        var oldInDisallowConditionalTypesContext = this.state.inDisallowConditionalTypesContext;
        this.state.inDisallowConditionalTypesContext = false;
        try {
          return cb();
        } finally {
          this.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
        }
      };
      _proto.tsEatThenParseType = function tsEatThenParseType(token) {
        if (this.match(token)) {
          return this.tsNextThenParseType();
        }
      };
      _proto.tsExpectThenParseType = function tsExpectThenParseType(token) {
        var _this12 = this;
        return this.tsInType(function () {
          _this12.expect(token);
          return _this12.tsParseType();
        });
      };
      _proto.tsNextThenParseType = function tsNextThenParseType() {
        var _this13 = this;
        return this.tsInType(function () {
          _this13.next();
          return _this13.tsParseType();
        });
      };
      _proto.tsParseEnumMember = function tsParseEnumMember() {
        var node = this.startNode();
        node.id = this.match(134) ? _superClass.prototype.parseStringLiteral.call(this, this.state.value) : this.parseIdentifier(true);
        if (this.eat(29)) {
          node.initializer = _superClass.prototype.parseMaybeAssignAllowIn.call(this);
        }
        return this.finishNode(node, "TSEnumMember");
      };
      _proto.tsParseEnumDeclaration = function tsParseEnumDeclaration(node, properties) {
        if (properties === void 0) {
          properties = {};
        }
        if (properties["const"]) node["const"] = true;
        if (properties.declare) node.declare = true;
        this.expectContextual(126);
        node.id = this.parseIdentifier();
        this.checkIdentifier(node.id, node["const"] ? BindingFlag.TYPE_TS_CONST_ENUM : BindingFlag.TYPE_TS_ENUM);
        {
          this.expect(5);
          node.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this));
          this.expect(8);
        }
        return this.finishNode(node, "TSEnumDeclaration");
      };
      _proto.tsParseEnumBody = function tsParseEnumBody() {
        var node = this.startNode();
        this.expect(5);
        node.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this));
        this.expect(8);
        return this.finishNode(node, "TSEnumBody");
      };
      _proto.tsParseModuleBlock = function tsParseModuleBlock() {
        var node = this.startNode();
        this.scope.enter(ScopeFlag.OTHER);
        this.expect(5);
        _superClass.prototype.parseBlockOrModuleBlockBody.call(this, node.body = [], undefined, true, 8);
        this.scope.exit();
        return this.finishNode(node, "TSModuleBlock");
      };
      _proto.tsParseModuleOrNamespaceDeclaration = function tsParseModuleOrNamespaceDeclaration(node, nested) {
        if (nested === void 0) {
          nested = false;
        }
        node.id = this.parseIdentifier();
        if (!nested) {
          this.checkIdentifier(node.id, BindingFlag.TYPE_TS_NAMESPACE);
        }
        if (this.eat(16)) {
          var inner = this.startNode();
          this.tsParseModuleOrNamespaceDeclaration(inner, true);
          node.body = inner;
        } else {
          this.scope.enter(ScopeFlag.TS_MODULE);
          this.prodParam.enter(ParamKind.PARAM);
          node.body = this.tsParseModuleBlock();
          this.prodParam.exit();
          this.scope.exit();
        }
        return this.finishNode(node, "TSModuleDeclaration");
      };
      _proto.tsParseAmbientExternalModuleDeclaration = function tsParseAmbientExternalModuleDeclaration(node) {
        if (this.isContextual(112)) {
          node.kind = "global";
          {
            node.global = true;
          }
          node.id = this.parseIdentifier();
        } else if (this.match(134)) {
          node.kind = "module";
          node.id = _superClass.prototype.parseStringLiteral.call(this, this.state.value);
        } else {
          this.unexpected();
        }
        if (this.match(5)) {
          this.scope.enter(ScopeFlag.TS_MODULE);
          this.prodParam.enter(ParamKind.PARAM);
          node.body = this.tsParseModuleBlock();
          this.prodParam.exit();
          this.scope.exit();
        } else {
          this.semicolon();
        }
        return this.finishNode(node, "TSModuleDeclaration");
      };
      _proto.tsParseImportEqualsDeclaration = function tsParseImportEqualsDeclaration(node, maybeDefaultIdentifier, isExport) {
        {
          node.isExport = isExport || false;
        }
        node.id = maybeDefaultIdentifier || this.parseIdentifier();
        this.checkIdentifier(node.id, BindingFlag.TYPE_TS_VALUE_IMPORT);
        this.expect(29);
        var moduleReference = this.tsParseModuleReference();
        if (node.importKind === "type" && moduleReference.type !== "TSExternalModuleReference") {
          this.raise(TSErrors.ImportAliasHasImportType, moduleReference);
        }
        node.moduleReference = moduleReference;
        this.semicolon();
        return this.finishNode(node, "TSImportEqualsDeclaration");
      };
      _proto.tsIsExternalModuleReference = function tsIsExternalModuleReference() {
        return this.isContextual(119) && this.lookaheadCharCode() === 40;
      };
      _proto.tsParseModuleReference = function tsParseModuleReference() {
        return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(tsParseEntityNameFlags.NONE);
      };
      _proto.tsParseExternalModuleReference = function tsParseExternalModuleReference() {
        var node = this.startNode();
        this.expectContextual(119);
        this.expect(10);
        if (!this.match(134)) {
          this.unexpected();
        }
        node.expression = _superClass.prototype.parseExprAtom.call(this);
        this.expect(11);
        this.sawUnambiguousESM = true;
        return this.finishNode(node, "TSExternalModuleReference");
      };
      _proto.tsLookAhead = function tsLookAhead(f) {
        var state = this.state.clone();
        var res = f();
        this.state = state;
        return res;
      };
      _proto.tsTryParseAndCatch = function tsTryParseAndCatch(f) {
        var result = this.tryParse(function (abort) {
          return (f() || abort()
          );
        });
        if (result.aborted || !result.node) return;
        if (result.error) this.state = result.failState;
        return result.node;
      };
      _proto.tsTryParse = function tsTryParse(f) {
        var state = this.state.clone();
        var result = f();
        if (result !== undefined && result !== false) {
          return result;
        }
        this.state = state;
      };
      _proto.tsTryParseDeclare = function tsTryParseDeclare(node) {
        var _this14 = this;
        if (this.isLineTerminator()) {
          return;
        }
        var startType = this.state.type;
        return this.tsInAmbientContext(function () {
          switch (startType) {
            case 68:
              node.declare = true;
              return _superClass.prototype.parseFunctionStatement.call(_this14, node, false, false);
            case 80:
              node.declare = true;
              return _this14.parseClass(node, true, false);
            case 126:
              return _this14.tsParseEnumDeclaration(node, {
                declare: true
              });
            case 112:
              return _this14.tsParseAmbientExternalModuleDeclaration(node);
            case 100:
              if (_this14.state.containsEsc) {
                return;
              }
            case 75:
            case 74:
              if (!_this14.match(75) || !_this14.isLookaheadContextual("enum")) {
                node.declare = true;
                return _this14.parseVarStatement(node, _this14.state.value, true);
              }
              _this14.expect(75);
              return _this14.tsParseEnumDeclaration(node, {
                "const": true,
                declare: true
              });
            case 107:
              if (_this14.isUsing()) {
                _this14.raise(TSErrors.InvalidModifierOnUsingDeclaration, _this14.state.startLoc, "declare");
                node.declare = true;
                return _this14.parseVarStatement(node, "using", true);
              }
              break;
            case 96:
              if (_this14.isAwaitUsing()) {
                _this14.raise(TSErrors.InvalidModifierOnAwaitUsingDeclaration, _this14.state.startLoc, "declare");
                node.declare = true;
                _this14.next();
                return _this14.parseVarStatement(node, "await using", true);
              }
              break;
            case 129:
              {
                var result = _this14.tsParseInterfaceDeclaration(node, {
                  declare: true
                });
                if (result) return result;
              }
            default:
              if (tokenIsIdentifier(startType)) {
                return _this14.tsParseDeclaration(node, _this14.state.value, true, null);
              }
          }
        });
      };
      _proto.tsTryParseExportDeclaration = function tsTryParseExportDeclaration() {
        return this.tsParseDeclaration(this.startNode(), this.state.value, true, null);
      };
      _proto.tsParseExpressionStatement = function tsParseExpressionStatement(node, expr, decorators) {
        switch (expr.name) {
          case "declare":
            {
              var declaration = this.tsTryParseDeclare(node);
              if (declaration) {
                declaration.declare = true;
              }
              return declaration;
            }
          case "global":
            if (this.match(5)) {
              this.scope.enter(ScopeFlag.TS_MODULE);
              this.prodParam.enter(ParamKind.PARAM);
              var mod = node;
              mod.kind = "global";
              {
                node.global = true;
              }
              mod.id = expr;
              mod.body = this.tsParseModuleBlock();
              this.scope.exit();
              this.prodParam.exit();
              return this.finishNode(mod, "TSModuleDeclaration");
            }
            break;
          default:
            return this.tsParseDeclaration(node, expr.name, false, decorators);
        }
      };
      _proto.tsParseDeclaration = function tsParseDeclaration(node, value, next, decorators) {
        switch (value) {
          case "abstract":
            if (this.tsCheckLineTerminator(next) && (this.match(80) || tokenIsIdentifier(this.state.type))) {
              return this.tsParseAbstractDeclaration(node, decorators);
            }
            break;
          case "module":
            if (this.tsCheckLineTerminator(next)) {
              if (this.match(134)) {
                return this.tsParseAmbientExternalModuleDeclaration(node);
              } else if (tokenIsIdentifier(this.state.type)) {
                node.kind = "module";
                return this.tsParseModuleOrNamespaceDeclaration(node);
              }
            }
            break;
          case "namespace":
            if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type)) {
              node.kind = "namespace";
              return this.tsParseModuleOrNamespaceDeclaration(node);
            }
            break;
          case "type":
            if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type)) {
              return this.tsParseTypeAliasDeclaration(node);
            }
            break;
        }
      };
      _proto.tsCheckLineTerminator = function tsCheckLineTerminator(next) {
        if (next) {
          if (this.hasFollowingLineBreak()) return false;
          this.next();
          return true;
        }
        return !this.isLineTerminator();
      };
      _proto.tsTryParseGenericAsyncArrowFunction = function tsTryParseGenericAsyncArrowFunction(startLoc) {
        var _this15 = this;
        if (!this.match(47)) return;
        var oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
        this.state.maybeInArrowParameters = true;
        var res = this.tsTryParseAndCatch(function () {
          var node = _this15.startNodeAt(startLoc);
          node.typeParameters = _this15.tsParseTypeParameters(_this15.tsParseConstModifier);
          _superClass.prototype.parseFunctionParams.call(_this15, node);
          node.returnType = _this15.tsTryParseTypeOrTypePredicateAnnotation();
          _this15.expect(19);
          return node;
        });
        this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
        if (!res) return;
        return _superClass.prototype.parseArrowExpression.call(this, res, null, true);
      };
      _proto.tsParseTypeArgumentsInExpression = function tsParseTypeArgumentsInExpression() {
        if (this.reScan_lt() !== 47) return;
        return this.tsParseTypeArguments();
      };
      _proto.tsParseTypeArguments = function tsParseTypeArguments() {
        var _this16 = this;
        var node = this.startNode();
        node.params = this.tsInType(function () {
          return _this16.tsInTopLevelContext(function () {
            _this16.expect(47);
            return _this16.tsParseDelimitedList("TypeParametersOrArguments", _this16.tsParseType.bind(_this16));
          });
        });
        if (node.params.length === 0) {
          this.raise(TSErrors.EmptyTypeArguments, node);
        } else if (!this.state.inType && this.curContext() === types.brace) {
          this.reScan_lt_gt();
        }
        this.expect(48);
        return this.finishNode(node, "TSTypeParameterInstantiation");
      };
      _proto.tsIsDeclarationStart = function tsIsDeclarationStart() {
        return tokenIsTSDeclarationStart(this.state.type);
      };
      _proto.isExportDefaultSpecifier = function isExportDefaultSpecifier() {
        if (this.tsIsDeclarationStart()) return false;
        return _superClass.prototype.isExportDefaultSpecifier.call(this);
      };
      _proto.parseBindingElement = function parseBindingElement(flags, decorators) {
        var startLoc = decorators.length ? decorators[0].loc.start : this.state.startLoc;
        var modified = {};
        this.tsParseModifiers({
          allowedModifiers: ["public", "private", "protected", "override", "readonly"]
        }, modified);
        var accessibility = modified.accessibility;
        var override = modified.override;
        var readonly = modified.readonly;
        if (!(flags & ParseBindingListFlags.IS_CONSTRUCTOR_PARAMS) && (accessibility || readonly || override)) {
          this.raise(TSErrors.UnexpectedParameterModifier, startLoc);
        }
        var left = this.parseMaybeDefault();
        if (flags & ParseBindingListFlags.IS_FUNCTION_PARAMS) {
          this.parseFunctionParamType(left);
        }
        var elt = this.parseMaybeDefault(left.loc.start, left);
        if (accessibility || readonly || override) {
          var pp = this.startNodeAt(startLoc);
          if (decorators.length) {
            pp.decorators = decorators;
          }
          if (accessibility) pp.accessibility = accessibility;
          if (readonly) pp.readonly = readonly;
          if (override) pp.override = override;
          if (elt.type !== "Identifier" && elt.type !== "AssignmentPattern") {
            this.raise(TSErrors.UnsupportedParameterPropertyKind, pp);
          }
          pp.parameter = elt;
          return this.finishNode(pp, "TSParameterProperty");
        }
        if (decorators.length) {
          left.decorators = decorators;
        }
        return elt;
      };
      _proto.isSimpleParameter = function isSimpleParameter(node) {
        return node.type === "TSParameterProperty" && _superClass.prototype.isSimpleParameter.call(this, node.parameter) || _superClass.prototype.isSimpleParameter.call(this, node);
      };
      _proto.tsDisallowOptionalPattern = function tsDisallowOptionalPattern(node) {
        for (var _i4 = 0, _node$params2 = node.params; _i4 < _node$params2.length; _i4++) {
          var param = _node$params2[_i4];
          if (param.type !== "Identifier" && param.optional && !this.state.isAmbientContext) {
            this.raise(TSErrors.PatternIsOptional, param);
          }
        }
      };
      _proto.setArrowFunctionParameters = function setArrowFunctionParameters(node, params, trailingCommaLoc) {
        _superClass.prototype.setArrowFunctionParameters.call(this, node, params, trailingCommaLoc);
        this.tsDisallowOptionalPattern(node);
      };
      _proto.parseFunctionBodyAndFinish = function parseFunctionBodyAndFinish(node, type, isMethod) {
        if (isMethod === void 0) {
          isMethod = false;
        }
        if (this.match(14)) {
          node.returnType = this.tsParseTypeOrTypePredicateAnnotation(14);
        }
        var bodilessType = type === "FunctionDeclaration" ? "TSDeclareFunction" : type === "ClassMethod" || type === "ClassPrivateMethod" ? "TSDeclareMethod" : undefined;
        if (bodilessType && !this.match(5) && this.isLineTerminator()) {
          return this.finishNode(node, bodilessType);
        }
        if (bodilessType === "TSDeclareFunction" && this.state.isAmbientContext) {
          this.raise(TSErrors.DeclareFunctionHasImplementation, node);
          if (node.declare) {
            return _superClass.prototype.parseFunctionBodyAndFinish.call(this, node, bodilessType, isMethod);
          }
        }
        this.tsDisallowOptionalPattern(node);
        return _superClass.prototype.parseFunctionBodyAndFinish.call(this, node, type, isMethod);
      };
      _proto.registerFunctionStatementId = function registerFunctionStatementId(node) {
        if (!node.body && node.id) {
          this.checkIdentifier(node.id, BindingFlag.TYPE_TS_AMBIENT);
        } else {
          _superClass.prototype.registerFunctionStatementId.call(this, node);
        }
      };
      _proto.tsCheckForInvalidTypeCasts = function tsCheckForInvalidTypeCasts(items) {
        var _this17 = this;
        items.forEach(function (node) {
          if ((node == null ? void 0 : node.type) === "TSTypeCastExpression") {
            _this17.raise(TSErrors.UnexpectedTypeAnnotation, node.typeAnnotation);
          }
        });
      };
      _proto.toReferencedList = function toReferencedList(exprList, isInParens) {
        this.tsCheckForInvalidTypeCasts(exprList);
        return exprList;
      };
      _proto.parseArrayLike = function parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
        var node = _superClass.prototype.parseArrayLike.call(this, close, canBePattern, isTuple, refExpressionErrors);
        if (node.type === "ArrayExpression") {
          this.tsCheckForInvalidTypeCasts(node.elements);
        }
        return node;
      };
      _proto.parseSubscript = function parseSubscript(base, startLoc, noCalls, state) {
        var _this18 = this;
        if (!this.hasPrecedingLineBreak() && this.match(35)) {
          this.state.canStartJSXElement = false;
          this.next();
          var nonNullExpression = this.startNodeAt(startLoc);
          nonNullExpression.expression = base;
          return this.finishNode(nonNullExpression, "TSNonNullExpression");
        }
        var isOptionalCall = false;
        if (this.match(18) && this.lookaheadCharCode() === 60) {
          if (noCalls) {
            state.stop = true;
            return base;
          }
          state.optionalChainMember = isOptionalCall = true;
          this.next();
        }
        if (this.match(47) || this.match(51)) {
          var missingParenErrorLoc;
          var result = this.tsTryParseAndCatch(function () {
            if (!noCalls && _this18.atPossibleAsyncArrow(base)) {
              var asyncArrowFn = _this18.tsTryParseGenericAsyncArrowFunction(startLoc);
              if (asyncArrowFn) {
                return asyncArrowFn;
              }
            }
            var typeArguments = _this18.tsParseTypeArgumentsInExpression();
            if (!typeArguments) return;
            if (isOptionalCall && !_this18.match(10)) {
              missingParenErrorLoc = _this18.state.curPosition();
              return;
            }
            if (tokenIsTemplate(_this18.state.type)) {
              var _result = _superClass.prototype.parseTaggedTemplateExpression.call(_this18, base, startLoc, state);
              {
                _result.typeParameters = typeArguments;
              }
              return _result;
            }
            if (!noCalls && _this18.eat(10)) {
              var _node5 = _this18.startNodeAt(startLoc);
              _node5.callee = base;
              _node5.arguments = _this18.parseCallExpressionArguments();
              _this18.tsCheckForInvalidTypeCasts(_node5.arguments);
              {
                _node5.typeParameters = typeArguments;
              }
              if (state.optionalChainMember) {
                _node5.optional = isOptionalCall;
              }
              return _this18.finishCallExpression(_node5, state.optionalChainMember);
            }
            var tokenType = _this18.state.type;
            if (tokenType === 48 || tokenType === 52 || tokenType !== 10 && tokenCanStartExpression(tokenType) && !_this18.hasPrecedingLineBreak()) {
              return;
            }
            var node = _this18.startNodeAt(startLoc);
            node.expression = base;
            {
              node.typeParameters = typeArguments;
            }
            return _this18.finishNode(node, "TSInstantiationExpression");
          });
          if (missingParenErrorLoc) {
            this.unexpected(missingParenErrorLoc, 10);
          }
          if (result) {
            if (result.type === "TSInstantiationExpression") {
              if (this.match(16) || this.match(18) && this.lookaheadCharCode() !== 40) {
                this.raise(TSErrors.InvalidPropertyAccessAfterInstantiationExpression, this.state.startLoc);
              }
              if (!this.match(16) && !this.match(18)) {
                result.expression = _superClass.prototype.stopParseSubscript.call(this, base, state);
              }
            }
            return result;
          }
        }
        return _superClass.prototype.parseSubscript.call(this, base, startLoc, noCalls, state);
      };
      _proto.parseNewCallee = function parseNewCallee(node) {
        var _callee$extra;
        _superClass.prototype.parseNewCallee.call(this, node);
        var callee = node.callee;
        if (callee.type === "TSInstantiationExpression" && !((_callee$extra = callee.extra) != null && _callee$extra.parenthesized)) {
          {
            node.typeParameters = callee.typeParameters;
          }
          node.callee = callee.expression;
        }
      };
      _proto.parseExprOp = function parseExprOp(left, leftStartLoc, minPrec) {
        var _this19 = this;
        var isSatisfies;
        if (tokenOperatorPrecedence(58) > minPrec && !this.hasPrecedingLineBreak() && (this.isContextual(93) || (isSatisfies = this.isContextual(120)))) {
          var node = this.startNodeAt(leftStartLoc);
          node.expression = left;
          node.typeAnnotation = this.tsInType(function () {
            _this19.next();
            if (_this19.match(75)) {
              if (isSatisfies) {
                _this19.raise(Errors.UnexpectedKeyword, _this19.state.startLoc, {
                  keyword: "const"
                });
              }
              return _this19.tsParseTypeReference();
            }
            return _this19.tsParseType();
          });
          this.finishNode(node, isSatisfies ? "TSSatisfiesExpression" : "TSAsExpression");
          this.reScan_lt_gt();
          return this.parseExprOp(node, leftStartLoc, minPrec);
        }
        return _superClass.prototype.parseExprOp.call(this, left, leftStartLoc, minPrec);
      };
      _proto.checkReservedWord = function checkReservedWord(word, startLoc, checkKeywords, isBinding) {
        if (!this.state.isAmbientContext) {
          _superClass.prototype.checkReservedWord.call(this, word, startLoc, checkKeywords, isBinding);
        }
      };
      _proto.checkImportReflection = function checkImportReflection(node) {
        _superClass.prototype.checkImportReflection.call(this, node);
        if (node.module && node.importKind !== "value") {
          this.raise(TSErrors.ImportReflectionHasImportType, node.specifiers[0].loc.start);
        }
      };
      _proto.checkDuplicateExports = function checkDuplicateExports() {};
      _proto.isPotentialImportPhase = function isPotentialImportPhase(isExport) {
        if (_superClass.prototype.isPotentialImportPhase.call(this, isExport)) return true;
        if (this.isContextual(130)) {
          var ch = this.lookaheadCharCode();
          return isExport ? ch === 123 || ch === 42 : ch !== 61;
        }
        return !isExport && this.isContextual(87);
      };
      _proto.applyImportPhase = function applyImportPhase(node, isExport, phase, loc) {
        _superClass.prototype.applyImportPhase.call(this, node, isExport, phase, loc);
        if (isExport) {
          node.exportKind = phase === "type" ? "type" : "value";
        } else {
          node.importKind = phase === "type" || phase === "typeof" ? phase : "value";
        }
      };
      _proto.parseImport = function parseImport(node) {
        if (this.match(134)) {
          node.importKind = "value";
          return _superClass.prototype.parseImport.call(this, node);
        }
        var importNode;
        if (tokenIsIdentifier(this.state.type) && this.lookaheadCharCode() === 61) {
          node.importKind = "value";
          return this.tsParseImportEqualsDeclaration(node);
        } else if (this.isContextual(130)) {
          var maybeDefaultIdentifier = this.parseMaybeImportPhase(node, false);
          if (this.lookaheadCharCode() === 61) {
            return this.tsParseImportEqualsDeclaration(node, maybeDefaultIdentifier);
          } else {
            importNode = _superClass.prototype.parseImportSpecifiersAndAfter.call(this, node, maybeDefaultIdentifier);
          }
        } else {
          importNode = _superClass.prototype.parseImport.call(this, node);
        }
        if (importNode.importKind === "type" && importNode.specifiers.length > 1 && importNode.specifiers[0].type === "ImportDefaultSpecifier") {
          this.raise(TSErrors.TypeImportCannotSpecifyDefaultAndNamed, importNode);
        }
        return importNode;
      };
      _proto.parseExport = function parseExport(node, decorators) {
        if (this.match(83)) {
          var nodeImportEquals = node;
          this.next();
          var maybeDefaultIdentifier = null;
          if (this.isContextual(130) && this.isPotentialImportPhase(false)) {
            maybeDefaultIdentifier = this.parseMaybeImportPhase(nodeImportEquals, false);
          } else {
            nodeImportEquals.importKind = "value";
          }
          var declaration = this.tsParseImportEqualsDeclaration(nodeImportEquals, maybeDefaultIdentifier, true);
          {
            return declaration;
          }
        } else if (this.eat(29)) {
          var assign = node;
          assign.expression = _superClass.prototype.parseExpression.call(this);
          this.semicolon();
          this.sawUnambiguousESM = true;
          return this.finishNode(assign, "TSExportAssignment");
        } else if (this.eatContextual(93)) {
          var decl = node;
          this.expectContextual(128);
          decl.id = this.parseIdentifier();
          this.semicolon();
          return this.finishNode(decl, "TSNamespaceExportDeclaration");
        } else {
          return _superClass.prototype.parseExport.call(this, node, decorators);
        }
      };
      _proto.isAbstractClass = function isAbstractClass() {
        return this.isContextual(124) && this.isLookaheadContextual("class");
      };
      _proto.parseExportDefaultExpression = function parseExportDefaultExpression() {
        if (this.isAbstractClass()) {
          var cls = this.startNode();
          this.next();
          cls["abstract"] = true;
          return this.parseClass(cls, true, true);
        }
        if (this.match(129)) {
          var result = this.tsParseInterfaceDeclaration(this.startNode());
          if (result) return result;
        }
        return _superClass.prototype.parseExportDefaultExpression.call(this);
      };
      _proto.parseVarStatement = function parseVarStatement(node, kind, allowMissingInitializer) {
        if (allowMissingInitializer === void 0) {
          allowMissingInitializer = false;
        }
        var isAmbientContext = this.state.isAmbientContext;
        var declaration = _superClass.prototype.parseVarStatement.call(this, node, kind, allowMissingInitializer || isAmbientContext);
        if (!isAmbientContext) return declaration;
        if (!node.declare && (kind === "using" || kind === "await using")) {
          this.raiseOverwrite(TSErrors.UsingDeclarationInAmbientContext, node, kind);
          return declaration;
        }
        for (var _i6 = 0, _declaration$declarat2 = declaration.declarations; _i6 < _declaration$declarat2.length; _i6++) {
          var _declaration$declarat3 = _declaration$declarat2[_i6],
            id = _declaration$declarat3.id,
            init = _declaration$declarat3.init;
          if (!init) continue;
          if (kind === "var" || kind === "let" || !!id.typeAnnotation) {
            this.raise(TSErrors.InitializerNotAllowedInAmbientContext, init);
          } else if (!isValidAmbientConstInitializer(init, this.hasPlugin("estree"))) {
            this.raise(TSErrors.ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference, init);
          }
        }
        return declaration;
      };
      _proto.parseStatementContent = function parseStatementContent(flags, decorators) {
        if (this.match(75) && this.isLookaheadContextual("enum")) {
          var node = this.startNode();
          this.expect(75);
          return this.tsParseEnumDeclaration(node, {
            "const": true
          });
        }
        if (this.isContextual(126)) {
          return this.tsParseEnumDeclaration(this.startNode());
        }
        if (this.isContextual(129)) {
          var result = this.tsParseInterfaceDeclaration(this.startNode());
          if (result) return result;
        }
        return _superClass.prototype.parseStatementContent.call(this, flags, decorators);
      };
      _proto.parseAccessModifier = function parseAccessModifier() {
        return this.tsParseModifier(["public", "protected", "private"]);
      };
      _proto.tsHasSomeModifiers = function tsHasSomeModifiers(member, modifiers) {
        return modifiers.some(function (modifier) {
          if (tsIsAccessModifier(modifier)) {
            return member.accessibility === modifier;
          }
          return !!member[modifier];
        });
      };
      _proto.tsIsStartOfStaticBlocks = function tsIsStartOfStaticBlocks() {
        return this.isContextual(106) && this.lookaheadCharCode() === 123;
      };
      _proto.parseClassMember = function parseClassMember(classBody, member, state) {
        var _this20 = this;
        var modifiers = ["declare", "private", "public", "protected", "override", "abstract", "readonly", "static"];
        this.tsParseModifiers({
          allowedModifiers: modifiers,
          disallowedModifiers: ["in", "out"],
          stopOnStartOfClassStaticBlock: true,
          errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions
        }, member);
        var callParseClassMemberWithIsStatic = function callParseClassMemberWithIsStatic() {
          if (_this20.tsIsStartOfStaticBlocks()) {
            _this20.next();
            _this20.next();
            if (_this20.tsHasSomeModifiers(member, modifiers)) {
              _this20.raise(TSErrors.StaticBlockCannotHaveModifier, _this20.state.curPosition());
            }
            _superClass.prototype.parseClassStaticBlock.call(_this20, classBody, member);
          } else {
            _this20.parseClassMemberWithIsStatic(classBody, member, state, !!member["static"]);
          }
        };
        if (member.declare) {
          this.tsInAmbientContext(callParseClassMemberWithIsStatic);
        } else {
          callParseClassMemberWithIsStatic();
        }
      };
      _proto.parseClassMemberWithIsStatic = function parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
        var idx = this.tsTryParseIndexSignature(member);
        if (idx) {
          classBody.body.push(idx);
          if (member["abstract"]) {
            this.raise(TSErrors.IndexSignatureHasAbstract, member);
          }
          if (member.accessibility) {
            this.raise(TSErrors.IndexSignatureHasAccessibility, member, {
              modifier: member.accessibility
            });
          }
          if (member.declare) {
            this.raise(TSErrors.IndexSignatureHasDeclare, member);
          }
          if (member.override) {
            this.raise(TSErrors.IndexSignatureHasOverride, member);
          }
          return;
        }
        if (!this.state.inAbstractClass && member["abstract"]) {
          this.raise(TSErrors.NonAbstractClassHasAbstractMethod, member);
        }
        if (member.override) {
          if (!state.hadSuperClass) {
            this.raise(TSErrors.OverrideNotInSubClass, member);
          }
        }
        _superClass.prototype.parseClassMemberWithIsStatic.call(this, classBody, member, state, isStatic);
      };
      _proto.parsePostMemberNameModifiers = function parsePostMemberNameModifiers(methodOrProp) {
        var optional = this.eat(17);
        if (optional) methodOrProp.optional = true;
        if (methodOrProp.readonly && this.match(10)) {
          this.raise(TSErrors.ClassMethodHasReadonly, methodOrProp);
        }
        if (methodOrProp.declare && this.match(10)) {
          this.raise(TSErrors.ClassMethodHasDeclare, methodOrProp);
        }
      };
      _proto.parseExpressionStatement = function parseExpressionStatement(node, expr, decorators) {
        var decl = expr.type === "Identifier" ? this.tsParseExpressionStatement(node, expr, decorators) : undefined;
        return decl || _superClass.prototype.parseExpressionStatement.call(this, node, expr, decorators);
      };
      _proto.shouldParseExportDeclaration = function shouldParseExportDeclaration() {
        if (this.tsIsDeclarationStart()) return true;
        return _superClass.prototype.shouldParseExportDeclaration.call(this);
      };
      _proto.parseConditional = function parseConditional(expr, startLoc, refExpressionErrors) {
        if (!this.match(17)) return expr;
        if (this.state.maybeInArrowParameters) {
          var nextCh = this.lookaheadCharCode();
          if (nextCh === 44 || nextCh === 61 || nextCh === 58 || nextCh === 41) {
            this.setOptionalParametersError(refExpressionErrors);
            return expr;
          }
        }
        return _superClass.prototype.parseConditional.call(this, expr, startLoc, refExpressionErrors);
      };
      _proto.parseParenItem = function parseParenItem(node, startLoc) {
        var newNode = _superClass.prototype.parseParenItem.call(this, node, startLoc);
        if (this.eat(17)) {
          newNode.optional = true;
          this.resetEndLocation(node);
        }
        if (this.match(14)) {
          var typeCastNode = this.startNodeAt(startLoc);
          typeCastNode.expression = node;
          typeCastNode.typeAnnotation = this.tsParseTypeAnnotation();
          return this.finishNode(typeCastNode, "TSTypeCastExpression");
        }
        return node;
      };
      _proto.parseExportDeclaration = function parseExportDeclaration(node) {
        var _this21 = this;
        if (!this.state.isAmbientContext && this.isContextual(125)) {
          return this.tsInAmbientContext(function () {
            return _this21.parseExportDeclaration(node);
          });
        }
        var startLoc = this.state.startLoc;
        var isDeclare = this.eatContextual(125);
        if (isDeclare && (this.isContextual(125) || !this.shouldParseExportDeclaration())) {
          throw this.raise(TSErrors.ExpectedAmbientAfterExportDeclare, this.state.startLoc);
        }
        var isIdentifier = tokenIsIdentifier(this.state.type);
        var declaration = isIdentifier && this.tsTryParseExportDeclaration() || _superClass.prototype.parseExportDeclaration.call(this, node);
        if (!declaration) return null;
        if (declaration.type === "TSInterfaceDeclaration" || declaration.type === "TSTypeAliasDeclaration" || isDeclare) {
          node.exportKind = "type";
        }
        if (isDeclare && declaration.type !== "TSImportEqualsDeclaration") {
          this.resetStartLocation(declaration, startLoc);
          declaration.declare = true;
        }
        return declaration;
      };
      _proto.parseClassId = function parseClassId(node, isStatement, optionalId, bindingType) {
        if ((!isStatement || optionalId) && this.isContextual(113)) {
          return;
        }
        _superClass.prototype.parseClassId.call(this, node, isStatement, optionalId, node.declare ? BindingFlag.TYPE_TS_AMBIENT : BindingFlag.TYPE_CLASS);
        var typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
        if (typeParameters) node.typeParameters = typeParameters;
      };
      _proto.parseClassPropertyAnnotation = function parseClassPropertyAnnotation(node) {
        if (!node.optional) {
          if (this.eat(35)) {
            node.definite = true;
          } else if (this.eat(17)) {
            node.optional = true;
          }
        }
        var type = this.tsTryParseTypeAnnotation();
        if (type) node.typeAnnotation = type;
      };
      _proto.parseClassProperty = function parseClassProperty(node) {
        this.parseClassPropertyAnnotation(node);
        if (this.state.isAmbientContext && !(node.readonly && !node.typeAnnotation) && this.match(29)) {
          this.raise(TSErrors.DeclareClassFieldHasInitializer, this.state.startLoc);
        }
        if (node["abstract"] && this.match(29)) {
          var _key2 = node.key;
          this.raise(TSErrors.AbstractPropertyHasInitializer, this.state.startLoc, {
            propertyName: _key2.type === "Identifier" && !node.computed ? _key2.name : "[" + this.input.slice(this.offsetToSourcePos(_key2.start), this.offsetToSourcePos(_key2.end)) + "]"
          });
        }
        return _superClass.prototype.parseClassProperty.call(this, node);
      };
      _proto.parseClassPrivateProperty = function parseClassPrivateProperty(node) {
        if (node["abstract"]) {
          this.raise(TSErrors.PrivateElementHasAbstract, node);
        }
        if (node.accessibility) {
          this.raise(TSErrors.PrivateElementHasAccessibility, node, {
            modifier: node.accessibility
          });
        }
        this.parseClassPropertyAnnotation(node);
        return _superClass.prototype.parseClassPrivateProperty.call(this, node);
      };
      _proto.parseClassAccessorProperty = function parseClassAccessorProperty(node) {
        this.parseClassPropertyAnnotation(node);
        if (node.optional) {
          this.raise(TSErrors.AccessorCannotBeOptional, node);
        }
        return _superClass.prototype.parseClassAccessorProperty.call(this, node);
      };
      _proto.pushClassMethod = function pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
        var typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
        if (typeParameters && isConstructor) {
          this.raise(TSErrors.ConstructorHasTypeParameters, typeParameters);
        }
        var _method$declare = method.declare,
          declare = _method$declare === void 0 ? false : _method$declare,
          kind = method.kind;
        if (declare && (kind === "get" || kind === "set")) {
          this.raise(TSErrors.DeclareAccessor, method, {
            kind: kind
          });
        }
        if (typeParameters) method.typeParameters = typeParameters;
        _superClass.prototype.pushClassMethod.call(this, classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);
      };
      _proto.pushClassPrivateMethod = function pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
        var typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
        if (typeParameters) method.typeParameters = typeParameters;
        _superClass.prototype.pushClassPrivateMethod.call(this, classBody, method, isGenerator, isAsync);
      };
      _proto.declareClassPrivateMethodInScope = function declareClassPrivateMethodInScope(node, kind) {
        if (node.type === "TSDeclareMethod") return;
        if (node.type === "MethodDefinition" && node.value.body == null) {
          return;
        }
        _superClass.prototype.declareClassPrivateMethodInScope.call(this, node, kind);
      };
      _proto.parseClassSuper = function parseClassSuper(node) {
        _superClass.prototype.parseClassSuper.call(this, node);
        if (node.superClass && (this.match(47) || this.match(51))) {
          {
            node.superTypeParameters = this.tsParseTypeArgumentsInExpression();
          }
        }
        if (this.eatContextual(113)) {
          node["implements"] = this.tsParseHeritageClause("implements");
        }
      };
      _proto.parseObjPropValue = function parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
        var typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
        if (typeParameters) prop.typeParameters = typeParameters;
        return _superClass.prototype.parseObjPropValue.call(this, prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);
      };
      _proto.parseFunctionParams = function parseFunctionParams(node, isConstructor) {
        var typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
        if (typeParameters) node.typeParameters = typeParameters;
        _superClass.prototype.parseFunctionParams.call(this, node, isConstructor);
      };
      _proto.parseVarId = function parseVarId(decl, kind) {
        _superClass.prototype.parseVarId.call(this, decl, kind);
        if (decl.id.type === "Identifier" && !this.hasPrecedingLineBreak() && this.eat(35)) {
          decl.definite = true;
        }
        var type = this.tsTryParseTypeAnnotation();
        if (type) {
          decl.id.typeAnnotation = type;
          this.resetEndLocation(decl.id);
        }
      };
      _proto.parseAsyncArrowFromCallExpression = function parseAsyncArrowFromCallExpression(node, call) {
        if (this.match(14)) {
          node.returnType = this.tsParseTypeAnnotation();
        }
        return _superClass.prototype.parseAsyncArrowFromCallExpression.call(this, node, call);
      };
      _proto.parseMaybeAssign = function parseMaybeAssign(refExpressionErrors, afterLeftParse) {
        var _this22 = this,
          _jsx,
          _jsx2,
          _typeCast,
          _jsx3,
          _typeCast2;
        var state;
        var jsx;
        var typeCast;
        if (this.hasPlugin("jsx") && (this.match(143) || this.match(47))) {
          state = this.state.clone();
          jsx = this.tryParse(function () {
            return _superClass.prototype.parseMaybeAssign.call(_this22, refExpressionErrors, afterLeftParse);
          }, state);
          if (!jsx.error) return jsx.node;
          var context = this.state.context;
          var currentContext = context[context.length - 1];
          if (currentContext === types.j_oTag || currentContext === types.j_expr) {
            context.pop();
          }
        }
        if (!((_jsx = jsx) != null && _jsx.error) && !this.match(47)) {
          return _superClass.prototype.parseMaybeAssign.call(this, refExpressionErrors, afterLeftParse);
        }
        if (!state || state === this.state) state = this.state.clone();
        var typeParameters;
        var arrow = this.tryParse(function (abort) {
          var _expr$extra, _typeParameters;
          typeParameters = _this22.tsParseTypeParameters(_this22.tsParseConstModifier);
          var expr = _superClass.prototype.parseMaybeAssign.call(_this22, refExpressionErrors, afterLeftParse);
          if (expr.type !== "ArrowFunctionExpression" || (_expr$extra = expr.extra) != null && _expr$extra.parenthesized) {
            abort();
          }
          if (((_typeParameters = typeParameters) == null ? void 0 : _typeParameters.params.length) !== 0) {
            _this22.resetStartLocationFromNode(expr, typeParameters);
          }
          expr.typeParameters = typeParameters;
          return expr;
        }, state);
        if (!arrow.error && !arrow.aborted) {
          if (typeParameters) this.reportReservedArrowTypeParam(typeParameters);
          return arrow.node;
        }
        if (!jsx) {
          assert$1(!this.hasPlugin("jsx"));
          typeCast = this.tryParse(function () {
            return _superClass.prototype.parseMaybeAssign.call(_this22, refExpressionErrors, afterLeftParse);
          }, state);
          if (!typeCast.error) return typeCast.node;
        }
        if ((_jsx2 = jsx) != null && _jsx2.node) {
          this.state = jsx.failState;
          return jsx.node;
        }
        if (arrow.node) {
          this.state = arrow.failState;
          if (typeParameters) this.reportReservedArrowTypeParam(typeParameters);
          return arrow.node;
        }
        if ((_typeCast = typeCast) != null && _typeCast.node) {
          this.state = typeCast.failState;
          return typeCast.node;
        }
        throw ((_jsx3 = jsx) == null ? void 0 : _jsx3.error) || arrow.error || ((_typeCast2 = typeCast) == null ? void 0 : _typeCast2.error);
      };
      _proto.reportReservedArrowTypeParam = function reportReservedArrowTypeParam(node) {
        var _node$extra2;
        if (node.params.length === 1 && !node.params[0].constraint && !((_node$extra2 = node.extra) != null && _node$extra2.trailingComma) && this.getPluginOption("typescript", "disallowAmbiguousJSXLike")) {
          this.raise(TSErrors.ReservedArrowTypeParam, node);
        }
      };
      _proto.parseMaybeUnary = function parseMaybeUnary(refExpressionErrors, sawUnary) {
        if (!this.hasPlugin("jsx") && this.match(47)) {
          return this.tsParseTypeAssertion();
        }
        return _superClass.prototype.parseMaybeUnary.call(this, refExpressionErrors, sawUnary);
      };
      _proto.parseArrow = function parseArrow(node) {
        var _this23 = this;
        if (this.match(14)) {
          var result = this.tryParse(function (abort) {
            var returnType = _this23.tsParseTypeOrTypePredicateAnnotation(14);
            if (_this23.canInsertSemicolon() || !_this23.match(19)) abort();
            return returnType;
          });
          if (result.aborted) return;
          if (!result.thrown) {
            if (result.error) this.state = result.failState;
            node.returnType = result.node;
          }
        }
        return _superClass.prototype.parseArrow.call(this, node);
      };
      _proto.parseFunctionParamType = function parseFunctionParamType(param) {
        if (this.eat(17)) {
          param.optional = true;
        }
        var type = this.tsTryParseTypeAnnotation();
        if (type) param.typeAnnotation = type;
        this.resetEndLocation(param);
        return param;
      };
      _proto.isAssignable = function isAssignable(node, isBinding) {
        switch (node.type) {
          case "TSTypeCastExpression":
            return this.isAssignable(node.expression, isBinding);
          case "TSParameterProperty":
            return true;
          default:
            return _superClass.prototype.isAssignable.call(this, node, isBinding);
        }
      };
      _proto.toAssignable = function toAssignable(node, isLHS) {
        if (isLHS === void 0) {
          isLHS = false;
        }
        switch (node.type) {
          case "ParenthesizedExpression":
            this.toAssignableParenthesizedExpression(node, isLHS);
            break;
          case "TSAsExpression":
          case "TSSatisfiesExpression":
          case "TSNonNullExpression":
          case "TSTypeAssertion":
            if (isLHS) {
              this.expressionScope.recordArrowParameterBindingError(TSErrors.UnexpectedTypeCastInParameter, node);
            } else {
              this.raise(TSErrors.UnexpectedTypeCastInParameter, node);
            }
            this.toAssignable(node.expression, isLHS);
            break;
          case "AssignmentExpression":
            if (!isLHS && node.left.type === "TSTypeCastExpression") {
              node.left = this.typeCastToParameter(node.left);
            }
          default:
            _superClass.prototype.toAssignable.call(this, node, isLHS);
        }
      };
      _proto.toAssignableParenthesizedExpression = function toAssignableParenthesizedExpression(node, isLHS) {
        switch (node.expression.type) {
          case "TSAsExpression":
          case "TSSatisfiesExpression":
          case "TSNonNullExpression":
          case "TSTypeAssertion":
          case "ParenthesizedExpression":
            this.toAssignable(node.expression, isLHS);
            break;
          default:
            _superClass.prototype.toAssignable.call(this, node, isLHS);
        }
      };
      _proto.checkToRestConversion = function checkToRestConversion(node, allowPattern) {
        switch (node.type) {
          case "TSAsExpression":
          case "TSSatisfiesExpression":
          case "TSTypeAssertion":
          case "TSNonNullExpression":
            this.checkToRestConversion(node.expression, false);
            break;
          default:
            _superClass.prototype.checkToRestConversion.call(this, node, allowPattern);
        }
      };
      _proto.isValidLVal = function isValidLVal(type, isUnparenthesizedInAssign, binding) {
        switch (type) {
          case "TSTypeCastExpression":
            return true;
          case "TSParameterProperty":
            return "parameter";
          case "TSNonNullExpression":
            return "expression";
          case "TSAsExpression":
          case "TSSatisfiesExpression":
          case "TSTypeAssertion":
            return (binding !== BindingFlag.TYPE_NONE || !isUnparenthesizedInAssign) && ["expression", true];
          default:
            return _superClass.prototype.isValidLVal.call(this, type, isUnparenthesizedInAssign, binding);
        }
      };
      _proto.parseBindingAtom = function parseBindingAtom() {
        if (this.state.type === 78) {
          return this.parseIdentifier(true);
        }
        return _superClass.prototype.parseBindingAtom.call(this);
      };
      _proto.parseMaybeDecoratorArguments = function parseMaybeDecoratorArguments(expr, startLoc) {
        if (this.match(47) || this.match(51)) {
          var typeArguments = this.tsParseTypeArgumentsInExpression();
          if (this.match(10)) {
            var call = _superClass.prototype.parseMaybeDecoratorArguments.call(this, expr, startLoc);
            {
              call.typeParameters = typeArguments;
            }
            return call;
          }
          this.unexpected(null, 10);
        }
        return _superClass.prototype.parseMaybeDecoratorArguments.call(this, expr, startLoc);
      };
      _proto.checkCommaAfterRest = function checkCommaAfterRest(close) {
        if (this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === close) {
          this.next();
          return false;
        }
        return _superClass.prototype.checkCommaAfterRest.call(this, close);
      };
      _proto.isClassMethod = function isClassMethod() {
        return this.match(47) || _superClass.prototype.isClassMethod.call(this);
      };
      _proto.isClassProperty = function isClassProperty() {
        return this.match(35) || this.match(14) || _superClass.prototype.isClassProperty.call(this);
      };
      _proto.parseMaybeDefault = function parseMaybeDefault(startLoc, left) {
        var node = _superClass.prototype.parseMaybeDefault.call(this, startLoc, left);
        if (node.type === "AssignmentPattern" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {
          this.raise(TSErrors.TypeAnnotationAfterAssign, node.typeAnnotation);
        }
        return node;
      };
      _proto.getTokenFromCode = function getTokenFromCode(code) {
        if (this.state.inType) {
          if (code === 62) {
            this.finishOp(48, 1);
            return;
          }
          if (code === 60) {
            this.finishOp(47, 1);
            return;
          }
        }
        _superClass.prototype.getTokenFromCode.call(this, code);
      };
      _proto.reScan_lt_gt = function reScan_lt_gt() {
        var type = this.state.type;
        if (type === 47) {
          this.state.pos -= 1;
          this.readToken_lt();
        } else if (type === 48) {
          this.state.pos -= 1;
          this.readToken_gt();
        }
      };
      _proto.reScan_lt = function reScan_lt() {
        var type = this.state.type;
        if (type === 51) {
          this.state.pos -= 2;
          this.finishOp(47, 1);
          return 47;
        }
        return type;
      };
      _proto.toAssignableListItem = function toAssignableListItem(exprList, index, isLHS) {
        var node = exprList[index];
        if (node.type === "TSTypeCastExpression") {
          exprList[index] = this.typeCastToParameter(node);
        }
        _superClass.prototype.toAssignableListItem.call(this, exprList, index, isLHS);
      };
      _proto.typeCastToParameter = function typeCastToParameter(node) {
        node.expression.typeAnnotation = node.typeAnnotation;
        this.resetEndLocation(node.expression, node.typeAnnotation.loc.end);
        return node.expression;
      };
      _proto.shouldParseArrow = function shouldParseArrow(params) {
        var _this24 = this;
        if (this.match(14)) {
          return params.every(function (expr) {
            return _this24.isAssignable(expr, true);
          });
        }
        return _superClass.prototype.shouldParseArrow.call(this, params);
      };
      _proto.shouldParseAsyncArrow = function shouldParseAsyncArrow() {
        return this.match(14) || _superClass.prototype.shouldParseAsyncArrow.call(this);
      };
      _proto.canHaveLeadingDecorator = function canHaveLeadingDecorator() {
        return _superClass.prototype.canHaveLeadingDecorator.call(this) || this.isAbstractClass();
      };
      _proto.jsxParseOpeningElementAfterName = function jsxParseOpeningElementAfterName(node) {
        var _this25 = this;
        if (this.match(47) || this.match(51)) {
          var typeArguments = this.tsTryParseAndCatch(function () {
            return _this25.tsParseTypeArgumentsInExpression();
          });
          if (typeArguments) {
            {
              node.typeParameters = typeArguments;
            }
          }
        }
        return _superClass.prototype.jsxParseOpeningElementAfterName.call(this, node);
      };
      _proto.getGetterSetterExpectedParamCount = function getGetterSetterExpectedParamCount(method) {
        var baseCount = _superClass.prototype.getGetterSetterExpectedParamCount.call(this, method);
        var params = this.getObjectOrClassMethodParams(method);
        var firstParam = params[0];
        var hasContextParam = firstParam && this.isThisParam(firstParam);
        return hasContextParam ? baseCount + 1 : baseCount;
      };
      _proto.parseCatchClauseParam = function parseCatchClauseParam() {
        var param = _superClass.prototype.parseCatchClauseParam.call(this);
        var type = this.tsTryParseTypeAnnotation();
        if (type) {
          param.typeAnnotation = type;
          this.resetEndLocation(param);
        }
        return param;
      };
      _proto.tsInAmbientContext = function tsInAmbientContext(cb) {
        var _this$state = this.state,
          oldIsAmbientContext = _this$state.isAmbientContext,
          oldStrict = _this$state.strict;
        this.state.isAmbientContext = true;
        this.state.strict = false;
        try {
          return cb();
        } finally {
          this.state.isAmbientContext = oldIsAmbientContext;
          this.state.strict = oldStrict;
        }
      };
      _proto.parseClass = function parseClass(node, isStatement, optionalId) {
        var oldInAbstractClass = this.state.inAbstractClass;
        this.state.inAbstractClass = !!node["abstract"];
        try {
          return _superClass.prototype.parseClass.call(this, node, isStatement, optionalId);
        } finally {
          this.state.inAbstractClass = oldInAbstractClass;
        }
      };
      _proto.tsParseAbstractDeclaration = function tsParseAbstractDeclaration(node, decorators) {
        if (this.match(80)) {
          node["abstract"] = true;
          return this.maybeTakeDecorators(decorators, this.parseClass(node, true, false));
        } else if (this.isContextual(129)) {
          if (!this.hasFollowingLineBreak()) {
            node["abstract"] = true;
            this.raise(TSErrors.NonClassMethodPropertyHasAbstractModifier, node);
            return this.tsParseInterfaceDeclaration(node);
          }
        } else {
          this.unexpected(null, 80);
        }
      };
      _proto.parseMethod = function parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope) {
        var method = _superClass.prototype.parseMethod.call(this, node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope);
        if (method["abstract"] || method.type === "TSAbstractMethodDefinition") {
          var hasEstreePlugin = this.hasPlugin("estree");
          var methodFn = hasEstreePlugin ? method.value : method;
          if (methodFn.body) {
            var _key3 = method.key;
            this.raise(TSErrors.AbstractMethodHasImplementation, method, {
              methodName: _key3.type === "Identifier" && !method.computed ? _key3.name : "[" + this.input.slice(this.offsetToSourcePos(_key3.start), this.offsetToSourcePos(_key3.end)) + "]"
            });
          }
        }
        return method;
      };
      _proto.tsParseTypeParameterName = function tsParseTypeParameterName() {
        var typeName = this.parseIdentifier();
        return typeName.name;
      };
      _proto.shouldParseAsAmbientContext = function shouldParseAsAmbientContext() {
        return !!this.getPluginOption("typescript", "dts");
      };
      _proto.parse = function parse() {
        if (this.shouldParseAsAmbientContext()) {
          this.state.isAmbientContext = true;
        }
        return _superClass.prototype.parse.call(this);
      };
      _proto.getExpression = function getExpression() {
        if (this.shouldParseAsAmbientContext()) {
          this.state.isAmbientContext = true;
        }
        return _superClass.prototype.getExpression.call(this);
      };
      _proto.parseExportSpecifier = function parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly) {
        if (!isString && isMaybeTypeOnly) {
          this.parseTypeOnlyImportExportSpecifier(node, false, isInTypeExport);
          return this.finishNode(node, "ExportSpecifier");
        }
        node.exportKind = "value";
        return _superClass.prototype.parseExportSpecifier.call(this, node, isString, isInTypeExport, isMaybeTypeOnly);
      };
      _proto.parseImportSpecifier = function parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {
        if (!importedIsString && isMaybeTypeOnly) {
          this.parseTypeOnlyImportExportSpecifier(specifier, true, isInTypeOnlyImport);
          return this.finishNode(specifier, "ImportSpecifier");
        }
        specifier.importKind = "value";
        return _superClass.prototype.parseImportSpecifier.call(this, specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, isInTypeOnlyImport ? BindingFlag.TYPE_TS_TYPE_IMPORT : BindingFlag.TYPE_TS_VALUE_IMPORT);
      };
      _proto.parseTypeOnlyImportExportSpecifier = function parseTypeOnlyImportExportSpecifier(node, isImport, isInTypeOnlyImportExport) {
        var leftOfAsKey = isImport ? "imported" : "local";
        var rightOfAsKey = isImport ? "local" : "exported";
        var leftOfAs = node[leftOfAsKey];
        var rightOfAs;
        var hasTypeSpecifier = false;
        var canParseAsKeyword = true;
        var loc = leftOfAs.loc.start;
        if (this.isContextual(93)) {
          var firstAs = this.parseIdentifier();
          if (this.isContextual(93)) {
            var secondAs = this.parseIdentifier();
            if (tokenIsKeywordOrIdentifier(this.state.type)) {
              hasTypeSpecifier = true;
              leftOfAs = firstAs;
              rightOfAs = isImport ? this.parseIdentifier() : this.parseModuleExportName();
              canParseAsKeyword = false;
            } else {
              rightOfAs = secondAs;
              canParseAsKeyword = false;
            }
          } else if (tokenIsKeywordOrIdentifier(this.state.type)) {
            canParseAsKeyword = false;
            rightOfAs = isImport ? this.parseIdentifier() : this.parseModuleExportName();
          } else {
            hasTypeSpecifier = true;
            leftOfAs = firstAs;
          }
        } else if (tokenIsKeywordOrIdentifier(this.state.type)) {
          hasTypeSpecifier = true;
          if (isImport) {
            leftOfAs = this.parseIdentifier(true);
            if (!this.isContextual(93)) {
              this.checkReservedWord(leftOfAs.name, leftOfAs.loc.start, true, true);
            }
          } else {
            leftOfAs = this.parseModuleExportName();
          }
        }
        if (hasTypeSpecifier && isInTypeOnlyImportExport) {
          this.raise(isImport ? TSErrors.TypeModifierIsUsedInTypeImports : TSErrors.TypeModifierIsUsedInTypeExports, loc);
        }
        node[leftOfAsKey] = leftOfAs;
        node[rightOfAsKey] = rightOfAs;
        var kindKey = isImport ? "importKind" : "exportKind";
        node[kindKey] = hasTypeSpecifier ? "type" : "value";
        if (canParseAsKeyword && this.eatContextual(93)) {
          node[rightOfAsKey] = isImport ? this.parseIdentifier() : this.parseModuleExportName();
        }
        if (!node[rightOfAsKey]) {
          node[rightOfAsKey] = this.cloneIdentifier(node[leftOfAsKey]);
        }
        if (isImport) {
          this.checkIdentifier(node[rightOfAsKey], hasTypeSpecifier ? BindingFlag.TYPE_TS_TYPE_IMPORT : BindingFlag.TYPE_TS_VALUE_IMPORT);
        }
      };
      _proto.fillOptionalPropertiesForTSESLint = function fillOptionalPropertiesForTSESLint(node) {
        var _node$directive, _node$decorators, _node$optional, _node$typeAnnotation, _node$accessibility, _node$decorators2, _node$override, _node$readonly, _node$static, _node$declare, _node$returnType, _node$typeParameters, _node$optional2, _node$optional3, _node$accessibility2, _node$readonly2, _node$static2, _node$declare2, _node$definite, _node$readonly3, _node$typeAnnotation2, _node$accessibility3, _node$decorators3, _node$override2, _node$optional4, _node$id, _node$abstract, _node$declare3, _node$decorators4, _node$implements, _node$superTypeArgume, _node$typeParameters2, _node$declare4, _node$definite2, _node$const, _node$declare5, _node$computed, _node$qualifier, _node$options, _node$declare6, _node$extends, _node$declare7, _node$global, _node$const2, _node$in, _node$out;
        switch (node.type) {
          case "ExpressionStatement":
            (_node$directive = node.directive) != null ? _node$directive : node.directive = undefined;
            return;
          case "RestElement":
            node.value = undefined;
          case "Identifier":
          case "ArrayPattern":
          case "AssignmentPattern":
          case "ObjectPattern":
            (_node$decorators = node.decorators) != null ? _node$decorators : node.decorators = [];
            (_node$optional = node.optional) != null ? _node$optional : node.optional = false;
            (_node$typeAnnotation = node.typeAnnotation) != null ? _node$typeAnnotation : node.typeAnnotation = undefined;
            return;
          case "TSParameterProperty":
            (_node$accessibility = node.accessibility) != null ? _node$accessibility : node.accessibility = undefined;
            (_node$decorators2 = node.decorators) != null ? _node$decorators2 : node.decorators = [];
            (_node$override = node.override) != null ? _node$override : node.override = false;
            (_node$readonly = node.readonly) != null ? _node$readonly : node.readonly = false;
            (_node$static = node["static"]) != null ? _node$static : node["static"] = false;
            return;
          case "TSEmptyBodyFunctionExpression":
            node.body = null;
          case "TSDeclareFunction":
          case "FunctionDeclaration":
          case "FunctionExpression":
          case "ClassMethod":
          case "ClassPrivateMethod":
            (_node$declare = node.declare) != null ? _node$declare : node.declare = false;
            (_node$returnType = node.returnType) != null ? _node$returnType : node.returnType = undefined;
            (_node$typeParameters = node.typeParameters) != null ? _node$typeParameters : node.typeParameters = undefined;
            return;
          case "Property":
            (_node$optional2 = node.optional) != null ? _node$optional2 : node.optional = false;
            return;
          case "TSMethodSignature":
          case "TSPropertySignature":
            (_node$optional3 = node.optional) != null ? _node$optional3 : node.optional = false;
          case "TSIndexSignature":
            (_node$accessibility2 = node.accessibility) != null ? _node$accessibility2 : node.accessibility = undefined;
            (_node$readonly2 = node.readonly) != null ? _node$readonly2 : node.readonly = false;
            (_node$static2 = node["static"]) != null ? _node$static2 : node["static"] = false;
            return;
          case "TSAbstractPropertyDefinition":
          case "PropertyDefinition":
          case "TSAbstractAccessorProperty":
          case "AccessorProperty":
            (_node$declare2 = node.declare) != null ? _node$declare2 : node.declare = false;
            (_node$definite = node.definite) != null ? _node$definite : node.definite = false;
            (_node$readonly3 = node.readonly) != null ? _node$readonly3 : node.readonly = false;
            (_node$typeAnnotation2 = node.typeAnnotation) != null ? _node$typeAnnotation2 : node.typeAnnotation = undefined;
          case "TSAbstractMethodDefinition":
          case "MethodDefinition":
            (_node$accessibility3 = node.accessibility) != null ? _node$accessibility3 : node.accessibility = undefined;
            (_node$decorators3 = node.decorators) != null ? _node$decorators3 : node.decorators = [];
            (_node$override2 = node.override) != null ? _node$override2 : node.override = false;
            (_node$optional4 = node.optional) != null ? _node$optional4 : node.optional = false;
            return;
          case "ClassExpression":
            (_node$id = node.id) != null ? _node$id : node.id = null;
          case "ClassDeclaration":
            (_node$abstract = node["abstract"]) != null ? _node$abstract : node["abstract"] = false;
            (_node$declare3 = node.declare) != null ? _node$declare3 : node.declare = false;
            (_node$decorators4 = node.decorators) != null ? _node$decorators4 : node.decorators = [];
            (_node$implements = node["implements"]) != null ? _node$implements : node["implements"] = [];
            (_node$superTypeArgume = node.superTypeArguments) != null ? _node$superTypeArgume : node.superTypeArguments = undefined;
            (_node$typeParameters2 = node.typeParameters) != null ? _node$typeParameters2 : node.typeParameters = undefined;
            return;
          case "TSTypeAliasDeclaration":
          case "VariableDeclaration":
            (_node$declare4 = node.declare) != null ? _node$declare4 : node.declare = false;
            return;
          case "VariableDeclarator":
            (_node$definite2 = node.definite) != null ? _node$definite2 : node.definite = false;
            return;
          case "TSEnumDeclaration":
            (_node$const = node["const"]) != null ? _node$const : node["const"] = false;
            (_node$declare5 = node.declare) != null ? _node$declare5 : node.declare = false;
            return;
          case "TSEnumMember":
            (_node$computed = node.computed) != null ? _node$computed : node.computed = false;
            return;
          case "TSImportType":
            (_node$qualifier = node.qualifier) != null ? _node$qualifier : node.qualifier = null;
            (_node$options = node.options) != null ? _node$options : node.options = null;
            return;
          case "TSInterfaceDeclaration":
            (_node$declare6 = node.declare) != null ? _node$declare6 : node.declare = false;
            (_node$extends = node["extends"]) != null ? _node$extends : node["extends"] = [];
            return;
          case "TSModuleDeclaration":
            (_node$declare7 = node.declare) != null ? _node$declare7 : node.declare = false;
            (_node$global = node.global) != null ? _node$global : node.global = node.kind === "global";
            return;
          case "TSTypeParameter":
            (_node$const2 = node["const"]) != null ? _node$const2 : node["const"] = false;
            (_node$in = node["in"]) != null ? _node$in : node["in"] = false;
            (_node$out = node.out) != null ? _node$out : node.out = false;
            return;
        }
      };
      return _createClass(TypeScriptParserMixin);
    }(superClass);
  });
  function isPossiblyLiteralEnum(expression) {
    if (expression.type !== "MemberExpression") return false;
    var computed = expression.computed,
      property = expression.property;
    if (computed && property.type !== "StringLiteral" && (property.type !== "TemplateLiteral" || property.expressions.length > 0)) {
      return false;
    }
    return isUncomputedMemberExpressionChain(expression.object);
  }
  function isValidAmbientConstInitializer(expression, estree) {
    var _expression$extra;
    var type = expression.type;
    if ((_expression$extra = expression.extra) != null && _expression$extra.parenthesized) {
      return false;
    }
    if (estree) {
      if (type === "Literal") {
        var value = expression.value;
        if (typeof value === "string" || typeof value === "boolean") {
          return true;
        }
      }
    } else {
      if (type === "StringLiteral" || type === "BooleanLiteral") {
        return true;
      }
    }
    if (isNumber$2(expression, estree) || isNegativeNumber(expression, estree)) {
      return true;
    }
    if (type === "TemplateLiteral" && expression.expressions.length === 0) {
      return true;
    }
    if (isPossiblyLiteralEnum(expression)) {
      return true;
    }
    return false;
  }
  function isNumber$2(expression, estree) {
    if (estree) {
      return expression.type === "Literal" && (typeof expression.value === "number" || "bigint" in expression);
    }
    return expression.type === "NumericLiteral" || expression.type === "BigIntLiteral";
  }
  function isNegativeNumber(expression, estree) {
    if (expression.type === "UnaryExpression") {
      var operator = expression.operator,
        argument = expression.argument;
      if (operator === "-" && isNumber$2(argument, estree)) {
        return true;
      }
    }
    return false;
  }
  function isUncomputedMemberExpressionChain(expression) {
    if (expression.type === "Identifier") return true;
    if (expression.type !== "MemberExpression" || expression.computed) {
      return false;
    }
    return isUncomputedMemberExpressionChain(expression.object);
  }

  var _templateObject$I;
  var PlaceholderErrors = ParseErrorEnum(_templateObject$I || (_templateObject$I = _taggedTemplateLiteralLoose(["placeholders"])))({
    ClassNameIsRequired: "A class name is required.",
    UnexpectedSpace: "Unexpected space in placeholder."
  });
  var placeholders = (function (superClass) {
    return function (_superClass) {
      function PlaceholdersParserMixin() {
        return _superClass.apply(this, arguments) || this;
      }
      _inherits(PlaceholdersParserMixin, _superClass);
      var _proto = PlaceholdersParserMixin.prototype;
      _proto.parsePlaceholder = function parsePlaceholder(expectedNode) {
        if (this.match(133)) {
          var node = this.startNode();
          this.next();
          this.assertNoSpace();
          node.name = _superClass.prototype.parseIdentifier.call(this, true);
          this.assertNoSpace();
          this.expect(133);
          return this.finishPlaceholder(node, expectedNode);
        }
      };
      _proto.finishPlaceholder = function finishPlaceholder(node, expectedNode) {
        var placeholder = node;
        if (!placeholder.expectedNode || !placeholder.type) {
          placeholder = this.finishNode(placeholder, "Placeholder");
        }
        placeholder.expectedNode = expectedNode;
        return placeholder;
      };
      _proto.getTokenFromCode = function getTokenFromCode(code) {
        if (code === 37 && this.input.charCodeAt(this.state.pos + 1) === 37) {
          this.finishOp(133, 2);
        } else {
          _superClass.prototype.getTokenFromCode.call(this, code);
        }
      };
      _proto.parseExprAtom = function parseExprAtom(refExpressionErrors) {
        return this.parsePlaceholder("Expression") || _superClass.prototype.parseExprAtom.call(this, refExpressionErrors);
      };
      _proto.parseIdentifier = function parseIdentifier(liberal) {
        return this.parsePlaceholder("Identifier") || _superClass.prototype.parseIdentifier.call(this, liberal);
      };
      _proto.checkReservedWord = function checkReservedWord(word, startLoc, checkKeywords, isBinding) {
        if (word !== undefined) {
          _superClass.prototype.checkReservedWord.call(this, word, startLoc, checkKeywords, isBinding);
        }
      };
      _proto.cloneIdentifier = function cloneIdentifier(node) {
        var cloned = _superClass.prototype.cloneIdentifier.call(this, node);
        if (cloned.type === "Placeholder") {
          cloned.expectedNode = node.expectedNode;
        }
        return cloned;
      };
      _proto.cloneStringLiteral = function cloneStringLiteral(node) {
        if (node.type === "Placeholder") {
          return this.cloneIdentifier(node);
        }
        return _superClass.prototype.cloneStringLiteral.call(this, node);
      };
      _proto.parseBindingAtom = function parseBindingAtom() {
        return this.parsePlaceholder("Pattern") || _superClass.prototype.parseBindingAtom.call(this);
      };
      _proto.isValidLVal = function isValidLVal(type, isParenthesized, binding) {
        return type === "Placeholder" || _superClass.prototype.isValidLVal.call(this, type, isParenthesized, binding);
      };
      _proto.toAssignable = function toAssignable(node, isLHS) {
        if (node && node.type === "Placeholder" && node.expectedNode === "Expression") {
          node.expectedNode = "Pattern";
        } else {
          _superClass.prototype.toAssignable.call(this, node, isLHS);
        }
      };
      _proto.chStartsBindingIdentifier = function chStartsBindingIdentifier(ch, pos) {
        if (_superClass.prototype.chStartsBindingIdentifier.call(this, ch, pos)) {
          return true;
        }
        var next = this.nextTokenStart();
        if (this.input.charCodeAt(next) === 37 && this.input.charCodeAt(next + 1) === 37) {
          return true;
        }
        return false;
      };
      _proto.verifyBreakContinue = function verifyBreakContinue(node, isBreak) {
        if (node.label && node.label.type === "Placeholder") return;
        _superClass.prototype.verifyBreakContinue.call(this, node, isBreak);
      };
      _proto.parseExpressionStatement = function parseExpressionStatement(node, expr) {
        var _expr$extra;
        if (expr.type !== "Placeholder" || (_expr$extra = expr.extra) != null && _expr$extra.parenthesized) {
          return _superClass.prototype.parseExpressionStatement.call(this, node, expr);
        }
        if (this.match(14)) {
          var stmt = node;
          stmt.label = this.finishPlaceholder(expr, "Identifier");
          this.next();
          stmt.body = _superClass.prototype.parseStatementOrSloppyAnnexBFunctionDeclaration.call(this);
          return this.finishNode(stmt, "LabeledStatement");
        }
        this.semicolon();
        var stmtPlaceholder = node;
        stmtPlaceholder.name = expr.name;
        return this.finishPlaceholder(stmtPlaceholder, "Statement");
      };
      _proto.parseBlock = function parseBlock(allowDirectives, createNewLexicalScope, afterBlockParse) {
        return this.parsePlaceholder("BlockStatement") || _superClass.prototype.parseBlock.call(this, allowDirectives, createNewLexicalScope, afterBlockParse);
      };
      _proto.parseFunctionId = function parseFunctionId(requireId) {
        return this.parsePlaceholder("Identifier") || _superClass.prototype.parseFunctionId.call(this, requireId);
      };
      _proto.parseClass = function parseClass(node, isStatement, optionalId) {
        var type = isStatement ? "ClassDeclaration" : "ClassExpression";
        this.next();
        var oldStrict = this.state.strict;
        var placeholder = this.parsePlaceholder("Identifier");
        if (placeholder) {
          if (this.match(81) || this.match(133) || this.match(5)) {
            node.id = placeholder;
          } else if (optionalId || !isStatement) {
            node.id = null;
            node.body = this.finishPlaceholder(placeholder, "ClassBody");
            return this.finishNode(node, type);
          } else {
            throw this.raise(PlaceholderErrors.ClassNameIsRequired, this.state.startLoc);
          }
        } else {
          this.parseClassId(node, isStatement, optionalId);
        }
        _superClass.prototype.parseClassSuper.call(this, node);
        node.body = this.parsePlaceholder("ClassBody") || _superClass.prototype.parseClassBody.call(this, !!node.superClass, oldStrict);
        return this.finishNode(node, type);
      };
      _proto.parseExport = function parseExport(node, decorators) {
        var placeholder = this.parsePlaceholder("Identifier");
        if (!placeholder) return _superClass.prototype.parseExport.call(this, node, decorators);
        var node2 = node;
        if (!this.isContextual(98) && !this.match(12)) {
          node2.specifiers = [];
          node2.source = null;
          node2.declaration = this.finishPlaceholder(placeholder, "Declaration");
          return this.finishNode(node2, "ExportNamedDeclaration");
        }
        this.expectPlugin("exportDefaultFrom");
        var specifier = this.startNode();
        specifier.exported = placeholder;
        node2.specifiers = [this.finishNode(specifier, "ExportDefaultSpecifier")];
        return _superClass.prototype.parseExport.call(this, node2, decorators);
      };
      _proto.isExportDefaultSpecifier = function isExportDefaultSpecifier() {
        if (this.match(65)) {
          var next = this.nextTokenStart();
          if (this.isUnparsedContextual(next, "from")) {
            if (this.input.startsWith(tokenLabelName(133), this.nextTokenStartSince(next + 4))) {
              return true;
            }
          }
        }
        return _superClass.prototype.isExportDefaultSpecifier.call(this);
      };
      _proto.maybeParseExportDefaultSpecifier = function maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier) {
        var _specifiers;
        if ((_specifiers = node.specifiers) != null && _specifiers.length) {
          return true;
        }
        return _superClass.prototype.maybeParseExportDefaultSpecifier.call(this, node, maybeDefaultIdentifier);
      };
      _proto.checkExport = function checkExport(node) {
        var specifiers = node.specifiers;
        if (specifiers != null && specifiers.length) {
          node.specifiers = specifiers.filter(function (node) {
            return node.exported.type === "Placeholder";
          });
        }
        _superClass.prototype.checkExport.call(this, node);
        node.specifiers = specifiers;
      };
      _proto.parseImport = function parseImport(node) {
        var placeholder = this.parsePlaceholder("Identifier");
        if (!placeholder) return _superClass.prototype.parseImport.call(this, node);
        node.specifiers = [];
        if (!this.isContextual(98) && !this.match(12)) {
          node.source = this.finishPlaceholder(placeholder, "StringLiteral");
          this.semicolon();
          return this.finishNode(node, "ImportDeclaration");
        }
        var specifier = this.startNodeAtNode(placeholder);
        specifier.local = placeholder;
        node.specifiers.push(this.finishNode(specifier, "ImportDefaultSpecifier"));
        if (this.eat(12)) {
          var hasStarImport = this.maybeParseStarImportSpecifier(node);
          if (!hasStarImport) this.parseNamedImportSpecifiers(node);
        }
        this.expectContextual(98);
        node.source = this.parseImportSource();
        this.semicolon();
        return this.finishNode(node, "ImportDeclaration");
      };
      _proto.parseImportSource = function parseImportSource() {
        return this.parsePlaceholder("StringLiteral") || _superClass.prototype.parseImportSource.call(this);
      };
      _proto.assertNoSpace = function assertNoSpace() {
        if (this.state.start > this.offsetToSourcePos(this.state.lastTokEndLoc.index)) {
          this.raise(PlaceholderErrors.UnexpectedSpace, this.state.lastTokEndLoc);
        }
      };
      return _createClass(PlaceholdersParserMixin);
    }(superClass);
  });

  var v8intrinsic = (function (superClass) {
    return function (_superClass) {
      function V8IntrinsicMixin() {
        return _superClass.apply(this, arguments) || this;
      }
      _inherits(V8IntrinsicMixin, _superClass);
      var _proto = V8IntrinsicMixin.prototype;
      _proto.parseV8Intrinsic = function parseV8Intrinsic() {
        if (this.match(54)) {
          var v8IntrinsicStartLoc = this.state.startLoc;
          var node = this.startNode();
          this.next();
          if (tokenIsIdentifier(this.state.type)) {
            var name = this.parseIdentifierName();
            var identifier = this.createIdentifier(node, name);
            this.castNodeTo(identifier, "V8IntrinsicIdentifier");
            if (this.match(10)) {
              return identifier;
            }
          }
          this.unexpected(v8IntrinsicStartLoc);
        }
      };
      _proto.parseExprAtom = function parseExprAtom(refExpressionErrors) {
        return this.parseV8Intrinsic() || _superClass.prototype.parseExprAtom.call(this, refExpressionErrors);
      };
      return _createClass(V8IntrinsicMixin);
    }(superClass);
  });

  var PIPELINE_PROPOSALS$1 = ["minimal", "fsharp", "hack", "smart"];
  var TOPIC_TOKENS$1 = ["^^", "@@", "^", "%", "#"];
  function validatePlugins(pluginsMap) {
    if (pluginsMap.has("decorators")) {
      if (pluginsMap.has("decorators-legacy")) {
        throw new Error("Cannot use the decorators and decorators-legacy plugin together");
      }
      var decoratorsBeforeExport = pluginsMap.get("decorators").decoratorsBeforeExport;
      if (decoratorsBeforeExport != null && typeof decoratorsBeforeExport !== "boolean") {
        throw new Error("'decoratorsBeforeExport' must be a boolean, if specified.");
      }
      var allowCallParenthesized = pluginsMap.get("decorators").allowCallParenthesized;
      if (allowCallParenthesized != null && typeof allowCallParenthesized !== "boolean") {
        throw new Error("'allowCallParenthesized' must be a boolean.");
      }
    }
    if (pluginsMap.has("flow") && pluginsMap.has("typescript")) {
      throw new Error("Cannot combine flow and typescript plugins.");
    }
    if (pluginsMap.has("placeholders") && pluginsMap.has("v8intrinsic")) {
      throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
    }
    if (pluginsMap.has("pipelineOperator")) {
      var _pluginsMap$get2;
      var proposal = pluginsMap.get("pipelineOperator").proposal;
      if (!PIPELINE_PROPOSALS$1.includes(proposal)) {
        var proposalList = PIPELINE_PROPOSALS$1.map(function (p) {
          return "\"" + p + "\"";
        }).join(", ");
        throw new Error("\"pipelineOperator\" requires \"proposal\" option whose value must be one of: " + proposalList + ".");
      }
      if (proposal === "hack") {
        if (pluginsMap.has("placeholders")) {
          throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
        }
        if (pluginsMap.has("v8intrinsic")) {
          throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
        }
        var topicToken = pluginsMap.get("pipelineOperator").topicToken;
        if (!TOPIC_TOKENS$1.includes(topicToken)) {
          var tokenList = TOPIC_TOKENS$1.map(function (t) {
            return "\"" + t + "\"";
          }).join(", ");
          throw new Error("\"pipelineOperator\" in \"proposal\": \"hack\" mode also requires a \"topicToken\" option whose value must be one of: " + tokenList + ".");
        }
        {
          var _pluginsMap$get;
          if (topicToken === "#" && ((_pluginsMap$get = pluginsMap.get("recordAndTuple")) == null ? void 0 : _pluginsMap$get.syntaxType) === "hash") {
            throw new Error("Plugin conflict between `[\"pipelineOperator\", { proposal: \"hack\", topicToken: \"#\" }]` and `" + JSON.stringify(["recordAndTuple", pluginsMap.get("recordAndTuple")]) + "`.");
          }
        }
      } else if (proposal === "smart" && ((_pluginsMap$get2 = pluginsMap.get("recordAndTuple")) == null ? void 0 : _pluginsMap$get2.syntaxType) === "hash") {
        throw new Error("Plugin conflict between `[\"pipelineOperator\", { proposal: \"smart\" }]` and `" + JSON.stringify(["recordAndTuple", pluginsMap.get("recordAndTuple")]) + "`.");
      }
    }
    if (pluginsMap.has("moduleAttributes")) {
      {
        if (pluginsMap.has("deprecatedImportAssert") || pluginsMap.has("importAssertions")) {
          throw new Error("Cannot combine importAssertions, deprecatedImportAssert and moduleAttributes plugins.");
        }
        var moduleAttributesVersionPluginOption = pluginsMap.get("moduleAttributes").version;
        if (moduleAttributesVersionPluginOption !== "may-2020") {
          throw new Error("The 'moduleAttributes' plugin requires a 'version' option," + " representing the last proposal update. Currently, the" + " only supported value is 'may-2020'.");
        }
      }
    }
    if (pluginsMap.has("importAssertions")) {
      if (pluginsMap.has("deprecatedImportAssert")) {
        throw new Error("Cannot combine importAssertions and deprecatedImportAssert plugins.");
      }
    }
    if (!pluginsMap.has("deprecatedImportAssert") && pluginsMap.has("importAttributes") && pluginsMap.get("importAttributes").deprecatedAssertSyntax) {
      {
        pluginsMap.set("deprecatedImportAssert", {});
      }
    }
    if (pluginsMap.has("recordAndTuple")) {
      {
        var syntaxType = pluginsMap.get("recordAndTuple").syntaxType;
        if (syntaxType != null) {
          var RECORD_AND_TUPLE_SYNTAX_TYPES = ["hash", "bar"];
          if (!RECORD_AND_TUPLE_SYNTAX_TYPES.includes(syntaxType)) {
            throw new Error("The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: " + RECORD_AND_TUPLE_SYNTAX_TYPES.map(function (p) {
              return "'" + p + "'";
            }).join(", "));
          }
        }
      }
    }
    if (pluginsMap.has("asyncDoExpressions") && !pluginsMap.has("doExpressions")) {
      var error = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
      error.missingPlugins = "doExpressions";
      throw error;
    }
    if (pluginsMap.has("optionalChainingAssign") && pluginsMap.get("optionalChainingAssign").version !== "2023-07") {
      throw new Error("The 'optionalChainingAssign' plugin requires a 'version' option," + " representing the last proposal update. Currently, the" + " only supported value is '2023-07'.");
    }
    if (pluginsMap.has("discardBinding") && pluginsMap.get("discardBinding").syntaxType !== "void") {
      throw new Error("The 'discardBinding' plugin requires a 'syntaxType' option. Currently the only supported value is 'void'.");
    }
  }
  var mixinPlugins = {
    estree: estree,
    jsx: jsx,
    flow: flow,
    typescript: typescript,
    v8intrinsic: v8intrinsic,
    placeholders: placeholders
  };
  var mixinPluginNames = Object.keys(mixinPlugins);

  var ExpressionParser = function (_LValParser) {
    function ExpressionParser() {
      return _LValParser.apply(this, arguments) || this;
    }
    _inherits(ExpressionParser, _LValParser);
    var _proto = ExpressionParser.prototype;
    _proto.checkProto = function checkProto(prop, isRecord, sawProto, refExpressionErrors) {
      if (prop.type === "SpreadElement" || this.isObjectMethod(prop) || prop.computed || prop.shorthand) {
        return sawProto;
      }
      var key = prop.key;
      var name = key.type === "Identifier" ? key.name : key.value;
      if (name === "__proto__") {
        if (isRecord) {
          this.raise(Errors.RecordNoProto, key);
          return true;
        }
        if (sawProto) {
          if (refExpressionErrors) {
            if (refExpressionErrors.doubleProtoLoc === null) {
              refExpressionErrors.doubleProtoLoc = key.loc.start;
            }
          } else {
            this.raise(Errors.DuplicateProto, key);
          }
        }
        return true;
      }
      return sawProto;
    };
    _proto.shouldExitDescending = function shouldExitDescending(expr, potentialArrowAt) {
      return expr.type === "ArrowFunctionExpression" && this.offsetToSourcePos(expr.start) === potentialArrowAt;
    };
    _proto.getExpression = function getExpression() {
      this.enterInitialScopes();
      this.nextToken();
      if (this.match(140)) {
        throw this.raise(Errors.ParseExpressionEmptyInput, this.state.startLoc);
      }
      var expr = this.parseExpression();
      if (!this.match(140)) {
        throw this.raise(Errors.ParseExpressionExpectsEOF, this.state.startLoc, {
          unexpected: this.input.codePointAt(this.state.start)
        });
      }
      this.finalizeRemainingComments();
      expr.comments = this.comments;
      expr.errors = this.state.errors;
      if (this.optionFlags & OptionFlags.Tokens) {
        expr.tokens = this.tokens;
      }
      return expr;
    };
    _proto.parseExpression = function parseExpression(disallowIn, refExpressionErrors) {
      var _this = this;
      if (disallowIn) {
        return this.disallowInAnd(function () {
          return _this.parseExpressionBase(refExpressionErrors);
        });
      }
      return this.allowInAnd(function () {
        return _this.parseExpressionBase(refExpressionErrors);
      });
    };
    _proto.parseExpressionBase = function parseExpressionBase(refExpressionErrors) {
      var startLoc = this.state.startLoc;
      var expr = this.parseMaybeAssign(refExpressionErrors);
      if (this.match(12)) {
        var _node = this.startNodeAt(startLoc);
        _node.expressions = [expr];
        while (this.eat(12)) {
          _node.expressions.push(this.parseMaybeAssign(refExpressionErrors));
        }
        this.toReferencedList(_node.expressions);
        return this.finishNode(_node, "SequenceExpression");
      }
      return expr;
    };
    _proto.parseMaybeAssignDisallowIn = function parseMaybeAssignDisallowIn(refExpressionErrors, afterLeftParse) {
      var _this2 = this;
      return this.disallowInAnd(function () {
        return _this2.parseMaybeAssign(refExpressionErrors, afterLeftParse);
      });
    };
    _proto.parseMaybeAssignAllowIn = function parseMaybeAssignAllowIn(refExpressionErrors, afterLeftParse) {
      var _this3 = this;
      return this.allowInAnd(function () {
        return _this3.parseMaybeAssign(refExpressionErrors, afterLeftParse);
      });
    };
    _proto.setOptionalParametersError = function setOptionalParametersError(refExpressionErrors) {
      refExpressionErrors.optionalParametersLoc = this.state.startLoc;
    };
    _proto.parseMaybeAssign = function parseMaybeAssign(refExpressionErrors, afterLeftParse) {
      var startLoc = this.state.startLoc;
      var isYield = this.isContextual(108);
      if (isYield) {
        if (this.prodParam.hasYield) {
          this.next();
          var _left = this.parseYield(startLoc);
          if (afterLeftParse) {
            _left = afterLeftParse.call(this, _left, startLoc);
          }
          return _left;
        }
      }
      var ownExpressionErrors;
      if (refExpressionErrors) {
        ownExpressionErrors = false;
      } else {
        refExpressionErrors = new ExpressionErrors();
        ownExpressionErrors = true;
      }
      var type = this.state.type;
      if (type === 10 || tokenIsIdentifier(type)) {
        this.state.potentialArrowAt = this.state.start;
      }
      var left = this.parseMaybeConditional(refExpressionErrors);
      if (afterLeftParse) {
        left = afterLeftParse.call(this, left, startLoc);
      }
      if (tokenIsAssignment(this.state.type)) {
        var _node2 = this.startNodeAt(startLoc);
        var operator = this.state.value;
        _node2.operator = operator;
        if (this.match(29)) {
          this.toAssignable(left, true);
          _node2.left = left;
          var startIndex = startLoc.index;
          if (refExpressionErrors.doubleProtoLoc != null && refExpressionErrors.doubleProtoLoc.index >= startIndex) {
            refExpressionErrors.doubleProtoLoc = null;
          }
          if (refExpressionErrors.shorthandAssignLoc != null && refExpressionErrors.shorthandAssignLoc.index >= startIndex) {
            refExpressionErrors.shorthandAssignLoc = null;
          }
          if (refExpressionErrors.privateKeyLoc != null && refExpressionErrors.privateKeyLoc.index >= startIndex) {
            this.checkDestructuringPrivate(refExpressionErrors);
            refExpressionErrors.privateKeyLoc = null;
          }
          if (refExpressionErrors.voidPatternLoc != null && refExpressionErrors.voidPatternLoc.index >= startIndex) {
            refExpressionErrors.voidPatternLoc = null;
          }
        } else {
          _node2.left = left;
        }
        this.next();
        _node2.right = this.parseMaybeAssign();
        this.checkLVal(left, this.finishNode(_node2, "AssignmentExpression"));
        return _node2;
      } else if (ownExpressionErrors) {
        this.checkExpressionErrors(refExpressionErrors, true);
      }
      if (isYield) {
        var _type = this.state.type;
        var startsExpr = this.hasPlugin("v8intrinsic") ? tokenCanStartExpression(_type) : tokenCanStartExpression(_type) && !this.match(54);
        if (startsExpr && !this.isAmbiguousPrefixOrIdentifier()) {
          this.raiseOverwrite(Errors.YieldNotInGeneratorFunction, startLoc);
          return this.parseYield(startLoc);
        }
      }
      return left;
    };
    _proto.parseMaybeConditional = function parseMaybeConditional(refExpressionErrors) {
      var startLoc = this.state.startLoc;
      var potentialArrowAt = this.state.potentialArrowAt;
      var expr = this.parseExprOps(refExpressionErrors);
      if (this.shouldExitDescending(expr, potentialArrowAt)) {
        return expr;
      }
      return this.parseConditional(expr, startLoc, refExpressionErrors);
    };
    _proto.parseConditional = function parseConditional(expr, startLoc, refExpressionErrors) {
      if (this.eat(17)) {
        var _node3 = this.startNodeAt(startLoc);
        _node3.test = expr;
        _node3.consequent = this.parseMaybeAssignAllowIn();
        this.expect(14);
        _node3.alternate = this.parseMaybeAssign();
        return this.finishNode(_node3, "ConditionalExpression");
      }
      return expr;
    };
    _proto.parseMaybeUnaryOrPrivate = function parseMaybeUnaryOrPrivate(refExpressionErrors) {
      return this.match(139) ? this.parsePrivateName() : this.parseMaybeUnary(refExpressionErrors);
    };
    _proto.parseExprOps = function parseExprOps(refExpressionErrors) {
      var startLoc = this.state.startLoc;
      var potentialArrowAt = this.state.potentialArrowAt;
      var expr = this.parseMaybeUnaryOrPrivate(refExpressionErrors);
      if (this.shouldExitDescending(expr, potentialArrowAt)) {
        return expr;
      }
      return this.parseExprOp(expr, startLoc, -1);
    };
    _proto.parseExprOp = function parseExprOp(left, leftStartLoc, minPrec) {
      if (this.isPrivateName(left)) {
        var value = this.getPrivateNameSV(left);
        if (minPrec >= tokenOperatorPrecedence(58) || !this.prodParam.hasIn || !this.match(58)) {
          this.raise(Errors.PrivateInExpectedIn, left, {
            identifierName: value
          });
        }
        this.classScope.usePrivateName(value, left.loc.start);
      }
      var op = this.state.type;
      if (tokenIsOperator(op) && (this.prodParam.hasIn || !this.match(58))) {
        var prec = tokenOperatorPrecedence(op);
        if (prec > minPrec) {
          if (op === 39) {
            this.expectPlugin("pipelineOperator");
            if (this.state.inFSharpPipelineDirectBody) {
              return left;
            }
            this.checkPipelineAtInfixOperator(left, leftStartLoc);
          }
          var _node4 = this.startNodeAt(leftStartLoc);
          _node4.left = left;
          _node4.operator = this.state.value;
          var logical = op === 41 || op === 42;
          var coalesce = op === 40;
          if (coalesce) {
            prec = tokenOperatorPrecedence(42);
          }
          this.next();
          if (op === 39 && this.hasPlugin(["pipelineOperator", {
            proposal: "minimal"
          }])) {
            if (this.state.type === 96 && this.prodParam.hasAwait) {
              throw this.raise(Errors.UnexpectedAwaitAfterPipelineBody, this.state.startLoc);
            }
          }
          _node4.right = this.parseExprOpRightExpr(op, prec);
          var finishedNode = this.finishNode(_node4, logical || coalesce ? "LogicalExpression" : "BinaryExpression");
          var nextOp = this.state.type;
          if (coalesce && (nextOp === 41 || nextOp === 42) || logical && nextOp === 40) {
            throw this.raise(Errors.MixingCoalesceWithLogical, this.state.startLoc);
          }
          return this.parseExprOp(finishedNode, leftStartLoc, minPrec);
        }
      }
      return left;
    };
    _proto.parseExprOpRightExpr = function parseExprOpRightExpr(op, prec) {
      var _this4 = this;
      var startLoc = this.state.startLoc;
      switch (op) {
        case 39:
          switch (this.getPluginOption("pipelineOperator", "proposal")) {
            case "hack":
              return this.withTopicBindingContext(function () {
                return _this4.parseHackPipeBody();
              });
            case "fsharp":
              return this.withSoloAwaitPermittingContext(function () {
                return _this4.parseFSharpPipelineBody(prec);
              });
          }
          if (this.getPluginOption("pipelineOperator", "proposal") === "smart") {
            return this.withTopicBindingContext(function () {
              if (_this4.prodParam.hasYield && _this4.isContextual(108)) {
                throw _this4.raise(Errors.PipeBodyIsTighter, _this4.state.startLoc);
              }
              return _this4.parseSmartPipelineBodyInStyle(_this4.parseExprOpBaseRightExpr(op, prec), startLoc);
            });
          }
        default:
          return this.parseExprOpBaseRightExpr(op, prec);
      }
    };
    _proto.parseExprOpBaseRightExpr = function parseExprOpBaseRightExpr(op, prec) {
      var startLoc = this.state.startLoc;
      return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startLoc, tokenIsRightAssociative(op) ? prec - 1 : prec);
    };
    _proto.parseHackPipeBody = function parseHackPipeBody() {
      var _body$extra;
      var startLoc = this.state.startLoc;
      var body = this.parseMaybeAssign();
      var requiredParentheses = UnparenthesizedPipeBodyDescriptions.has(body.type);
      if (requiredParentheses && !((_body$extra = body.extra) != null && _body$extra.parenthesized)) {
        this.raise(Errors.PipeUnparenthesizedBody, startLoc, {
          type: body.type
        });
      }
      if (!this.topicReferenceWasUsedInCurrentContext()) {
        this.raise(Errors.PipeTopicUnused, startLoc);
      }
      return body;
    };
    _proto.checkExponentialAfterUnary = function checkExponentialAfterUnary(node) {
      if (this.match(57)) {
        this.raise(Errors.UnexpectedTokenUnaryExponentiation, node.argument);
      }
    };
    _proto.parseMaybeUnary = function parseMaybeUnary(refExpressionErrors, sawUnary) {
      var startLoc = this.state.startLoc;
      var isAwait = this.isContextual(96);
      if (isAwait && this.recordAwaitIfAllowed()) {
        this.next();
        var _expr = this.parseAwait(startLoc);
        if (!sawUnary) this.checkExponentialAfterUnary(_expr);
        return _expr;
      }
      var update = this.match(34);
      var node = this.startNode();
      if (tokenIsPrefix(this.state.type)) {
        node.operator = this.state.value;
        node.prefix = true;
        if (this.match(72)) {
          this.expectPlugin("throwExpressions");
        }
        var isDelete = this.match(89);
        this.next();
        node.argument = this.parseMaybeUnary(null, true);
        this.checkExpressionErrors(refExpressionErrors, true);
        if (this.state.strict && isDelete) {
          var arg = node.argument;
          if (arg.type === "Identifier") {
            this.raise(Errors.StrictDelete, node);
          } else if (this.hasPropertyAsPrivateName(arg)) {
            this.raise(Errors.DeletePrivateField, node);
          }
        }
        if (!update) {
          if (!sawUnary) {
            this.checkExponentialAfterUnary(node);
          }
          return this.finishNode(node, "UnaryExpression");
        }
      }
      var expr = this.parseUpdate(node, update, refExpressionErrors);
      if (isAwait) {
        var type = this.state.type;
        var startsExpr = this.hasPlugin("v8intrinsic") ? tokenCanStartExpression(type) : tokenCanStartExpression(type) && !this.match(54);
        if (startsExpr && !this.isAmbiguousPrefixOrIdentifier()) {
          this.raiseOverwrite(Errors.AwaitNotInAsyncContext, startLoc);
          return this.parseAwait(startLoc);
        }
      }
      return expr;
    };
    _proto.parseUpdate = function parseUpdate(node, update, refExpressionErrors) {
      if (update) {
        var updateExpressionNode = node;
        this.checkLVal(updateExpressionNode.argument, this.finishNode(updateExpressionNode, "UpdateExpression"));
        return node;
      }
      var startLoc = this.state.startLoc;
      var expr = this.parseExprSubscripts(refExpressionErrors);
      if (this.checkExpressionErrors(refExpressionErrors, false)) return expr;
      while (tokenIsPostfix(this.state.type) && !this.canInsertSemicolon()) {
        var _node5 = this.startNodeAt(startLoc);
        _node5.operator = this.state.value;
        _node5.prefix = false;
        _node5.argument = expr;
        this.next();
        this.checkLVal(expr, expr = this.finishNode(_node5, "UpdateExpression"));
      }
      return expr;
    };
    _proto.parseExprSubscripts = function parseExprSubscripts(refExpressionErrors) {
      var startLoc = this.state.startLoc;
      var potentialArrowAt = this.state.potentialArrowAt;
      var expr = this.parseExprAtom(refExpressionErrors);
      if (this.shouldExitDescending(expr, potentialArrowAt)) {
        return expr;
      }
      return this.parseSubscripts(expr, startLoc);
    };
    _proto.parseSubscripts = function parseSubscripts(base, startLoc, noCalls) {
      var state = {
        optionalChainMember: false,
        maybeAsyncArrow: this.atPossibleAsyncArrow(base),
        stop: false
      };
      do {
        base = this.parseSubscript(base, startLoc, noCalls, state);
        state.maybeAsyncArrow = false;
      } while (!state.stop);
      return base;
    };
    _proto.parseSubscript = function parseSubscript(base, startLoc, noCalls, state) {
      var type = this.state.type;
      if (!noCalls && type === 15) {
        return this.parseBind(base, startLoc, noCalls, state);
      } else if (tokenIsTemplate(type)) {
        return this.parseTaggedTemplateExpression(base, startLoc, state);
      }
      var optional = false;
      if (type === 18) {
        if (noCalls) {
          this.raise(Errors.OptionalChainingNoNew, this.state.startLoc);
          if (this.lookaheadCharCode() === 40) {
            return this.stopParseSubscript(base, state);
          }
        }
        state.optionalChainMember = optional = true;
        this.next();
      }
      if (!noCalls && this.match(10)) {
        return this.parseCoverCallAndAsyncArrowHead(base, startLoc, state, optional);
      } else {
        var computed = this.eat(0);
        if (computed || optional || this.eat(16)) {
          return this.parseMember(base, startLoc, state, computed, optional);
        } else {
          return this.stopParseSubscript(base, state);
        }
      }
    };
    _proto.stopParseSubscript = function stopParseSubscript(base, state) {
      state.stop = true;
      return base;
    };
    _proto.parseMember = function parseMember(base, startLoc, state, computed, optional) {
      var node = this.startNodeAt(startLoc);
      node.object = base;
      node.computed = computed;
      if (computed) {
        node.property = this.parseExpression();
        this.expect(3);
      } else if (this.match(139)) {
        if (base.type === "Super") {
          this.raise(Errors.SuperPrivateField, startLoc);
        }
        this.classScope.usePrivateName(this.state.value, this.state.startLoc);
        node.property = this.parsePrivateName();
      } else {
        node.property = this.parseIdentifier(true);
      }
      if (state.optionalChainMember) {
        node.optional = optional;
        return this.finishNode(node, "OptionalMemberExpression");
      } else {
        return this.finishNode(node, "MemberExpression");
      }
    };
    _proto.parseBind = function parseBind(base, startLoc, noCalls, state) {
      var node = this.startNodeAt(startLoc);
      node.object = base;
      this.next();
      node.callee = this.parseNoCallExpr();
      state.stop = true;
      return this.parseSubscripts(this.finishNode(node, "BindExpression"), startLoc, noCalls);
    };
    _proto.parseCoverCallAndAsyncArrowHead = function parseCoverCallAndAsyncArrowHead(base, startLoc, state, optional) {
      var oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
      var refExpressionErrors = null;
      this.state.maybeInArrowParameters = true;
      this.next();
      var node = this.startNodeAt(startLoc);
      node.callee = base;
      var maybeAsyncArrow = state.maybeAsyncArrow,
        optionalChainMember = state.optionalChainMember;
      if (maybeAsyncArrow) {
        this.expressionScope.enter(newAsyncArrowScope());
        refExpressionErrors = new ExpressionErrors();
      }
      if (optionalChainMember) {
        node.optional = optional;
      }
      if (optional) {
        node.arguments = this.parseCallExpressionArguments();
      } else {
        node.arguments = this.parseCallExpressionArguments(base.type !== "Super", node, refExpressionErrors);
      }
      var finishedNode = this.finishCallExpression(node, optionalChainMember);
      if (maybeAsyncArrow && this.shouldParseAsyncArrow() && !optional) {
        state.stop = true;
        this.checkDestructuringPrivate(refExpressionErrors);
        this.expressionScope.validateAsPattern();
        this.expressionScope.exit();
        finishedNode = this.parseAsyncArrowFromCallExpression(this.startNodeAt(startLoc), finishedNode);
      } else {
        if (maybeAsyncArrow) {
          this.checkExpressionErrors(refExpressionErrors, true);
          this.expressionScope.exit();
        }
        this.toReferencedArguments(finishedNode);
      }
      this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
      return finishedNode;
    };
    _proto.toReferencedArguments = function toReferencedArguments(node, isParenthesizedExpr) {
      this.toReferencedListDeep(node.arguments, isParenthesizedExpr);
    };
    _proto.parseTaggedTemplateExpression = function parseTaggedTemplateExpression(base, startLoc, state) {
      var node = this.startNodeAt(startLoc);
      node.tag = base;
      node.quasi = this.parseTemplate(true);
      if (state.optionalChainMember) {
        this.raise(Errors.OptionalChainingNoTemplate, startLoc);
      }
      return this.finishNode(node, "TaggedTemplateExpression");
    };
    _proto.atPossibleAsyncArrow = function atPossibleAsyncArrow(base) {
      return base.type === "Identifier" && base.name === "async" && this.state.lastTokEndLoc.index === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && this.offsetToSourcePos(base.start) === this.state.potentialArrowAt;
    };
    _proto.finishCallExpression = function finishCallExpression(node, optional) {
      if (node.callee.type === "Import") {
        if (node.arguments.length === 0 || node.arguments.length > 2) {
          this.raise(Errors.ImportCallArity, node);
        } else {
          for (var _i2 = 0, _node$arguments2 = node.arguments; _i2 < _node$arguments2.length; _i2++) {
            var arg = _node$arguments2[_i2];
            if (arg.type === "SpreadElement") {
              this.raise(Errors.ImportCallSpreadArgument, arg);
            }
          }
        }
      }
      return this.finishNode(node, optional ? "OptionalCallExpression" : "CallExpression");
    };
    _proto.parseCallExpressionArguments = function parseCallExpressionArguments(allowPlaceholder, nodeForExtra, refExpressionErrors) {
      var elts = [];
      var first = true;
      var oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = false;
      while (!this.eat(11)) {
        if (first) {
          first = false;
        } else {
          this.expect(12);
          if (this.match(11)) {
            if (nodeForExtra) {
              this.addTrailingCommaExtraToNode(nodeForExtra);
            }
            this.next();
            break;
          }
        }
        elts.push(this.parseExprListItem(11, false, refExpressionErrors, allowPlaceholder));
      }
      this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
      return elts;
    };
    _proto.shouldParseAsyncArrow = function shouldParseAsyncArrow() {
      return this.match(19) && !this.canInsertSemicolon();
    };
    _proto.parseAsyncArrowFromCallExpression = function parseAsyncArrowFromCallExpression(node, call) {
      var _call$extra;
      this.resetPreviousNodeTrailingComments(call);
      this.expect(19);
      this.parseArrowExpression(node, call.arguments, true, (_call$extra = call.extra) == null ? void 0 : _call$extra.trailingCommaLoc);
      if (call.innerComments) {
        setInnerComments(node, call.innerComments);
      }
      if (call.callee.trailingComments) {
        setInnerComments(node, call.callee.trailingComments);
      }
      return node;
    };
    _proto.parseNoCallExpr = function parseNoCallExpr() {
      var startLoc = this.state.startLoc;
      return this.parseSubscripts(this.parseExprAtom(), startLoc, true);
    };
    _proto.parseExprAtom = function parseExprAtom(refExpressionErrors) {
      var node;
      var decorators = null;
      var type = this.state.type;
      switch (type) {
        case 79:
          return this.parseSuper();
        case 83:
          node = this.startNode();
          this.next();
          if (this.match(16)) {
            return this.parseImportMetaPropertyOrPhaseCall(node);
          }
          if (this.match(10)) {
            if (this.optionFlags & OptionFlags.CreateImportExpressions) {
              return this.parseImportCall(node);
            } else {
              return this.finishNode(node, "Import");
            }
          } else {
            this.raise(Errors.UnsupportedImport, this.state.lastTokStartLoc);
            return this.finishNode(node, "Import");
          }
        case 78:
          node = this.startNode();
          this.next();
          return this.finishNode(node, "ThisExpression");
        case 90:
          {
            return this.parseDo(this.startNode(), false);
          }
        case 56:
        case 31:
          {
            this.readRegexp();
            return this.parseRegExpLiteral(this.state.value);
          }
        case 135:
          return this.parseNumericLiteral(this.state.value);
        case 136:
          return this.parseBigIntLiteral(this.state.value);
        case 134:
          return this.parseStringLiteral(this.state.value);
        case 84:
          return this.parseNullLiteral();
        case 85:
          return this.parseBooleanLiteral(true);
        case 86:
          return this.parseBooleanLiteral(false);
        case 10:
          {
            var canBeArrow = this.state.potentialArrowAt === this.state.start;
            return this.parseParenAndDistinguishExpression(canBeArrow);
          }
        case 0:
          {
            return this.parseArrayLike(3, true, false, refExpressionErrors);
          }
        case 5:
          {
            return this.parseObjectLike(8, false, false, refExpressionErrors);
          }
        case 68:
          return this.parseFunctionOrFunctionSent();
        case 26:
          decorators = this.parseDecorators();
        case 80:
          return this.parseClass(this.maybeTakeDecorators(decorators, this.startNode()), false);
        case 77:
          return this.parseNewOrNewTarget();
        case 25:
        case 24:
          return this.parseTemplate(false);
        case 15:
          {
            node = this.startNode();
            this.next();
            node.object = null;
            var callee = node.callee = this.parseNoCallExpr();
            if (callee.type === "MemberExpression") {
              return this.finishNode(node, "BindExpression");
            } else {
              throw this.raise(Errors.UnsupportedBind, callee);
            }
          }
        case 139:
          {
            this.raise(Errors.PrivateInExpectedIn, this.state.startLoc, {
              identifierName: this.state.value
            });
            return this.parsePrivateName();
          }
        case 33:
          {
            return this.parseTopicReferenceThenEqualsSign(54, "%");
          }
        case 32:
          {
            return this.parseTopicReferenceThenEqualsSign(44, "^");
          }
        case 37:
        case 38:
          {
            return this.parseTopicReference("hack");
          }
        case 44:
        case 54:
        case 27:
          {
            var pipeProposal = this.getPluginOption("pipelineOperator", "proposal");
            if (pipeProposal) {
              return this.parseTopicReference(pipeProposal);
            }
            this.unexpected();
            break;
          }
        case 47:
          {
            var lookaheadCh = this.input.codePointAt(this.nextTokenStart());
            if (isIdentifierStart(lookaheadCh) || lookaheadCh === 62) {
              this.expectOnePlugin(["jsx", "flow", "typescript"]);
            } else {
              this.unexpected();
            }
            break;
          }
        default:
          {
            if (type === 137) {
              return this.parseDecimalLiteral(this.state.value);
            } else if (type === 2 || type === 1) {
              return this.parseArrayLike(this.state.type === 2 ? 4 : 3, false, true);
            } else if (type === 6 || type === 7) {
              return this.parseObjectLike(this.state.type === 6 ? 9 : 8, false, true);
            }
          }
          if (tokenIsIdentifier(type)) {
            if (this.isContextual(127) && this.lookaheadInLineCharCode() === 123) {
              return this.parseModuleExpression();
            }
            var _canBeArrow = this.state.potentialArrowAt === this.state.start;
            var containsEsc = this.state.containsEsc;
            var id = this.parseIdentifier();
            if (!containsEsc && id.name === "async" && !this.canInsertSemicolon()) {
              var _type2 = this.state.type;
              if (_type2 === 68) {
                this.resetPreviousNodeTrailingComments(id);
                this.next();
                return this.parseAsyncFunctionExpression(this.startNodeAtNode(id));
              } else if (tokenIsIdentifier(_type2)) {
                if (this.lookaheadCharCode() === 61) {
                  return this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(id));
                } else {
                  return id;
                }
              } else if (_type2 === 90) {
                this.resetPreviousNodeTrailingComments(id);
                return this.parseDo(this.startNodeAtNode(id), true);
              }
            }
            if (_canBeArrow && this.match(19) && !this.canInsertSemicolon()) {
              this.next();
              return this.parseArrowExpression(this.startNodeAtNode(id), [id], false);
            }
            return id;
          } else {
            this.unexpected();
          }
      }
    };
    _proto.parseTopicReferenceThenEqualsSign = function parseTopicReferenceThenEqualsSign(topicTokenType, topicTokenValue) {
      var pipeProposal = this.getPluginOption("pipelineOperator", "proposal");
      if (pipeProposal) {
        this.state.type = topicTokenType;
        this.state.value = topicTokenValue;
        this.state.pos--;
        this.state.end--;
        this.state.endLoc = createPositionWithColumnOffset(this.state.endLoc, -1);
        return this.parseTopicReference(pipeProposal);
      } else {
        this.unexpected();
      }
    };
    _proto.parseTopicReference = function parseTopicReference(pipeProposal) {
      var node = this.startNode();
      var startLoc = this.state.startLoc;
      var tokenType = this.state.type;
      this.next();
      return this.finishTopicReference(node, startLoc, pipeProposal, tokenType);
    };
    _proto.finishTopicReference = function finishTopicReference(node, startLoc, pipeProposal, tokenType) {
      if (this.testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType)) {
        if (pipeProposal === "hack") {
          if (!this.topicReferenceIsAllowedInCurrentContext()) {
            this.raise(Errors.PipeTopicUnbound, startLoc);
          }
          this.registerTopicReference();
          return this.finishNode(node, "TopicReference");
        } else {
          if (!this.topicReferenceIsAllowedInCurrentContext()) {
            this.raise(Errors.PrimaryTopicNotAllowed, startLoc);
          }
          this.registerTopicReference();
          return this.finishNode(node, "PipelinePrimaryTopicReference");
        }
      } else {
        throw this.raise(Errors.PipeTopicUnconfiguredToken, startLoc, {
          token: tokenLabelName(tokenType)
        });
      }
    };
    _proto.testTopicReferenceConfiguration = function testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType) {
      switch (pipeProposal) {
        case "hack":
          {
            return this.hasPlugin(["pipelineOperator", {
              topicToken: tokenLabelName(tokenType)
            }]);
          }
        case "smart":
          return tokenType === 27;
        default:
          throw this.raise(Errors.PipeTopicRequiresHackPipes, startLoc);
      }
    };
    _proto.parseAsyncArrowUnaryFunction = function parseAsyncArrowUnaryFunction(node) {
      this.prodParam.enter(functionFlags(true, this.prodParam.hasYield));
      var params = [this.parseIdentifier()];
      this.prodParam.exit();
      if (this.hasPrecedingLineBreak()) {
        this.raise(Errors.LineTerminatorBeforeArrow, this.state.curPosition());
      }
      this.expect(19);
      return this.parseArrowExpression(node, params, true);
    };
    _proto.parseDo = function parseDo(node, isAsync) {
      this.expectPlugin("doExpressions");
      if (isAsync) {
        this.expectPlugin("asyncDoExpressions");
      }
      node.async = isAsync;
      this.next();
      var oldLabels = this.state.labels;
      this.state.labels = [];
      if (isAsync) {
        this.prodParam.enter(ParamKind.PARAM_AWAIT);
        node.body = this.parseBlock();
        this.prodParam.exit();
      } else {
        node.body = this.parseBlock();
      }
      this.state.labels = oldLabels;
      return this.finishNode(node, "DoExpression");
    };
    _proto.parseSuper = function parseSuper() {
      var node = this.startNode();
      this.next();
      if (this.match(10) && !this.scope.allowDirectSuper && !(this.optionFlags & OptionFlags.AllowSuperOutsideMethod)) {
        this.raise(Errors.SuperNotAllowed, node);
      } else if (!this.scope.allowSuper && !(this.optionFlags & OptionFlags.AllowSuperOutsideMethod)) {
        this.raise(Errors.UnexpectedSuper, node);
      }
      if (!this.match(10) && !this.match(0) && !this.match(16)) {
        this.raise(Errors.UnsupportedSuper, node);
      }
      return this.finishNode(node, "Super");
    };
    _proto.parsePrivateName = function parsePrivateName() {
      var node = this.startNode();
      var id = this.startNodeAt(createPositionWithColumnOffset(this.state.startLoc, 1));
      var name = this.state.value;
      this.next();
      node.id = this.createIdentifier(id, name);
      return this.finishNode(node, "PrivateName");
    };
    _proto.parseFunctionOrFunctionSent = function parseFunctionOrFunctionSent() {
      var node = this.startNode();
      this.next();
      if (this.prodParam.hasYield && this.match(16)) {
        var meta = this.createIdentifier(this.startNodeAtNode(node), "function");
        this.next();
        if (this.match(103)) {
          this.expectPlugin("functionSent");
        } else if (!this.hasPlugin("functionSent")) {
          this.unexpected();
        }
        return this.parseMetaProperty(node, meta, "sent");
      }
      return this.parseFunction(node);
    };
    _proto.parseMetaProperty = function parseMetaProperty(node, meta, propertyName) {
      node.meta = meta;
      var containsEsc = this.state.containsEsc;
      node.property = this.parseIdentifier(true);
      if (node.property.name !== propertyName || containsEsc) {
        this.raise(Errors.UnsupportedMetaProperty, node.property, {
          target: meta.name,
          onlyValidPropertyName: propertyName
        });
      }
      return this.finishNode(node, "MetaProperty");
    };
    _proto.parseImportMetaPropertyOrPhaseCall = function parseImportMetaPropertyOrPhaseCall(node) {
      this.next();
      if (this.isContextual(105) || this.isContextual(97)) {
        var isSource = this.isContextual(105);
        this.expectPlugin(isSource ? "sourcePhaseImports" : "deferredImportEvaluation");
        this.next();
        node.phase = isSource ? "source" : "defer";
        return this.parseImportCall(node);
      } else {
        var id = this.createIdentifierAt(this.startNodeAtNode(node), "import", this.state.lastTokStartLoc);
        if (this.isContextual(101)) {
          if (!this.inModule) {
            this.raise(Errors.ImportMetaOutsideModule, id);
          }
          this.sawUnambiguousESM = true;
        }
        return this.parseMetaProperty(node, id, "meta");
      }
    };
    _proto.parseLiteralAtNode = function parseLiteralAtNode(value, type, node) {
      this.addExtra(node, "rawValue", value);
      this.addExtra(node, "raw", this.input.slice(this.offsetToSourcePos(node.start), this.state.end));
      node.value = value;
      this.next();
      return this.finishNode(node, type);
    };
    _proto.parseLiteral = function parseLiteral(value, type) {
      var node = this.startNode();
      return this.parseLiteralAtNode(value, type, node);
    };
    _proto.parseStringLiteral = function parseStringLiteral(value) {
      return this.parseLiteral(value, "StringLiteral");
    };
    _proto.parseNumericLiteral = function parseNumericLiteral(value) {
      return this.parseLiteral(value, "NumericLiteral");
    };
    _proto.parseBigIntLiteral = function parseBigIntLiteral(value) {
      {
        return this.parseLiteral(value, "BigIntLiteral");
      }
    };
    _proto.parseDecimalLiteral = function parseDecimalLiteral(value) {
      return this.parseLiteral(value, "DecimalLiteral");
    };
    _proto.parseRegExpLiteral = function parseRegExpLiteral(value) {
      var node = this.startNode();
      this.addExtra(node, "raw", this.input.slice(this.offsetToSourcePos(node.start), this.state.end));
      node.pattern = value.pattern;
      node.flags = value.flags;
      this.next();
      return this.finishNode(node, "RegExpLiteral");
    };
    _proto.parseBooleanLiteral = function parseBooleanLiteral(value) {
      var node = this.startNode();
      node.value = value;
      this.next();
      return this.finishNode(node, "BooleanLiteral");
    };
    _proto.parseNullLiteral = function parseNullLiteral() {
      var node = this.startNode();
      this.next();
      return this.finishNode(node, "NullLiteral");
    };
    _proto.parseParenAndDistinguishExpression = function parseParenAndDistinguishExpression(canBeArrow) {
      var startLoc = this.state.startLoc;
      var val;
      this.next();
      this.expressionScope.enter(newArrowHeadScope());
      var oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
      var oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
      this.state.maybeInArrowParameters = true;
      this.state.inFSharpPipelineDirectBody = false;
      var innerStartLoc = this.state.startLoc;
      var exprList = [];
      var refExpressionErrors = new ExpressionErrors();
      var first = true;
      var spreadStartLoc;
      var optionalCommaStartLoc;
      while (!this.match(11)) {
        if (first) {
          first = false;
        } else {
          this.expect(12, refExpressionErrors.optionalParametersLoc === null ? null : refExpressionErrors.optionalParametersLoc);
          if (this.match(11)) {
            optionalCommaStartLoc = this.state.startLoc;
            break;
          }
        }
        if (this.match(21)) {
          var spreadNodeStartLoc = this.state.startLoc;
          spreadStartLoc = this.state.startLoc;
          exprList.push(this.parseParenItem(this.parseRestBinding(), spreadNodeStartLoc));
          if (!this.checkCommaAfterRest(41)) {
            break;
          }
        } else {
          exprList.push(this.parseMaybeAssignAllowInOrVoidPattern(11, refExpressionErrors, this.parseParenItem));
        }
      }
      var innerEndLoc = this.state.lastTokEndLoc;
      this.expect(11);
      this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
      this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
      var arrowNode = this.startNodeAt(startLoc);
      if (canBeArrow && this.shouldParseArrow(exprList) && (arrowNode = this.parseArrow(arrowNode))) {
        this.checkDestructuringPrivate(refExpressionErrors);
        this.expressionScope.validateAsPattern();
        this.expressionScope.exit();
        this.parseArrowExpression(arrowNode, exprList, false);
        return arrowNode;
      }
      this.expressionScope.exit();
      if (!exprList.length) {
        this.unexpected(this.state.lastTokStartLoc);
      }
      if (optionalCommaStartLoc) this.unexpected(optionalCommaStartLoc);
      if (spreadStartLoc) this.unexpected(spreadStartLoc);
      this.checkExpressionErrors(refExpressionErrors, true);
      this.toReferencedListDeep(exprList, true);
      if (exprList.length > 1) {
        val = this.startNodeAt(innerStartLoc);
        val.expressions = exprList;
        this.finishNode(val, "SequenceExpression");
        this.resetEndLocation(val, innerEndLoc);
      } else {
        val = exprList[0];
      }
      return this.wrapParenthesis(startLoc, val);
    };
    _proto.wrapParenthesis = function wrapParenthesis(startLoc, expression) {
      if (!(this.optionFlags & OptionFlags.CreateParenthesizedExpressions)) {
        this.addExtra(expression, "parenthesized", true);
        this.addExtra(expression, "parenStart", startLoc.index);
        this.takeSurroundingComments(expression, startLoc.index, this.state.lastTokEndLoc.index);
        return expression;
      }
      var parenExpression = this.startNodeAt(startLoc);
      parenExpression.expression = expression;
      return this.finishNode(parenExpression, "ParenthesizedExpression");
    };
    _proto.shouldParseArrow = function shouldParseArrow(params) {
      return !this.canInsertSemicolon();
    };
    _proto.parseArrow = function parseArrow(node) {
      if (this.eat(19)) {
        return node;
      }
    };
    _proto.parseParenItem = function parseParenItem(node, startLoc) {
      return node;
    };
    _proto.parseNewOrNewTarget = function parseNewOrNewTarget() {
      var node = this.startNode();
      this.next();
      if (this.match(16)) {
        var meta = this.createIdentifier(this.startNodeAtNode(node), "new");
        this.next();
        var metaProp = this.parseMetaProperty(node, meta, "target");
        if (!this.scope.allowNewTarget) {
          this.raise(Errors.UnexpectedNewTarget, metaProp);
        }
        return metaProp;
      }
      return this.parseNew(node);
    };
    _proto.parseNew = function parseNew(node) {
      this.parseNewCallee(node);
      if (this.eat(10)) {
        var args = this.parseExprList(11);
        this.toReferencedList(args);
        node.arguments = args;
      } else {
        node.arguments = [];
      }
      return this.finishNode(node, "NewExpression");
    };
    _proto.parseNewCallee = function parseNewCallee(node) {
      var isImport = this.match(83);
      var callee = this.parseNoCallExpr();
      node.callee = callee;
      if (isImport && (callee.type === "Import" || callee.type === "ImportExpression")) {
        this.raise(Errors.ImportCallNotNewExpression, callee);
      }
    };
    _proto.parseTemplateElement = function parseTemplateElement(isTagged) {
      var _this$state = this.state,
        start = _this$state.start,
        startLoc = _this$state.startLoc,
        end = _this$state.end,
        value = _this$state.value;
      var elemStart = start + 1;
      var elem = this.startNodeAt(createPositionWithColumnOffset(startLoc, 1));
      if (value === null) {
        if (!isTagged) {
          this.raise(Errors.InvalidEscapeSequenceTemplate, createPositionWithColumnOffset(this.state.firstInvalidTemplateEscapePos, 1));
        }
      }
      var isTail = this.match(24);
      var endOffset = isTail ? -1 : -2;
      var elemEnd = end + endOffset;
      elem.value = {
        raw: this.input.slice(elemStart, elemEnd).replace(/\r\n?/g, "\n"),
        cooked: value === null ? null : value.slice(1, endOffset)
      };
      elem.tail = isTail;
      this.next();
      var finishedNode = this.finishNode(elem, "TemplateElement");
      this.resetEndLocation(finishedNode, createPositionWithColumnOffset(this.state.lastTokEndLoc, endOffset));
      return finishedNode;
    };
    _proto.parseTemplate = function parseTemplate(isTagged) {
      var node = this.startNode();
      var curElt = this.parseTemplateElement(isTagged);
      var quasis = [curElt];
      var substitutions = [];
      while (!curElt.tail) {
        substitutions.push(this.parseTemplateSubstitution());
        this.readTemplateContinuation();
        quasis.push(curElt = this.parseTemplateElement(isTagged));
      }
      node.expressions = substitutions;
      node.quasis = quasis;
      return this.finishNode(node, "TemplateLiteral");
    };
    _proto.parseTemplateSubstitution = function parseTemplateSubstitution() {
      return this.parseExpression();
    };
    _proto.parseObjectLike = function parseObjectLike(close, isPattern, isRecord, refExpressionErrors) {
      if (isRecord) {
        this.expectPlugin("recordAndTuple");
      }
      var oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = false;
      var sawProto = false;
      var first = true;
      var node = this.startNode();
      node.properties = [];
      this.next();
      while (!this.match(close)) {
        if (first) {
          first = false;
        } else {
          this.expect(12);
          if (this.match(close)) {
            this.addTrailingCommaExtraToNode(node);
            break;
          }
        }
        var prop = void 0;
        if (isPattern) {
          prop = this.parseBindingProperty();
        } else {
          prop = this.parsePropertyDefinition(refExpressionErrors);
          sawProto = this.checkProto(prop, isRecord, sawProto, refExpressionErrors);
        }
        if (isRecord && !this.isObjectProperty(prop) && prop.type !== "SpreadElement") {
          this.raise(Errors.InvalidRecordProperty, prop);
        }
        {
          if (prop.shorthand) {
            this.addExtra(prop, "shorthand", true);
          }
        }
        node.properties.push(prop);
      }
      this.next();
      this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
      var type = "ObjectExpression";
      if (isPattern) {
        type = "ObjectPattern";
      } else if (isRecord) {
        type = "RecordExpression";
      }
      return this.finishNode(node, type);
    };
    _proto.addTrailingCommaExtraToNode = function addTrailingCommaExtraToNode(node) {
      this.addExtra(node, "trailingComma", this.state.lastTokStartLoc.index);
      this.addExtra(node, "trailingCommaLoc", this.state.lastTokStartLoc, false);
    };
    _proto.maybeAsyncOrAccessorProp = function maybeAsyncOrAccessorProp(prop) {
      return !prop.computed && prop.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(0) || this.match(55));
    };
    _proto.parsePropertyDefinition = function parsePropertyDefinition(refExpressionErrors) {
      var decorators = [];
      if (this.match(26)) {
        if (this.hasPlugin("decorators")) {
          this.raise(Errors.UnsupportedPropertyDecorator, this.state.startLoc);
        }
        while (this.match(26)) {
          decorators.push(this.parseDecorator());
        }
      }
      var prop = this.startNode();
      var isAsync = false;
      var isAccessor = false;
      var startLoc;
      if (this.match(21)) {
        if (decorators.length) this.unexpected();
        return this.parseSpread();
      }
      if (decorators.length) {
        prop.decorators = decorators;
        decorators = [];
      }
      prop.method = false;
      if (refExpressionErrors) {
        startLoc = this.state.startLoc;
      }
      var isGenerator = this.eat(55);
      this.parsePropertyNamePrefixOperator(prop);
      var containsEsc = this.state.containsEsc;
      this.parsePropertyName(prop, refExpressionErrors);
      if (!isGenerator && !containsEsc && this.maybeAsyncOrAccessorProp(prop)) {
        var key = prop.key;
        var keyName = key.name;
        if (keyName === "async" && !this.hasPrecedingLineBreak()) {
          isAsync = true;
          this.resetPreviousNodeTrailingComments(key);
          isGenerator = this.eat(55);
          this.parsePropertyName(prop);
        }
        if (keyName === "get" || keyName === "set") {
          isAccessor = true;
          this.resetPreviousNodeTrailingComments(key);
          prop.kind = keyName;
          if (this.match(55)) {
            isGenerator = true;
            this.raise(Errors.AccessorIsGenerator, this.state.curPosition(), {
              kind: keyName
            });
            this.next();
          }
          this.parsePropertyName(prop);
        }
      }
      return this.parseObjPropValue(prop, startLoc, isGenerator, isAsync, false, isAccessor, refExpressionErrors);
    };
    _proto.getGetterSetterExpectedParamCount = function getGetterSetterExpectedParamCount(method) {
      return method.kind === "get" ? 0 : 1;
    };
    _proto.getObjectOrClassMethodParams = function getObjectOrClassMethodParams(method) {
      return method.params;
    };
    _proto.checkGetterSetterParams = function checkGetterSetterParams(method) {
      var _params;
      var paramCount = this.getGetterSetterExpectedParamCount(method);
      var params = this.getObjectOrClassMethodParams(method);
      if (params.length !== paramCount) {
        this.raise(method.kind === "get" ? Errors.BadGetterArity : Errors.BadSetterArity, method);
      }
      if (method.kind === "set" && ((_params = params[params.length - 1]) == null ? void 0 : _params.type) === "RestElement") {
        this.raise(Errors.BadSetterRestParameter, method);
      }
    };
    _proto.parseObjectMethod = function parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {
      if (isAccessor) {
        var finishedProp = this.parseMethod(prop, isGenerator, false, false, false, "ObjectMethod");
        this.checkGetterSetterParams(finishedProp);
        return finishedProp;
      }
      if (isAsync || isGenerator || this.match(10)) {
        if (isPattern) this.unexpected();
        prop.kind = "method";
        prop.method = true;
        return this.parseMethod(prop, isGenerator, isAsync, false, false, "ObjectMethod");
      }
    };
    _proto.parseObjectProperty = function parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors) {
      prop.shorthand = false;
      if (this.eat(14)) {
        prop.value = isPattern ? this.parseMaybeDefault(this.state.startLoc) : this.parseMaybeAssignAllowInOrVoidPattern(8, refExpressionErrors);
        return this.finishObjectProperty(prop);
      }
      if (!prop.computed && prop.key.type === "Identifier") {
        this.checkReservedWord(prop.key.name, prop.key.loc.start, true, false);
        if (isPattern) {
          prop.value = this.parseMaybeDefault(startLoc, this.cloneIdentifier(prop.key));
        } else if (this.match(29)) {
          var shorthandAssignLoc = this.state.startLoc;
          if (refExpressionErrors != null) {
            if (refExpressionErrors.shorthandAssignLoc === null) {
              refExpressionErrors.shorthandAssignLoc = shorthandAssignLoc;
            }
          } else {
            this.raise(Errors.InvalidCoverInitializedName, shorthandAssignLoc);
          }
          prop.value = this.parseMaybeDefault(startLoc, this.cloneIdentifier(prop.key));
        } else {
          prop.value = this.cloneIdentifier(prop.key);
        }
        prop.shorthand = true;
        return this.finishObjectProperty(prop);
      }
    };
    _proto.finishObjectProperty = function finishObjectProperty(node) {
      return this.finishNode(node, "ObjectProperty");
    };
    _proto.parseObjPropValue = function parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
      var node = this.parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) || this.parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors);
      if (!node) this.unexpected();
      return node;
    };
    _proto.parsePropertyName = function parsePropertyName(prop, refExpressionErrors) {
      if (this.eat(0)) {
        prop.computed = true;
        prop.key = this.parseMaybeAssignAllowIn();
        this.expect(3);
      } else {
        var _this$state2 = this.state,
          type = _this$state2.type,
          value = _this$state2.value;
        var key;
        if (tokenIsKeywordOrIdentifier(type)) {
          key = this.parseIdentifier(true);
        } else {
          switch (type) {
            case 135:
              key = this.parseNumericLiteral(value);
              break;
            case 134:
              key = this.parseStringLiteral(value);
              break;
            case 136:
              key = this.parseBigIntLiteral(value);
              break;
            case 139:
              {
                var privateKeyLoc = this.state.startLoc;
                if (refExpressionErrors != null) {
                  if (refExpressionErrors.privateKeyLoc === null) {
                    refExpressionErrors.privateKeyLoc = privateKeyLoc;
                  }
                } else {
                  this.raise(Errors.UnexpectedPrivateField, privateKeyLoc);
                }
                key = this.parsePrivateName();
                break;
              }
            default:
              if (type === 137) {
                key = this.parseDecimalLiteral(value);
                break;
              }
              this.unexpected();
          }
        }
        prop.key = key;
        if (type !== 139) {
          prop.computed = false;
        }
      }
    };
    _proto.initFunction = function initFunction(node, isAsync) {
      node.id = null;
      node.generator = false;
      node.async = isAsync;
    };
    _proto.parseMethod = function parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope) {
      if (inClassScope === void 0) {
        inClassScope = false;
      }
      this.initFunction(node, isAsync);
      node.generator = isGenerator;
      this.scope.enter(ScopeFlag.FUNCTION | ScopeFlag.SUPER | (inClassScope ? ScopeFlag.CLASS : 0) | (allowDirectSuper ? ScopeFlag.DIRECT_SUPER : 0));
      this.prodParam.enter(functionFlags(isAsync, node.generator));
      this.parseFunctionParams(node, isConstructor);
      var finishedNode = this.parseFunctionBodyAndFinish(node, type, true);
      this.prodParam.exit();
      this.scope.exit();
      return finishedNode;
    };
    _proto.parseArrayLike = function parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
      if (isTuple) {
        this.expectPlugin("recordAndTuple");
      }
      var oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = false;
      var node = this.startNode();
      this.next();
      node.elements = this.parseExprList(close, !isTuple, refExpressionErrors, node);
      this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
      return this.finishNode(node, isTuple ? "TupleExpression" : "ArrayExpression");
    };
    _proto.parseArrowExpression = function parseArrowExpression(node, params, isAsync, trailingCommaLoc) {
      this.scope.enter(ScopeFlag.FUNCTION | ScopeFlag.ARROW);
      var flags = functionFlags(isAsync, false);
      if (!this.match(5) && this.prodParam.hasIn) {
        flags |= ParamKind.PARAM_IN;
      }
      this.prodParam.enter(flags);
      this.initFunction(node, isAsync);
      var oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
      if (params) {
        this.state.maybeInArrowParameters = true;
        this.setArrowFunctionParameters(node, params, trailingCommaLoc);
      }
      this.state.maybeInArrowParameters = false;
      this.parseFunctionBody(node, true);
      this.prodParam.exit();
      this.scope.exit();
      this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
      return this.finishNode(node, "ArrowFunctionExpression");
    };
    _proto.setArrowFunctionParameters = function setArrowFunctionParameters(node, params, trailingCommaLoc) {
      this.toAssignableList(params, trailingCommaLoc, false);
      node.params = params;
    };
    _proto.parseFunctionBodyAndFinish = function parseFunctionBodyAndFinish(node, type, isMethod) {
      if (isMethod === void 0) {
        isMethod = false;
      }
      this.parseFunctionBody(node, false, isMethod);
      return this.finishNode(node, type);
    };
    _proto.parseFunctionBody = function parseFunctionBody(node, allowExpression, isMethod) {
      var _this5 = this;
      if (isMethod === void 0) {
        isMethod = false;
      }
      var isExpression = allowExpression && !this.match(5);
      this.expressionScope.enter(newExpressionScope());
      if (isExpression) {
        node.body = this.parseMaybeAssign();
        this.checkParams(node, false, allowExpression, false);
      } else {
        var oldStrict = this.state.strict;
        var oldLabels = this.state.labels;
        this.state.labels = [];
        this.prodParam.enter(this.prodParam.currentFlags() | ParamKind.PARAM_RETURN);
        node.body = this.parseBlock(true, false, function (hasStrictModeDirective) {
          var nonSimple = !_this5.isSimpleParamList(node.params);
          if (hasStrictModeDirective && nonSimple) {
            _this5.raise(Errors.IllegalLanguageModeDirective, (node.kind === "method" || node.kind === "constructor") && !!node.key ? node.key.loc.end : node);
          }
          var strictModeChanged = !oldStrict && _this5.state.strict;
          _this5.checkParams(node, !_this5.state.strict && !allowExpression && !isMethod && !nonSimple, allowExpression, strictModeChanged);
          if (_this5.state.strict && node.id) {
            _this5.checkIdentifier(node.id, BindingFlag.TYPE_OUTSIDE, strictModeChanged);
          }
        });
        this.prodParam.exit();
        this.state.labels = oldLabels;
      }
      this.expressionScope.exit();
    };
    _proto.isSimpleParameter = function isSimpleParameter(node) {
      return node.type === "Identifier";
    };
    _proto.isSimpleParamList = function isSimpleParamList(params) {
      for (var i = 0, len = params.length; i < len; i++) {
        if (!this.isSimpleParameter(params[i])) return false;
      }
      return true;
    };
    _proto.checkParams = function checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged) {
      if (strictModeChanged === void 0) {
        strictModeChanged = true;
      }
      var checkClashes = !allowDuplicates && new Set();
      var formalParameters = {
        type: "FormalParameters"
      };
      for (var _i4 = 0, _node$params2 = node.params; _i4 < _node$params2.length; _i4++) {
        var param = _node$params2[_i4];
        this.checkLVal(param, formalParameters, BindingFlag.TYPE_VAR, checkClashes, strictModeChanged);
      }
    };
    _proto.parseExprList = function parseExprList(close, allowEmpty, refExpressionErrors, nodeForExtra) {
      var elts = [];
      var first = true;
      while (!this.eat(close)) {
        if (first) {
          first = false;
        } else {
          this.expect(12);
          if (this.match(close)) {
            if (nodeForExtra) {
              this.addTrailingCommaExtraToNode(nodeForExtra);
            }
            this.next();
            break;
          }
        }
        elts.push(this.parseExprListItem(close, allowEmpty, refExpressionErrors));
      }
      return elts;
    };
    _proto.parseExprListItem = function parseExprListItem(close, allowEmpty, refExpressionErrors, allowPlaceholder) {
      var elt;
      if (this.match(12)) {
        if (!allowEmpty) {
          this.raise(Errors.UnexpectedToken, this.state.curPosition(), {
            unexpected: ","
          });
        }
        elt = null;
      } else if (this.match(21)) {
        var spreadNodeStartLoc = this.state.startLoc;
        elt = this.parseParenItem(this.parseSpread(refExpressionErrors), spreadNodeStartLoc);
      } else if (this.match(17)) {
        this.expectPlugin("partialApplication");
        if (!allowPlaceholder) {
          this.raise(Errors.UnexpectedArgumentPlaceholder, this.state.startLoc);
        }
        var _node6 = this.startNode();
        this.next();
        elt = this.finishNode(_node6, "ArgumentPlaceholder");
      } else {
        elt = this.parseMaybeAssignAllowInOrVoidPattern(close, refExpressionErrors, this.parseParenItem);
      }
      return elt;
    };
    _proto.parseIdentifier = function parseIdentifier(liberal) {
      var node = this.startNode();
      var name = this.parseIdentifierName(liberal);
      return this.createIdentifier(node, name);
    };
    _proto.createIdentifier = function createIdentifier(node, name) {
      node.name = name;
      node.loc.identifierName = name;
      return this.finishNode(node, "Identifier");
    };
    _proto.createIdentifierAt = function createIdentifierAt(node, name, endLoc) {
      node.name = name;
      node.loc.identifierName = name;
      return this.finishNodeAt(node, "Identifier", endLoc);
    };
    _proto.parseIdentifierName = function parseIdentifierName(liberal) {
      var name;
      var _this$state3 = this.state,
        startLoc = _this$state3.startLoc,
        type = _this$state3.type;
      if (tokenIsKeywordOrIdentifier(type)) {
        name = this.state.value;
      } else {
        this.unexpected();
      }
      var tokenIsKeyword = tokenKeywordOrIdentifierIsKeyword(type);
      if (liberal) {
        if (tokenIsKeyword) {
          this.replaceToken(132);
        }
      } else {
        this.checkReservedWord(name, startLoc, tokenIsKeyword, false);
      }
      this.next();
      return name;
    };
    _proto.checkReservedWord = function checkReservedWord(word, startLoc, checkKeywords, isBinding) {
      if (word.length > 10) {
        return;
      }
      if (!canBeReservedWord(word)) {
        return;
      }
      if (checkKeywords && isKeyword(word)) {
        this.raise(Errors.UnexpectedKeyword, startLoc, {
          keyword: word
        });
        return;
      }
      var reservedTest = !this.state.strict ? isReservedWord : isBinding ? isStrictBindReservedWord : isStrictReservedWord;
      if (reservedTest(word, this.inModule)) {
        this.raise(Errors.UnexpectedReservedWord, startLoc, {
          reservedWord: word
        });
        return;
      } else if (word === "yield") {
        if (this.prodParam.hasYield) {
          this.raise(Errors.YieldBindingIdentifier, startLoc);
          return;
        }
      } else if (word === "await") {
        if (this.prodParam.hasAwait) {
          this.raise(Errors.AwaitBindingIdentifier, startLoc);
          return;
        }
        if (this.scope.inStaticBlock) {
          this.raise(Errors.AwaitBindingIdentifierInStaticBlock, startLoc);
          return;
        }
        this.expressionScope.recordAsyncArrowParametersError(startLoc);
      } else if (word === "arguments") {
        if (this.scope.inClassAndNotInNonArrowFunction) {
          this.raise(Errors.ArgumentsInClass, startLoc);
          return;
        }
      }
    };
    _proto.recordAwaitIfAllowed = function recordAwaitIfAllowed() {
      var isAwaitAllowed = this.prodParam.hasAwait;
      if (isAwaitAllowed && !this.scope.inFunction) {
        this.state.hasTopLevelAwait = true;
      }
      return isAwaitAllowed;
    };
    _proto.parseAwait = function parseAwait(startLoc) {
      var node = this.startNodeAt(startLoc);
      this.expressionScope.recordParameterInitializerError(Errors.AwaitExpressionFormalParameter, node);
      if (this.eat(55)) {
        this.raise(Errors.ObsoleteAwaitStar, node);
      }
      if (!this.scope.inFunction && !(this.optionFlags & OptionFlags.AllowAwaitOutsideFunction)) {
        if (this.isAmbiguousPrefixOrIdentifier()) {
          this.ambiguousScriptDifferentAst = true;
        } else {
          this.sawUnambiguousESM = true;
        }
      }
      if (!this.state.soloAwait) {
        node.argument = this.parseMaybeUnary(null, true);
      }
      return this.finishNode(node, "AwaitExpression");
    };
    _proto.isAmbiguousPrefixOrIdentifier = function isAmbiguousPrefixOrIdentifier() {
      if (this.hasPrecedingLineBreak()) return true;
      var type = this.state.type;
      return (type === 53 || type === 10 || type === 0 || tokenIsTemplate(type) || type === 102 && !this.state.containsEsc || type === 138 || type === 56 || this.hasPlugin("v8intrinsic") && type === 54
      );
    };
    _proto.parseYield = function parseYield(startLoc) {
      var node = this.startNodeAt(startLoc);
      this.expressionScope.recordParameterInitializerError(Errors.YieldInParameter, node);
      var delegating = false;
      var argument = null;
      if (!this.hasPrecedingLineBreak()) {
        delegating = this.eat(55);
        switch (this.state.type) {
          case 13:
          case 140:
          case 8:
          case 11:
          case 3:
          case 9:
          case 14:
          case 12:
            if (!delegating) break;
          default:
            argument = this.parseMaybeAssign();
        }
      }
      node.delegate = delegating;
      node.argument = argument;
      return this.finishNode(node, "YieldExpression");
    };
    _proto.parseImportCall = function parseImportCall(node) {
      this.next();
      node.source = this.parseMaybeAssignAllowIn();
      node.options = null;
      if (this.eat(12)) {
        if (!this.match(11)) {
          node.options = this.parseMaybeAssignAllowIn();
          if (this.eat(12)) {
            this.addTrailingCommaExtraToNode(node.options);
            if (!this.match(11)) {
              do {
                this.parseMaybeAssignAllowIn();
              } while (this.eat(12) && !this.match(11));
              this.raise(Errors.ImportCallArity, node);
            }
          }
        } else {
          this.addTrailingCommaExtraToNode(node.source);
        }
      }
      this.expect(11);
      return this.finishNode(node, "ImportExpression");
    };
    _proto.checkPipelineAtInfixOperator = function checkPipelineAtInfixOperator(left, leftStartLoc) {
      if (this.hasPlugin(["pipelineOperator", {
        proposal: "smart"
      }])) {
        if (left.type === "SequenceExpression") {
          this.raise(Errors.PipelineHeadSequenceExpression, leftStartLoc);
        }
      }
    };
    _proto.parseSmartPipelineBodyInStyle = function parseSmartPipelineBodyInStyle(childExpr, startLoc) {
      if (this.isSimpleReference(childExpr)) {
        var bodyNode = this.startNodeAt(startLoc);
        bodyNode.callee = childExpr;
        return this.finishNode(bodyNode, "PipelineBareFunction");
      } else {
        var _bodyNode = this.startNodeAt(startLoc);
        this.checkSmartPipeTopicBodyEarlyErrors(startLoc);
        _bodyNode.expression = childExpr;
        return this.finishNode(_bodyNode, "PipelineTopicExpression");
      }
    };
    _proto.isSimpleReference = function isSimpleReference(expression) {
      switch (expression.type) {
        case "MemberExpression":
          return !expression.computed && this.isSimpleReference(expression.object);
        case "Identifier":
          return true;
        default:
          return false;
      }
    };
    _proto.checkSmartPipeTopicBodyEarlyErrors = function checkSmartPipeTopicBodyEarlyErrors(startLoc) {
      if (this.match(19)) {
        throw this.raise(Errors.PipelineBodyNoArrow, this.state.startLoc);
      }
      if (!this.topicReferenceWasUsedInCurrentContext()) {
        this.raise(Errors.PipelineTopicUnused, startLoc);
      }
    };
    _proto.withTopicBindingContext = function withTopicBindingContext(callback) {
      var outerContextTopicState = this.state.topicContext;
      this.state.topicContext = {
        maxNumOfResolvableTopics: 1,
        maxTopicIndex: null
      };
      try {
        return callback();
      } finally {
        this.state.topicContext = outerContextTopicState;
      }
    };
    _proto.withSmartMixTopicForbiddingContext = function withSmartMixTopicForbiddingContext(callback) {
      if (this.hasPlugin(["pipelineOperator", {
        proposal: "smart"
      }])) {
        var outerContextTopicState = this.state.topicContext;
        this.state.topicContext = {
          maxNumOfResolvableTopics: 0,
          maxTopicIndex: null
        };
        try {
          return callback();
        } finally {
          this.state.topicContext = outerContextTopicState;
        }
      } else {
        return callback();
      }
    };
    _proto.withSoloAwaitPermittingContext = function withSoloAwaitPermittingContext(callback) {
      var outerContextSoloAwaitState = this.state.soloAwait;
      this.state.soloAwait = true;
      try {
        return callback();
      } finally {
        this.state.soloAwait = outerContextSoloAwaitState;
      }
    };
    _proto.allowInAnd = function allowInAnd(callback) {
      var flags = this.prodParam.currentFlags();
      var prodParamToSet = ParamKind.PARAM_IN & ~flags;
      if (prodParamToSet) {
        this.prodParam.enter(flags | ParamKind.PARAM_IN);
        try {
          return callback();
        } finally {
          this.prodParam.exit();
        }
      }
      return callback();
    };
    _proto.disallowInAnd = function disallowInAnd(callback) {
      var flags = this.prodParam.currentFlags();
      var prodParamToClear = ParamKind.PARAM_IN & flags;
      if (prodParamToClear) {
        this.prodParam.enter(flags & ~ParamKind.PARAM_IN);
        try {
          return callback();
        } finally {
          this.prodParam.exit();
        }
      }
      return callback();
    };
    _proto.registerTopicReference = function registerTopicReference() {
      this.state.topicContext.maxTopicIndex = 0;
    };
    _proto.topicReferenceIsAllowedInCurrentContext = function topicReferenceIsAllowedInCurrentContext() {
      return this.state.topicContext.maxNumOfResolvableTopics >= 1;
    };
    _proto.topicReferenceWasUsedInCurrentContext = function topicReferenceWasUsedInCurrentContext() {
      return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
    };
    _proto.parseFSharpPipelineBody = function parseFSharpPipelineBody(prec) {
      var startLoc = this.state.startLoc;
      this.state.potentialArrowAt = this.state.start;
      var oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = true;
      var ret = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startLoc, prec);
      this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
      return ret;
    };
    _proto.parseModuleExpression = function parseModuleExpression() {
      this.expectPlugin("moduleBlocks");
      var node = this.startNode();
      this.next();
      if (!this.match(5)) {
        this.unexpected(null, 5);
      }
      var program = this.startNodeAt(this.state.endLoc);
      this.next();
      var revertScopes = this.initializeScopes(true);
      this.enterInitialScopes();
      try {
        node.body = this.parseProgram(program, 8, "module");
      } finally {
        revertScopes();
      }
      return this.finishNode(node, "ModuleExpression");
    };
    _proto.parseVoidPattern = function parseVoidPattern(refExpressionErrors) {
      this.expectPlugin("discardBinding");
      var node = this.startNode();
      if (refExpressionErrors != null) {
        refExpressionErrors.voidPatternLoc = this.state.startLoc;
      }
      this.next();
      return this.finishNode(node, "VoidPattern");
    };
    _proto.parseMaybeAssignAllowInOrVoidPattern = function parseMaybeAssignAllowInOrVoidPattern(close, refExpressionErrors, afterLeftParse) {
      if (refExpressionErrors != null && this.match(88)) {
        var nextCode = this.lookaheadCharCode();
        if (nextCode === 44 || nextCode === (close === 3 ? 93 : close === 8 ? 125 : 41) || nextCode === 61) {
          return this.parseMaybeDefault(this.state.startLoc, this.parseVoidPattern(refExpressionErrors));
        }
      }
      return this.parseMaybeAssignAllowIn(refExpressionErrors, afterLeftParse);
    };
    _proto.parsePropertyNamePrefixOperator = function parsePropertyNamePrefixOperator(prop) {};
    return _createClass(ExpressionParser);
  }(LValParser);

  var loopLabel = {
      kind: LoopLabelKind.Loop
    },
    switchLabel = {
      kind: LoopLabelKind.Switch
    };
  var ParseFunctionFlag = {
    Expression: 0,
    Declaration: 1,
    HangingDeclaration: 2,
    NullableId: 4,
    Async: 8
  };
  var ParseStatementFlag = {
    StatementOnly: 0,
    AllowImportExport: 1,
    AllowDeclaration: 2,
    AllowFunctionDeclaration: 4,
    AllowLabeledFunction: 8
  };
  var loneSurrogate = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/;
  var keywordRelationalOperator = new RegExp("in(?:stanceof)?", "y");
  function babel7CompatTokens(tokens, input, startIndex) {
    for (var i = 0; i < tokens.length; i++) {
      var token = tokens[i];
      var type = token.type;
      if (typeof type === "number") {
        {
          if (type === 139) {
            var loc = token.loc,
              start = token.start,
              value = token.value,
              end = token.end;
            var hashEndPos = start + 1;
            var hashEndLoc = createPositionWithColumnOffset(loc.start, 1);
            tokens.splice(i, 1, new Token({
              type: getExportedToken(27),
              value: "#",
              start: start,
              end: hashEndPos,
              startLoc: loc.start,
              endLoc: hashEndLoc
            }), new Token({
              type: getExportedToken(132),
              value: value,
              start: hashEndPos,
              end: end,
              startLoc: hashEndLoc,
              endLoc: loc.end
            }));
            i++;
            continue;
          }
          if (tokenIsTemplate(type)) {
            var _loc = token.loc,
              _start = token.start,
              _value = token.value,
              _end = token.end;
            var backquoteEnd = _start + 1;
            var backquoteEndLoc = createPositionWithColumnOffset(_loc.start, 1);
            var startToken = void 0;
            if (input.charCodeAt(_start - startIndex) === 96) {
              startToken = new Token({
                type: getExportedToken(22),
                value: "`",
                start: _start,
                end: backquoteEnd,
                startLoc: _loc.start,
                endLoc: backquoteEndLoc
              });
            } else {
              startToken = new Token({
                type: getExportedToken(8),
                value: "}",
                start: _start,
                end: backquoteEnd,
                startLoc: _loc.start,
                endLoc: backquoteEndLoc
              });
            }
            var templateValue = void 0,
              templateElementEnd = void 0,
              templateElementEndLoc = void 0,
              endToken = void 0;
            if (type === 24) {
              templateElementEnd = _end - 1;
              templateElementEndLoc = createPositionWithColumnOffset(_loc.end, -1);
              templateValue = _value === null ? null : _value.slice(1, -1);
              endToken = new Token({
                type: getExportedToken(22),
                value: "`",
                start: templateElementEnd,
                end: _end,
                startLoc: templateElementEndLoc,
                endLoc: _loc.end
              });
            } else {
              templateElementEnd = _end - 2;
              templateElementEndLoc = createPositionWithColumnOffset(_loc.end, -2);
              templateValue = _value === null ? null : _value.slice(1, -2);
              endToken = new Token({
                type: getExportedToken(23),
                value: "${",
                start: templateElementEnd,
                end: _end,
                startLoc: templateElementEndLoc,
                endLoc: _loc.end
              });
            }
            tokens.splice(i, 1, startToken, new Token({
              type: getExportedToken(20),
              value: templateValue,
              start: backquoteEnd,
              end: templateElementEnd,
              startLoc: backquoteEndLoc,
              endLoc: templateElementEndLoc
            }), endToken);
            i += 2;
            continue;
          }
        }
        token.type = getExportedToken(type);
      }
    }
    return tokens;
  }
  var StatementParser = function (_ExpressionParser) {
    function StatementParser() {
      return _ExpressionParser.apply(this, arguments) || this;
    }
    _inherits(StatementParser, _ExpressionParser);
    var _proto = StatementParser.prototype;
    _proto.parseTopLevel = function parseTopLevel(file, program) {
      file.program = this.parseProgram(program, 140, this.options.sourceType === "module" ? "module" : "script");
      file.comments = this.comments;
      if (this.optionFlags & OptionFlags.Tokens) {
        file.tokens = babel7CompatTokens(this.tokens, this.input, this.startIndex);
      }
      return this.finishNode(file, "File");
    };
    _proto.parseProgram = function parseProgram(program, end, sourceType) {
      program.sourceType = sourceType;
      program.interpreter = this.parseInterpreterDirective();
      this.parseBlockBody(program, true, true, end);
      if (this.inModule) {
        if (!(this.optionFlags & OptionFlags.AllowUndeclaredExports) && this.scope.undefinedExports.size > 0) {
          for (var _i2 = 0, _Array$from2 = Array.from(this.scope.undefinedExports); _i2 < _Array$from2.length; _i2++) {
            var _Array$from2$_i = _Array$from2[_i2],
              localName = _Array$from2$_i[0],
              at = _Array$from2$_i[1];
            this.raise(Errors.ModuleExportUndefined, at, {
              localName: localName
            });
          }
        }
        this.addExtra(program, "topLevelAwait", this.state.hasTopLevelAwait);
      }
      var finishedProgram;
      if (end === 140) {
        finishedProgram = this.finishNode(program, "Program");
      } else {
        finishedProgram = this.finishNodeAt(program, "Program", createPositionWithColumnOffset(this.state.startLoc, -1));
      }
      return finishedProgram;
    };
    _proto.stmtToDirective = function stmtToDirective(stmt) {
      var directive = this.castNodeTo(stmt, "Directive");
      var directiveLiteral = this.castNodeTo(stmt.expression, "DirectiveLiteral");
      var expressionValue = directiveLiteral.value;
      var raw = this.input.slice(this.offsetToSourcePos(directiveLiteral.start), this.offsetToSourcePos(directiveLiteral.end));
      var val = directiveLiteral.value = raw.slice(1, -1);
      this.addExtra(directiveLiteral, "raw", raw);
      this.addExtra(directiveLiteral, "rawValue", val);
      this.addExtra(directiveLiteral, "expressionValue", expressionValue);
      directive.value = directiveLiteral;
      delete stmt.expression;
      return directive;
    };
    _proto.parseInterpreterDirective = function parseInterpreterDirective() {
      if (!this.match(28)) {
        return null;
      }
      var node = this.startNode();
      node.value = this.state.value;
      this.next();
      return this.finishNode(node, "InterpreterDirective");
    };
    _proto.isLet = function isLet() {
      if (!this.isContextual(100)) {
        return false;
      }
      return this.hasFollowingBindingAtom();
    };
    _proto.isUsing = function isUsing() {
      if (!this.isContextual(107)) {
        return false;
      }
      var next = this.nextTokenInLineStart();
      var nextCh = this.codePointAtPos(next);
      return this.chStartsBindingIdentifier(nextCh, next);
    };
    _proto.isForUsing = function isForUsing() {
      if (!this.isContextual(107)) {
        return false;
      }
      var next = this.nextTokenInLineStart();
      var nextCh = this.codePointAtPos(next);
      if (this.isUnparsedContextual(next, "of")) {
        var nextCharAfterOf = this.lookaheadCharCodeSince(next + 2);
        if (nextCharAfterOf !== 61 && nextCharAfterOf !== 58 && nextCharAfterOf !== 59) {
          return false;
        }
      }
      if (this.chStartsBindingIdentifier(nextCh, next) || this.isUnparsedContextual(next, "void")) {
        return true;
      }
      return false;
    };
    _proto.isAwaitUsing = function isAwaitUsing() {
      if (!this.isContextual(96)) {
        return false;
      }
      var next = this.nextTokenInLineStart();
      if (this.isUnparsedContextual(next, "using")) {
        next = this.nextTokenInLineStartSince(next + 5);
        var nextCh = this.codePointAtPos(next);
        if (this.chStartsBindingIdentifier(nextCh, next)) {
          return true;
        }
      }
      return false;
    };
    _proto.chStartsBindingIdentifier = function chStartsBindingIdentifier(ch, pos) {
      if (isIdentifierStart(ch)) {
        keywordRelationalOperator.lastIndex = pos;
        if (keywordRelationalOperator.test(this.input)) {
          var endCh = this.codePointAtPos(keywordRelationalOperator.lastIndex);
          if (!isIdentifierChar(endCh) && endCh !== 92) {
            return false;
          }
        }
        return true;
      } else if (ch === 92) {
        return true;
      } else {
        return false;
      }
    };
    _proto.chStartsBindingPattern = function chStartsBindingPattern(ch) {
      return ch === 91 || ch === 123;
    };
    _proto.hasFollowingBindingAtom = function hasFollowingBindingAtom() {
      var next = this.nextTokenStart();
      var nextCh = this.codePointAtPos(next);
      return this.chStartsBindingPattern(nextCh) || this.chStartsBindingIdentifier(nextCh, next);
    };
    _proto.hasInLineFollowingBindingIdentifierOrBrace = function hasInLineFollowingBindingIdentifierOrBrace() {
      var next = this.nextTokenInLineStart();
      var nextCh = this.codePointAtPos(next);
      return nextCh === 123 || this.chStartsBindingIdentifier(nextCh, next);
    };
    _proto.allowsUsing = function allowsUsing() {
      return (this.scope.inModule || !this.scope.inTopLevel) && !this.scope.inBareCaseStatement;
    };
    _proto.parseModuleItem = function parseModuleItem() {
      return this.parseStatementLike(ParseStatementFlag.AllowImportExport | ParseStatementFlag.AllowDeclaration | ParseStatementFlag.AllowFunctionDeclaration | ParseStatementFlag.AllowLabeledFunction);
    };
    _proto.parseStatementListItem = function parseStatementListItem() {
      return this.parseStatementLike(ParseStatementFlag.AllowDeclaration | ParseStatementFlag.AllowFunctionDeclaration | (!this.options.annexB || this.state.strict ? 0 : ParseStatementFlag.AllowLabeledFunction));
    };
    _proto.parseStatementOrSloppyAnnexBFunctionDeclaration = function parseStatementOrSloppyAnnexBFunctionDeclaration(allowLabeledFunction) {
      if (allowLabeledFunction === void 0) {
        allowLabeledFunction = false;
      }
      var flags = ParseStatementFlag.StatementOnly;
      if (this.options.annexB && !this.state.strict) {
        flags |= ParseStatementFlag.AllowFunctionDeclaration;
        if (allowLabeledFunction) {
          flags |= ParseStatementFlag.AllowLabeledFunction;
        }
      }
      return this.parseStatementLike(flags);
    };
    _proto.parseStatement = function parseStatement() {
      return this.parseStatementLike(ParseStatementFlag.StatementOnly);
    };
    _proto.parseStatementLike = function parseStatementLike(flags) {
      var decorators = null;
      if (this.match(26)) {
        decorators = this.parseDecorators(true);
      }
      return this.parseStatementContent(flags, decorators);
    };
    _proto.parseStatementContent = function parseStatementContent(flags, decorators) {
      var startType = this.state.type;
      var node = this.startNode();
      var allowDeclaration = !!(flags & ParseStatementFlag.AllowDeclaration);
      var allowFunctionDeclaration = !!(flags & ParseStatementFlag.AllowFunctionDeclaration);
      var topLevel = flags & ParseStatementFlag.AllowImportExport;
      switch (startType) {
        case 60:
          return this.parseBreakContinueStatement(node, true);
        case 63:
          return this.parseBreakContinueStatement(node, false);
        case 64:
          return this.parseDebuggerStatement(node);
        case 90:
          return this.parseDoWhileStatement(node);
        case 91:
          return this.parseForStatement(node);
        case 68:
          if (this.lookaheadCharCode() === 46) break;
          if (!allowFunctionDeclaration) {
            this.raise(this.state.strict ? Errors.StrictFunction : this.options.annexB ? Errors.SloppyFunctionAnnexB : Errors.SloppyFunction, this.state.startLoc);
          }
          return this.parseFunctionStatement(node, false, !allowDeclaration && allowFunctionDeclaration);
        case 80:
          if (!allowDeclaration) this.unexpected();
          return this.parseClass(this.maybeTakeDecorators(decorators, node), true);
        case 69:
          return this.parseIfStatement(node);
        case 70:
          return this.parseReturnStatement(node);
        case 71:
          return this.parseSwitchStatement(node);
        case 72:
          return this.parseThrowStatement(node);
        case 73:
          return this.parseTryStatement(node);
        case 96:
          if (this.isAwaitUsing()) {
            if (!this.allowsUsing()) {
              this.raise(Errors.UnexpectedUsingDeclaration, node);
            } else if (!allowDeclaration) {
              this.raise(Errors.UnexpectedLexicalDeclaration, node);
            } else if (!this.recordAwaitIfAllowed()) {
              this.raise(Errors.AwaitUsingNotInAsyncContext, node);
            }
            this.next();
            return this.parseVarStatement(node, "await using");
          }
          break;
        case 107:
          if (this.state.containsEsc || !this.hasInLineFollowingBindingIdentifierOrBrace()) {
            break;
          }
          if (!this.allowsUsing()) {
            this.raise(Errors.UnexpectedUsingDeclaration, this.state.startLoc);
          } else if (!allowDeclaration) {
            this.raise(Errors.UnexpectedLexicalDeclaration, this.state.startLoc);
          }
          return this.parseVarStatement(node, "using");
        case 100:
          {
            if (this.state.containsEsc) {
              break;
            }
            var next = this.nextTokenStart();
            var nextCh = this.codePointAtPos(next);
            if (nextCh !== 91) {
              if (!allowDeclaration && this.hasFollowingLineBreak()) break;
              if (!this.chStartsBindingIdentifier(nextCh, next) && nextCh !== 123) {
                break;
              }
            }
          }
        case 75:
          {
            if (!allowDeclaration) {
              this.raise(Errors.UnexpectedLexicalDeclaration, this.state.startLoc);
            }
          }
        case 74:
          {
            var kind = this.state.value;
            return this.parseVarStatement(node, kind);
          }
        case 92:
          return this.parseWhileStatement(node);
        case 76:
          return this.parseWithStatement(node);
        case 5:
          return this.parseBlock();
        case 13:
          return this.parseEmptyStatement(node);
        case 83:
          {
            var nextTokenCharCode = this.lookaheadCharCode();
            if (nextTokenCharCode === 40 || nextTokenCharCode === 46) {
              break;
            }
          }
        case 82:
          {
            if (!(this.optionFlags & OptionFlags.AllowImportExportEverywhere) && !topLevel) {
              this.raise(Errors.UnexpectedImportExport, this.state.startLoc);
            }
            this.next();
            var result;
            if (startType === 83) {
              result = this.parseImport(node);
            } else {
              result = this.parseExport(node, decorators);
            }
            this.assertModuleNodeAllowed(result);
            return result;
          }
        default:
          {
            if (this.isAsyncFunction()) {
              if (!allowDeclaration) {
                this.raise(Errors.AsyncFunctionInSingleStatementContext, this.state.startLoc);
              }
              this.next();
              return this.parseFunctionStatement(node, true, !allowDeclaration && allowFunctionDeclaration);
            }
          }
      }
      var maybeName = this.state.value;
      var expr = this.parseExpression();
      if (tokenIsIdentifier(startType) && expr.type === "Identifier" && this.eat(14)) {
        return this.parseLabeledStatement(node, maybeName, expr, flags);
      } else {
        return this.parseExpressionStatement(node, expr, decorators);
      }
    };
    _proto.assertModuleNodeAllowed = function assertModuleNodeAllowed(node) {
      if (!(this.optionFlags & OptionFlags.AllowImportExportEverywhere) && !this.inModule) {
        this.raise(Errors.ImportOutsideModule, node);
      }
    };
    _proto.decoratorsEnabledBeforeExport = function decoratorsEnabledBeforeExport() {
      if (this.hasPlugin("decorators-legacy")) return true;
      return this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") !== false;
    };
    _proto.maybeTakeDecorators = function maybeTakeDecorators(maybeDecorators, classNode, exportNode) {
      if (maybeDecorators) {
        var _classNode$decorators;
        if ((_classNode$decorators = classNode.decorators) != null && _classNode$decorators.length) {
          var _classNode$decorators2;
          if (typeof this.getPluginOption("decorators", "decoratorsBeforeExport") !== "boolean") {
            this.raise(Errors.DecoratorsBeforeAfterExport, classNode.decorators[0]);
          }
          (_classNode$decorators2 = classNode.decorators).unshift.apply(_classNode$decorators2, maybeDecorators);
        } else {
          classNode.decorators = maybeDecorators;
        }
        this.resetStartLocationFromNode(classNode, maybeDecorators[0]);
        if (exportNode) this.resetStartLocationFromNode(exportNode, classNode);
      }
      return classNode;
    };
    _proto.canHaveLeadingDecorator = function canHaveLeadingDecorator() {
      return this.match(80);
    };
    _proto.parseDecorators = function parseDecorators(allowExport) {
      var decorators = [];
      do {
        decorators.push(this.parseDecorator());
      } while (this.match(26));
      if (this.match(82)) {
        if (!allowExport) {
          this.unexpected();
        }
        if (!this.decoratorsEnabledBeforeExport()) {
          this.raise(Errors.DecoratorExportClass, this.state.startLoc);
        }
      } else if (!this.canHaveLeadingDecorator()) {
        throw this.raise(Errors.UnexpectedLeadingDecorator, this.state.startLoc);
      }
      return decorators;
    };
    _proto.parseDecorator = function parseDecorator() {
      this.expectOnePlugin(["decorators", "decorators-legacy"]);
      var node = this.startNode();
      this.next();
      if (this.hasPlugin("decorators")) {
        var startLoc = this.state.startLoc;
        var expr;
        if (this.match(10)) {
          var _startLoc = this.state.startLoc;
          this.next();
          expr = this.parseExpression();
          this.expect(11);
          expr = this.wrapParenthesis(_startLoc, expr);
          var paramsStartLoc = this.state.startLoc;
          node.expression = this.parseMaybeDecoratorArguments(expr, _startLoc);
          if (this.getPluginOption("decorators", "allowCallParenthesized") === false && node.expression !== expr) {
            this.raise(Errors.DecoratorArgumentsOutsideParentheses, paramsStartLoc);
          }
        } else {
          expr = this.parseIdentifier(false);
          while (this.eat(16)) {
            var _node = this.startNodeAt(startLoc);
            _node.object = expr;
            if (this.match(139)) {
              this.classScope.usePrivateName(this.state.value, this.state.startLoc);
              _node.property = this.parsePrivateName();
            } else {
              _node.property = this.parseIdentifier(true);
            }
            _node.computed = false;
            expr = this.finishNode(_node, "MemberExpression");
          }
          node.expression = this.parseMaybeDecoratorArguments(expr, startLoc);
        }
      } else {
        node.expression = this.parseExprSubscripts();
      }
      return this.finishNode(node, "Decorator");
    };
    _proto.parseMaybeDecoratorArguments = function parseMaybeDecoratorArguments(expr, startLoc) {
      if (this.eat(10)) {
        var _node2 = this.startNodeAt(startLoc);
        _node2.callee = expr;
        _node2.arguments = this.parseCallExpressionArguments();
        this.toReferencedList(_node2.arguments);
        return this.finishNode(_node2, "CallExpression");
      }
      return expr;
    };
    _proto.parseBreakContinueStatement = function parseBreakContinueStatement(node, isBreak) {
      this.next();
      if (this.isLineTerminator()) {
        node.label = null;
      } else {
        node.label = this.parseIdentifier();
        this.semicolon();
      }
      this.verifyBreakContinue(node, isBreak);
      return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
    };
    _proto.verifyBreakContinue = function verifyBreakContinue(node, isBreak) {
      var i;
      for (i = 0; i < this.state.labels.length; ++i) {
        var lab = this.state.labels[i];
        if (node.label == null || lab.name === node.label.name) {
          if (lab.kind != null && (isBreak || lab.kind === LoopLabelKind.Loop)) {
            break;
          }
          if (node.label && isBreak) break;
        }
      }
      if (i === this.state.labels.length) {
        var type = isBreak ? "BreakStatement" : "ContinueStatement";
        this.raise(Errors.IllegalBreakContinue, node, {
          type: type
        });
      }
    };
    _proto.parseDebuggerStatement = function parseDebuggerStatement(node) {
      this.next();
      this.semicolon();
      return this.finishNode(node, "DebuggerStatement");
    };
    _proto.parseHeaderExpression = function parseHeaderExpression() {
      this.expect(10);
      var val = this.parseExpression();
      this.expect(11);
      return val;
    };
    _proto.parseDoWhileStatement = function parseDoWhileStatement(node) {
      var _this = this;
      this.next();
      this.state.labels.push(loopLabel);
      node.body = this.withSmartMixTopicForbiddingContext(function () {
        return (_this.parseStatement()
        );
      });
      this.state.labels.pop();
      this.expect(92);
      node.test = this.parseHeaderExpression();
      this.eat(13);
      return this.finishNode(node, "DoWhileStatement");
    };
    _proto.parseForStatement = function parseForStatement(node) {
      this.next();
      this.state.labels.push(loopLabel);
      var awaitAt = null;
      if (this.isContextual(96) && this.recordAwaitIfAllowed()) {
        awaitAt = this.state.startLoc;
        this.next();
      }
      this.scope.enter(ScopeFlag.OTHER);
      this.expect(10);
      if (this.match(13)) {
        if (awaitAt !== null) {
          this.unexpected(awaitAt);
        }
        return this.parseFor(node, null);
      }
      var startsWithLet = this.isContextual(100);
      {
        var startsWithAwaitUsing = this.isAwaitUsing();
        var starsWithUsingDeclaration = startsWithAwaitUsing || this.isForUsing();
        var isLetOrUsing = startsWithLet && this.hasFollowingBindingAtom() || starsWithUsingDeclaration;
        if (this.match(74) || this.match(75) || isLetOrUsing) {
          var initNode = this.startNode();
          var kind;
          if (startsWithAwaitUsing) {
            kind = "await using";
            if (!this.recordAwaitIfAllowed()) {
              this.raise(Errors.AwaitUsingNotInAsyncContext, this.state.startLoc);
            }
            this.next();
          } else {
            kind = this.state.value;
          }
          this.next();
          this.parseVar(initNode, true, kind);
          var _init = this.finishNode(initNode, "VariableDeclaration");
          var isForIn = this.match(58);
          if (isForIn && starsWithUsingDeclaration) {
            this.raise(Errors.ForInUsing, _init);
          }
          if ((isForIn || this.isContextual(102)) && _init.declarations.length === 1) {
            return this.parseForIn(node, _init, awaitAt);
          }
          if (awaitAt !== null) {
            this.unexpected(awaitAt);
          }
          return this.parseFor(node, _init);
        }
      }
      var startsWithAsync = this.isContextual(95);
      var refExpressionErrors = new ExpressionErrors();
      var init = this.parseExpression(true, refExpressionErrors);
      var isForOf = this.isContextual(102);
      if (isForOf) {
        if (startsWithLet) {
          this.raise(Errors.ForOfLet, init);
        }
        if (awaitAt === null && startsWithAsync && init.type === "Identifier") {
          this.raise(Errors.ForOfAsync, init);
        }
      }
      if (isForOf || this.match(58)) {
        this.checkDestructuringPrivate(refExpressionErrors);
        this.toAssignable(init, true);
        var type = isForOf ? "ForOfStatement" : "ForInStatement";
        this.checkLVal(init, {
          type: type
        });
        return this.parseForIn(node, init, awaitAt);
      } else {
        this.checkExpressionErrors(refExpressionErrors, true);
      }
      if (awaitAt !== null) {
        this.unexpected(awaitAt);
      }
      return this.parseFor(node, init);
    };
    _proto.parseFunctionStatement = function parseFunctionStatement(node, isAsync, isHangingDeclaration) {
      this.next();
      return this.parseFunction(node, ParseFunctionFlag.Declaration | (isHangingDeclaration ? ParseFunctionFlag.HangingDeclaration : 0) | (isAsync ? ParseFunctionFlag.Async : 0));
    };
    _proto.parseIfStatement = function parseIfStatement(node) {
      this.next();
      node.test = this.parseHeaderExpression();
      node.consequent = this.parseStatementOrSloppyAnnexBFunctionDeclaration();
      node.alternate = this.eat(66) ? this.parseStatementOrSloppyAnnexBFunctionDeclaration() : null;
      return this.finishNode(node, "IfStatement");
    };
    _proto.parseReturnStatement = function parseReturnStatement(node) {
      if (!this.prodParam.hasReturn) {
        this.raise(Errors.IllegalReturn, this.state.startLoc);
      }
      this.next();
      if (this.isLineTerminator()) {
        node.argument = null;
      } else {
        node.argument = this.parseExpression();
        this.semicolon();
      }
      return this.finishNode(node, "ReturnStatement");
    };
    _proto.parseSwitchStatement = function parseSwitchStatement(node) {
      this.next();
      node.discriminant = this.parseHeaderExpression();
      var cases = node.cases = [];
      this.expect(5);
      this.state.labels.push(switchLabel);
      this.scope.enter(ScopeFlag.SWITCH);
      var cur;
      for (var sawDefault; !this.match(8);) {
        if (this.match(61) || this.match(65)) {
          var isCase = this.match(61);
          if (cur) this.finishNode(cur, "SwitchCase");
          cases.push(cur = this.startNode());
          cur.consequent = [];
          this.next();
          if (isCase) {
            cur.test = this.parseExpression();
          } else {
            if (sawDefault) {
              this.raise(Errors.MultipleDefaultsInSwitch, this.state.lastTokStartLoc);
            }
            sawDefault = true;
            cur.test = null;
          }
          this.expect(14);
        } else {
          if (cur) {
            cur.consequent.push(this.parseStatementListItem());
          } else {
            this.unexpected();
          }
        }
      }
      this.scope.exit();
      if (cur) this.finishNode(cur, "SwitchCase");
      this.next();
      this.state.labels.pop();
      return this.finishNode(node, "SwitchStatement");
    };
    _proto.parseThrowStatement = function parseThrowStatement(node) {
      this.next();
      if (this.hasPrecedingLineBreak()) {
        this.raise(Errors.NewlineAfterThrow, this.state.lastTokEndLoc);
      }
      node.argument = this.parseExpression();
      this.semicolon();
      return this.finishNode(node, "ThrowStatement");
    };
    _proto.parseCatchClauseParam = function parseCatchClauseParam() {
      var param = this.parseBindingAtom();
      this.scope.enter(this.options.annexB && param.type === "Identifier" ? ScopeFlag.SIMPLE_CATCH : ScopeFlag.OTHER);
      this.checkLVal(param, {
        type: "CatchClause"
      }, BindingFlag.TYPE_CATCH_PARAM);
      return param;
    };
    _proto.parseTryStatement = function parseTryStatement(node) {
      var _this2 = this;
      this.next();
      node.block = this.parseBlock();
      node.handler = null;
      if (this.match(62)) {
        var clause = this.startNode();
        this.next();
        if (this.match(10)) {
          this.expect(10);
          clause.param = this.parseCatchClauseParam();
          this.expect(11);
        } else {
          clause.param = null;
          this.scope.enter(ScopeFlag.OTHER);
        }
        clause.body = this.withSmartMixTopicForbiddingContext(function () {
          return (_this2.parseBlock(false, false)
          );
        });
        this.scope.exit();
        node.handler = this.finishNode(clause, "CatchClause");
      }
      node.finalizer = this.eat(67) ? this.parseBlock() : null;
      if (!node.handler && !node.finalizer) {
        this.raise(Errors.NoCatchOrFinally, node);
      }
      return this.finishNode(node, "TryStatement");
    };
    _proto.parseVarStatement = function parseVarStatement(node, kind, allowMissingInitializer) {
      if (allowMissingInitializer === void 0) {
        allowMissingInitializer = false;
      }
      this.next();
      this.parseVar(node, false, kind, allowMissingInitializer);
      this.semicolon();
      return this.finishNode(node, "VariableDeclaration");
    };
    _proto.parseWhileStatement = function parseWhileStatement(node) {
      var _this3 = this;
      this.next();
      node.test = this.parseHeaderExpression();
      this.state.labels.push(loopLabel);
      node.body = this.withSmartMixTopicForbiddingContext(function () {
        return (_this3.parseStatement()
        );
      });
      this.state.labels.pop();
      return this.finishNode(node, "WhileStatement");
    };
    _proto.parseWithStatement = function parseWithStatement(node) {
      var _this4 = this;
      if (this.state.strict) {
        this.raise(Errors.StrictWith, this.state.startLoc);
      }
      this.next();
      node.object = this.parseHeaderExpression();
      node.body = this.withSmartMixTopicForbiddingContext(function () {
        return (_this4.parseStatement()
        );
      });
      return this.finishNode(node, "WithStatement");
    };
    _proto.parseEmptyStatement = function parseEmptyStatement(node) {
      this.next();
      return this.finishNode(node, "EmptyStatement");
    };
    _proto.parseLabeledStatement = function parseLabeledStatement(node, maybeName, expr, flags) {
      for (var _i4 = 0, _this$state$labels2 = this.state.labels; _i4 < _this$state$labels2.length; _i4++) {
        var label = _this$state$labels2[_i4];
        if (label.name === maybeName) {
          this.raise(Errors.LabelRedeclaration, expr, {
            labelName: maybeName
          });
        }
      }
      var kind = tokenIsLoop(this.state.type) ? LoopLabelKind.Loop : this.match(71) ? LoopLabelKind.Switch : null;
      for (var i = this.state.labels.length - 1; i >= 0; i--) {
        var _label = this.state.labels[i];
        if (_label.statementStart === node.start) {
          _label.statementStart = this.sourceToOffsetPos(this.state.start);
          _label.kind = kind;
        } else {
          break;
        }
      }
      this.state.labels.push({
        name: maybeName,
        kind: kind,
        statementStart: this.sourceToOffsetPos(this.state.start)
      });
      node.body = flags & ParseStatementFlag.AllowLabeledFunction ? this.parseStatementOrSloppyAnnexBFunctionDeclaration(true) : this.parseStatement();
      this.state.labels.pop();
      node.label = expr;
      return this.finishNode(node, "LabeledStatement");
    };
    _proto.parseExpressionStatement = function parseExpressionStatement(node, expr, decorators) {
      node.expression = expr;
      this.semicolon();
      return this.finishNode(node, "ExpressionStatement");
    };
    _proto.parseBlock = function parseBlock(allowDirectives, createNewLexicalScope, afterBlockParse) {
      if (allowDirectives === void 0) {
        allowDirectives = false;
      }
      if (createNewLexicalScope === void 0) {
        createNewLexicalScope = true;
      }
      var node = this.startNode();
      if (allowDirectives) {
        this.state.strictErrors.clear();
      }
      this.expect(5);
      if (createNewLexicalScope) {
        this.scope.enter(ScopeFlag.OTHER);
      }
      this.parseBlockBody(node, allowDirectives, false, 8, afterBlockParse);
      if (createNewLexicalScope) {
        this.scope.exit();
      }
      return this.finishNode(node, "BlockStatement");
    };
    _proto.isValidDirective = function isValidDirective(stmt) {
      return stmt.type === "ExpressionStatement" && stmt.expression.type === "StringLiteral" && !stmt.expression.extra.parenthesized;
    };
    _proto.parseBlockBody = function parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {
      var body = node.body = [];
      var directives = node.directives = [];
      this.parseBlockOrModuleBlockBody(body, allowDirectives ? directives : undefined, topLevel, end, afterBlockParse);
    };
    _proto.parseBlockOrModuleBlockBody = function parseBlockOrModuleBlockBody(body, directives, topLevel, end, afterBlockParse) {
      var oldStrict = this.state.strict;
      var hasStrictModeDirective = false;
      var parsedNonDirective = false;
      while (!this.match(end)) {
        var stmt = topLevel ? this.parseModuleItem() : this.parseStatementListItem();
        if (directives && !parsedNonDirective) {
          if (this.isValidDirective(stmt)) {
            var directive = this.stmtToDirective(stmt);
            directives.push(directive);
            if (!hasStrictModeDirective && directive.value.value === "use strict") {
              hasStrictModeDirective = true;
              this.setStrict(true);
            }
            continue;
          }
          parsedNonDirective = true;
          this.state.strictErrors.clear();
        }
        body.push(stmt);
      }
      afterBlockParse == null || afterBlockParse.call(this, hasStrictModeDirective);
      if (!oldStrict) {
        this.setStrict(false);
      }
      this.next();
    };
    _proto.parseFor = function parseFor(node, init) {
      var _this5 = this;
      node.init = init;
      this.semicolon(false);
      node.test = this.match(13) ? null : this.parseExpression();
      this.semicolon(false);
      node.update = this.match(11) ? null : this.parseExpression();
      this.expect(11);
      node.body = this.withSmartMixTopicForbiddingContext(function () {
        return (_this5.parseStatement()
        );
      });
      this.scope.exit();
      this.state.labels.pop();
      return this.finishNode(node, "ForStatement");
    };
    _proto.parseForIn = function parseForIn(node, init, awaitAt) {
      var _this6 = this;
      var isForIn = this.match(58);
      this.next();
      if (isForIn) {
        if (awaitAt !== null) this.unexpected(awaitAt);
      } else {
        node["await"] = awaitAt !== null;
      }
      if (init.type === "VariableDeclaration" && init.declarations[0].init != null && (!isForIn || !this.options.annexB || this.state.strict || init.kind !== "var" || init.declarations[0].id.type !== "Identifier")) {
        this.raise(Errors.ForInOfLoopInitializer, init, {
          type: isForIn ? "ForInStatement" : "ForOfStatement"
        });
      }
      if (init.type === "AssignmentPattern") {
        this.raise(Errors.InvalidLhs, init, {
          ancestor: {
            type: "ForStatement"
          }
        });
      }
      node.left = init;
      node.right = isForIn ? this.parseExpression() : this.parseMaybeAssignAllowIn();
      this.expect(11);
      node.body = this.withSmartMixTopicForbiddingContext(function () {
        return (_this6.parseStatement()
        );
      });
      this.scope.exit();
      this.state.labels.pop();
      return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement");
    };
    _proto.parseVar = function parseVar(node, isFor, kind, allowMissingInitializer) {
      if (allowMissingInitializer === void 0) {
        allowMissingInitializer = false;
      }
      var declarations = node.declarations = [];
      node.kind = kind;
      for (;;) {
        var decl = this.startNode();
        this.parseVarId(decl, kind);
        decl.init = !this.eat(29) ? null : isFor ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn();
        if (decl.init === null && !allowMissingInitializer) {
          if (decl.id.type !== "Identifier" && !(isFor && (this.match(58) || this.isContextual(102)))) {
            this.raise(Errors.DeclarationMissingInitializer, this.state.lastTokEndLoc, {
              kind: "destructuring"
            });
          } else if ((kind === "const" || kind === "using" || kind === "await using") && !(this.match(58) || this.isContextual(102))) {
            this.raise(Errors.DeclarationMissingInitializer, this.state.lastTokEndLoc, {
              kind: kind
            });
          }
        }
        declarations.push(this.finishNode(decl, "VariableDeclarator"));
        if (!this.eat(12)) break;
      }
      return node;
    };
    _proto.parseVarId = function parseVarId(decl, kind) {
      var id = this.parseBindingAtom();
      if (kind === "using" || kind === "await using") {
        if (id.type === "ArrayPattern" || id.type === "ObjectPattern") {
          this.raise(Errors.UsingDeclarationHasBindingPattern, id.loc.start);
        }
      } else {
        if (id.type === "VoidPattern") {
          this.raise(Errors.UnexpectedVoidPattern, id.loc.start);
        }
      }
      this.checkLVal(id, {
        type: "VariableDeclarator"
      }, kind === "var" ? BindingFlag.TYPE_VAR : BindingFlag.TYPE_LEXICAL);
      decl.id = id;
    };
    _proto.parseAsyncFunctionExpression = function parseAsyncFunctionExpression(node) {
      return this.parseFunction(node, ParseFunctionFlag.Async);
    };
    _proto.parseFunction = function parseFunction(node, flags) {
      var _this7 = this;
      if (flags === void 0) {
        flags = ParseFunctionFlag.Expression;
      }
      var hangingDeclaration = flags & ParseFunctionFlag.HangingDeclaration;
      var isDeclaration = !!(flags & ParseFunctionFlag.Declaration);
      var requireId = isDeclaration && !(flags & ParseFunctionFlag.NullableId);
      var isAsync = !!(flags & ParseFunctionFlag.Async);
      this.initFunction(node, isAsync);
      if (this.match(55)) {
        if (hangingDeclaration) {
          this.raise(Errors.GeneratorInSingleStatementContext, this.state.startLoc);
        }
        this.next();
        node.generator = true;
      }
      if (isDeclaration) {
        node.id = this.parseFunctionId(requireId);
      }
      var oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
      this.state.maybeInArrowParameters = false;
      this.scope.enter(ScopeFlag.FUNCTION);
      this.prodParam.enter(functionFlags(isAsync, node.generator));
      if (!isDeclaration) {
        node.id = this.parseFunctionId();
      }
      this.parseFunctionParams(node, false);
      this.withSmartMixTopicForbiddingContext(function () {
        _this7.parseFunctionBodyAndFinish(node, isDeclaration ? "FunctionDeclaration" : "FunctionExpression");
      });
      this.prodParam.exit();
      this.scope.exit();
      if (isDeclaration && !hangingDeclaration) {
        this.registerFunctionStatementId(node);
      }
      this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
      return node;
    };
    _proto.parseFunctionId = function parseFunctionId(requireId) {
      return requireId || tokenIsIdentifier(this.state.type) ? this.parseIdentifier() : null;
    };
    _proto.parseFunctionParams = function parseFunctionParams(node, isConstructor) {
      this.expect(10);
      this.expressionScope.enter(newParameterDeclarationScope());
      node.params = this.parseBindingList(11, 41, ParseBindingListFlags.IS_FUNCTION_PARAMS | (isConstructor ? ParseBindingListFlags.IS_CONSTRUCTOR_PARAMS : 0));
      this.expressionScope.exit();
    };
    _proto.registerFunctionStatementId = function registerFunctionStatementId(node) {
      if (!node.id) return;
      this.scope.declareName(node.id.name, !this.options.annexB || this.state.strict || node.generator || node.async ? this.scope.treatFunctionsAsVar ? BindingFlag.TYPE_VAR : BindingFlag.TYPE_LEXICAL : BindingFlag.TYPE_FUNCTION, node.id.loc.start);
    };
    _proto.parseClass = function parseClass(node, isStatement, optionalId) {
      this.next();
      var oldStrict = this.state.strict;
      this.state.strict = true;
      this.parseClassId(node, isStatement, optionalId);
      this.parseClassSuper(node);
      node.body = this.parseClassBody(!!node.superClass, oldStrict);
      return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
    };
    _proto.isClassProperty = function isClassProperty() {
      return this.match(29) || this.match(13) || this.match(8);
    };
    _proto.isClassMethod = function isClassMethod() {
      return this.match(10);
    };
    _proto.nameIsConstructor = function nameIsConstructor(key) {
      return key.type === "Identifier" && key.name === "constructor" || key.type === "StringLiteral" && key.value === "constructor";
    };
    _proto.isNonstaticConstructor = function isNonstaticConstructor(method) {
      return !method.computed && !method["static"] && this.nameIsConstructor(method.key);
    };
    _proto.parseClassBody = function parseClassBody(hadSuperClass, oldStrict) {
      var _this8 = this;
      this.classScope.enter();
      var state = {
        hadConstructor: false,
        hadSuperClass: hadSuperClass
      };
      var decorators = [];
      var classBody = this.startNode();
      classBody.body = [];
      this.expect(5);
      this.withSmartMixTopicForbiddingContext(function () {
        while (!_this8.match(8)) {
          if (_this8.eat(13)) {
            if (decorators.length > 0) {
              throw _this8.raise(Errors.DecoratorSemicolon, _this8.state.lastTokEndLoc);
            }
            continue;
          }
          if (_this8.match(26)) {
            decorators.push(_this8.parseDecorator());
            continue;
          }
          var member = _this8.startNode();
          if (decorators.length) {
            member.decorators = decorators;
            _this8.resetStartLocationFromNode(member, decorators[0]);
            decorators = [];
          }
          _this8.parseClassMember(classBody, member, state);
          if (member.kind === "constructor" && member.decorators && member.decorators.length > 0) {
            _this8.raise(Errors.DecoratorConstructor, member);
          }
        }
      });
      this.state.strict = oldStrict;
      this.next();
      if (decorators.length) {
        throw this.raise(Errors.TrailingDecorator, this.state.startLoc);
      }
      this.classScope.exit();
      return this.finishNode(classBody, "ClassBody");
    };
    _proto.parseClassMemberFromModifier = function parseClassMemberFromModifier(classBody, member) {
      var key = this.parseIdentifier(true);
      if (this.isClassMethod()) {
        var method = member;
        method.kind = "method";
        method.computed = false;
        method.key = key;
        method["static"] = false;
        this.pushClassMethod(classBody, method, false, false, false, false);
        return true;
      } else if (this.isClassProperty()) {
        var prop = member;
        prop.computed = false;
        prop.key = key;
        prop["static"] = false;
        classBody.body.push(this.parseClassProperty(prop));
        return true;
      }
      this.resetPreviousNodeTrailingComments(key);
      return false;
    };
    _proto.parseClassMember = function parseClassMember(classBody, member, state) {
      var isStatic = this.isContextual(106);
      if (isStatic) {
        if (this.parseClassMemberFromModifier(classBody, member)) {
          return;
        }
        if (this.eat(5)) {
          this.parseClassStaticBlock(classBody, member);
          return;
        }
      }
      this.parseClassMemberWithIsStatic(classBody, member, state, isStatic);
    };
    _proto.parseClassMemberWithIsStatic = function parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
      var publicMethod = member;
      var privateMethod = member;
      var publicProp = member;
      var privateProp = member;
      var accessorProp = member;
      var method = publicMethod;
      var publicMember = publicMethod;
      member["static"] = isStatic;
      this.parsePropertyNamePrefixOperator(member);
      if (this.eat(55)) {
        method.kind = "method";
        var isPrivateName = this.match(139);
        this.parseClassElementName(method);
        this.parsePostMemberNameModifiers(method);
        if (isPrivateName) {
          this.pushClassPrivateMethod(classBody, privateMethod, true, false);
          return;
        }
        if (this.isNonstaticConstructor(publicMethod)) {
          this.raise(Errors.ConstructorIsGenerator, publicMethod.key);
        }
        this.pushClassMethod(classBody, publicMethod, true, false, false, false);
        return;
      }
      var isContextual = !this.state.containsEsc && tokenIsIdentifier(this.state.type);
      var key = this.parseClassElementName(member);
      var maybeContextualKw = isContextual ? key.name : null;
      var isPrivate = this.isPrivateName(key);
      var maybeQuestionTokenStartLoc = this.state.startLoc;
      this.parsePostMemberNameModifiers(publicMember);
      if (this.isClassMethod()) {
        method.kind = "method";
        if (isPrivate) {
          this.pushClassPrivateMethod(classBody, privateMethod, false, false);
          return;
        }
        var isConstructor = this.isNonstaticConstructor(publicMethod);
        var allowsDirectSuper = false;
        if (isConstructor) {
          publicMethod.kind = "constructor";
          if (state.hadConstructor && !this.hasPlugin("typescript")) {
            this.raise(Errors.DuplicateConstructor, key);
          }
          if (isConstructor && this.hasPlugin("typescript") && member.override) {
            this.raise(Errors.OverrideOnConstructor, key);
          }
          state.hadConstructor = true;
          allowsDirectSuper = state.hadSuperClass;
        }
        this.pushClassMethod(classBody, publicMethod, false, false, isConstructor, allowsDirectSuper);
      } else if (this.isClassProperty()) {
        if (isPrivate) {
          this.pushClassPrivateProperty(classBody, privateProp);
        } else {
          this.pushClassProperty(classBody, publicProp);
        }
      } else if (maybeContextualKw === "async" && !this.isLineTerminator()) {
        this.resetPreviousNodeTrailingComments(key);
        var isGenerator = this.eat(55);
        if (publicMember.optional) {
          this.unexpected(maybeQuestionTokenStartLoc);
        }
        method.kind = "method";
        var _isPrivate = this.match(139);
        this.parseClassElementName(method);
        this.parsePostMemberNameModifiers(publicMember);
        if (_isPrivate) {
          this.pushClassPrivateMethod(classBody, privateMethod, isGenerator, true);
        } else {
          if (this.isNonstaticConstructor(publicMethod)) {
            this.raise(Errors.ConstructorIsAsync, publicMethod.key);
          }
          this.pushClassMethod(classBody, publicMethod, isGenerator, true, false, false);
        }
      } else if ((maybeContextualKw === "get" || maybeContextualKw === "set") && !(this.match(55) && this.isLineTerminator())) {
        this.resetPreviousNodeTrailingComments(key);
        method.kind = maybeContextualKw;
        var _isPrivate2 = this.match(139);
        this.parseClassElementName(publicMethod);
        if (_isPrivate2) {
          this.pushClassPrivateMethod(classBody, privateMethod, false, false);
        } else {
          if (this.isNonstaticConstructor(publicMethod)) {
            this.raise(Errors.ConstructorIsAccessor, publicMethod.key);
          }
          this.pushClassMethod(classBody, publicMethod, false, false, false, false);
        }
        this.checkGetterSetterParams(publicMethod);
      } else if (maybeContextualKw === "accessor" && !this.isLineTerminator()) {
        this.expectPlugin("decoratorAutoAccessors");
        this.resetPreviousNodeTrailingComments(key);
        var _isPrivate3 = this.match(139);
        this.parseClassElementName(publicProp);
        this.pushClassAccessorProperty(classBody, accessorProp, _isPrivate3);
      } else if (this.isLineTerminator()) {
        if (isPrivate) {
          this.pushClassPrivateProperty(classBody, privateProp);
        } else {
          this.pushClassProperty(classBody, publicProp);
        }
      } else {
        this.unexpected();
      }
    };
    _proto.parseClassElementName = function parseClassElementName(member) {
      var _this$state = this.state,
        type = _this$state.type,
        value = _this$state.value;
      if ((type === 132 || type === 134) && member["static"] && value === "prototype") {
        this.raise(Errors.StaticPrototype, this.state.startLoc);
      }
      if (type === 139) {
        if (value === "constructor") {
          this.raise(Errors.ConstructorClassPrivateField, this.state.startLoc);
        }
        var key = this.parsePrivateName();
        member.key = key;
        return key;
      }
      this.parsePropertyName(member);
      return member.key;
    };
    _proto.parseClassStaticBlock = function parseClassStaticBlock(classBody, member) {
      var _member$decorators;
      this.scope.enter(ScopeFlag.CLASS | ScopeFlag.STATIC_BLOCK | ScopeFlag.SUPER);
      var oldLabels = this.state.labels;
      this.state.labels = [];
      this.prodParam.enter(ParamKind.PARAM);
      var body = member.body = [];
      this.parseBlockOrModuleBlockBody(body, undefined, false, 8);
      this.prodParam.exit();
      this.scope.exit();
      this.state.labels = oldLabels;
      classBody.body.push(this.finishNode(member, "StaticBlock"));
      if ((_member$decorators = member.decorators) != null && _member$decorators.length) {
        this.raise(Errors.DecoratorStaticBlock, member);
      }
    };
    _proto.pushClassProperty = function pushClassProperty(classBody, prop) {
      if (!prop.computed && this.nameIsConstructor(prop.key)) {
        this.raise(Errors.ConstructorClassField, prop.key);
      }
      classBody.body.push(this.parseClassProperty(prop));
    };
    _proto.pushClassPrivateProperty = function pushClassPrivateProperty(classBody, prop) {
      var node = this.parseClassPrivateProperty(prop);
      classBody.body.push(node);
      this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), ClassElementType.OTHER, node.key.loc.start);
    };
    _proto.pushClassAccessorProperty = function pushClassAccessorProperty(classBody, prop, isPrivate) {
      if (!isPrivate && !prop.computed && this.nameIsConstructor(prop.key)) {
        this.raise(Errors.ConstructorClassField, prop.key);
      }
      var node = this.parseClassAccessorProperty(prop);
      classBody.body.push(node);
      if (isPrivate) {
        this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), ClassElementType.OTHER, node.key.loc.start);
      }
    };
    _proto.pushClassMethod = function pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
      classBody.body.push(this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, "ClassMethod", true));
    };
    _proto.pushClassPrivateMethod = function pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
      var node = this.parseMethod(method, isGenerator, isAsync, false, false, "ClassPrivateMethod", true);
      classBody.body.push(node);
      var kind = node.kind === "get" ? node["static"] ? ClassElementType.STATIC_GETTER : ClassElementType.INSTANCE_GETTER : node.kind === "set" ? node["static"] ? ClassElementType.STATIC_SETTER : ClassElementType.INSTANCE_SETTER : ClassElementType.OTHER;
      this.declareClassPrivateMethodInScope(node, kind);
    };
    _proto.declareClassPrivateMethodInScope = function declareClassPrivateMethodInScope(node, kind) {
      this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), kind, node.key.loc.start);
    };
    _proto.parsePostMemberNameModifiers = function parsePostMemberNameModifiers(methodOrProp) {};
    _proto.parseClassPrivateProperty = function parseClassPrivateProperty(node) {
      this.parseInitializer(node);
      this.semicolon();
      return this.finishNode(node, "ClassPrivateProperty");
    };
    _proto.parseClassProperty = function parseClassProperty(node) {
      this.parseInitializer(node);
      this.semicolon();
      return this.finishNode(node, "ClassProperty");
    };
    _proto.parseClassAccessorProperty = function parseClassAccessorProperty(node) {
      this.parseInitializer(node);
      this.semicolon();
      return this.finishNode(node, "ClassAccessorProperty");
    };
    _proto.parseInitializer = function parseInitializer(node) {
      this.scope.enter(ScopeFlag.CLASS | ScopeFlag.SUPER);
      this.expressionScope.enter(newExpressionScope());
      this.prodParam.enter(ParamKind.PARAM);
      node.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null;
      this.expressionScope.exit();
      this.prodParam.exit();
      this.scope.exit();
    };
    _proto.parseClassId = function parseClassId(node, isStatement, optionalId, bindingType) {
      if (bindingType === void 0) {
        bindingType = BindingFlag.TYPE_CLASS;
      }
      if (tokenIsIdentifier(this.state.type)) {
        node.id = this.parseIdentifier();
        if (isStatement) {
          this.declareNameFromIdentifier(node.id, bindingType);
        }
      } else {
        if (optionalId || !isStatement) {
          node.id = null;
        } else {
          throw this.raise(Errors.MissingClassName, this.state.startLoc);
        }
      }
    };
    _proto.parseClassSuper = function parseClassSuper(node) {
      node.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
    };
    _proto.parseExport = function parseExport(node, decorators) {
      var maybeDefaultIdentifier = this.parseMaybeImportPhase(node, true);
      var hasDefault = this.maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier);
      var parseAfterDefault = !hasDefault || this.eat(12);
      var hasStar = parseAfterDefault && this.eatExportStar(node);
      var hasNamespace = hasStar && this.maybeParseExportNamespaceSpecifier(node);
      var parseAfterNamespace = parseAfterDefault && (!hasNamespace || this.eat(12));
      var isFromRequired = hasDefault || hasStar;
      if (hasStar && !hasNamespace) {
        if (hasDefault) this.unexpected();
        if (decorators) {
          throw this.raise(Errors.UnsupportedDecoratorExport, node);
        }
        this.parseExportFrom(node, true);
        this.sawUnambiguousESM = true;
        return this.finishNode(node, "ExportAllDeclaration");
      }
      var hasSpecifiers = this.maybeParseExportNamedSpecifiers(node);
      if (hasDefault && parseAfterDefault && !hasStar && !hasSpecifiers) {
        this.unexpected(null, 5);
      }
      if (hasNamespace && parseAfterNamespace) {
        this.unexpected(null, 98);
      }
      var hasDeclaration;
      if (isFromRequired || hasSpecifiers) {
        hasDeclaration = false;
        if (decorators) {
          throw this.raise(Errors.UnsupportedDecoratorExport, node);
        }
        this.parseExportFrom(node, isFromRequired);
      } else {
        hasDeclaration = this.maybeParseExportDeclaration(node);
      }
      if (isFromRequired || hasSpecifiers || hasDeclaration) {
        var _node2$declaration;
        var node2 = node;
        this.checkExport(node2, true, false, !!node2.source);
        if (((_node2$declaration = node2.declaration) == null ? void 0 : _node2$declaration.type) === "ClassDeclaration") {
          this.maybeTakeDecorators(decorators, node2.declaration, node2);
        } else if (decorators) {
          throw this.raise(Errors.UnsupportedDecoratorExport, node);
        }
        this.sawUnambiguousESM = true;
        return this.finishNode(node2, "ExportNamedDeclaration");
      }
      if (this.eat(65)) {
        var _node3 = node;
        var decl = this.parseExportDefaultExpression();
        _node3.declaration = decl;
        if (decl.type === "ClassDeclaration") {
          this.maybeTakeDecorators(decorators, decl, _node3);
        } else if (decorators) {
          throw this.raise(Errors.UnsupportedDecoratorExport, node);
        }
        this.checkExport(_node3, true, true);
        this.sawUnambiguousESM = true;
        return this.finishNode(_node3, "ExportDefaultDeclaration");
      }
      this.unexpected(null, 5);
    };
    _proto.eatExportStar = function eatExportStar(node) {
      return this.eat(55);
    };
    _proto.maybeParseExportDefaultSpecifier = function maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier) {
      if (maybeDefaultIdentifier || this.isExportDefaultSpecifier()) {
        this.expectPlugin("exportDefaultFrom", maybeDefaultIdentifier == null ? void 0 : maybeDefaultIdentifier.loc.start);
        var id = maybeDefaultIdentifier || this.parseIdentifier(true);
        var specifier = this.startNodeAtNode(id);
        specifier.exported = id;
        node.specifiers = [this.finishNode(specifier, "ExportDefaultSpecifier")];
        return true;
      }
      return false;
    };
    _proto.maybeParseExportNamespaceSpecifier = function maybeParseExportNamespaceSpecifier(node) {
      if (this.isContextual(93)) {
        var _ref, _ref$specifiers;
        (_ref$specifiers = (_ref = node).specifiers) != null ? _ref$specifiers : _ref.specifiers = [];
        var specifier = this.startNodeAt(this.state.lastTokStartLoc);
        this.next();
        specifier.exported = this.parseModuleExportName();
        node.specifiers.push(this.finishNode(specifier, "ExportNamespaceSpecifier"));
        return true;
      }
      return false;
    };
    _proto.maybeParseExportNamedSpecifiers = function maybeParseExportNamedSpecifiers(node) {
      if (this.match(5)) {
        var _node2$specifiers;
        var node2 = node;
        if (!node2.specifiers) node2.specifiers = [];
        var isTypeExport = node2.exportKind === "type";
        (_node2$specifiers = node2.specifiers).push.apply(_node2$specifiers, this.parseExportSpecifiers(isTypeExport));
        node2.source = null;
        if (this.hasPlugin("importAssertions")) {
          node2.assertions = [];
        } else {
          node2.attributes = [];
        }
        node2.declaration = null;
        return true;
      }
      return false;
    };
    _proto.maybeParseExportDeclaration = function maybeParseExportDeclaration(node) {
      if (this.shouldParseExportDeclaration()) {
        node.specifiers = [];
        node.source = null;
        if (this.hasPlugin("importAssertions")) {
          node.assertions = [];
        } else {
          node.attributes = [];
        }
        node.declaration = this.parseExportDeclaration(node);
        return true;
      }
      return false;
    };
    _proto.isAsyncFunction = function isAsyncFunction() {
      if (!this.isContextual(95)) return false;
      var next = this.nextTokenInLineStart();
      return this.isUnparsedContextual(next, "function");
    };
    _proto.parseExportDefaultExpression = function parseExportDefaultExpression() {
      var expr = this.startNode();
      if (this.match(68)) {
        this.next();
        return this.parseFunction(expr, ParseFunctionFlag.Declaration | ParseFunctionFlag.NullableId);
      } else if (this.isAsyncFunction()) {
        this.next();
        this.next();
        return this.parseFunction(expr, ParseFunctionFlag.Declaration | ParseFunctionFlag.NullableId | ParseFunctionFlag.Async);
      }
      if (this.match(80)) {
        return this.parseClass(expr, true, true);
      }
      if (this.match(26)) {
        if (this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") === true) {
          this.raise(Errors.DecoratorBeforeExport, this.state.startLoc);
        }
        return this.parseClass(this.maybeTakeDecorators(this.parseDecorators(false), this.startNode()), true, true);
      }
      if (this.match(75) || this.match(74) || this.isLet() || this.isUsing() || this.isAwaitUsing()) {
        throw this.raise(Errors.UnsupportedDefaultExport, this.state.startLoc);
      }
      var res = this.parseMaybeAssignAllowIn();
      this.semicolon();
      return res;
    };
    _proto.parseExportDeclaration = function parseExportDeclaration(node) {
      if (this.match(80)) {
        var _node4 = this.parseClass(this.startNode(), true, false);
        return _node4;
      }
      return this.parseStatementListItem();
    };
    _proto.isExportDefaultSpecifier = function isExportDefaultSpecifier() {
      var type = this.state.type;
      if (tokenIsIdentifier(type)) {
        if (type === 95 && !this.state.containsEsc || type === 100) {
          return false;
        }
        if ((type === 130 || type === 129) && !this.state.containsEsc) {
          var _next = this.nextTokenStart();
          var nextChar = this.input.charCodeAt(_next);
          if (nextChar === 123 || this.chStartsBindingIdentifier(nextChar, _next) && !this.input.startsWith("from", _next)) {
            this.expectOnePlugin(["flow", "typescript"]);
            return false;
          }
        }
      } else if (!this.match(65)) {
        return false;
      }
      var next = this.nextTokenStart();
      var hasFrom = this.isUnparsedContextual(next, "from");
      if (this.input.charCodeAt(next) === 44 || tokenIsIdentifier(this.state.type) && hasFrom) {
        return true;
      }
      if (this.match(65) && hasFrom) {
        var nextAfterFrom = this.input.charCodeAt(this.nextTokenStartSince(next + 4));
        return nextAfterFrom === 34 || nextAfterFrom === 39;
      }
      return false;
    };
    _proto.parseExportFrom = function parseExportFrom(node, expect) {
      if (this.eatContextual(98)) {
        node.source = this.parseImportSource();
        this.checkExport(node);
        this.maybeParseImportAttributes(node);
        this.checkJSONModuleImport(node);
      } else if (expect) {
        this.unexpected();
      }
      this.semicolon();
    };
    _proto.shouldParseExportDeclaration = function shouldParseExportDeclaration() {
      var type = this.state.type;
      if (type === 26) {
        this.expectOnePlugin(["decorators", "decorators-legacy"]);
        if (this.hasPlugin("decorators")) {
          if (this.getPluginOption("decorators", "decoratorsBeforeExport") === true) {
            this.raise(Errors.DecoratorBeforeExport, this.state.startLoc);
          }
          return true;
        }
      }
      if (this.isUsing()) {
        this.raise(Errors.UsingDeclarationExport, this.state.startLoc);
        return true;
      }
      if (this.isAwaitUsing()) {
        this.raise(Errors.UsingDeclarationExport, this.state.startLoc);
        return true;
      }
      return type === 74 || type === 75 || type === 68 || type === 80 || this.isLet() || this.isAsyncFunction();
    };
    _proto.checkExport = function checkExport(node, checkNames, isDefault, isFrom) {
      if (checkNames) {
        var _node$specifiers;
        if (isDefault) {
          this.checkDuplicateExports(node, "default");
          if (this.hasPlugin("exportDefaultFrom")) {
            var _declaration$extra;
            var declaration = node.declaration;
            if (declaration.type === "Identifier" && declaration.name === "from" && declaration.end - declaration.start === 4 && !((_declaration$extra = declaration.extra) != null && _declaration$extra.parenthesized)) {
              this.raise(Errors.ExportDefaultFromAsIdentifier, declaration);
            }
          }
        } else if ((_node$specifiers = node.specifiers) != null && _node$specifiers.length) {
          for (var _i6 = 0, _node$specifiers3 = node.specifiers; _i6 < _node$specifiers3.length; _i6++) {
            var specifier = _node$specifiers3[_i6];
            var exported = specifier.exported;
            var exportName = exported.type === "Identifier" ? exported.name : exported.value;
            this.checkDuplicateExports(specifier, exportName);
            if (!isFrom && specifier.local) {
              var local = specifier.local;
              if (local.type !== "Identifier") {
                this.raise(Errors.ExportBindingIsString, specifier, {
                  localName: local.value,
                  exportName: exportName
                });
              } else {
                this.checkReservedWord(local.name, local.loc.start, true, false);
                this.scope.checkLocalExport(local);
              }
            }
          }
        } else if (node.declaration) {
          var decl = node.declaration;
          if (decl.type === "FunctionDeclaration" || decl.type === "ClassDeclaration") {
            var id = decl.id;
            if (!id) throw new Error("Assertion failure");
            this.checkDuplicateExports(node, id.name);
          } else if (decl.type === "VariableDeclaration") {
            for (var _i8 = 0, _decl$declarations2 = decl.declarations; _i8 < _decl$declarations2.length; _i8++) {
              var _declaration = _decl$declarations2[_i8];
              this.checkDeclaration(_declaration.id);
            }
          }
        }
      }
    };
    _proto.checkDeclaration = function checkDeclaration(node) {
      if (node.type === "Identifier") {
        this.checkDuplicateExports(node, node.name);
      } else if (node.type === "ObjectPattern") {
        for (var _i0 = 0, _node$properties2 = node.properties; _i0 < _node$properties2.length; _i0++) {
          var prop = _node$properties2[_i0];
          this.checkDeclaration(prop);
        }
      } else if (node.type === "ArrayPattern") {
        for (var _i10 = 0, _node$elements2 = node.elements; _i10 < _node$elements2.length; _i10++) {
          var elem = _node$elements2[_i10];
          if (elem) {
            this.checkDeclaration(elem);
          }
        }
      } else if (node.type === "ObjectProperty") {
        this.checkDeclaration(node.value);
      } else if (node.type === "RestElement") {
        this.checkDeclaration(node.argument);
      } else if (node.type === "AssignmentPattern") {
        this.checkDeclaration(node.left);
      }
    };
    _proto.checkDuplicateExports = function checkDuplicateExports(node, exportName) {
      if (this.exportedIdentifiers.has(exportName)) {
        if (exportName === "default") {
          this.raise(Errors.DuplicateDefaultExport, node);
        } else {
          this.raise(Errors.DuplicateExport, node, {
            exportName: exportName
          });
        }
      }
      this.exportedIdentifiers.add(exportName);
    };
    _proto.parseExportSpecifiers = function parseExportSpecifiers(isInTypeExport) {
      var nodes = [];
      var first = true;
      this.expect(5);
      while (!this.eat(8)) {
        if (first) {
          first = false;
        } else {
          this.expect(12);
          if (this.eat(8)) break;
        }
        var isMaybeTypeOnly = this.isContextual(130);
        var isString = this.match(134);
        var _node5 = this.startNode();
        _node5.local = this.parseModuleExportName();
        nodes.push(this.parseExportSpecifier(_node5, isString, isInTypeExport, isMaybeTypeOnly));
      }
      return nodes;
    };
    _proto.parseExportSpecifier = function parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly) {
      if (this.eatContextual(93)) {
        node.exported = this.parseModuleExportName();
      } else if (isString) {
        node.exported = this.cloneStringLiteral(node.local);
      } else if (!node.exported) {
        node.exported = this.cloneIdentifier(node.local);
      }
      return this.finishNode(node, "ExportSpecifier");
    };
    _proto.parseModuleExportName = function parseModuleExportName() {
      if (this.match(134)) {
        var result = this.parseStringLiteral(this.state.value);
        var surrogate = loneSurrogate.exec(result.value);
        if (surrogate) {
          this.raise(Errors.ModuleExportNameHasLoneSurrogate, result, {
            surrogateCharCode: surrogate[0].charCodeAt(0)
          });
        }
        return result;
      }
      return this.parseIdentifier(true);
    };
    _proto.isJSONModuleImport = function isJSONModuleImport(node) {
      if (node.assertions != null) {
        return node.assertions.some(function (_ref2) {
          var key = _ref2.key,
            value = _ref2.value;
          return value.value === "json" && (key.type === "Identifier" ? key.name === "type" : key.value === "type");
        });
      }
      return false;
    };
    _proto.checkImportReflection = function checkImportReflection(node) {
      var specifiers = node.specifiers;
      var singleBindingType = specifiers.length === 1 ? specifiers[0].type : null;
      if (node.phase === "source") {
        if (singleBindingType !== "ImportDefaultSpecifier") {
          this.raise(Errors.SourcePhaseImportRequiresDefault, specifiers[0].loc.start);
        }
      } else if (node.phase === "defer") {
        if (singleBindingType !== "ImportNamespaceSpecifier") {
          this.raise(Errors.DeferImportRequiresNamespace, specifiers[0].loc.start);
        }
      } else if (node.module) {
        var _node$assertions;
        if (singleBindingType !== "ImportDefaultSpecifier") {
          this.raise(Errors.ImportReflectionNotBinding, specifiers[0].loc.start);
        }
        if (((_node$assertions = node.assertions) == null ? void 0 : _node$assertions.length) > 0) {
          this.raise(Errors.ImportReflectionHasAssertion, specifiers[0].loc.start);
        }
      }
    };
    _proto.checkJSONModuleImport = function checkJSONModuleImport(node) {
      if (this.isJSONModuleImport(node) && node.type !== "ExportAllDeclaration") {
        var specifiers = node.specifiers;
        if (specifiers != null) {
          var nonDefaultNamedSpecifier = specifiers.find(function (specifier) {
            var imported;
            if (specifier.type === "ExportSpecifier") {
              imported = specifier.local;
            } else if (specifier.type === "ImportSpecifier") {
              imported = specifier.imported;
            }
            if (imported !== undefined) {
              return imported.type === "Identifier" ? imported.name !== "default" : imported.value !== "default";
            }
          });
          if (nonDefaultNamedSpecifier !== undefined) {
            this.raise(Errors.ImportJSONBindingNotDefault, nonDefaultNamedSpecifier.loc.start);
          }
        }
      }
    };
    _proto.isPotentialImportPhase = function isPotentialImportPhase(isExport) {
      if (isExport) return false;
      return this.isContextual(105) || this.isContextual(97) || this.isContextual(127);
    };
    _proto.applyImportPhase = function applyImportPhase(node, isExport, phase, loc) {
      if (isExport) {
        return;
      }
      if (phase === "module") {
        this.expectPlugin("importReflection", loc);
        node.module = true;
      } else if (this.hasPlugin("importReflection")) {
        node.module = false;
      }
      if (phase === "source") {
        this.expectPlugin("sourcePhaseImports", loc);
        node.phase = "source";
      } else if (phase === "defer") {
        this.expectPlugin("deferredImportEvaluation", loc);
        node.phase = "defer";
      } else if (this.hasPlugin("sourcePhaseImports")) {
        node.phase = null;
      }
    };
    _proto.parseMaybeImportPhase = function parseMaybeImportPhase(node, isExport) {
      if (!this.isPotentialImportPhase(isExport)) {
        this.applyImportPhase(node, isExport, null);
        return null;
      }
      var phaseIdentifier = this.startNode();
      var phaseIdentifierName = this.parseIdentifierName(true);
      var type = this.state.type;
      var isImportPhase = tokenIsKeywordOrIdentifier(type) ? type !== 98 || this.lookaheadCharCode() === 102 : type !== 12;
      if (isImportPhase) {
        this.applyImportPhase(node, isExport, phaseIdentifierName, phaseIdentifier.loc.start);
        return null;
      } else {
        this.applyImportPhase(node, isExport, null);
        return this.createIdentifier(phaseIdentifier, phaseIdentifierName);
      }
    };
    _proto.isPrecedingIdImportPhase = function isPrecedingIdImportPhase(phase) {
      var type = this.state.type;
      return tokenIsIdentifier(type) ? type !== 98 || this.lookaheadCharCode() === 102 : type !== 12;
    };
    _proto.parseImport = function parseImport(node) {
      if (this.match(134)) {
        return this.parseImportSourceAndAttributes(node);
      }
      return this.parseImportSpecifiersAndAfter(node, this.parseMaybeImportPhase(node, false));
    };
    _proto.parseImportSpecifiersAndAfter = function parseImportSpecifiersAndAfter(node, maybeDefaultIdentifier) {
      node.specifiers = [];
      var hasDefault = this.maybeParseDefaultImportSpecifier(node, maybeDefaultIdentifier);
      var parseNext = !hasDefault || this.eat(12);
      var hasStar = parseNext && this.maybeParseStarImportSpecifier(node);
      if (parseNext && !hasStar) this.parseNamedImportSpecifiers(node);
      this.expectContextual(98);
      return this.parseImportSourceAndAttributes(node);
    };
    _proto.parseImportSourceAndAttributes = function parseImportSourceAndAttributes(node) {
      var _node$specifiers4;
      (_node$specifiers4 = node.specifiers) != null ? _node$specifiers4 : node.specifiers = [];
      node.source = this.parseImportSource();
      this.maybeParseImportAttributes(node);
      this.checkImportReflection(node);
      this.checkJSONModuleImport(node);
      this.semicolon();
      this.sawUnambiguousESM = true;
      return this.finishNode(node, "ImportDeclaration");
    };
    _proto.parseImportSource = function parseImportSource() {
      if (!this.match(134)) this.unexpected();
      return this.parseExprAtom();
    };
    _proto.parseImportSpecifierLocal = function parseImportSpecifierLocal(node, specifier, type) {
      specifier.local = this.parseIdentifier();
      node.specifiers.push(this.finishImportSpecifier(specifier, type));
    };
    _proto.finishImportSpecifier = function finishImportSpecifier(specifier, type, bindingType) {
      if (bindingType === void 0) {
        bindingType = BindingFlag.TYPE_LEXICAL;
      }
      this.checkLVal(specifier.local, {
        type: type
      }, bindingType);
      return this.finishNode(specifier, type);
    };
    _proto.parseImportAttributes = function parseImportAttributes() {
      this.expect(5);
      var attrs = [];
      var attrNames = new Set();
      do {
        if (this.match(8)) {
          break;
        }
        var _node6 = this.startNode();
        var keyName = this.state.value;
        if (attrNames.has(keyName)) {
          this.raise(Errors.ModuleAttributesWithDuplicateKeys, this.state.startLoc, {
            key: keyName
          });
        }
        attrNames.add(keyName);
        if (this.match(134)) {
          _node6.key = this.parseStringLiteral(keyName);
        } else {
          _node6.key = this.parseIdentifier(true);
        }
        this.expect(14);
        if (!this.match(134)) {
          throw this.raise(Errors.ModuleAttributeInvalidValue, this.state.startLoc);
        }
        _node6.value = this.parseStringLiteral(this.state.value);
        attrs.push(this.finishNode(_node6, "ImportAttribute"));
      } while (this.eat(12));
      this.expect(8);
      return attrs;
    };
    _proto.parseModuleAttributes = function parseModuleAttributes() {
      var attrs = [];
      var attributes = new Set();
      do {
        var _node7 = this.startNode();
        _node7.key = this.parseIdentifier(true);
        if (_node7.key.name !== "type") {
          this.raise(Errors.ModuleAttributeDifferentFromType, _node7.key);
        }
        if (attributes.has(_node7.key.name)) {
          this.raise(Errors.ModuleAttributesWithDuplicateKeys, _node7.key, {
            key: _node7.key.name
          });
        }
        attributes.add(_node7.key.name);
        this.expect(14);
        if (!this.match(134)) {
          throw this.raise(Errors.ModuleAttributeInvalidValue, this.state.startLoc);
        }
        _node7.value = this.parseStringLiteral(this.state.value);
        attrs.push(this.finishNode(_node7, "ImportAttribute"));
      } while (this.eat(12));
      return attrs;
    };
    _proto.maybeParseImportAttributes = function maybeParseImportAttributes(node) {
      var attributes;
      {
        var useWith = false;
      }
      if (this.match(76)) {
        if (this.hasPrecedingLineBreak() && this.lookaheadCharCode() === 40) {
          return;
        }
        this.next();
        if (this.hasPlugin("moduleAttributes")) {
          attributes = this.parseModuleAttributes();
          this.addExtra(node, "deprecatedWithLegacySyntax", true);
        } else {
          attributes = this.parseImportAttributes();
        }
        {
          useWith = true;
        }
      } else if (this.isContextual(94) && !this.hasPrecedingLineBreak()) {
        if (!this.hasPlugin("deprecatedImportAssert") && !this.hasPlugin("importAssertions")) {
          this.raise(Errors.ImportAttributesUseAssert, this.state.startLoc);
        }
        if (!this.hasPlugin("importAssertions")) {
          this.addExtra(node, "deprecatedAssertSyntax", true);
        }
        this.next();
        attributes = this.parseImportAttributes();
      } else {
        attributes = [];
      }
      if (!useWith && this.hasPlugin("importAssertions")) {
        node.assertions = attributes;
      } else {
        node.attributes = attributes;
      }
    };
    _proto.maybeParseDefaultImportSpecifier = function maybeParseDefaultImportSpecifier(node, maybeDefaultIdentifier) {
      if (maybeDefaultIdentifier) {
        var specifier = this.startNodeAtNode(maybeDefaultIdentifier);
        specifier.local = maybeDefaultIdentifier;
        node.specifiers.push(this.finishImportSpecifier(specifier, "ImportDefaultSpecifier"));
        return true;
      } else if (tokenIsKeywordOrIdentifier(this.state.type)) {
        this.parseImportSpecifierLocal(node, this.startNode(), "ImportDefaultSpecifier");
        return true;
      }
      return false;
    };
    _proto.maybeParseStarImportSpecifier = function maybeParseStarImportSpecifier(node) {
      if (this.match(55)) {
        var specifier = this.startNode();
        this.next();
        this.expectContextual(93);
        this.parseImportSpecifierLocal(node, specifier, "ImportNamespaceSpecifier");
        return true;
      }
      return false;
    };
    _proto.parseNamedImportSpecifiers = function parseNamedImportSpecifiers(node) {
      var first = true;
      this.expect(5);
      while (!this.eat(8)) {
        if (first) {
          first = false;
        } else {
          if (this.eat(14)) {
            throw this.raise(Errors.DestructureNamedImport, this.state.startLoc);
          }
          this.expect(12);
          if (this.eat(8)) break;
        }
        var specifier = this.startNode();
        var importedIsString = this.match(134);
        var isMaybeTypeOnly = this.isContextual(130);
        specifier.imported = this.parseModuleExportName();
        var importSpecifier = this.parseImportSpecifier(specifier, importedIsString, node.importKind === "type" || node.importKind === "typeof", isMaybeTypeOnly, undefined);
        node.specifiers.push(importSpecifier);
      }
    };
    _proto.parseImportSpecifier = function parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {
      if (this.eatContextual(93)) {
        specifier.local = this.parseIdentifier();
      } else {
        var imported = specifier.imported;
        if (importedIsString) {
          throw this.raise(Errors.ImportBindingIsString, specifier, {
            importName: imported.value
          });
        }
        this.checkReservedWord(imported.name, specifier.loc.start, true, true);
        if (!specifier.local) {
          specifier.local = this.cloneIdentifier(imported);
        }
      }
      return this.finishImportSpecifier(specifier, "ImportSpecifier", bindingType);
    };
    _proto.isThisParam = function isThisParam(param) {
      return param.type === "Identifier" && param.name === "this";
    };
    return _createClass(StatementParser);
  }(ExpressionParser);

  var Parser = function (_StatementParser) {
    function Parser(options, input, pluginsMap) {
      var _this;
      options = getOptions(options);
      _this = _StatementParser.call(this, options, input) || this;
      _this.options = options;
      _this.initializeScopes();
      _this.plugins = pluginsMap;
      _this.filename = options.sourceFilename;
      _this.startIndex = options.startIndex;
      var optionFlags = 0;
      if (options.allowAwaitOutsideFunction) {
        optionFlags |= OptionFlags.AllowAwaitOutsideFunction;
      }
      if (options.allowReturnOutsideFunction) {
        optionFlags |= OptionFlags.AllowReturnOutsideFunction;
      }
      if (options.allowImportExportEverywhere) {
        optionFlags |= OptionFlags.AllowImportExportEverywhere;
      }
      if (options.allowSuperOutsideMethod) {
        optionFlags |= OptionFlags.AllowSuperOutsideMethod;
      }
      if (options.allowUndeclaredExports) {
        optionFlags |= OptionFlags.AllowUndeclaredExports;
      }
      if (options.allowNewTargetOutsideFunction) {
        optionFlags |= OptionFlags.AllowNewTargetOutsideFunction;
      }
      if (options.allowYieldOutsideFunction) {
        optionFlags |= OptionFlags.AllowYieldOutsideFunction;
      }
      if (options.ranges) {
        optionFlags |= OptionFlags.Ranges;
      }
      if (options.tokens) {
        optionFlags |= OptionFlags.Tokens;
      }
      if (options.createImportExpressions) {
        optionFlags |= OptionFlags.CreateImportExpressions;
      }
      if (options.createParenthesizedExpressions) {
        optionFlags |= OptionFlags.CreateParenthesizedExpressions;
      }
      if (options.errorRecovery) {
        optionFlags |= OptionFlags.ErrorRecovery;
      }
      if (options.attachComment) {
        optionFlags |= OptionFlags.AttachComment;
      }
      if (options.annexB) {
        optionFlags |= OptionFlags.AnnexB;
      }
      _this.optionFlags = optionFlags;
      return _this;
    }
    _inherits(Parser, _StatementParser);
    var _proto = Parser.prototype;
    _proto.getScopeHandler = function getScopeHandler() {
      return ScopeHandler;
    };
    _proto.parse = function parse() {
      this.enterInitialScopes();
      var file = this.startNode();
      var program = this.startNode();
      this.nextToken();
      file.errors = null;
      this.parseTopLevel(file, program);
      file.errors = this.state.errors;
      file.comments.length = this.state.commentsLen;
      return file;
    };
    return _createClass(Parser);
  }(StatementParser);

  function parse$4(input, options) {
    var _options;
    if (((_options = options) == null ? void 0 : _options.sourceType) === "unambiguous") {
      options = Object.assign({}, options);
      try {
        options.sourceType = "module";
        var parser = getParser(options, input);
        var ast = parser.parse();
        if (parser.sawUnambiguousESM) {
          return ast;
        }
        if (parser.ambiguousScriptDifferentAst) {
          try {
            options.sourceType = "script";
            return getParser(options, input).parse();
          } catch (_unused) {}
        } else {
          ast.program.sourceType = "script";
        }
        return ast;
      } catch (moduleError) {
        try {
          options.sourceType = "script";
          return getParser(options, input).parse();
        } catch (_unused2) {}
        throw moduleError;
      }
    } else {
      return getParser(options, input).parse();
    }
  }
  function parseExpression(input, options) {
    var parser = getParser(options, input);
    if (parser.options.strictMode) {
      parser.state.strict = true;
    }
    return parser.getExpression();
  }
  function generateExportedTokenTypes(internalTokenTypes) {
    var tokenTypes = {};
    for (var _i2 = 0, _Object$keys2 = Object.keys(internalTokenTypes); _i2 < _Object$keys2.length; _i2++) {
      var typeName = _Object$keys2[_i2];
      tokenTypes[typeName] = getExportedToken(internalTokenTypes[typeName]);
    }
    return tokenTypes;
  }
  var tokTypes = generateExportedTokenTypes(tt);
  function getParser(options, input) {
    var cls = Parser;
    var pluginsMap = new Map();
    if (options != null && options.plugins) {
      for (var _i4 = 0, _options$plugins2 = options.plugins; _i4 < _options$plugins2.length; _i4++) {
        var plugin = _options$plugins2[_i4];
        var name = void 0,
          opts = void 0;
        if (typeof plugin === "string") {
          name = plugin;
        } else {
          name = plugin[0];
          opts = plugin[1];
        }
        if (!pluginsMap.has(name)) {
          pluginsMap.set(name, opts || {});
        }
      }
      validatePlugins(pluginsMap);
      cls = getParserClass(pluginsMap);
    }
    return new cls(options, input, pluginsMap);
  }
  var parserClassCache = new Map();
  function getParserClass(pluginsMap) {
    var pluginList = [];
    for (var _i6 = 0; _i6 < mixinPluginNames.length; _i6++) {
      var name = mixinPluginNames[_i6];
      if (pluginsMap.has(name)) {
        pluginList.push(name);
      }
    }
    var key = pluginList.join("|");
    var cls = parserClassCache.get(key);
    if (!cls) {
      cls = Parser;
      for (var _i8 = 0; _i8 < pluginList.length; _i8++) {
        var plugin = pluginList[_i8];
        cls = mixinPlugins[plugin](cls);
      }
      parserClassCache.set(key, cls);
    }
    return cls;
  }

  var index$4 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    parse: parse$4,
    parseExpression: parseExpression,
    tokTypes: tokTypes
  });

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function getAugmentedNamespace(n) {
    if (n.__esModule) return n;
    var f = n.default;
  	if (typeof f == "function") {
  		var a = function a () {
  			if (this instanceof a) {
          return Reflect.construct(f, arguments, this.constructor);
  			}
  			return f.apply(this, arguments);
  		};
  		a.prototype = f.prototype;
    } else a = {};
    Object.defineProperty(a, '__esModule', {value: true});
  	Object.keys(n).forEach(function (k) {
  		var d = Object.getOwnPropertyDescriptor(n, k);
  		Object.defineProperty(a, k, d.get ? d : {
  			enumerable: true,
  			get: function () {
  				return n[k];
  			}
  		});
  	});
  	return a;
  }

  var picocolors_browser = {exports: {}};

  var x = String;
  var create = function create() {
    return {
      isColorSupported: false,
      reset: x,
      bold: x,
      dim: x,
      italic: x,
      underline: x,
      inverse: x,
      hidden: x,
      strikethrough: x,
      black: x,
      red: x,
      green: x,
      yellow: x,
      blue: x,
      magenta: x,
      cyan: x,
      white: x,
      gray: x,
      bgBlack: x,
      bgRed: x,
      bgGreen: x,
      bgYellow: x,
      bgBlue: x,
      bgMagenta: x,
      bgCyan: x,
      bgWhite: x,
      blackBright: x,
      redBright: x,
      greenBright: x,
      yellowBright: x,
      blueBright: x,
      magentaBright: x,
      cyanBright: x,
      whiteBright: x,
      bgBlackBright: x,
      bgRedBright: x,
      bgGreenBright: x,
      bgYellowBright: x,
      bgBlueBright: x,
      bgMagentaBright: x,
      bgCyanBright: x,
      bgWhiteBright: x
    };
  };
  picocolors_browser.exports = create();
  var createColors = picocolors_browser.exports.createColors = create;
  var picocolors_browserExports = picocolors_browser.exports;

  function isColorSupported() {
    return (typeof browser$1$1 === "object" && (browser$1$1.env.FORCE_COLOR === "0" || browser$1$1.env.FORCE_COLOR === "false") ? false : picocolors_browserExports.isColorSupported
    );
  }
  var compose = function compose(f, g) {
    return function (v) {
      return f(g(v));
    };
  };
  function buildDefs(colors) {
    return {
      keyword: colors.cyan,
      capitalized: colors.yellow,
      jsxIdentifier: colors.yellow,
      punctuator: colors.yellow,
      number: colors.magenta,
      string: colors.green,
      regex: colors.magenta,
      comment: colors.gray,
      invalid: compose(compose(colors.white, colors.bgRed), colors.bold),
      gutter: colors.gray,
      marker: compose(colors.red, colors.bold),
      message: compose(colors.red, colors.bold),
      reset: colors.reset
    };
  }
  var defsOn = buildDefs(createColors(true));
  var defsOff = buildDefs(createColors(false));
  function getDefs(enabled) {
    return enabled ? defsOn : defsOff;
  }

  var jsTokensBABEL_8_BREAKINGFalse = {};

  var hasRequiredJsTokensBABEL_8_BREAKINGFalse;
  function requireJsTokensBABEL_8_BREAKINGFalse() {
    if (hasRequiredJsTokensBABEL_8_BREAKINGFalse) return jsTokensBABEL_8_BREAKINGFalse;
    hasRequiredJsTokensBABEL_8_BREAKINGFalse = 1;
    Object.defineProperty(jsTokensBABEL_8_BREAKINGFalse, "__esModule", {
      value: true
    });
    jsTokensBABEL_8_BREAKINGFalse["default"] = /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyus]{1,6}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g;
    jsTokensBABEL_8_BREAKINGFalse.matchToToken = function (match) {
      var token = {
        type: "invalid",
        value: match[0],
        closed: undefined
      };
      if (match[1]) token.type = "string", token.closed = !!(match[3] || match[4]);else if (match[5]) token.type = "comment";else if (match[6]) token.type = "comment", token.closed = !!match[7];else if (match[8]) token.type = "regex";else if (match[9]) token.type = "number";else if (match[10]) token.type = "name";else if (match[11]) token.type = "punctuator";else if (match[12]) token.type = "whitespace";
      return token;
    };
    return jsTokensBABEL_8_BREAKINGFalse;
  }

  function bool$7(value) {
    if (value == null) return false;
    return value && value !== "false" && value !== "0";
  }
  var jsTokens = bool$7(browser$1$1.env["BABEL_8_BREAKING"]) ? requireJsTokensBABEL_8_BREAKINGFalse() : requireJsTokensBABEL_8_BREAKINGFalse();

  var sometimesKeywords = new Set(["as", "async", "from", "get", "of", "set"]);
  var NEWLINE$1 = /\r\n|[\n\r\u2028\u2029]/;
  var BRACKET = /^[()[\]{}]$/;
  var tokenize;
  {
    var JSX_TAG = /^[a-z][\w-]*$/i;
    var getTokenType = function getTokenType(token, offset, text) {
      if (token.type === "name") {
        if (isKeyword(token.value) || isStrictReservedWord(token.value, true) || sometimesKeywords.has(token.value)) {
          return "keyword";
        }
        if (JSX_TAG.test(token.value) && (text[offset - 1] === "<" || text.slice(offset - 2, offset) === "</")) {
          return "jsxIdentifier";
        }
        if (token.value[0] !== token.value[0].toLowerCase()) {
          return "capitalized";
        }
      }
      if (token.type === "punctuator" && BRACKET.test(token.value)) {
        return "bracket";
      }
      if (token.type === "invalid" && (token.value === "@" || token.value === "#")) {
        return "punctuator";
      }
      return token.type;
    };
    tokenize = _regenerator().m(function tokenize(text) {
      var match, token;
      return _regenerator().w(function (_context) {
        while (1) switch (_context.n) {
          case 0:
            if (!(match = jsTokens["default"].exec(text))) {
              _context.n = 2;
              break;
            }
            token = jsTokens.matchToToken(match);
            _context.n = 1;
            return {
              type: getTokenType(token, match.index, text),
              value: token.value
            };
          case 1:
            _context.n = 0;
            break;
          case 2:
            return _context.a(2);
        }
      }, tokenize);
    });
  }
  function highlight(text) {
    if (text === "") return "";
    var defs = getDefs(true);
    var highlighted = "";
    var _loop = function _loop() {
      var _step$value = _step.value,
        type = _step$value.type,
        value = _step$value.value;
      if (type in defs) {
        highlighted += value.split(NEWLINE$1).map(function (str) {
          return defs[type](str);
        }).join("\n");
      } else {
        highlighted += value;
      }
    };
    for (var _iterator = _createForOfIteratorHelperLoose(tokenize(text)), _step; !(_step = _iterator()).done;) {
      _loop();
    }
    return highlighted;
  }

  var NEWLINE = /\r\n|[\n\r\u2028\u2029]/;
  function getMarkerLines(loc, source, opts) {
    var startLoc = Object.assign({
      column: 0,
      line: -1
    }, loc.start);
    var endLoc = Object.assign({}, startLoc, loc.end);
    var _ref = opts || {},
      _ref$linesAbove = _ref.linesAbove,
      linesAbove = _ref$linesAbove === void 0 ? 2 : _ref$linesAbove,
      _ref$linesBelow = _ref.linesBelow,
      linesBelow = _ref$linesBelow === void 0 ? 3 : _ref$linesBelow;
    var startLine = startLoc.line;
    var startColumn = startLoc.column;
    var endLine = endLoc.line;
    var endColumn = endLoc.column;
    var start = Math.max(startLine - (linesAbove + 1), 0);
    var end = Math.min(source.length, endLine + linesBelow);
    if (startLine === -1) {
      start = 0;
    }
    if (endLine === -1) {
      end = source.length;
    }
    var lineDiff = endLine - startLine;
    var markerLines = {};
    if (lineDiff) {
      for (var i = 0; i <= lineDiff; i++) {
        var lineNumber = i + startLine;
        if (!startColumn) {
          markerLines[lineNumber] = true;
        } else if (i === 0) {
          var sourceLength = source[lineNumber - 1].length;
          markerLines[lineNumber] = [startColumn, sourceLength - startColumn + 1];
        } else if (i === lineDiff) {
          markerLines[lineNumber] = [0, endColumn];
        } else {
          var _sourceLength = source[lineNumber - i].length;
          markerLines[lineNumber] = [0, _sourceLength];
        }
      }
    } else {
      if (startColumn === endColumn) {
        if (startColumn) {
          markerLines[startLine] = [startColumn, 0];
        } else {
          markerLines[startLine] = true;
        }
      } else {
        markerLines[startLine] = [startColumn, endColumn - startColumn];
      }
    }
    return {
      start: start,
      end: end,
      markerLines: markerLines
    };
  }
  function codeFrameColumns(rawLines, loc, opts) {
    if (opts === void 0) {
      opts = {};
    }
    var shouldHighlight = opts.forceColor || isColorSupported() && opts.highlightCode;
    var defs = getDefs(shouldHighlight);
    var lines = rawLines.split(NEWLINE);
    var _getMarkerLines = getMarkerLines(loc, lines, opts),
      start = _getMarkerLines.start,
      end = _getMarkerLines.end,
      markerLines = _getMarkerLines.markerLines;
    var hasColumns = loc.start && typeof loc.start.column === "number";
    var numberMaxWidth = String(end).length;
    var highlightedLines = shouldHighlight ? highlight(rawLines) : rawLines;
    var frame = highlightedLines.split(NEWLINE, end).slice(start, end).map(function (line, index) {
      var number = start + 1 + index;
      var paddedNumber = (" " + number).slice(-numberMaxWidth);
      var gutter = " " + paddedNumber + " |";
      var hasMarker = markerLines[number];
      var lastMarkerLine = !markerLines[number + 1];
      if (hasMarker) {
        var markerLine = "";
        if (Array.isArray(hasMarker)) {
          var markerSpacing = line.slice(0, Math.max(hasMarker[0] - 1, 0)).replace(/[^\t]/g, " ");
          var numberOfMarkers = hasMarker[1] || 1;
          markerLine = ["\n ", defs.gutter(gutter.replace(/\d/g, " ")), " ", markerSpacing, defs.marker("^").repeat(numberOfMarkers)].join("");
          if (lastMarkerLine && opts.message) {
            markerLine += " " + defs.message(opts.message);
          }
        }
        return [defs.marker(">"), defs.gutter(gutter), line.length > 0 ? " " + line : "", markerLine].join("");
      } else {
        return " " + defs.gutter(gutter) + (line.length > 0 ? " " + line : "");
      }
    }).join("\n");
    if (opts.message && !hasColumns) {
      frame = "" + " ".repeat(numberMaxWidth + 1) + opts.message + "\n" + frame;
    }
    if (shouldHighlight) {
      return defs.reset(frame);
    } else {
      return frame;
    }
  }

  var isCallExpression$7 = isCallExpression$8,
    isExpressionStatement$1 = isExpressionStatement$2,
    isFunction$5 = isFunction$6,
    isIdentifier$d = isIdentifier$e,
    isJSXIdentifier$2 = isJSXIdentifier$3,
    isNewExpression$2 = isNewExpression$3,
    isPlaceholder = isPlaceholder$1,
    isStatement$8 = isStatement$9,
    isStringLiteral$4 = isStringLiteral$5,
    removePropertiesDeep = removePropertiesDeep$1,
    traverse$1 = traverse$2;
  var PATTERN = /^[_$A-Z0-9]+$/;
  function parseAndBuildMetadata(formatter, code, opts) {
    var placeholderWhitelist = opts.placeholderWhitelist,
      placeholderPattern = opts.placeholderPattern,
      preserveComments = opts.preserveComments,
      syntacticPlaceholders = opts.syntacticPlaceholders;
    var ast = parseWithCodeFrame(code, opts.parser, syntacticPlaceholders);
    removePropertiesDeep(ast, {
      preserveComments: preserveComments
    });
    formatter.validate(ast);
    var state = {
      syntactic: {
        placeholders: [],
        placeholderNames: new Set()
      },
      legacy: {
        placeholders: [],
        placeholderNames: new Set()
      },
      placeholderWhitelist: placeholderWhitelist,
      placeholderPattern: placeholderPattern,
      syntacticPlaceholders: syntacticPlaceholders
    };
    traverse$1(ast, placeholderVisitorHandler, state);
    return Object.assign({
      ast: ast
    }, state.syntactic.placeholders.length ? state.syntactic : state.legacy);
  }
  function placeholderVisitorHandler(node, ancestors, state) {
    var _state$placeholderWhi;
    var name;
    var hasSyntacticPlaceholders = state.syntactic.placeholders.length > 0;
    if (isPlaceholder(node)) {
      if (state.syntacticPlaceholders === false) {
        throw new Error("%%foo%%-style placeholders can't be used when " + "'.syntacticPlaceholders' is false.");
      }
      name = node.name.name;
      hasSyntacticPlaceholders = true;
    } else if (hasSyntacticPlaceholders || state.syntacticPlaceholders) {
      return;
    } else if (isIdentifier$d(node) || isJSXIdentifier$2(node)) {
      name = node.name;
    } else if (isStringLiteral$4(node)) {
      name = node.value;
    } else {
      return;
    }
    if (hasSyntacticPlaceholders && (state.placeholderPattern != null || state.placeholderWhitelist != null)) {
      throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible" + " with '.syntacticPlaceholders: true'");
    }
    if (!hasSyntacticPlaceholders && (state.placeholderPattern === false || !(state.placeholderPattern || PATTERN).test(name)) && !((_state$placeholderWhi = state.placeholderWhitelist) != null && _state$placeholderWhi.has(name))) {
      return;
    }
    ancestors = ancestors.slice();
    var _ancestors = ancestors[ancestors.length - 1],
      parent = _ancestors.node,
      key = _ancestors.key;
    var type;
    if (isStringLiteral$4(node) || isPlaceholder(node, {
      expectedNode: "StringLiteral"
    })) {
      type = "string";
    } else if (isNewExpression$2(parent) && key === "arguments" || isCallExpression$7(parent) && key === "arguments" || isFunction$5(parent) && key === "params") {
      type = "param";
    } else if (isExpressionStatement$1(parent) && !isPlaceholder(node)) {
      type = "statement";
      ancestors = ancestors.slice(0, -1);
    } else if (isStatement$8(node) && isPlaceholder(node)) {
      type = "statement";
    } else {
      type = "other";
    }
    var _ref = !hasSyntacticPlaceholders ? state.legacy : state.syntactic,
      placeholders = _ref.placeholders,
      placeholderNames = _ref.placeholderNames;
    placeholders.push({
      name: name,
      type: type,
      resolve: function resolve(ast) {
        return resolveAncestors(ast, ancestors);
      },
      isDuplicate: placeholderNames.has(name)
    });
    placeholderNames.add(name);
  }
  function resolveAncestors(ast, ancestors) {
    var parent = ast;
    for (var i = 0; i < ancestors.length - 1; i++) {
      var _ancestors$i = ancestors[i],
        _key = _ancestors$i.key,
        _index = _ancestors$i.index;
      if (_index === undefined) {
        parent = parent[_key];
      } else {
        parent = parent[_key][_index];
      }
    }
    var _ancestors2 = ancestors[ancestors.length - 1],
      key = _ancestors2.key,
      index = _ancestors2.index;
    return {
      parent: parent,
      key: key,
      index: index
    };
  }
  function parseWithCodeFrame(code, parserOpts, syntacticPlaceholders) {
    var plugins = (parserOpts.plugins || []).slice();
    if (syntacticPlaceholders !== false) {
      plugins.push("placeholders");
    }
    parserOpts = Object.assign({
      allowAwaitOutsideFunction: true,
      allowReturnOutsideFunction: true,
      allowNewTargetOutsideFunction: true,
      allowSuperOutsideMethod: true,
      allowYieldOutsideFunction: true,
      sourceType: "module"
    }, parserOpts, {
      plugins: plugins
    });
    try {
      return parse$4(code, parserOpts);
    } catch (err) {
      var loc = err.loc;
      if (loc) {
        err.message += "\n" + codeFrameColumns(code, {
          start: loc
        });
        err.code = "BABEL_TEMPLATE_PARSE_ERROR";
      }
      throw err;
    }
  }

  var blockStatement$5 = blockStatement$6,
    cloneNode$d = cloneNode$e,
    emptyStatement = emptyStatement$1,
    expressionStatement$6 = expressionStatement$7,
    identifier$d = identifier$e,
    isStatement$7 = isStatement$9,
    isStringLiteral$3 = isStringLiteral$5,
    stringLiteral$5 = stringLiteral$6,
    validate$3 = validate$6;
  function populatePlaceholders(metadata, replacements) {
    var ast = cloneNode$d(metadata.ast);
    if (replacements) {
      metadata.placeholders.forEach(function (placeholder) {
        if (!hasOwnProperty.call(replacements, placeholder.name)) {
          var placeholderName = placeholder.name;
          throw new Error("Error: No substitution given for \"" + placeholderName + "\". If this is not meant to be a\n            placeholder you may want to consider passing one of the following options to @babel/template:\n            - { placeholderPattern: false, placeholderWhitelist: new Set(['" + placeholderName + "'])}\n            - { placeholderPattern: /^" + placeholderName + "$/ }");
        }
      });
      Object.keys(replacements).forEach(function (key) {
        if (!metadata.placeholderNames.has(key)) {
          throw new Error("Unknown substitution \"" + key + "\" given");
        }
      });
    }
    metadata.placeholders.slice().reverse().forEach(function (placeholder) {
      try {
        var _ref;
        applyReplacement(placeholder, ast, (_ref = replacements && replacements[placeholder.name]) != null ? _ref : null);
      } catch (e) {
        e.message = "@babel/template placeholder \"" + placeholder.name + "\": " + e.message;
        throw e;
      }
    });
    return ast;
  }
  function applyReplacement(placeholder, ast, replacement) {
    if (placeholder.isDuplicate) {
      if (Array.isArray(replacement)) {
        replacement = replacement.map(function (node) {
          return cloneNode$d(node);
        });
      } else if (typeof replacement === "object") {
        replacement = cloneNode$d(replacement);
      }
    }
    var _placeholder$resolve = placeholder.resolve(ast),
      parent = _placeholder$resolve.parent,
      key = _placeholder$resolve.key,
      index = _placeholder$resolve.index;
    if (placeholder.type === "string") {
      if (typeof replacement === "string") {
        replacement = stringLiteral$5(replacement);
      }
      if (!replacement || !isStringLiteral$3(replacement)) {
        throw new Error("Expected string substitution");
      }
    } else if (placeholder.type === "statement") {
      if (index === undefined) {
        if (!replacement) {
          replacement = emptyStatement();
        } else if (Array.isArray(replacement)) {
          replacement = blockStatement$5(replacement);
        } else if (typeof replacement === "string") {
          replacement = expressionStatement$6(identifier$d(replacement));
        } else if (!isStatement$7(replacement)) {
          replacement = expressionStatement$6(replacement);
        }
      } else {
        if (replacement && !Array.isArray(replacement)) {
          if (typeof replacement === "string") {
            replacement = identifier$d(replacement);
          }
          if (!isStatement$7(replacement)) {
            replacement = expressionStatement$6(replacement);
          }
        }
      }
    } else if (placeholder.type === "param") {
      if (typeof replacement === "string") {
        replacement = identifier$d(replacement);
      }
      if (index === undefined) throw new Error("Assertion failure.");
    } else {
      if (typeof replacement === "string") {
        replacement = identifier$d(replacement);
      }
      if (Array.isArray(replacement)) {
        throw new Error("Cannot replace single expression with an array.");
      }
    }
    function set(parent, key, value) {
      var node = parent[key];
      parent[key] = value;
      if (node.type === "Identifier" || node.type === "Placeholder") {
        if (node.typeAnnotation) {
          value.typeAnnotation = node.typeAnnotation;
        }
        if (node.optional) {
          value.optional = node.optional;
        }
        if (node.decorators) {
          value.decorators = node.decorators;
        }
      }
    }
    if (index === undefined) {
      validate$3(parent, key, replacement);
      set(parent, key, replacement);
    } else {
      var items = parent[key].slice();
      if (placeholder.type === "statement" || placeholder.type === "param") {
        if (replacement == null) {
          items.splice(index, 1);
        } else if (Array.isArray(replacement)) {
          items.splice.apply(items, [index, 1].concat(_toConsumableArray(replacement)));
        } else {
          set(items, index, replacement);
        }
      } else {
        set(items, index, replacement);
      }
      validate$3(parent, key, items);
      parent[key] = items;
    }
  }

  function stringTemplate(formatter, code, opts) {
    code = formatter.code(code);
    var metadata;
    return function (arg) {
      var replacements = normalizeReplacements(arg);
      if (!metadata) metadata = parseAndBuildMetadata(formatter, code, opts);
      return formatter.unwrap(populatePlaceholders(metadata, replacements));
    };
  }

  function literalTemplate(formatter, tpl, opts) {
    var _buildLiteralData = buildLiteralData(formatter, tpl, opts),
      metadata = _buildLiteralData.metadata,
      names = _buildLiteralData.names;
    return function (arg) {
      var defaultReplacements = {};
      arg.forEach(function (replacement, i) {
        defaultReplacements[names[i]] = replacement;
      });
      return function (arg) {
        var replacements = normalizeReplacements(arg);
        if (replacements) {
          Object.keys(replacements).forEach(function (key) {
            if (hasOwnProperty.call(defaultReplacements, key)) {
              throw new Error("Unexpected replacement overlap.");
            }
          });
        }
        return formatter.unwrap(populatePlaceholders(metadata, replacements ? Object.assign(replacements, defaultReplacements) : defaultReplacements));
      };
    };
  }
  function buildLiteralData(formatter, tpl, opts) {
    var prefix = "BABEL_TPL$";
    var raw = tpl.join("");
    do {
      prefix = "$$" + prefix;
    } while (raw.includes(prefix));
    var _buildTemplateCode = buildTemplateCode(tpl, prefix),
      names = _buildTemplateCode.names,
      code = _buildTemplateCode.code;
    var metadata = parseAndBuildMetadata(formatter, formatter.code(code), {
      parser: opts.parser,
      placeholderWhitelist: new Set(names.concat(opts.placeholderWhitelist ? Array.from(opts.placeholderWhitelist) : [])),
      placeholderPattern: opts.placeholderPattern,
      preserveComments: opts.preserveComments,
      syntacticPlaceholders: opts.syntacticPlaceholders
    });
    return {
      metadata: metadata,
      names: names
    };
  }
  function buildTemplateCode(tpl, prefix) {
    var names = [];
    var code = tpl[0];
    for (var i = 1; i < tpl.length; i++) {
      var value = "" + prefix + (i - 1);
      names.push(value);
      code += value + tpl[i];
    }
    return {
      names: names,
      code: code
    };
  }

  var NO_PLACEHOLDER = validate$4({
    placeholderPattern: false
  });
  function createTemplateBuilder(formatter, defaultOpts) {
    var templateFnCache = new WeakMap();
    var templateAstCache = new WeakMap();
    var cachedOpts = defaultOpts || validate$4(null);
    return Object.assign(function (tpl) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      if (typeof tpl === "string") {
        if (args.length > 1) throw new Error("Unexpected extra params.");
        return extendedTrace(stringTemplate(formatter, tpl, merge$1(cachedOpts, validate$4(args[0]))));
      } else if (Array.isArray(tpl)) {
        var builder = templateFnCache.get(tpl);
        if (!builder) {
          builder = literalTemplate(formatter, tpl, cachedOpts);
          templateFnCache.set(tpl, builder);
        }
        return extendedTrace(builder(args));
      } else if (typeof tpl === "object" && tpl) {
        if (args.length > 0) throw new Error("Unexpected extra params.");
        return createTemplateBuilder(formatter, merge$1(cachedOpts, validate$4(tpl)));
      }
      throw new Error("Unexpected template param " + typeof tpl);
    }, {
      ast: function ast(tpl) {
        for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          args[_key2 - 1] = arguments[_key2];
        }
        if (typeof tpl === "string") {
          if (args.length > 1) throw new Error("Unexpected extra params.");
          return stringTemplate(formatter, tpl, merge$1(merge$1(cachedOpts, validate$4(args[0])), NO_PLACEHOLDER))();
        } else if (Array.isArray(tpl)) {
          var builder = templateAstCache.get(tpl);
          if (!builder) {
            builder = literalTemplate(formatter, tpl, merge$1(cachedOpts, NO_PLACEHOLDER));
            templateAstCache.set(tpl, builder);
          }
          return builder(args)();
        }
        throw new Error("Unexpected template param " + typeof tpl);
      }
    });
  }
  function extendedTrace(fn) {
    var rootStack = "";
    try {
      throw new Error();
    } catch (error) {
      if (error.stack) {
        rootStack = error.stack.split("\n").slice(3).join("\n");
      }
    }
    return function (arg) {
      try {
        return fn(arg);
      } catch (err) {
        err.stack += "\n    =============\n" + rootStack;
        throw err;
      }
    };
  }

  var smart = createTemplateBuilder(smart$1);
  var statement = createTemplateBuilder(statement$1);
  var statements = createTemplateBuilder(statements$1);
  var expression = createTemplateBuilder(expression$1);
  var program$1 = createTemplateBuilder(program$2);
  var template$2 = Object.assign(smart.bind(undefined), {
    smart: smart,
    statement: statement,
    statements: statements,
    expression: expression,
    program: program$1,
    ast: smart.ast
  });

  var index$3 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    default: template$2,
    expression: expression,
    program: program$1,
    smart: smart,
    statement: statement,
    statements: statements
  });

  function helper$2(minVersion, source, metadata) {
    return Object.freeze({
      minVersion: minVersion,
      ast: function ast() {
        return template$2.program.ast(source, {
          preserveComments: true
        });
      },
      metadata: metadata
    });
  }
  var helpers$3 = {
    __proto__: null,
    OverloadYield: helper$2("7.18.14", "function _OverloadYield(e,d){this.v=e,this.k=d}", {
      globals: [],
      locals: {
        _OverloadYield: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_OverloadYield",
      dependencies: {},
      internal: false
    }),
    applyDecoratedDescriptor: helper$2("7.0.0-beta.0", 'function _applyDecoratedDescriptor(i,e,r,n,l){var a={};return Object.keys(n).forEach((function(i){a[i]=n[i]})),a.enumerable=!!a.enumerable,a.configurable=!!a.configurable,("value"in a||a.initializer)&&(a.writable=!0),a=r.slice().reverse().reduce((function(r,n){return n(i,e,r)||r}),a),l&&void 0!==a.initializer&&(a.value=a.initializer?a.initializer.call(l):void 0,a.initializer=void 0),void 0===a.initializer?(Object.defineProperty(i,e,a),null):a}', {
      globals: ["Object"],
      locals: {
        _applyDecoratedDescriptor: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_applyDecoratedDescriptor",
      dependencies: {},
      internal: false
    }),
    applyDecs2311: helper$2("7.24.0", 'function applyDecs2311(e,t,n,r,o,i){var a,c,u,s,f,l,p,d=Symbol.metadata||Symbol.for("Symbol.metadata"),m=Object.defineProperty,h=Object.create,y=[h(null),h(null)],v=t.length;function g(t,n,r){return function(o,i){n&&(i=o,o=e);for(var a=0;a<t.length;a++)i=t[a].apply(o,r?[i]:[]);return r?i:o}}function b(e,t,n,r){if("function"!=typeof e&&(r||void 0!==e))throw new TypeError(t+" must "+(n||"be")+" a function"+(r?"":" or undefined"));return e}function applyDec(e,t,n,r,o,i,u,s,f,l,p){function d(e){if(!p(e))throw new TypeError("Attempted to access private element on non-instance")}var h=[].concat(t[0]),v=t[3],w=!u,D=1===o,S=3===o,j=4===o,E=2===o;function I(t,n,r){return function(o,i){return n&&(i=o,o=e),r&&r(o),P[t].call(o,i)}}if(!w){var P={},k=[],F=S?"get":j||D?"set":"value";if(f?(l||D?P={get:setFunctionName((function(){return v(this)}),r,"get"),set:function(e){t[4](this,e)}}:P[F]=v,l||setFunctionName(P[F],r,E?"":F)):l||(P=Object.getOwnPropertyDescriptor(e,r)),!l&&!f){if((c=y[+s][r])&&7!=(c^o))throw Error("Decorating two elements with the same name ("+P[F].name+") is not supported yet");y[+s][r]=o<3?1:o}}for(var N=e,O=h.length-1;O>=0;O-=n?2:1){var T=b(h[O],"A decorator","be",!0),z=n?h[O-1]:void 0,A={},H={kind:["field","accessor","method","getter","setter","class"][o],name:r,metadata:a,addInitializer:function(e,t){if(e.v)throw new TypeError("attempted to call addInitializer after decoration was finished");b(t,"An initializer","be",!0),i.push(t)}.bind(null,A)};if(w)c=T.call(z,N,H),A.v=1,b(c,"class decorators","return")&&(N=c);else if(H.static=s,H.private=f,c=H.access={has:f?p.bind():function(e){return r in e}},j||(c.get=f?E?function(e){return d(e),P.value}:I("get",0,d):function(e){return e[r]}),E||S||(c.set=f?I("set",0,d):function(e,t){e[r]=t}),N=T.call(z,D?{get:P.get,set:P.set}:P[F],H),A.v=1,D){if("object"==typeof N&&N)(c=b(N.get,"accessor.get"))&&(P.get=c),(c=b(N.set,"accessor.set"))&&(P.set=c),(c=b(N.init,"accessor.init"))&&k.unshift(c);else if(void 0!==N)throw new TypeError("accessor decorators must return an object with get, set, or init properties or undefined")}else b(N,(l?"field":"method")+" decorators","return")&&(l?k.unshift(N):P[F]=N)}return o<2&&u.push(g(k,s,1),g(i,s,0)),l||w||(f?D?u.splice(-1,0,I("get",s),I("set",s)):u.push(E?P[F]:b.call.bind(P[F])):m(e,r,P)),N}function w(e){return m(e,d,{configurable:!0,enumerable:!0,value:a})}return void 0!==i&&(a=i[d]),a=h(null==a?null:a),f=[],l=function(e){e&&f.push(g(e))},p=function(t,r){for(var i=0;i<n.length;i++){var a=n[i],c=a[1],l=7&c;if((8&c)==t&&!l==r){var p=a[2],d=!!a[3],m=16&c;applyDec(t?e:e.prototype,a,m,d?"#"+p:toPropertyKey(p),l,l<2?[]:t?s=s||[]:u=u||[],f,!!t,d,r,t&&d?function(t){return checkInRHS(t)===e}:o)}}},p(8,0),p(0,0),p(8,1),p(0,1),l(u),l(s),c=f,v||w(e),{e:c,get c(){var n=[];return v&&[w(e=applyDec(e,[t],r,e.name,5,n)),g(n,1)]}}}', {
      globals: ["Symbol", "Object", "TypeError", "Error"],
      locals: {
        applyDecs2311: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "applyDecs2311",
      dependencies: {
        checkInRHS: ["body.0.body.body.5.argument.expressions.4.right.body.body.0.body.body.1.consequent.body.1.expression.arguments.10.consequent.body.body.0.argument.left.callee"],
        setFunctionName: ["body.0.body.body.3.body.body.3.consequent.body.1.test.expressions.0.consequent.expressions.0.consequent.right.properties.0.value.callee", "body.0.body.body.3.body.body.3.consequent.body.1.test.expressions.0.consequent.expressions.1.right.callee"],
        toPropertyKey: ["body.0.body.body.5.argument.expressions.4.right.body.body.0.body.body.1.consequent.body.1.expression.arguments.3.alternate.callee"]
      },
      internal: false
    }),
    arrayLikeToArray: helper$2("7.9.0", "function _arrayLikeToArray(r,a){(null==a||a>r.length)&&(a=r.length);for(var e=0,n=Array(a);e<a;e++)n[e]=r[e];return n}", {
      globals: ["Array"],
      locals: {
        _arrayLikeToArray: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_arrayLikeToArray",
      dependencies: {},
      internal: false
    }),
    arrayWithHoles: helper$2("7.0.0-beta.0", "function _arrayWithHoles(r){if(Array.isArray(r))return r}", {
      globals: ["Array"],
      locals: {
        _arrayWithHoles: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_arrayWithHoles",
      dependencies: {},
      internal: false
    }),
    arrayWithoutHoles: helper$2("7.0.0-beta.0", "function _arrayWithoutHoles(r){if(Array.isArray(r))return arrayLikeToArray(r)}", {
      globals: ["Array"],
      locals: {
        _arrayWithoutHoles: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_arrayWithoutHoles",
      dependencies: {
        arrayLikeToArray: ["body.0.body.body.0.consequent.argument.callee"]
      },
      internal: false
    }),
    assertClassBrand: helper$2("7.24.0", 'function _assertClassBrand(e,t,n){if("function"==typeof e?e===t:e.has(t))return arguments.length<3?t:n;throw new TypeError("Private element is not present on this object")}', {
      globals: ["TypeError"],
      locals: {
        _assertClassBrand: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_assertClassBrand",
      dependencies: {},
      internal: false
    }),
    assertThisInitialized: helper$2("7.0.0-beta.0", "function _assertThisInitialized(e){if(void 0===e)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return e}", {
      globals: ["ReferenceError"],
      locals: {
        _assertThisInitialized: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_assertThisInitialized",
      dependencies: {},
      internal: false
    }),
    asyncGeneratorDelegate: helper$2("7.0.0-beta.0", 'function _asyncGeneratorDelegate(t){var e={},n=!1;function pump(e,r){return n=!0,r=new Promise((function(n){n(t[e](r))})),{done:!1,value:new OverloadYield(r,1)}}return e["undefined"!=typeof Symbol&&Symbol.iterator||"@@iterator"]=function(){return this},e.next=function(t){return n?(n=!1,t):pump("next",t)},"function"==typeof t.throw&&(e.throw=function(t){if(n)throw n=!1,t;return pump("throw",t)}),"function"==typeof t.return&&(e.return=function(t){return n?(n=!1,t):pump("return",t)}),e}', {
      globals: ["Promise", "Symbol"],
      locals: {
        _asyncGeneratorDelegate: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_asyncGeneratorDelegate",
      dependencies: {
        OverloadYield: ["body.0.body.body.1.body.body.0.argument.expressions.2.properties.1.value.callee"]
      },
      internal: false
    }),
    asyncIterator: helper$2("7.15.9", 'function _asyncIterator(r){var n,t,o,e=2;for("undefined"!=typeof Symbol&&(t=Symbol.asyncIterator,o=Symbol.iterator);e--;){if(t&&null!=(n=r[t]))return n.call(r);if(o&&null!=(n=r[o]))return new AsyncFromSyncIterator(n.call(r));t="@@asyncIterator",o="@@iterator"}throw new TypeError("Object is not async iterable")}function AsyncFromSyncIterator(r){function AsyncFromSyncIteratorContinuation(r){if(Object(r)!==r)return Promise.reject(new TypeError(r+" is not an object."));var n=r.done;return Promise.resolve(r.value).then((function(r){return{value:r,done:n}}))}return AsyncFromSyncIterator=function(r){this.s=r,this.n=r.next},AsyncFromSyncIterator.prototype={s:null,n:null,next:function(){return AsyncFromSyncIteratorContinuation(this.n.apply(this.s,arguments))},return:function(r){var n=this.s.return;return void 0===n?Promise.resolve({value:r,done:!0}):AsyncFromSyncIteratorContinuation(n.apply(this.s,arguments))},throw:function(r){var n=this.s.return;return void 0===n?Promise.reject(r):AsyncFromSyncIteratorContinuation(n.apply(this.s,arguments))}},new AsyncFromSyncIterator(r)}', {
      globals: ["Symbol", "TypeError", "Object", "Promise"],
      locals: {
        _asyncIterator: ["body.0.id"],
        AsyncFromSyncIterator: ["body.1.id", "body.0.body.body.1.body.body.1.consequent.argument.callee", "body.1.body.body.1.argument.expressions.1.left.object", "body.1.body.body.1.argument.expressions.2.callee", "body.1.body.body.1.argument.expressions.0.left"]
      },
      exportBindingAssignments: [],
      exportName: "_asyncIterator",
      dependencies: {},
      internal: false
    }),
    asyncToGenerator: helper$2("7.0.0-beta.0", 'function asyncGeneratorStep(n,t,e,r,o,a,c){try{var i=n[a](c),u=i.value}catch(n){return void e(n)}i.done?t(u):Promise.resolve(u).then(r,o)}function _asyncToGenerator(n){return function(){var t=this,e=arguments;return new Promise((function(r,o){var a=n.apply(t,e);function _next(n){asyncGeneratorStep(a,r,o,_next,_throw,"next",n)}function _throw(n){asyncGeneratorStep(a,r,o,_next,_throw,"throw",n)}_next(void 0)}))}}', {
      globals: ["Promise"],
      locals: {
        asyncGeneratorStep: ["body.0.id", "body.1.body.body.0.argument.body.body.1.argument.arguments.0.body.body.1.body.body.0.expression.callee", "body.1.body.body.0.argument.body.body.1.argument.arguments.0.body.body.2.body.body.0.expression.callee"],
        _asyncToGenerator: ["body.1.id"]
      },
      exportBindingAssignments: [],
      exportName: "_asyncToGenerator",
      dependencies: {},
      internal: false
    }),
    awaitAsyncGenerator: helper$2("7.0.0-beta.0", "function _awaitAsyncGenerator(e){return new OverloadYield(e,0)}", {
      globals: [],
      locals: {
        _awaitAsyncGenerator: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_awaitAsyncGenerator",
      dependencies: {
        OverloadYield: ["body.0.body.body.0.argument.callee"]
      },
      internal: false
    }),
    callSuper: helper$2("7.23.8", "function _callSuper(t,o,e){return o=getPrototypeOf(o),possibleConstructorReturn(t,isNativeReflectConstruct()?Reflect.construct(o,e||[],getPrototypeOf(t).constructor):o.apply(t,e))}", {
      globals: ["Reflect"],
      locals: {
        _callSuper: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_callSuper",
      dependencies: {
        getPrototypeOf: ["body.0.body.body.0.argument.expressions.0.right.callee", "body.0.body.body.0.argument.expressions.1.arguments.1.consequent.arguments.2.object.callee"],
        isNativeReflectConstruct: ["body.0.body.body.0.argument.expressions.1.arguments.1.test.callee"],
        possibleConstructorReturn: ["body.0.body.body.0.argument.expressions.1.callee"]
      },
      internal: false
    }),
    checkInRHS: helper$2("7.20.5", 'function _checkInRHS(e){if(Object(e)!==e)throw TypeError("right-hand side of \'in\' should be an object, got "+(null!==e?typeof e:"null"));return e}', {
      globals: ["Object", "TypeError"],
      locals: {
        _checkInRHS: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_checkInRHS",
      dependencies: {},
      internal: false
    }),
    checkPrivateRedeclaration: helper$2("7.14.1", 'function _checkPrivateRedeclaration(e,t){if(t.has(e))throw new TypeError("Cannot initialize the same private elements twice on an object")}', {
      globals: ["TypeError"],
      locals: {
        _checkPrivateRedeclaration: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_checkPrivateRedeclaration",
      dependencies: {},
      internal: false
    }),
    classCallCheck: helper$2("7.0.0-beta.0", 'function _classCallCheck(a,n){if(!(a instanceof n))throw new TypeError("Cannot call a class as a function")}', {
      globals: ["TypeError"],
      locals: {
        _classCallCheck: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classCallCheck",
      dependencies: {},
      internal: false
    }),
    classNameTDZError: helper$2("7.0.0-beta.0", "function _classNameTDZError(e){throw new ReferenceError('Class \"'+e+'\" cannot be referenced in computed property keys.')}", {
      globals: ["ReferenceError"],
      locals: {
        _classNameTDZError: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classNameTDZError",
      dependencies: {},
      internal: false
    }),
    classPrivateFieldGet2: helper$2("7.24.0", "function _classPrivateFieldGet2(s,a){return s.get(assertClassBrand(s,a))}", {
      globals: [],
      locals: {
        _classPrivateFieldGet2: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classPrivateFieldGet2",
      dependencies: {
        assertClassBrand: ["body.0.body.body.0.argument.arguments.0.callee"]
      },
      internal: false
    }),
    classPrivateFieldInitSpec: helper$2("7.14.1", "function _classPrivateFieldInitSpec(e,t,a){checkPrivateRedeclaration(e,t),t.set(e,a)}", {
      globals: [],
      locals: {
        _classPrivateFieldInitSpec: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classPrivateFieldInitSpec",
      dependencies: {
        checkPrivateRedeclaration: ["body.0.body.body.0.expression.expressions.0.callee"]
      },
      internal: false
    }),
    classPrivateFieldLooseBase: helper$2("7.0.0-beta.0", 'function _classPrivateFieldBase(e,t){if(!{}.hasOwnProperty.call(e,t))throw new TypeError("attempted to use private field on non-instance");return e}', {
      globals: ["TypeError"],
      locals: {
        _classPrivateFieldBase: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classPrivateFieldBase",
      dependencies: {},
      internal: false
    }),
    classPrivateFieldLooseKey: helper$2("7.0.0-beta.0", 'var id=0;function _classPrivateFieldKey(e){return"__private_"+id+++"_"+e}', {
      globals: [],
      locals: {
        id: ["body.0.declarations.0.id", "body.1.body.body.0.argument.left.left.right.argument", "body.1.body.body.0.argument.left.left.right.argument"],
        _classPrivateFieldKey: ["body.1.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classPrivateFieldKey",
      dependencies: {},
      internal: false
    }),
    classPrivateFieldSet2: helper$2("7.24.0", "function _classPrivateFieldSet2(s,a,r){return s.set(assertClassBrand(s,a),r),r}", {
      globals: [],
      locals: {
        _classPrivateFieldSet2: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classPrivateFieldSet2",
      dependencies: {
        assertClassBrand: ["body.0.body.body.0.argument.expressions.0.arguments.0.callee"]
      },
      internal: false
    }),
    classPrivateGetter: helper$2("7.24.0", "function _classPrivateGetter(s,r,a){return a(assertClassBrand(s,r))}", {
      globals: [],
      locals: {
        _classPrivateGetter: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classPrivateGetter",
      dependencies: {
        assertClassBrand: ["body.0.body.body.0.argument.arguments.0.callee"]
      },
      internal: false
    }),
    classPrivateMethodInitSpec: helper$2("7.14.1", "function _classPrivateMethodInitSpec(e,a){checkPrivateRedeclaration(e,a),a.add(e)}", {
      globals: [],
      locals: {
        _classPrivateMethodInitSpec: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classPrivateMethodInitSpec",
      dependencies: {
        checkPrivateRedeclaration: ["body.0.body.body.0.expression.expressions.0.callee"]
      },
      internal: false
    }),
    classPrivateSetter: helper$2("7.24.0", "function _classPrivateSetter(s,r,a,t){return r(assertClassBrand(s,a),t),t}", {
      globals: [],
      locals: {
        _classPrivateSetter: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classPrivateSetter",
      dependencies: {
        assertClassBrand: ["body.0.body.body.0.argument.expressions.0.arguments.0.callee"]
      },
      internal: false
    }),
    classStaticPrivateMethodGet: helper$2("7.3.2", "function _classStaticPrivateMethodGet(s,a,t){return assertClassBrand(a,s),t}", {
      globals: [],
      locals: {
        _classStaticPrivateMethodGet: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classStaticPrivateMethodGet",
      dependencies: {
        assertClassBrand: ["body.0.body.body.0.argument.expressions.0.callee"]
      },
      internal: false
    }),
    construct: helper$2("7.0.0-beta.0", "function _construct(t,e,r){if(isNativeReflectConstruct())return Reflect.construct.apply(null,arguments);var o=[null];o.push.apply(o,e);var p=new(t.bind.apply(t,o));return r&&setPrototypeOf(p,r.prototype),p}", {
      globals: ["Reflect"],
      locals: {
        _construct: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_construct",
      dependencies: {
        isNativeReflectConstruct: ["body.0.body.body.0.test.callee"],
        setPrototypeOf: ["body.0.body.body.4.argument.expressions.0.right.callee"]
      },
      internal: false
    }),
    createClass: helper$2("7.0.0-beta.0", 'function _defineProperties(e,r){for(var t=0;t<r.length;t++){var o=r[t];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,toPropertyKey(o.key),o)}}function _createClass(e,r,t){return r&&_defineProperties(e.prototype,r),t&&_defineProperties(e,t),Object.defineProperty(e,"prototype",{writable:!1}),e}', {
      globals: ["Object"],
      locals: {
        _defineProperties: ["body.0.id", "body.1.body.body.0.argument.expressions.0.right.callee", "body.1.body.body.0.argument.expressions.1.right.callee"],
        _createClass: ["body.1.id"]
      },
      exportBindingAssignments: [],
      exportName: "_createClass",
      dependencies: {
        toPropertyKey: ["body.0.body.body.0.body.body.1.expression.expressions.3.arguments.1.callee"]
      },
      internal: false
    }),
    createForOfIteratorHelper: helper$2("7.9.0", 'function _createForOfIteratorHelper(r,e){var t="undefined"!=typeof Symbol&&r[Symbol.iterator]||r["@@iterator"];if(!t){if(Array.isArray(r)||(t=unsupportedIterableToArray(r))||e&&r&&"number"==typeof r.length){t&&(r=t);var n=0,F=function(){};return{s:F,n:function(){return n>=r.length?{done:!0}:{done:!1,value:r[n++]}},e:function(r){throw r},f:F}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var o,a=!0,u=!1;return{s:function(){t=t.call(r)},n:function(){var r=t.next();return a=r.done,r},e:function(r){u=!0,o=r},f:function(){try{a||null==t.return||t.return()}finally{if(u)throw o}}}}', {
      globals: ["Symbol", "Array", "TypeError"],
      locals: {
        _createForOfIteratorHelper: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_createForOfIteratorHelper",
      dependencies: {
        unsupportedIterableToArray: ["body.0.body.body.1.consequent.body.0.test.left.right.right.callee"]
      },
      internal: false
    }),
    createForOfIteratorHelperLoose: helper$2("7.9.0", 'function _createForOfIteratorHelperLoose(r,e){var t="undefined"!=typeof Symbol&&r[Symbol.iterator]||r["@@iterator"];if(t)return(t=t.call(r)).next.bind(t);if(Array.isArray(r)||(t=unsupportedIterableToArray(r))||e&&r&&"number"==typeof r.length){t&&(r=t);var o=0;return function(){return o>=r.length?{done:!0}:{done:!1,value:r[o++]}}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}', {
      globals: ["Symbol", "Array", "TypeError"],
      locals: {
        _createForOfIteratorHelperLoose: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_createForOfIteratorHelperLoose",
      dependencies: {
        unsupportedIterableToArray: ["body.0.body.body.2.test.left.right.right.callee"]
      },
      internal: false
    }),
    createSuper: helper$2("7.9.0", "function _createSuper(t){var r=isNativeReflectConstruct();return function(){var e,o=getPrototypeOf(t);if(r){var s=getPrototypeOf(this).constructor;e=Reflect.construct(o,arguments,s)}else e=o.apply(this,arguments);return possibleConstructorReturn(this,e)}}", {
      globals: ["Reflect"],
      locals: {
        _createSuper: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_createSuper",
      dependencies: {
        getPrototypeOf: ["body.0.body.body.1.argument.body.body.0.declarations.1.init.callee", "body.0.body.body.1.argument.body.body.1.consequent.body.0.declarations.0.init.object.callee"],
        isNativeReflectConstruct: ["body.0.body.body.0.declarations.0.init.callee"],
        possibleConstructorReturn: ["body.0.body.body.1.argument.body.body.2.argument.callee"]
      },
      internal: false
    }),
    decorate: helper$2("7.1.5", 'function _decorate(e,r,t,i){var o=_getDecoratorsApi();if(i)for(var n=0;n<i.length;n++)o=i[n](o);var s=r((function(e){o.initializeInstanceElements(e,a.elements)}),t),a=o.decorateClass(_coalesceClassElements(s.d.map(_createElementDescriptor)),e);return o.initializeClassElements(s.F,a.elements),o.runClassFinishers(s.F,a.finishers)}function _getDecoratorsApi(){_getDecoratorsApi=function(){return e};var e={elementsDefinitionOrder:[["method"],["field"]],initializeInstanceElements:function(e,r){["method","field"].forEach((function(t){r.forEach((function(r){r.kind===t&&"own"===r.placement&&this.defineClassElement(e,r)}),this)}),this)},initializeClassElements:function(e,r){var t=e.prototype;["method","field"].forEach((function(i){r.forEach((function(r){var o=r.placement;if(r.kind===i&&("static"===o||"prototype"===o)){var n="static"===o?e:t;this.defineClassElement(n,r)}}),this)}),this)},defineClassElement:function(e,r){var t=r.descriptor;if("field"===r.kind){var i=r.initializer;t={enumerable:t.enumerable,writable:t.writable,configurable:t.configurable,value:void 0===i?void 0:i.call(e)}}Object.defineProperty(e,r.key,t)},decorateClass:function(e,r){var t=[],i=[],o={static:[],prototype:[],own:[]};if(e.forEach((function(e){this.addElementPlacement(e,o)}),this),e.forEach((function(e){if(!_hasDecorators(e))return t.push(e);var r=this.decorateElement(e,o);t.push(r.element),t.push.apply(t,r.extras),i.push.apply(i,r.finishers)}),this),!r)return{elements:t,finishers:i};var n=this.decorateConstructor(t,r);return i.push.apply(i,n.finishers),n.finishers=i,n},addElementPlacement:function(e,r,t){var i=r[e.placement];if(!t&&-1!==i.indexOf(e.key))throw new TypeError("Duplicated element ("+e.key+")");i.push(e.key)},decorateElement:function(e,r){for(var t=[],i=[],o=e.decorators,n=o.length-1;n>=0;n--){var s=r[e.placement];s.splice(s.indexOf(e.key),1);var a=this.fromElementDescriptor(e),l=this.toElementFinisherExtras((0,o[n])(a)||a);e=l.element,this.addElementPlacement(e,r),l.finisher&&i.push(l.finisher);var c=l.extras;if(c){for(var p=0;p<c.length;p++)this.addElementPlacement(c[p],r);t.push.apply(t,c)}}return{element:e,finishers:i,extras:t}},decorateConstructor:function(e,r){for(var t=[],i=r.length-1;i>=0;i--){var o=this.fromClassDescriptor(e),n=this.toClassDescriptor((0,r[i])(o)||o);if(void 0!==n.finisher&&t.push(n.finisher),void 0!==n.elements){e=n.elements;for(var s=0;s<e.length-1;s++)for(var a=s+1;a<e.length;a++)if(e[s].key===e[a].key&&e[s].placement===e[a].placement)throw new TypeError("Duplicated element ("+e[s].key+")")}}return{elements:e,finishers:t}},fromElementDescriptor:function(e){var r={kind:e.kind,key:e.key,placement:e.placement,descriptor:e.descriptor};return Object.defineProperty(r,Symbol.toStringTag,{value:"Descriptor",configurable:!0}),"field"===e.kind&&(r.initializer=e.initializer),r},toElementDescriptors:function(e){if(void 0!==e)return toArray(e).map((function(e){var r=this.toElementDescriptor(e);return this.disallowProperty(e,"finisher","An element descriptor"),this.disallowProperty(e,"extras","An element descriptor"),r}),this)},toElementDescriptor:function(e){var r=e.kind+"";if("method"!==r&&"field"!==r)throw new TypeError(\'An element descriptor\\\'s .kind property must be either "method" or "field", but a decorator created an element descriptor with .kind "\'+r+\'"\');var t=toPropertyKey(e.key),i=e.placement+"";if("static"!==i&&"prototype"!==i&&"own"!==i)throw new TypeError(\'An element descriptor\\\'s .placement property must be one of "static", "prototype" or "own", but a decorator created an element descriptor with .placement "\'+i+\'"\');var o=e.descriptor;this.disallowProperty(e,"elements","An element descriptor");var n={kind:r,key:t,placement:i,descriptor:Object.assign({},o)};return"field"!==r?this.disallowProperty(e,"initializer","A method descriptor"):(this.disallowProperty(o,"get","The property descriptor of a field descriptor"),this.disallowProperty(o,"set","The property descriptor of a field descriptor"),this.disallowProperty(o,"value","The property descriptor of a field descriptor"),n.initializer=e.initializer),n},toElementFinisherExtras:function(e){return{element:this.toElementDescriptor(e),finisher:_optionalCallableProperty(e,"finisher"),extras:this.toElementDescriptors(e.extras)}},fromClassDescriptor:function(e){var r={kind:"class",elements:e.map(this.fromElementDescriptor,this)};return Object.defineProperty(r,Symbol.toStringTag,{value:"Descriptor",configurable:!0}),r},toClassDescriptor:function(e){var r=e.kind+"";if("class"!==r)throw new TypeError(\'A class descriptor\\\'s .kind property must be "class", but a decorator created a class descriptor with .kind "\'+r+\'"\');this.disallowProperty(e,"key","A class descriptor"),this.disallowProperty(e,"placement","A class descriptor"),this.disallowProperty(e,"descriptor","A class descriptor"),this.disallowProperty(e,"initializer","A class descriptor"),this.disallowProperty(e,"extras","A class descriptor");var t=_optionalCallableProperty(e,"finisher");return{elements:this.toElementDescriptors(e.elements),finisher:t}},runClassFinishers:function(e,r){for(var t=0;t<r.length;t++){var i=(0,r[t])(e);if(void 0!==i){if("function"!=typeof i)throw new TypeError("Finishers must return a constructor.");e=i}}return e},disallowProperty:function(e,r,t){if(void 0!==e[r])throw new TypeError(t+" can\'t have a ."+r+" property.")}};return e}function _createElementDescriptor(e){var r,t=toPropertyKey(e.key);"method"===e.kind?r={value:e.value,writable:!0,configurable:!0,enumerable:!1}:"get"===e.kind?r={get:e.value,configurable:!0,enumerable:!1}:"set"===e.kind?r={set:e.value,configurable:!0,enumerable:!1}:"field"===e.kind&&(r={configurable:!0,writable:!0,enumerable:!0});var i={kind:"field"===e.kind?"field":"method",key:t,placement:e.static?"static":"field"===e.kind?"own":"prototype",descriptor:r};return e.decorators&&(i.decorators=e.decorators),"field"===e.kind&&(i.initializer=e.value),i}function _coalesceGetterSetter(e,r){void 0!==e.descriptor.get?r.descriptor.get=e.descriptor.get:r.descriptor.set=e.descriptor.set}function _coalesceClassElements(e){for(var r=[],isSameElement=function(e){return"method"===e.kind&&e.key===o.key&&e.placement===o.placement},t=0;t<e.length;t++){var i,o=e[t];if("method"===o.kind&&(i=r.find(isSameElement)))if(_isDataDescriptor(o.descriptor)||_isDataDescriptor(i.descriptor)){if(_hasDecorators(o)||_hasDecorators(i))throw new ReferenceError("Duplicated methods ("+o.key+") can\'t be decorated.");i.descriptor=o.descriptor}else{if(_hasDecorators(o)){if(_hasDecorators(i))throw new ReferenceError("Decorators can\'t be placed on different accessors with for the same property ("+o.key+").");i.decorators=o.decorators}_coalesceGetterSetter(o,i)}else r.push(o)}return r}function _hasDecorators(e){return e.decorators&&e.decorators.length}function _isDataDescriptor(e){return void 0!==e&&!(void 0===e.value&&void 0===e.writable)}function _optionalCallableProperty(e,r){var t=e[r];if(void 0!==t&&"function"!=typeof t)throw new TypeError("Expected \'"+r+"\' to be a function");return t}', {
      globals: ["Object", "TypeError", "Symbol", "ReferenceError"],
      locals: {
        _decorate: ["body.0.id"],
        _getDecoratorsApi: ["body.1.id", "body.0.body.body.0.declarations.0.init.callee", "body.1.body.body.0.expression.left"],
        _createElementDescriptor: ["body.2.id", "body.0.body.body.2.declarations.1.init.arguments.0.arguments.0.arguments.0"],
        _coalesceGetterSetter: ["body.3.id", "body.4.body.body.0.body.body.1.consequent.alternate.body.1.expression.callee"],
        _coalesceClassElements: ["body.4.id", "body.0.body.body.2.declarations.1.init.arguments.0.callee"],
        _hasDecorators: ["body.5.id", "body.1.body.body.1.declarations.0.init.properties.4.value.body.body.1.test.expressions.1.arguments.0.body.body.0.test.argument.callee", "body.4.body.body.0.body.body.1.consequent.consequent.body.0.test.left.callee", "body.4.body.body.0.body.body.1.consequent.consequent.body.0.test.right.callee", "body.4.body.body.0.body.body.1.consequent.alternate.body.0.test.callee", "body.4.body.body.0.body.body.1.consequent.alternate.body.0.consequent.body.0.test.callee"],
        _isDataDescriptor: ["body.6.id", "body.4.body.body.0.body.body.1.consequent.test.left.callee", "body.4.body.body.0.body.body.1.consequent.test.right.callee"],
        _optionalCallableProperty: ["body.7.id", "body.1.body.body.1.declarations.0.init.properties.11.value.body.body.0.argument.properties.1.value.callee", "body.1.body.body.1.declarations.0.init.properties.13.value.body.body.3.declarations.0.init.callee"]
      },
      exportBindingAssignments: [],
      exportName: "_decorate",
      dependencies: {
        toArray: ["body.1.body.body.1.declarations.0.init.properties.9.value.body.body.0.consequent.argument.callee.object.callee"],
        toPropertyKey: ["body.1.body.body.1.declarations.0.init.properties.10.value.body.body.2.declarations.0.init.callee", "body.2.body.body.0.declarations.1.init.callee"]
      },
      internal: false
    }),
    defaults: helper$2("7.0.0-beta.0", "function _defaults(e,r){for(var t=Object.getOwnPropertyNames(r),o=0;o<t.length;o++){var n=t[o],a=Object.getOwnPropertyDescriptor(r,n);a&&a.configurable&&void 0===e[n]&&Object.defineProperty(e,n,a)}return e}", {
      globals: ["Object"],
      locals: {
        _defaults: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_defaults",
      dependencies: {},
      internal: false
    }),
    defineAccessor: helper$2("7.20.7", "function _defineAccessor(e,r,n,t){var c={configurable:!0,enumerable:!0};return c[e]=t,Object.defineProperty(r,n,c)}", {
      globals: ["Object"],
      locals: {
        _defineAccessor: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_defineAccessor",
      dependencies: {},
      internal: false
    }),
    defineProperty: helper$2("7.0.0-beta.0", "function _defineProperty(e,r,t){return(r=toPropertyKey(r))in e?Object.defineProperty(e,r,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[r]=t,e}", {
      globals: ["Object"],
      locals: {
        _defineProperty: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_defineProperty",
      dependencies: {
        toPropertyKey: ["body.0.body.body.0.argument.expressions.0.test.left.right.callee"]
      },
      internal: false
    }),
    "extends": helper$2("7.0.0-beta.0", "function _extends(){return _extends=Object.assign?Object.assign.bind():function(n){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var r in t)({}).hasOwnProperty.call(t,r)&&(n[r]=t[r])}return n},_extends.apply(null,arguments)}", {
      globals: ["Object"],
      locals: {
        _extends: ["body.0.id", "body.0.body.body.0.argument.expressions.1.callee.object", "body.0.body.body.0.argument.expressions.0.left"]
      },
      exportBindingAssignments: ["body.0.body.body.0.argument.expressions.0"],
      exportName: "_extends",
      dependencies: {},
      internal: false
    }),
    get: helper$2("7.0.0-beta.0", 'function _get(){return _get="undefined"!=typeof Reflect&&Reflect.get?Reflect.get.bind():function(e,t,r){var p=superPropBase(e,t);if(p){var n=Object.getOwnPropertyDescriptor(p,t);return n.get?n.get.call(arguments.length<3?e:r):n.value}},_get.apply(null,arguments)}', {
      globals: ["Reflect", "Object"],
      locals: {
        _get: ["body.0.id", "body.0.body.body.0.argument.expressions.1.callee.object", "body.0.body.body.0.argument.expressions.0.left"]
      },
      exportBindingAssignments: ["body.0.body.body.0.argument.expressions.0"],
      exportName: "_get",
      dependencies: {
        superPropBase: ["body.0.body.body.0.argument.expressions.0.right.alternate.body.body.0.declarations.0.init.callee"]
      },
      internal: false
    }),
    getPrototypeOf: helper$2("7.0.0-beta.0", "function _getPrototypeOf(t){return _getPrototypeOf=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)},_getPrototypeOf(t)}", {
      globals: ["Object"],
      locals: {
        _getPrototypeOf: ["body.0.id", "body.0.body.body.0.argument.expressions.1.callee", "body.0.body.body.0.argument.expressions.0.left"]
      },
      exportBindingAssignments: ["body.0.body.body.0.argument.expressions.0"],
      exportName: "_getPrototypeOf",
      dependencies: {},
      internal: false
    }),
    identity: helper$2("7.17.0", "function _identity(t){return t}", {
      globals: [],
      locals: {
        _identity: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_identity",
      dependencies: {},
      internal: false
    }),
    importDeferProxy: helper$2("7.23.0", "function _importDeferProxy(e){var t=null,constValue=function(e){return function(){return e}},proxy=function(r){return function(n,o,f){return null===t&&(t=e()),r(t,o,f)}};return new Proxy({},{defineProperty:constValue(!1),deleteProperty:constValue(!1),get:proxy(Reflect.get),getOwnPropertyDescriptor:proxy(Reflect.getOwnPropertyDescriptor),getPrototypeOf:constValue(null),isExtensible:constValue(!1),has:proxy(Reflect.has),ownKeys:proxy(Reflect.ownKeys),preventExtensions:constValue(!0),set:constValue(!1),setPrototypeOf:constValue(!1)})}", {
      globals: ["Proxy", "Reflect"],
      locals: {
        _importDeferProxy: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_importDeferProxy",
      dependencies: {},
      internal: false
    }),
    inherits: helper$2("7.0.0-beta.0", 'function _inherits(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,"prototype",{writable:!1}),e&&setPrototypeOf(t,e)}', {
      globals: ["TypeError", "Object"],
      locals: {
        _inherits: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_inherits",
      dependencies: {
        setPrototypeOf: ["body.0.body.body.1.expression.expressions.2.right.callee"]
      },
      internal: false
    }),
    inheritsLoose: helper$2("7.0.0-beta.0", "function _inheritsLoose(t,o){t.prototype=Object.create(o.prototype),t.prototype.constructor=t,setPrototypeOf(t,o)}", {
      globals: ["Object"],
      locals: {
        _inheritsLoose: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_inheritsLoose",
      dependencies: {
        setPrototypeOf: ["body.0.body.body.0.expression.expressions.2.callee"]
      },
      internal: false
    }),
    initializerDefineProperty: helper$2("7.0.0-beta.0", "function _initializerDefineProperty(e,i,r,l){r&&Object.defineProperty(e,i,{enumerable:r.enumerable,configurable:r.configurable,writable:r.writable,value:r.initializer?r.initializer.call(l):void 0})}", {
      globals: ["Object"],
      locals: {
        _initializerDefineProperty: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_initializerDefineProperty",
      dependencies: {},
      internal: false
    }),
    initializerWarningHelper: helper$2("7.0.0-beta.0", 'function _initializerWarningHelper(r,e){throw Error("Decorating class property failed. Please ensure that transform-class-properties is enabled and runs after the decorators transform.")}', {
      globals: ["Error"],
      locals: {
        _initializerWarningHelper: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_initializerWarningHelper",
      dependencies: {},
      internal: false
    }),
    "instanceof": helper$2("7.0.0-beta.0", 'function _instanceof(n,e){return null!=e&&"undefined"!=typeof Symbol&&e[Symbol.hasInstance]?!!e[Symbol.hasInstance](n):n instanceof e}', {
      globals: ["Symbol"],
      locals: {
        _instanceof: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_instanceof",
      dependencies: {},
      internal: false
    }),
    interopRequireDefault: helper$2("7.0.0-beta.0", "function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}", {
      globals: [],
      locals: {
        _interopRequireDefault: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_interopRequireDefault",
      dependencies: {},
      internal: false
    }),
    interopRequireWildcard: helper$2("7.14.0", 'function _interopRequireWildcard(e,t){if("function"==typeof WeakMap)var r=new WeakMap,n=new WeakMap;return(_interopRequireWildcard=function(e,t){if(!t&&e&&e.__esModule)return e;var o,i,f={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return f;if(o=t?n:r){if(o.has(e))return o.get(e);o.set(e,f)}for(const t in e)"default"!==t&&{}.hasOwnProperty.call(e,t)&&((i=(o=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,t))&&(i.get||i.set)?o(f,t,i):f[t]=e[t]);return f})(e,t)}', {
      globals: ["WeakMap", "Object"],
      locals: {
        _interopRequireWildcard: ["body.0.id", "body.0.body.body.1.argument.callee.left"]
      },
      exportBindingAssignments: ["body.0.body.body.1.argument.callee"],
      exportName: "_interopRequireWildcard",
      dependencies: {},
      internal: false
    }),
    isNativeFunction: helper$2("7.0.0-beta.0", 'function _isNativeFunction(t){try{return-1!==Function.toString.call(t).indexOf("[native code]")}catch(n){return"function"==typeof t}}', {
      globals: ["Function"],
      locals: {
        _isNativeFunction: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_isNativeFunction",
      dependencies: {},
      internal: false
    }),
    isNativeReflectConstruct: helper$2("7.9.0", "function _isNativeReflectConstruct(){try{var t=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){})))}catch(t){}return(_isNativeReflectConstruct=function(){return!!t})()}", {
      globals: ["Boolean", "Reflect"],
      locals: {
        _isNativeReflectConstruct: ["body.0.id", "body.0.body.body.1.argument.callee.left"]
      },
      exportBindingAssignments: ["body.0.body.body.1.argument.callee"],
      exportName: "_isNativeReflectConstruct",
      dependencies: {},
      internal: false
    }),
    iterableToArray: helper$2("7.0.0-beta.0", 'function _iterableToArray(r){if("undefined"!=typeof Symbol&&null!=r[Symbol.iterator]||null!=r["@@iterator"])return Array.from(r)}', {
      globals: ["Symbol", "Array"],
      locals: {
        _iterableToArray: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_iterableToArray",
      dependencies: {},
      internal: false
    }),
    iterableToArrayLimit: helper$2("7.0.0-beta.0", 'function _iterableToArrayLimit(r,l){var t=null==r?null:"undefined"!=typeof Symbol&&r[Symbol.iterator]||r["@@iterator"];if(null!=t){var e,n,i,u,a=[],f=!0,o=!1;try{if(i=(t=t.call(r)).next,0===l){if(Object(t)!==t)return;f=!1}else for(;!(f=(e=i.call(t)).done)&&(a.push(e.value),a.length!==l);f=!0);}catch(r){o=!0,n=r}finally{try{if(!f&&null!=t.return&&(u=t.return(),Object(u)!==u))return}finally{if(o)throw n}}return a}}', {
      globals: ["Symbol", "Object"],
      locals: {
        _iterableToArrayLimit: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_iterableToArrayLimit",
      dependencies: {},
      internal: false
    }),
    jsx: helper$2("7.0.0-beta.0", 'var REACT_ELEMENT_TYPE;function _createRawReactElement(e,r,E,l){REACT_ELEMENT_TYPE||(REACT_ELEMENT_TYPE="function"==typeof Symbol&&Symbol.for&&Symbol.for("react.element")||60103);var o=e&&e.defaultProps,n=arguments.length-3;if(r||0===n||(r={children:void 0}),1===n)r.children=l;else if(n>1){for(var t=Array(n),f=0;f<n;f++)t[f]=arguments[f+3];r.children=t}if(r&&o)for(var i in o)void 0===r[i]&&(r[i]=o[i]);else r||(r=o||{});return{$$typeof:REACT_ELEMENT_TYPE,type:e,key:void 0===E?null:""+E,ref:null,props:r,_owner:null}}', {
      globals: ["Symbol", "Array"],
      locals: {
        REACT_ELEMENT_TYPE: ["body.0.declarations.0.id", "body.1.body.body.0.expression.left", "body.1.body.body.4.argument.properties.0.value", "body.1.body.body.0.expression.right.left"],
        _createRawReactElement: ["body.1.id"]
      },
      exportBindingAssignments: [],
      exportName: "_createRawReactElement",
      dependencies: {},
      internal: false
    }),
    maybeArrayLike: helper$2("7.9.0", 'function _maybeArrayLike(r,a,e){if(a&&!Array.isArray(a)&&"number"==typeof a.length){var y=a.length;return arrayLikeToArray(a,void 0!==e&&e<y?e:y)}return r(a,e)}', {
      globals: ["Array"],
      locals: {
        _maybeArrayLike: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_maybeArrayLike",
      dependencies: {
        arrayLikeToArray: ["body.0.body.body.0.consequent.body.1.argument.callee"]
      },
      internal: false
    }),
    newArrowCheck: helper$2("7.0.0-beta.0", 'function _newArrowCheck(n,r){if(n!==r)throw new TypeError("Cannot instantiate an arrow function")}', {
      globals: ["TypeError"],
      locals: {
        _newArrowCheck: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_newArrowCheck",
      dependencies: {},
      internal: false
    }),
    nonIterableRest: helper$2("7.0.0-beta.0", 'function _nonIterableRest(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}', {
      globals: ["TypeError"],
      locals: {
        _nonIterableRest: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_nonIterableRest",
      dependencies: {},
      internal: false
    }),
    nonIterableSpread: helper$2("7.0.0-beta.0", 'function _nonIterableSpread(){throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}', {
      globals: ["TypeError"],
      locals: {
        _nonIterableSpread: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_nonIterableSpread",
      dependencies: {},
      internal: false
    }),
    nullishReceiverError: helper$2("7.22.6", 'function _nullishReceiverError(r){throw new TypeError("Cannot set property of null or undefined.")}', {
      globals: ["TypeError"],
      locals: {
        _nullishReceiverError: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_nullishReceiverError",
      dependencies: {},
      internal: false
    }),
    objectDestructuringEmpty: helper$2("7.0.0-beta.0", 'function _objectDestructuringEmpty(t){if(null==t)throw new TypeError("Cannot destructure "+t)}', {
      globals: ["TypeError"],
      locals: {
        _objectDestructuringEmpty: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_objectDestructuringEmpty",
      dependencies: {},
      internal: false
    }),
    objectSpread2: helper$2("7.5.0", "function ownKeys(e,r){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);r&&(o=o.filter((function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable}))),t.push.apply(t,o)}return t}function _objectSpread2(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?arguments[r]:{};r%2?ownKeys(Object(t),!0).forEach((function(r){defineProperty(e,r,t[r])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):ownKeys(Object(t)).forEach((function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(t,r))}))}return e}", {
      globals: ["Object"],
      locals: {
        ownKeys: ["body.0.id", "body.1.body.body.0.body.body.1.expression.consequent.callee.object.callee", "body.1.body.body.0.body.body.1.expression.alternate.alternate.callee.object.callee"],
        _objectSpread2: ["body.1.id"]
      },
      exportBindingAssignments: [],
      exportName: "_objectSpread2",
      dependencies: {
        defineProperty: ["body.1.body.body.0.body.body.1.expression.consequent.arguments.0.body.body.0.expression.callee"]
      },
      internal: false
    }),
    objectWithoutProperties: helper$2("7.0.0-beta.0", "function _objectWithoutProperties(e,t){if(null==e)return{};var o,r,i=objectWithoutPropertiesLoose(e,t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);for(r=0;r<n.length;r++)o=n[r],-1===t.indexOf(o)&&{}.propertyIsEnumerable.call(e,o)&&(i[o]=e[o])}return i}", {
      globals: ["Object"],
      locals: {
        _objectWithoutProperties: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_objectWithoutProperties",
      dependencies: {
        objectWithoutPropertiesLoose: ["body.0.body.body.1.declarations.2.init.callee"]
      },
      internal: false
    }),
    objectWithoutPropertiesLoose: helper$2("7.0.0-beta.0", "function _objectWithoutPropertiesLoose(r,e){if(null==r)return{};var t={};for(var n in r)if({}.hasOwnProperty.call(r,n)){if(-1!==e.indexOf(n))continue;t[n]=r[n]}return t}", {
      globals: [],
      locals: {
        _objectWithoutPropertiesLoose: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_objectWithoutPropertiesLoose",
      dependencies: {},
      internal: false
    }),
    possibleConstructorReturn: helper$2("7.0.0-beta.0", 'function _possibleConstructorReturn(t,e){if(e&&("object"==typeof e||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return assertThisInitialized(t)}', {
      globals: ["TypeError"],
      locals: {
        _possibleConstructorReturn: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_possibleConstructorReturn",
      dependencies: {
        assertThisInitialized: ["body.0.body.body.2.argument.callee"]
      },
      internal: false
    }),
    readOnlyError: helper$2("7.0.0-beta.0", "function _readOnlyError(r){throw new TypeError('\"'+r+'\" is read-only')}", {
      globals: ["TypeError"],
      locals: {
        _readOnlyError: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_readOnlyError",
      dependencies: {},
      internal: false
    }),
    regenerator: helper$2("7.27.0", 'function _regenerator(){\n/*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */\nvar e,t,r="function"==typeof Symbol?Symbol:{},n=r.iterator||"@@iterator",o=r.toStringTag||"@@toStringTag";function i(r,n,o,i){var c=n&&n.prototype instanceof Generator?n:Generator,u=Object.create(c.prototype);return define(u,"_invoke",function(r,n,o){var i,c,u,f=0,p=o||[],y=!1,G={p:0,n:0,v:e,a:d,f:d.bind(e,4),d:function(t,r){return i=t,c=0,u=e,G.n=r,a}};function d(r,n){for(c=r,u=n,t=0;!y&&f&&!o&&t<p.length;t++){var o,i=p[t],d=G.p,l=i[2];r>3?(o=l===n)&&(u=i[(c=i[4])?5:(c=3,3)],i[4]=i[5]=e):i[0]<=d&&((o=r<2&&d<i[1])?(c=0,G.v=n,G.n=i[1]):d<l&&(o=r<3||i[0]>n||n>l)&&(i[4]=r,i[5]=n,G.n=l,c=0))}if(o||r>1)return a;throw y=!0,n}return function(o,p,l){if(f>1)throw TypeError("Generator is already running");for(y&&1===p&&d(p,l),c=p,u=l;(t=c<2?e:u)||!y;){i||(c?c<3?(c>1&&(G.n=-1),d(c,u)):G.n=u:G.v=u);try{if(f=2,i){if(c||(o="next"),t=i[o]){if(!(t=t.call(i,u)))throw TypeError("iterator result is not an object");if(!t.done)return t;u=t.value,c<2&&(c=0)}else 1===c&&(t=i.return)&&t.call(i),c<2&&(u=TypeError("The iterator does not provide a \'"+o+"\' method"),c=1);i=e}else if((t=(y=G.n<0)?u:r.call(n,G))!==a)break}catch(t){i=e,c=1,u=t}finally{f=1}}return{value:t,done:y}}}(r,o,i),!0),u}var a={};function Generator(){}function GeneratorFunction(){}function GeneratorFunctionPrototype(){}t=Object.getPrototypeOf;var c=[][n]?t(t([][n]())):(define(t={},n,(function(){return this})),t),u=GeneratorFunctionPrototype.prototype=Generator.prototype=Object.create(c);function f(e){return Object.setPrototypeOf?Object.setPrototypeOf(e,GeneratorFunctionPrototype):(e.__proto__=GeneratorFunctionPrototype,define(e,o,"GeneratorFunction")),e.prototype=Object.create(u),e}return GeneratorFunction.prototype=GeneratorFunctionPrototype,define(u,"constructor",GeneratorFunctionPrototype),define(GeneratorFunctionPrototype,"constructor",GeneratorFunction),GeneratorFunction.displayName="GeneratorFunction",define(GeneratorFunctionPrototype,o,"GeneratorFunction"),define(u),define(u,o,"Generator"),define(u,n,(function(){return this})),define(u,"toString",(function(){return"[object Generator]"})),(_regenerator=function(){return{w:i,m:f}})()}', {
      globals: ["Symbol", "Object", "TypeError"],
      locals: {
        _regenerator: ["body.0.id", "body.0.body.body.9.argument.expressions.9.callee.left"]
      },
      exportBindingAssignments: ["body.0.body.body.9.argument.expressions.9.callee"],
      exportName: "_regenerator",
      dependencies: {
        regeneratorDefine: ["body.0.body.body.1.body.body.1.argument.expressions.0.callee", "body.0.body.body.7.declarations.0.init.alternate.expressions.0.callee", "body.0.body.body.8.body.body.0.argument.expressions.0.alternate.expressions.1.callee", "body.0.body.body.9.argument.expressions.1.callee", "body.0.body.body.9.argument.expressions.2.callee", "body.0.body.body.9.argument.expressions.4.callee", "body.0.body.body.9.argument.expressions.5.callee", "body.0.body.body.9.argument.expressions.6.callee", "body.0.body.body.9.argument.expressions.7.callee", "body.0.body.body.9.argument.expressions.8.callee"]
      },
      internal: false
    }),
    regeneratorAsync: helper$2("7.27.0", "function _regeneratorAsync(n,e,r,t,o){var a=asyncGen(n,e,r,t,o);return a.next().then((function(n){return n.done?n.value:a.next()}))}", {
      globals: [],
      locals: {
        _regeneratorAsync: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_regeneratorAsync",
      dependencies: {
        regeneratorAsyncGen: ["body.0.body.body.0.declarations.0.init.callee"]
      },
      internal: false
    }),
    regeneratorAsyncGen: helper$2("7.27.0", "function _regeneratorAsyncGen(r,e,t,o,n){return new regeneratorAsyncIterator(regenerator().w(r,e,t,o),n||Promise)}", {
      globals: ["Promise"],
      locals: {
        _regeneratorAsyncGen: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_regeneratorAsyncGen",
      dependencies: {
        regenerator: ["body.0.body.body.0.argument.arguments.0.callee.object.callee"],
        regeneratorAsyncIterator: ["body.0.body.body.0.argument.callee"]
      },
      internal: false
    }),
    regeneratorAsyncIterator: helper$2("7.27.0", 'function AsyncIterator(t,e){function n(r,o,i,f){try{var c=t[r](o),u=c.value;return u instanceof OverloadYield?e.resolve(u.v).then((function(t){n("next",t,i,f)}),(function(t){n("throw",t,i,f)})):e.resolve(u).then((function(t){c.value=t,i(c)}),(function(t){return n("throw",t,i,f)}))}catch(t){f(t)}}var r;this.next||(define(AsyncIterator.prototype),define(AsyncIterator.prototype,"function"==typeof Symbol&&Symbol.asyncIterator||"@asyncIterator",(function(){return this}))),define(this,"_invoke",(function(t,o,i){function f(){return new e((function(e,r){n(t,i,e,r)}))}return r=r?r.then(f,f):f()}),!0)}', {
      globals: ["Symbol"],
      locals: {
        AsyncIterator: ["body.0.id", "body.0.body.body.2.expression.expressions.0.right.expressions.0.arguments.0.object", "body.0.body.body.2.expression.expressions.0.right.expressions.1.arguments.0.object"]
      },
      exportBindingAssignments: [],
      exportName: "AsyncIterator",
      dependencies: {
        OverloadYield: ["body.0.body.body.0.body.body.0.block.body.1.argument.test.right"],
        regeneratorDefine: ["body.0.body.body.2.expression.expressions.0.right.expressions.0.callee", "body.0.body.body.2.expression.expressions.0.right.expressions.1.callee", "body.0.body.body.2.expression.expressions.1.callee"]
      },
      internal: true
    }),
    regeneratorDefine: helper$2("7.27.0", 'function regeneratorDefine(e,r,n,t){var i=Object.defineProperty;try{i({},"",{})}catch(e){i=0}regeneratorDefine=function(e,r,n,t){if(r)i?i(e,r,{value:n,enumerable:!t,configurable:!t,writable:!t}):e[r]=n;else{function o(r,n){regeneratorDefine(e,r,(function(e){return this._invoke(r,n,e)}))}o("next",0),o("throw",1),o("return",2)}},regeneratorDefine(e,r,n,t)}', {
      globals: ["Object"],
      locals: {
        regeneratorDefine: ["body.0.id", "body.0.body.body.2.expression.expressions.0.right.body.body.0.alternate.body.0.body.body.0.expression.callee", "body.0.body.body.2.expression.expressions.1.callee", "body.0.body.body.2.expression.expressions.0.left"]
      },
      exportBindingAssignments: ["body.0.body.body.2.expression.expressions.0"],
      exportName: "regeneratorDefine",
      dependencies: {},
      internal: true
    }),
    regeneratorKeys: helper$2("7.27.0", "function _regeneratorKeys(e){var n=Object(e),r=[];for(var t in n)r.unshift(t);return function e(){for(;r.length;)if((t=r.pop())in n)return e.value=t,e.done=!1,e;return e.done=!0,e}}", {
      globals: ["Object"],
      locals: {
        _regeneratorKeys: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_regeneratorKeys",
      dependencies: {},
      internal: false
    }),
    regeneratorValues: helper$2("7.18.0", 'function _regeneratorValues(e){if(null!=e){var t=e["function"==typeof Symbol&&Symbol.iterator||"@@iterator"],r=0;if(t)return t.call(e);if("function"==typeof e.next)return e;if(!isNaN(e.length))return{next:function(){return e&&r>=e.length&&(e=void 0),{value:e&&e[r++],done:!e}}}}throw new TypeError(typeof e+" is not iterable")}', {
      globals: ["Symbol", "isNaN", "TypeError"],
      locals: {
        _regeneratorValues: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_regeneratorValues",
      dependencies: {},
      internal: false
    }),
    set: helper$2("7.0.0-beta.0", 'function set(e,r,t,o){return set="undefined"!=typeof Reflect&&Reflect.set?Reflect.set:function(e,r,t,o){var f,i=superPropBase(e,r);if(i){if((f=Object.getOwnPropertyDescriptor(i,r)).set)return f.set.call(o,t),!0;if(!f.writable)return!1}if(f=Object.getOwnPropertyDescriptor(o,r)){if(!f.writable)return!1;f.value=t,Object.defineProperty(o,r,f)}else defineProperty(o,r,t);return!0},set(e,r,t,o)}function _set(e,r,t,o,f){if(!set(e,r,t,o||e)&&f)throw new TypeError("failed to set property");return t}', {
      globals: ["Reflect", "Object", "TypeError"],
      locals: {
        set: ["body.0.id", "body.0.body.body.0.argument.expressions.1.callee", "body.1.body.body.0.test.left.argument.callee", "body.0.body.body.0.argument.expressions.0.left"],
        _set: ["body.1.id"]
      },
      exportBindingAssignments: [],
      exportName: "_set",
      dependencies: {
        superPropBase: ["body.0.body.body.0.argument.expressions.0.right.alternate.body.body.0.declarations.1.init.callee"],
        defineProperty: ["body.0.body.body.0.argument.expressions.0.right.alternate.body.body.2.alternate.expression.callee"]
      },
      internal: false
    }),
    setFunctionName: helper$2("7.23.6", 'function setFunctionName(e,t,n){"symbol"==typeof t&&(t=(t=t.description)?"["+t+"]":"");try{Object.defineProperty(e,"name",{configurable:!0,value:n?n+" "+t:t})}catch(e){}return e}', {
      globals: ["Object"],
      locals: {
        setFunctionName: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "setFunctionName",
      dependencies: {},
      internal: false
    }),
    setPrototypeOf: helper$2("7.0.0-beta.0", "function _setPrototypeOf(t,e){return _setPrototypeOf=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t},_setPrototypeOf(t,e)}", {
      globals: ["Object"],
      locals: {
        _setPrototypeOf: ["body.0.id", "body.0.body.body.0.argument.expressions.1.callee", "body.0.body.body.0.argument.expressions.0.left"]
      },
      exportBindingAssignments: ["body.0.body.body.0.argument.expressions.0"],
      exportName: "_setPrototypeOf",
      dependencies: {},
      internal: false
    }),
    skipFirstGeneratorNext: helper$2("7.0.0-beta.0", "function _skipFirstGeneratorNext(t){return function(){var r=t.apply(this,arguments);return r.next(),r}}", {
      globals: [],
      locals: {
        _skipFirstGeneratorNext: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_skipFirstGeneratorNext",
      dependencies: {},
      internal: false
    }),
    slicedToArray: helper$2("7.0.0-beta.0", "function _slicedToArray(r,e){return arrayWithHoles(r)||iterableToArrayLimit(r,e)||unsupportedIterableToArray(r,e)||nonIterableRest()}", {
      globals: [],
      locals: {
        _slicedToArray: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_slicedToArray",
      dependencies: {
        arrayWithHoles: ["body.0.body.body.0.argument.left.left.left.callee"],
        iterableToArrayLimit: ["body.0.body.body.0.argument.left.left.right.callee"],
        unsupportedIterableToArray: ["body.0.body.body.0.argument.left.right.callee"],
        nonIterableRest: ["body.0.body.body.0.argument.right.callee"]
      },
      internal: false
    }),
    superPropBase: helper$2("7.0.0-beta.0", "function _superPropBase(t,o){for(;!{}.hasOwnProperty.call(t,o)&&null!==(t=getPrototypeOf(t)););return t}", {
      globals: [],
      locals: {
        _superPropBase: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_superPropBase",
      dependencies: {
        getPrototypeOf: ["body.0.body.body.0.test.right.right.right.callee"]
      },
      internal: false
    }),
    superPropGet: helper$2("7.25.0", 'function _superPropGet(t,o,e,r){var p=get(getPrototypeOf(1&r?t.prototype:t),o,e);return 2&r&&"function"==typeof p?function(t){return p.apply(e,t)}:p}', {
      globals: [],
      locals: {
        _superPropGet: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_superPropGet",
      dependencies: {
        get: ["body.0.body.body.0.declarations.0.init.callee"],
        getPrototypeOf: ["body.0.body.body.0.declarations.0.init.arguments.0.callee"]
      },
      internal: false
    }),
    superPropSet: helper$2("7.25.0", "function _superPropSet(t,e,o,r,p,f){return set(getPrototypeOf(f?t.prototype:t),e,o,r,p)}", {
      globals: [],
      locals: {
        _superPropSet: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_superPropSet",
      dependencies: {
        set: ["body.0.body.body.0.argument.callee"],
        getPrototypeOf: ["body.0.body.body.0.argument.arguments.0.callee"]
      },
      internal: false
    }),
    taggedTemplateLiteral: helper$2("7.0.0-beta.0", "function _taggedTemplateLiteral(e,t){return t||(t=e.slice(0)),Object.freeze(Object.defineProperties(e,{raw:{value:Object.freeze(t)}}))}", {
      globals: ["Object"],
      locals: {
        _taggedTemplateLiteral: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_taggedTemplateLiteral",
      dependencies: {},
      internal: false
    }),
    taggedTemplateLiteralLoose: helper$2("7.0.0-beta.0", "function _taggedTemplateLiteralLoose(e,t){return t||(t=e.slice(0)),e.raw=t,e}", {
      globals: [],
      locals: {
        _taggedTemplateLiteralLoose: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_taggedTemplateLiteralLoose",
      dependencies: {},
      internal: false
    }),
    tdz: helper$2("7.5.5", 'function _tdzError(e){throw new ReferenceError(e+" is not defined - temporal dead zone")}', {
      globals: ["ReferenceError"],
      locals: {
        _tdzError: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_tdzError",
      dependencies: {},
      internal: false
    }),
    temporalRef: helper$2("7.0.0-beta.0", "function _temporalRef(r,e){return r===undef?err(e):r}", {
      globals: [],
      locals: {
        _temporalRef: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_temporalRef",
      dependencies: {
        temporalUndefined: ["body.0.body.body.0.argument.test.right"],
        tdz: ["body.0.body.body.0.argument.consequent.callee"]
      },
      internal: false
    }),
    temporalUndefined: helper$2("7.0.0-beta.0", "function _temporalUndefined(){}", {
      globals: [],
      locals: {
        _temporalUndefined: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_temporalUndefined",
      dependencies: {},
      internal: false
    }),
    toArray: helper$2("7.0.0-beta.0", "function _toArray(r){return arrayWithHoles(r)||iterableToArray(r)||unsupportedIterableToArray(r)||nonIterableRest()}", {
      globals: [],
      locals: {
        _toArray: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_toArray",
      dependencies: {
        arrayWithHoles: ["body.0.body.body.0.argument.left.left.left.callee"],
        iterableToArray: ["body.0.body.body.0.argument.left.left.right.callee"],
        unsupportedIterableToArray: ["body.0.body.body.0.argument.left.right.callee"],
        nonIterableRest: ["body.0.body.body.0.argument.right.callee"]
      },
      internal: false
    }),
    toConsumableArray: helper$2("7.0.0-beta.0", "function _toConsumableArray(r){return arrayWithoutHoles(r)||iterableToArray(r)||unsupportedIterableToArray(r)||nonIterableSpread()}", {
      globals: [],
      locals: {
        _toConsumableArray: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_toConsumableArray",
      dependencies: {
        arrayWithoutHoles: ["body.0.body.body.0.argument.left.left.left.callee"],
        iterableToArray: ["body.0.body.body.0.argument.left.left.right.callee"],
        unsupportedIterableToArray: ["body.0.body.body.0.argument.left.right.callee"],
        nonIterableSpread: ["body.0.body.body.0.argument.right.callee"]
      },
      internal: false
    }),
    toPrimitive: helper$2("7.1.5", 'function toPrimitive(t,r){if("object"!=typeof t||!t)return t;var e=t[Symbol.toPrimitive];if(void 0!==e){var i=e.call(t,r||"default");if("object"!=typeof i)return i;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===r?String:Number)(t)}', {
      globals: ["Symbol", "TypeError", "String", "Number"],
      locals: {
        toPrimitive: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "toPrimitive",
      dependencies: {},
      internal: false
    }),
    toPropertyKey: helper$2("7.1.5", 'function toPropertyKey(t){var i=toPrimitive(t,"string");return"symbol"==typeof i?i:i+""}', {
      globals: [],
      locals: {
        toPropertyKey: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "toPropertyKey",
      dependencies: {
        toPrimitive: ["body.0.body.body.0.declarations.0.init.callee"]
      },
      internal: false
    }),
    toSetter: helper$2("7.24.0", 'function _toSetter(t,e,n){e||(e=[]);var r=e.length++;return Object.defineProperty({},"_",{set:function(o){e[r]=o,t.apply(n,e)}})}', {
      globals: ["Object"],
      locals: {
        _toSetter: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_toSetter",
      dependencies: {},
      internal: false
    }),
    tsRewriteRelativeImportExtensions: helper$2("7.27.0", 'function tsRewriteRelativeImportExtensions(t,e){return"string"==typeof t&&/^\\.\\.?\\//.test(t)?t.replace(/\\.(tsx)$|((?:\\.d)?)((?:\\.[^./]+)?)\\.([cm]?)ts$/i,(function(t,s,r,n,o){return s?e?".jsx":".js":!r||n&&o?r+n+"."+o.toLowerCase()+"js":t})):t}', {
      globals: [],
      locals: {
        tsRewriteRelativeImportExtensions: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "tsRewriteRelativeImportExtensions",
      dependencies: {},
      internal: false
    }),
    "typeof": helper$2("7.0.0-beta.0", 'function _typeof(o){"@babel/helpers - typeof";return _typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(o){return typeof o}:function(o){return o&&"function"==typeof Symbol&&o.constructor===Symbol&&o!==Symbol.prototype?"symbol":typeof o},_typeof(o)}', {
      globals: ["Symbol"],
      locals: {
        _typeof: ["body.0.id", "body.0.body.body.0.argument.expressions.1.callee", "body.0.body.body.0.argument.expressions.0.left"]
      },
      exportBindingAssignments: ["body.0.body.body.0.argument.expressions.0"],
      exportName: "_typeof",
      dependencies: {},
      internal: false
    }),
    unsupportedIterableToArray: helper$2("7.9.0", 'function _unsupportedIterableToArray(r,a){if(r){if("string"==typeof r)return arrayLikeToArray(r,a);var t={}.toString.call(r).slice(8,-1);return"Object"===t&&r.constructor&&(t=r.constructor.name),"Map"===t||"Set"===t?Array.from(r):"Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)?arrayLikeToArray(r,a):void 0}}', {
      globals: ["Array"],
      locals: {
        _unsupportedIterableToArray: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_unsupportedIterableToArray",
      dependencies: {
        arrayLikeToArray: ["body.0.body.body.0.consequent.body.0.consequent.argument.callee", "body.0.body.body.0.consequent.body.2.argument.expressions.1.alternate.consequent.callee"]
      },
      internal: false
    }),
    usingCtx: helper$2("7.23.9", 'function _usingCtx(){var r="function"==typeof SuppressedError?SuppressedError:function(r,e){var n=Error();return n.name="SuppressedError",n.error=r,n.suppressed=e,n},e={},n=[];function using(r,e){if(null!=e){if(Object(e)!==e)throw new TypeError("using declarations can only be used with objects, functions, null, or undefined.");if(r)var o=e[Symbol.asyncDispose||Symbol.for("Symbol.asyncDispose")];if(void 0===o&&(o=e[Symbol.dispose||Symbol.for("Symbol.dispose")],r))var t=o;if("function"!=typeof o)throw new TypeError("Object is not disposable.");t&&(o=function(){try{t.call(e)}catch(r){return Promise.reject(r)}}),n.push({v:e,d:o,a:r})}else r&&n.push({d:e,a:r});return e}return{e:e,u:using.bind(null,!1),a:using.bind(null,!0),d:function(){var o,t=this.e,s=0;function next(){for(;o=n.pop();)try{if(!o.a&&1===s)return s=0,n.push(o),Promise.resolve().then(next);if(o.d){var r=o.d.call(o.v);if(o.a)return s|=2,Promise.resolve(r).then(next,err)}else s|=1}catch(r){return err(r)}if(1===s)return t!==e?Promise.reject(t):Promise.resolve();if(t!==e)throw t}function err(n){return t=t!==e?new r(n,t):n,next()}return next()}}}', {
      globals: ["SuppressedError", "Error", "Object", "TypeError", "Symbol", "Promise"],
      locals: {
        _usingCtx: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_usingCtx",
      dependencies: {},
      internal: false
    }),
    wrapAsyncGenerator: helper$2("7.0.0-beta.0", 'function _wrapAsyncGenerator(e){return function(){return new AsyncGenerator(e.apply(this,arguments))}}function AsyncGenerator(e){var r,t;function resume(r,t){try{var n=e[r](t),o=n.value,u=o instanceof OverloadYield;Promise.resolve(u?o.v:o).then((function(t){if(u){var i="return"===r?"return":"next";if(!o.k||t.done)return resume(i,t);t=e[i](t).value}settle(n.done?"return":"normal",t)}),(function(e){resume("throw",e)}))}catch(e){settle("throw",e)}}function settle(e,n){switch(e){case"return":r.resolve({value:n,done:!0});break;case"throw":r.reject(n);break;default:r.resolve({value:n,done:!1})}(r=r.next)?resume(r.key,r.arg):t=null}this._invoke=function(e,n){return new Promise((function(o,u){var i={key:e,arg:n,resolve:o,reject:u,next:null};t?t=t.next=i:(r=t=i,resume(e,n))}))},"function"!=typeof e.return&&(this.return=void 0)}AsyncGenerator.prototype["function"==typeof Symbol&&Symbol.asyncIterator||"@@asyncIterator"]=function(){return this},AsyncGenerator.prototype.next=function(e){return this._invoke("next",e)},AsyncGenerator.prototype.throw=function(e){return this._invoke("throw",e)},AsyncGenerator.prototype.return=function(e){return this._invoke("return",e)};', {
      globals: ["Promise", "Symbol"],
      locals: {
        _wrapAsyncGenerator: ["body.0.id"],
        AsyncGenerator: ["body.1.id", "body.0.body.body.0.argument.body.body.0.argument.callee", "body.2.expression.expressions.0.left.object.object", "body.2.expression.expressions.1.left.object.object", "body.2.expression.expressions.2.left.object.object", "body.2.expression.expressions.3.left.object.object"]
      },
      exportBindingAssignments: [],
      exportName: "_wrapAsyncGenerator",
      dependencies: {
        OverloadYield: ["body.1.body.body.1.body.body.0.block.body.0.declarations.2.init.right"]
      },
      internal: false
    }),
    wrapNativeSuper: helper$2("7.0.0-beta.0", 'function _wrapNativeSuper(t){var r="function"==typeof Map?new Map:void 0;return _wrapNativeSuper=function(t){if(null===t||!isNativeFunction(t))return t;if("function"!=typeof t)throw new TypeError("Super expression must either be null or a function");if(void 0!==r){if(r.has(t))return r.get(t);r.set(t,Wrapper)}function Wrapper(){return construct(t,arguments,getPrototypeOf(this).constructor)}return Wrapper.prototype=Object.create(t.prototype,{constructor:{value:Wrapper,enumerable:!1,writable:!0,configurable:!0}}),setPrototypeOf(Wrapper,t)},_wrapNativeSuper(t)}', {
      globals: ["Map", "TypeError", "Object"],
      locals: {
        _wrapNativeSuper: ["body.0.id", "body.0.body.body.1.argument.expressions.1.callee", "body.0.body.body.1.argument.expressions.0.left"]
      },
      exportBindingAssignments: ["body.0.body.body.1.argument.expressions.0"],
      exportName: "_wrapNativeSuper",
      dependencies: {
        getPrototypeOf: ["body.0.body.body.1.argument.expressions.0.right.body.body.3.body.body.0.argument.arguments.2.object.callee"],
        setPrototypeOf: ["body.0.body.body.1.argument.expressions.0.right.body.body.4.argument.expressions.1.callee"],
        isNativeFunction: ["body.0.body.body.1.argument.expressions.0.right.body.body.0.test.right.argument.callee"],
        construct: ["body.0.body.body.1.argument.expressions.0.right.body.body.3.body.body.0.argument.callee"]
      },
      internal: false
    }),
    wrapRegExp: helper$2("7.19.0", 'function _wrapRegExp(){_wrapRegExp=function(e,r){return new BabelRegExp(e,void 0,r)};var e=RegExp.prototype,r=new WeakMap;function BabelRegExp(e,t,p){var o=RegExp(e,t);return r.set(o,p||r.get(e)),setPrototypeOf(o,BabelRegExp.prototype)}function buildGroups(e,t){var p=r.get(t);return Object.keys(p).reduce((function(r,t){var o=p[t];if("number"==typeof o)r[t]=e[o];else{for(var i=0;void 0===e[o[i]]&&i+1<o.length;)i++;r[t]=e[o[i]]}return r}),Object.create(null))}return inherits(BabelRegExp,RegExp),BabelRegExp.prototype.exec=function(r){var t=e.exec.call(this,r);if(t){t.groups=buildGroups(t,this);var p=t.indices;p&&(p.groups=buildGroups(p,this))}return t},BabelRegExp.prototype[Symbol.replace]=function(t,p){if("string"==typeof p){var o=r.get(this);return e[Symbol.replace].call(this,t,p.replace(/\\$<([^>]+)(>|$)/g,(function(e,r,t){if(""===t)return e;var p=o[r];return Array.isArray(p)?"$"+p.join("$"):"number"==typeof p?"$"+p:""})))}if("function"==typeof p){var i=this;return e[Symbol.replace].call(this,t,(function(){var e=arguments;return"object"!=typeof e[e.length-1]&&(e=[].slice.call(e)).push(buildGroups(e,i)),p.apply(this,e)}))}return e[Symbol.replace].call(this,t,p)},_wrapRegExp.apply(this,arguments)}', {
      globals: ["RegExp", "WeakMap", "Object", "Symbol", "Array"],
      locals: {
        _wrapRegExp: ["body.0.id", "body.0.body.body.4.argument.expressions.3.callee.object", "body.0.body.body.0.expression.left"]
      },
      exportBindingAssignments: ["body.0.body.body.0.expression"],
      exportName: "_wrapRegExp",
      dependencies: {
        setPrototypeOf: ["body.0.body.body.2.body.body.1.argument.expressions.1.callee"],
        inherits: ["body.0.body.body.4.argument.expressions.0.callee"]
      },
      internal: false
    }),
    writeOnlyError: helper$2("7.12.13", "function _writeOnlyError(r){throw new TypeError('\"'+r+'\" is write-only')}", {
      globals: ["TypeError"],
      locals: {
        _writeOnlyError: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_writeOnlyError",
      dependencies: {},
      internal: false
    })
  };
  {
    Object.assign(helpers$3, {
      AwaitValue: helper$2("7.0.0-beta.0", "function _AwaitValue(t){this.wrapped=t}", {
        globals: [],
        locals: {
          _AwaitValue: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_AwaitValue",
        dependencies: {},
        internal: false
      }),
      applyDecs: helper$2("7.17.8", 'function old_createMetadataMethodsForProperty(e,t,a,r){return{getMetadata:function(o){old_assertNotFinished(r,"getMetadata"),old_assertMetadataKey(o);var i=e[o];if(void 0!==i)if(1===t){var n=i.public;if(void 0!==n)return n[a]}else if(2===t){var l=i.private;if(void 0!==l)return l.get(a)}else if(Object.hasOwnProperty.call(i,"constructor"))return i.constructor},setMetadata:function(o,i){old_assertNotFinished(r,"setMetadata"),old_assertMetadataKey(o);var n=e[o];if(void 0===n&&(n=e[o]={}),1===t){var l=n.public;void 0===l&&(l=n.public={}),l[a]=i}else if(2===t){var s=n.priv;void 0===s&&(s=n.private=new Map),s.set(a,i)}else n.constructor=i}}}function old_convertMetadataMapToFinal(e,t){var a=e[Symbol.metadata||Symbol.for("Symbol.metadata")],r=Object.getOwnPropertySymbols(t);if(0!==r.length){for(var o=0;o<r.length;o++){var i=r[o],n=t[i],l=a?a[i]:null,s=n.public,c=l?l.public:null;s&&c&&Object.setPrototypeOf(s,c);var d=n.private;if(d){var u=Array.from(d.values()),f=l?l.private:null;f&&(u=u.concat(f)),n.private=u}l&&Object.setPrototypeOf(n,l)}a&&Object.setPrototypeOf(t,a),e[Symbol.metadata||Symbol.for("Symbol.metadata")]=t}}function old_createAddInitializerMethod(e,t){return function(a){old_assertNotFinished(t,"addInitializer"),old_assertCallable(a,"An initializer"),e.push(a)}}function old_memberDec(e,t,a,r,o,i,n,l,s){var c;switch(i){case 1:c="accessor";break;case 2:c="method";break;case 3:c="getter";break;case 4:c="setter";break;default:c="field"}var d,u,f={kind:c,name:l?"#"+t:toPropertyKey(t),isStatic:n,isPrivate:l},p={v:!1};if(0!==i&&(f.addInitializer=old_createAddInitializerMethod(o,p)),l){d=2,u=Symbol(t);var v={};0===i?(v.get=a.get,v.set=a.set):2===i?v.get=function(){return a.value}:(1!==i&&3!==i||(v.get=function(){return a.get.call(this)}),1!==i&&4!==i||(v.set=function(e){a.set.call(this,e)})),f.access=v}else d=1,u=t;try{return e(s,Object.assign(f,old_createMetadataMethodsForProperty(r,d,u,p)))}finally{p.v=!0}}function old_assertNotFinished(e,t){if(e.v)throw Error("attempted to call "+t+" after decoration was finished")}function old_assertMetadataKey(e){if("symbol"!=typeof e)throw new TypeError("Metadata keys must be symbols, received: "+e)}function old_assertCallable(e,t){if("function"!=typeof e)throw new TypeError(t+" must be a function")}function old_assertValidReturnValue(e,t){var a=typeof t;if(1===e){if("object"!==a||null===t)throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0");void 0!==t.get&&old_assertCallable(t.get,"accessor.get"),void 0!==t.set&&old_assertCallable(t.set,"accessor.set"),void 0!==t.init&&old_assertCallable(t.init,"accessor.init"),void 0!==t.initializer&&old_assertCallable(t.initializer,"accessor.initializer")}else if("function"!==a)throw new TypeError((0===e?"field":10===e?"class":"method")+" decorators must return a function or void 0")}function old_getInit(e){var t;return null==(t=e.init)&&(t=e.initializer)&&void 0!==console&&console.warn(".initializer has been renamed to .init as of March 2022"),t}function old_applyMemberDec(e,t,a,r,o,i,n,l,s){var c,d,u,f,p,v,y,h=a[0];if(n?(0===o||1===o?(c={get:a[3],set:a[4]},u="get"):3===o?(c={get:a[3]},u="get"):4===o?(c={set:a[3]},u="set"):c={value:a[3]},0!==o&&(1===o&&setFunctionName(a[4],"#"+r,"set"),setFunctionName(a[3],"#"+r,u))):0!==o&&(c=Object.getOwnPropertyDescriptor(t,r)),1===o?f={get:c.get,set:c.set}:2===o?f=c.value:3===o?f=c.get:4===o&&(f=c.set),"function"==typeof h)void 0!==(p=old_memberDec(h,r,c,l,s,o,i,n,f))&&(old_assertValidReturnValue(o,p),0===o?d=p:1===o?(d=old_getInit(p),v=p.get||f.get,y=p.set||f.set,f={get:v,set:y}):f=p);else for(var m=h.length-1;m>=0;m--){var b;void 0!==(p=old_memberDec(h[m],r,c,l,s,o,i,n,f))&&(old_assertValidReturnValue(o,p),0===o?b=p:1===o?(b=old_getInit(p),v=p.get||f.get,y=p.set||f.set,f={get:v,set:y}):f=p,void 0!==b&&(void 0===d?d=b:"function"==typeof d?d=[d,b]:d.push(b)))}if(0===o||1===o){if(void 0===d)d=function(e,t){return t};else if("function"!=typeof d){var g=d;d=function(e,t){for(var a=t,r=0;r<g.length;r++)a=g[r].call(e,a);return a}}else{var _=d;d=function(e,t){return _.call(e,t)}}e.push(d)}0!==o&&(1===o?(c.get=f.get,c.set=f.set):2===o?c.value=f:3===o?c.get=f:4===o&&(c.set=f),n?1===o?(e.push((function(e,t){return f.get.call(e,t)})),e.push((function(e,t){return f.set.call(e,t)}))):2===o?e.push(f):e.push((function(e,t){return f.call(e,t)})):Object.defineProperty(t,r,c))}function old_applyMemberDecs(e,t,a,r,o){for(var i,n,l=new Map,s=new Map,c=0;c<o.length;c++){var d=o[c];if(Array.isArray(d)){var u,f,p,v=d[1],y=d[2],h=d.length>3,m=v>=5;if(m?(u=t,f=r,0!=(v-=5)&&(p=n=n||[])):(u=t.prototype,f=a,0!==v&&(p=i=i||[])),0!==v&&!h){var b=m?s:l,g=b.get(y)||0;if(!0===g||3===g&&4!==v||4===g&&3!==v)throw Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: "+y);!g&&v>2?b.set(y,v):b.set(y,!0)}old_applyMemberDec(e,u,d,y,v,m,h,f,p)}}old_pushInitializers(e,i),old_pushInitializers(e,n)}function old_pushInitializers(e,t){t&&e.push((function(e){for(var a=0;a<t.length;a++)t[a].call(e);return e}))}function old_applyClassDecs(e,t,a,r){if(r.length>0){for(var o=[],i=t,n=t.name,l=r.length-1;l>=0;l--){var s={v:!1};try{var c=Object.assign({kind:"class",name:n,addInitializer:old_createAddInitializerMethod(o,s)},old_createMetadataMethodsForProperty(a,0,n,s)),d=r[l](i,c)}finally{s.v=!0}void 0!==d&&(old_assertValidReturnValue(10,d),i=d)}e.push(i,(function(){for(var e=0;e<o.length;e++)o[e].call(i)}))}}function applyDecs(e,t,a){var r=[],o={},i={};return old_applyMemberDecs(r,e,i,o,t),old_convertMetadataMapToFinal(e.prototype,i),old_applyClassDecs(r,e,o,a),old_convertMetadataMapToFinal(e,o),r}', {
        globals: ["Object", "Map", "Symbol", "Array", "Error", "TypeError", "console"],
        locals: {
          old_createMetadataMethodsForProperty: ["body.0.id", "body.3.body.body.4.block.body.0.argument.arguments.1.arguments.1.callee", "body.12.body.body.0.consequent.body.0.body.body.1.block.body.0.declarations.0.init.arguments.1.callee"],
          old_convertMetadataMapToFinal: ["body.1.id", "body.13.body.body.1.argument.expressions.1.callee", "body.13.body.body.1.argument.expressions.3.callee"],
          old_createAddInitializerMethod: ["body.2.id", "body.3.body.body.3.test.expressions.0.right.right.callee", "body.12.body.body.0.consequent.body.0.body.body.1.block.body.0.declarations.0.init.arguments.0.properties.2.value.callee"],
          old_memberDec: ["body.3.id", "body.9.body.body.1.consequent.expression.left.right.right.callee", "body.9.body.body.1.alternate.body.body.1.expression.left.right.right.callee"],
          old_assertNotFinished: ["body.4.id", "body.0.body.body.0.argument.properties.0.value.body.body.0.expression.expressions.0.callee", "body.0.body.body.0.argument.properties.1.value.body.body.0.expression.expressions.0.callee", "body.2.body.body.0.argument.body.body.0.expression.expressions.0.callee"],
          old_assertMetadataKey: ["body.5.id", "body.0.body.body.0.argument.properties.0.value.body.body.0.expression.expressions.1.callee", "body.0.body.body.0.argument.properties.1.value.body.body.0.expression.expressions.1.callee"],
          old_assertCallable: ["body.6.id", "body.2.body.body.0.argument.body.body.0.expression.expressions.1.callee", "body.7.body.body.1.consequent.body.1.expression.expressions.0.right.callee", "body.7.body.body.1.consequent.body.1.expression.expressions.1.right.callee", "body.7.body.body.1.consequent.body.1.expression.expressions.2.right.callee", "body.7.body.body.1.consequent.body.1.expression.expressions.3.right.callee"],
          old_assertValidReturnValue: ["body.7.id", "body.9.body.body.1.consequent.expression.right.expressions.0.callee", "body.9.body.body.1.alternate.body.body.1.expression.right.expressions.0.callee", "body.12.body.body.0.consequent.body.0.body.body.2.expression.right.expressions.0.callee"],
          old_getInit: ["body.8.id", "body.9.body.body.1.consequent.expression.right.expressions.1.alternate.consequent.expressions.0.right.callee", "body.9.body.body.1.alternate.body.body.1.expression.right.expressions.1.alternate.consequent.expressions.0.right.callee"],
          old_applyMemberDec: ["body.9.id", "body.10.body.body.0.body.body.1.consequent.body.2.expression.callee"],
          old_applyMemberDecs: ["body.10.id", "body.13.body.body.1.argument.expressions.0.callee"],
          old_pushInitializers: ["body.11.id", "body.10.body.body.1.expression.expressions.0.callee", "body.10.body.body.1.expression.expressions.1.callee"],
          old_applyClassDecs: ["body.12.id", "body.13.body.body.1.argument.expressions.2.callee"],
          applyDecs: ["body.13.id"]
        },
        exportBindingAssignments: [],
        exportName: "applyDecs",
        dependencies: {
          setFunctionName: ["body.9.body.body.1.test.expressions.0.consequent.expressions.1.right.expressions.0.right.callee", "body.9.body.body.1.test.expressions.0.consequent.expressions.1.right.expressions.1.callee"],
          toPropertyKey: ["body.3.body.body.2.declarations.2.init.properties.1.value.alternate.callee"]
        },
        internal: false
      }),
      applyDecs2203: helper$2("7.19.0", 'function applyDecs2203Factory(){function createAddInitializerMethod(e,t){return function(r){!function(e,t){if(e.v)throw Error("attempted to call addInitializer after decoration was finished")}(t),assertCallable(r,"An initializer"),e.push(r)}}function memberDec(e,t,r,a,n,i,s,o){var c;switch(n){case 1:c="accessor";break;case 2:c="method";break;case 3:c="getter";break;case 4:c="setter";break;default:c="field"}var l,u,f={kind:c,name:s?"#"+t:t,static:i,private:s},p={v:!1};0!==n&&(f.addInitializer=createAddInitializerMethod(a,p)),0===n?s?(l=r.get,u=r.set):(l=function(){return this[t]},u=function(e){this[t]=e}):2===n?l=function(){return r.value}:(1!==n&&3!==n||(l=function(){return r.get.call(this)}),1!==n&&4!==n||(u=function(e){r.set.call(this,e)})),f.access=l&&u?{get:l,set:u}:l?{get:l}:{set:u};try{return e(o,f)}finally{p.v=!0}}function assertCallable(e,t){if("function"!=typeof e)throw new TypeError(t+" must be a function")}function assertValidReturnValue(e,t){var r=typeof t;if(1===e){if("object"!==r||null===t)throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0");void 0!==t.get&&assertCallable(t.get,"accessor.get"),void 0!==t.set&&assertCallable(t.set,"accessor.set"),void 0!==t.init&&assertCallable(t.init,"accessor.init")}else if("function"!==r)throw new TypeError((0===e?"field":10===e?"class":"method")+" decorators must return a function or void 0")}function applyMemberDec(e,t,r,a,n,i,s,o){var c,l,u,f,p,d,h=r[0];if(s?c=0===n||1===n?{get:r[3],set:r[4]}:3===n?{get:r[3]}:4===n?{set:r[3]}:{value:r[3]}:0!==n&&(c=Object.getOwnPropertyDescriptor(t,a)),1===n?u={get:c.get,set:c.set}:2===n?u=c.value:3===n?u=c.get:4===n&&(u=c.set),"function"==typeof h)void 0!==(f=memberDec(h,a,c,o,n,i,s,u))&&(assertValidReturnValue(n,f),0===n?l=f:1===n?(l=f.init,p=f.get||u.get,d=f.set||u.set,u={get:p,set:d}):u=f);else for(var v=h.length-1;v>=0;v--){var g;void 0!==(f=memberDec(h[v],a,c,o,n,i,s,u))&&(assertValidReturnValue(n,f),0===n?g=f:1===n?(g=f.init,p=f.get||u.get,d=f.set||u.set,u={get:p,set:d}):u=f,void 0!==g&&(void 0===l?l=g:"function"==typeof l?l=[l,g]:l.push(g)))}if(0===n||1===n){if(void 0===l)l=function(e,t){return t};else if("function"!=typeof l){var y=l;l=function(e,t){for(var r=t,a=0;a<y.length;a++)r=y[a].call(e,r);return r}}else{var m=l;l=function(e,t){return m.call(e,t)}}e.push(l)}0!==n&&(1===n?(c.get=u.get,c.set=u.set):2===n?c.value=u:3===n?c.get=u:4===n&&(c.set=u),s?1===n?(e.push((function(e,t){return u.get.call(e,t)})),e.push((function(e,t){return u.set.call(e,t)}))):2===n?e.push(u):e.push((function(e,t){return u.call(e,t)})):Object.defineProperty(t,a,c))}function pushInitializers(e,t){t&&e.push((function(e){for(var r=0;r<t.length;r++)t[r].call(e);return e}))}return function(e,t,r){var a=[];return function(e,t,r){for(var a,n,i=new Map,s=new Map,o=0;o<r.length;o++){var c=r[o];if(Array.isArray(c)){var l,u,f=c[1],p=c[2],d=c.length>3,h=f>=5;if(h?(l=t,0!=(f-=5)&&(u=n=n||[])):(l=t.prototype,0!==f&&(u=a=a||[])),0!==f&&!d){var v=h?s:i,g=v.get(p)||0;if(!0===g||3===g&&4!==f||4===g&&3!==f)throw Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: "+p);!g&&f>2?v.set(p,f):v.set(p,!0)}applyMemberDec(e,l,c,p,f,h,d,u)}}pushInitializers(e,a),pushInitializers(e,n)}(a,e,t),function(e,t,r){if(r.length>0){for(var a=[],n=t,i=t.name,s=r.length-1;s>=0;s--){var o={v:!1};try{var c=r[s](n,{kind:"class",name:i,addInitializer:createAddInitializerMethod(a,o)})}finally{o.v=!0}void 0!==c&&(assertValidReturnValue(10,c),n=c)}e.push(n,(function(){for(var e=0;e<a.length;e++)a[e].call(n)}))}}(a,e,r),a}}var applyDecs2203Impl;function applyDecs2203(e,t,r){return(applyDecs2203Impl=applyDecs2203Impl||applyDecs2203Factory())(e,t,r)}', {
        globals: ["Error", "TypeError", "Object", "Map", "Array"],
        locals: {
          applyDecs2203Factory: ["body.0.id", "body.2.body.body.0.argument.callee.right.right.callee"],
          applyDecs2203Impl: ["body.1.declarations.0.id", "body.2.body.body.0.argument.callee.right.left", "body.2.body.body.0.argument.callee.left"],
          applyDecs2203: ["body.2.id"]
        },
        exportBindingAssignments: [],
        exportName: "applyDecs2203",
        dependencies: {},
        internal: false
      }),
      applyDecs2203R: helper$2("7.20.0", 'function applyDecs2203RFactory(){function createAddInitializerMethod(e,t){return function(r){!function(e,t){if(e.v)throw Error("attempted to call addInitializer after decoration was finished")}(t),assertCallable(r,"An initializer"),e.push(r)}}function memberDec(e,t,r,n,a,i,o,s){var c;switch(a){case 1:c="accessor";break;case 2:c="method";break;case 3:c="getter";break;case 4:c="setter";break;default:c="field"}var l,u,f={kind:c,name:o?"#"+t:toPropertyKey(t),static:i,private:o},p={v:!1};0!==a&&(f.addInitializer=createAddInitializerMethod(n,p)),0===a?o?(l=r.get,u=r.set):(l=function(){return this[t]},u=function(e){this[t]=e}):2===a?l=function(){return r.value}:(1!==a&&3!==a||(l=function(){return r.get.call(this)}),1!==a&&4!==a||(u=function(e){r.set.call(this,e)})),f.access=l&&u?{get:l,set:u}:l?{get:l}:{set:u};try{return e(s,f)}finally{p.v=!0}}function assertCallable(e,t){if("function"!=typeof e)throw new TypeError(t+" must be a function")}function assertValidReturnValue(e,t){var r=typeof t;if(1===e){if("object"!==r||null===t)throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0");void 0!==t.get&&assertCallable(t.get,"accessor.get"),void 0!==t.set&&assertCallable(t.set,"accessor.set"),void 0!==t.init&&assertCallable(t.init,"accessor.init")}else if("function"!==r)throw new TypeError((0===e?"field":10===e?"class":"method")+" decorators must return a function or void 0")}function applyMemberDec(e,t,r,n,a,i,o,s){var c,l,u,f,p,d,h,v=r[0];if(o?(0===a||1===a?(c={get:r[3],set:r[4]},u="get"):3===a?(c={get:r[3]},u="get"):4===a?(c={set:r[3]},u="set"):c={value:r[3]},0!==a&&(1===a&&setFunctionName(r[4],"#"+n,"set"),setFunctionName(r[3],"#"+n,u))):0!==a&&(c=Object.getOwnPropertyDescriptor(t,n)),1===a?f={get:c.get,set:c.set}:2===a?f=c.value:3===a?f=c.get:4===a&&(f=c.set),"function"==typeof v)void 0!==(p=memberDec(v,n,c,s,a,i,o,f))&&(assertValidReturnValue(a,p),0===a?l=p:1===a?(l=p.init,d=p.get||f.get,h=p.set||f.set,f={get:d,set:h}):f=p);else for(var g=v.length-1;g>=0;g--){var y;void 0!==(p=memberDec(v[g],n,c,s,a,i,o,f))&&(assertValidReturnValue(a,p),0===a?y=p:1===a?(y=p.init,d=p.get||f.get,h=p.set||f.set,f={get:d,set:h}):f=p,void 0!==y&&(void 0===l?l=y:"function"==typeof l?l=[l,y]:l.push(y)))}if(0===a||1===a){if(void 0===l)l=function(e,t){return t};else if("function"!=typeof l){var m=l;l=function(e,t){for(var r=t,n=0;n<m.length;n++)r=m[n].call(e,r);return r}}else{var b=l;l=function(e,t){return b.call(e,t)}}e.push(l)}0!==a&&(1===a?(c.get=f.get,c.set=f.set):2===a?c.value=f:3===a?c.get=f:4===a&&(c.set=f),o?1===a?(e.push((function(e,t){return f.get.call(e,t)})),e.push((function(e,t){return f.set.call(e,t)}))):2===a?e.push(f):e.push((function(e,t){return f.call(e,t)})):Object.defineProperty(t,n,c))}function applyMemberDecs(e,t){for(var r,n,a=[],i=new Map,o=new Map,s=0;s<t.length;s++){var c=t[s];if(Array.isArray(c)){var l,u,f=c[1],p=c[2],d=c.length>3,h=f>=5;if(h?(l=e,0!=(f-=5)&&(u=n=n||[])):(l=e.prototype,0!==f&&(u=r=r||[])),0!==f&&!d){var v=h?o:i,g=v.get(p)||0;if(!0===g||3===g&&4!==f||4===g&&3!==f)throw Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: "+p);!g&&f>2?v.set(p,f):v.set(p,!0)}applyMemberDec(a,l,c,p,f,h,d,u)}}return pushInitializers(a,r),pushInitializers(a,n),a}function pushInitializers(e,t){t&&e.push((function(e){for(var r=0;r<t.length;r++)t[r].call(e);return e}))}return function(e,t,r){return{e:applyMemberDecs(e,t),get c(){return function(e,t){if(t.length>0){for(var r=[],n=e,a=e.name,i=t.length-1;i>=0;i--){var o={v:!1};try{var s=t[i](n,{kind:"class",name:a,addInitializer:createAddInitializerMethod(r,o)})}finally{o.v=!0}void 0!==s&&(assertValidReturnValue(10,s),n=s)}return[n,function(){for(var e=0;e<r.length;e++)r[e].call(n)}]}}(e,r)}}}}function applyDecs2203R(e,t,r){return(applyDecs2203R=applyDecs2203RFactory())(e,t,r)}', {
        globals: ["Error", "TypeError", "Object", "Map", "Array"],
        locals: {
          applyDecs2203RFactory: ["body.0.id", "body.1.body.body.0.argument.callee.right.callee"],
          applyDecs2203R: ["body.1.id", "body.1.body.body.0.argument.callee.left"]
        },
        exportBindingAssignments: ["body.1.body.body.0.argument.callee"],
        exportName: "applyDecs2203R",
        dependencies: {
          setFunctionName: ["body.0.body.body.4.body.body.1.test.expressions.0.consequent.expressions.1.right.expressions.0.right.callee", "body.0.body.body.4.body.body.1.test.expressions.0.consequent.expressions.1.right.expressions.1.callee"],
          toPropertyKey: ["body.0.body.body.1.body.body.2.declarations.2.init.properties.1.value.alternate.callee"]
        },
        internal: false
      }),
      applyDecs2301: helper$2("7.21.0", 'function applyDecs2301Factory(){function createAddInitializerMethod(e,t){return function(r){!function(e,t){if(e.v)throw Error("attempted to call addInitializer after decoration was finished")}(t),assertCallable(r,"An initializer"),e.push(r)}}function assertInstanceIfPrivate(e,t){if(!e(t))throw new TypeError("Attempted to access private element on non-instance")}function memberDec(e,t,r,n,a,i,s,o,c){var u;switch(a){case 1:u="accessor";break;case 2:u="method";break;case 3:u="getter";break;case 4:u="setter";break;default:u="field"}var l,f,p={kind:u,name:s?"#"+t:toPropertyKey(t),static:i,private:s},d={v:!1};if(0!==a&&(p.addInitializer=createAddInitializerMethod(n,d)),s||0!==a&&2!==a)if(2===a)l=function(e){return assertInstanceIfPrivate(c,e),r.value};else{var h=0===a||1===a;(h||3===a)&&(l=s?function(e){return assertInstanceIfPrivate(c,e),r.get.call(e)}:function(e){return r.get.call(e)}),(h||4===a)&&(f=s?function(e,t){assertInstanceIfPrivate(c,e),r.set.call(e,t)}:function(e,t){r.set.call(e,t)})}else l=function(e){return e[t]},0===a&&(f=function(e,r){e[t]=r});var v=s?c.bind():function(e){return t in e};p.access=l&&f?{get:l,set:f,has:v}:l?{get:l,has:v}:{set:f,has:v};try{return e(o,p)}finally{d.v=!0}}function assertCallable(e,t){if("function"!=typeof e)throw new TypeError(t+" must be a function")}function assertValidReturnValue(e,t){var r=typeof t;if(1===e){if("object"!==r||null===t)throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0");void 0!==t.get&&assertCallable(t.get,"accessor.get"),void 0!==t.set&&assertCallable(t.set,"accessor.set"),void 0!==t.init&&assertCallable(t.init,"accessor.init")}else if("function"!==r)throw new TypeError((0===e?"field":10===e?"class":"method")+" decorators must return a function or void 0")}function curryThis2(e){return function(t){e(this,t)}}function applyMemberDec(e,t,r,n,a,i,s,o,c){var u,l,f,p,d,h,v,y,g=r[0];if(s?(0===a||1===a?(u={get:(d=r[3],function(){return d(this)}),set:curryThis2(r[4])},f="get"):3===a?(u={get:r[3]},f="get"):4===a?(u={set:r[3]},f="set"):u={value:r[3]},0!==a&&(1===a&&setFunctionName(u.set,"#"+n,"set"),setFunctionName(u[f||"value"],"#"+n,f))):0!==a&&(u=Object.getOwnPropertyDescriptor(t,n)),1===a?p={get:u.get,set:u.set}:2===a?p=u.value:3===a?p=u.get:4===a&&(p=u.set),"function"==typeof g)void 0!==(h=memberDec(g,n,u,o,a,i,s,p,c))&&(assertValidReturnValue(a,h),0===a?l=h:1===a?(l=h.init,v=h.get||p.get,y=h.set||p.set,p={get:v,set:y}):p=h);else for(var m=g.length-1;m>=0;m--){var b;void 0!==(h=memberDec(g[m],n,u,o,a,i,s,p,c))&&(assertValidReturnValue(a,h),0===a?b=h:1===a?(b=h.init,v=h.get||p.get,y=h.set||p.set,p={get:v,set:y}):p=h,void 0!==b&&(void 0===l?l=b:"function"==typeof l?l=[l,b]:l.push(b)))}if(0===a||1===a){if(void 0===l)l=function(e,t){return t};else if("function"!=typeof l){var I=l;l=function(e,t){for(var r=t,n=0;n<I.length;n++)r=I[n].call(e,r);return r}}else{var w=l;l=function(e,t){return w.call(e,t)}}e.push(l)}0!==a&&(1===a?(u.get=p.get,u.set=p.set):2===a?u.value=p:3===a?u.get=p:4===a&&(u.set=p),s?1===a?(e.push((function(e,t){return p.get.call(e,t)})),e.push((function(e,t){return p.set.call(e,t)}))):2===a?e.push(p):e.push((function(e,t){return p.call(e,t)})):Object.defineProperty(t,n,u))}function applyMemberDecs(e,t,r){for(var n,a,i,s=[],o=new Map,c=new Map,u=0;u<t.length;u++){var l=t[u];if(Array.isArray(l)){var f,p,d=l[1],h=l[2],v=l.length>3,y=d>=5,g=r;if(y?(f=e,0!=(d-=5)&&(p=a=a||[]),v&&!i&&(i=function(t){return checkInRHS(t)===e}),g=i):(f=e.prototype,0!==d&&(p=n=n||[])),0!==d&&!v){var m=y?c:o,b=m.get(h)||0;if(!0===b||3===b&&4!==d||4===b&&3!==d)throw Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: "+h);!b&&d>2?m.set(h,d):m.set(h,!0)}applyMemberDec(s,f,l,h,d,y,v,p,g)}}return pushInitializers(s,n),pushInitializers(s,a),s}function pushInitializers(e,t){t&&e.push((function(e){for(var r=0;r<t.length;r++)t[r].call(e);return e}))}return function(e,t,r,n){return{e:applyMemberDecs(e,t,n),get c(){return function(e,t){if(t.length>0){for(var r=[],n=e,a=e.name,i=t.length-1;i>=0;i--){var s={v:!1};try{var o=t[i](n,{kind:"class",name:a,addInitializer:createAddInitializerMethod(r,s)})}finally{s.v=!0}void 0!==o&&(assertValidReturnValue(10,o),n=o)}return[n,function(){for(var e=0;e<r.length;e++)r[e].call(n)}]}}(e,r)}}}}function applyDecs2301(e,t,r,n){return(applyDecs2301=applyDecs2301Factory())(e,t,r,n)}', {
        globals: ["Error", "TypeError", "Object", "Map", "Array"],
        locals: {
          applyDecs2301Factory: ["body.0.id", "body.1.body.body.0.argument.callee.right.callee"],
          applyDecs2301: ["body.1.id", "body.1.body.body.0.argument.callee.left"]
        },
        exportBindingAssignments: ["body.1.body.body.0.argument.callee"],
        exportName: "applyDecs2301",
        dependencies: {
          checkInRHS: ["body.0.body.body.7.body.body.0.body.body.1.consequent.body.1.test.expressions.0.consequent.expressions.2.right.right.body.body.0.argument.left.callee"],
          setFunctionName: ["body.0.body.body.6.body.body.1.test.expressions.0.consequent.expressions.1.right.expressions.0.right.callee", "body.0.body.body.6.body.body.1.test.expressions.0.consequent.expressions.1.right.expressions.1.callee"],
          toPropertyKey: ["body.0.body.body.2.body.body.2.declarations.2.init.properties.1.value.alternate.callee"]
        },
        internal: false
      }),
      applyDecs2305: helper$2("7.21.0", 'function applyDecs2305(e,t,r,n,o,a){function i(e,t,r){return function(n,o){return r&&r(n),e[t].call(n,o)}}function c(e,t){for(var r=0;r<e.length;r++)e[r].call(t);return t}function s(e,t,r,n){if("function"!=typeof e&&(n||void 0!==e))throw new TypeError(t+" must "+(r||"be")+" a function"+(n?"":" or undefined"));return e}function applyDec(e,t,r,n,o,a,c,u,l,f,p,d,h){function m(e){if(!h(e))throw new TypeError("Attempted to access private element on non-instance")}var y,v=t[0],g=t[3],b=!u;if(!b){r||Array.isArray(v)||(v=[v]);var w={},S=[],A=3===o?"get":4===o||d?"set":"value";f?(p||d?w={get:setFunctionName((function(){return g(this)}),n,"get"),set:function(e){t[4](this,e)}}:w[A]=g,p||setFunctionName(w[A],n,2===o?"":A)):p||(w=Object.getOwnPropertyDescriptor(e,n))}for(var P=e,j=v.length-1;j>=0;j-=r?2:1){var D=v[j],E=r?v[j-1]:void 0,I={},O={kind:["field","accessor","method","getter","setter","class"][o],name:n,metadata:a,addInitializer:function(e,t){if(e.v)throw Error("attempted to call addInitializer after decoration was finished");s(t,"An initializer","be",!0),c.push(t)}.bind(null,I)};try{if(b)(y=s(D.call(E,P,O),"class decorators","return"))&&(P=y);else{var k,F;O.static=l,O.private=f,f?2===o?k=function(e){return m(e),w.value}:(o<4&&(k=i(w,"get",m)),3!==o&&(F=i(w,"set",m))):(k=function(e){return e[n]},(o<2||4===o)&&(F=function(e,t){e[n]=t}));var N=O.access={has:f?h.bind():function(e){return n in e}};if(k&&(N.get=k),F&&(N.set=F),P=D.call(E,d?{get:w.get,set:w.set}:w[A],O),d){if("object"==typeof P&&P)(y=s(P.get,"accessor.get"))&&(w.get=y),(y=s(P.set,"accessor.set"))&&(w.set=y),(y=s(P.init,"accessor.init"))&&S.push(y);else if(void 0!==P)throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0")}else s(P,(p?"field":"method")+" decorators","return")&&(p?S.push(P):w[A]=P)}}finally{I.v=!0}}return(p||d)&&u.push((function(e,t){for(var r=S.length-1;r>=0;r--)t=S[r].call(e,t);return t})),p||b||(f?d?u.push(i(w,"get"),i(w,"set")):u.push(2===o?w[A]:i.call.bind(w[A])):Object.defineProperty(e,n,w)),P}function u(e,t){return Object.defineProperty(e,Symbol.metadata||Symbol.for("Symbol.metadata"),{configurable:!0,enumerable:!0,value:t})}if(arguments.length>=6)var l=a[Symbol.metadata||Symbol.for("Symbol.metadata")];var f=Object.create(null==l?null:l),p=function(e,t,r,n){var o,a,i=[],s=function(t){return checkInRHS(t)===e},u=new Map;function l(e){e&&i.push(c.bind(null,e))}for(var f=0;f<t.length;f++){var p=t[f];if(Array.isArray(p)){var d=p[1],h=p[2],m=p.length>3,y=16&d,v=!!(8&d),g=0==(d&=7),b=h+"/"+v;if(!g&&!m){var w=u.get(b);if(!0===w||3===w&&4!==d||4===w&&3!==d)throw Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: "+h);u.set(b,!(d>2)||d)}applyDec(v?e:e.prototype,p,y,m?"#"+h:toPropertyKey(h),d,n,v?a=a||[]:o=o||[],i,v,m,g,1===d,v&&m?s:r)}}return l(o),l(a),i}(e,t,o,f);return r.length||u(e,f),{e:p,get c(){var t=[];return r.length&&[u(applyDec(e,[r],n,e.name,5,f,t),f),c.bind(null,t,e)]}}}', {
        globals: ["TypeError", "Array", "Object", "Error", "Symbol", "Map"],
        locals: {
          applyDecs2305: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "applyDecs2305",
        dependencies: {
          checkInRHS: ["body.0.body.body.6.declarations.1.init.callee.body.body.0.declarations.3.init.body.body.0.argument.left.callee"],
          setFunctionName: ["body.0.body.body.3.body.body.2.consequent.body.2.expression.consequent.expressions.0.consequent.right.properties.0.value.callee", "body.0.body.body.3.body.body.2.consequent.body.2.expression.consequent.expressions.1.right.callee"],
          toPropertyKey: ["body.0.body.body.6.declarations.1.init.callee.body.body.2.body.body.1.consequent.body.2.expression.arguments.3.alternate.callee"]
        },
        internal: false
      }),
      classApplyDescriptorDestructureSet: helper$2("7.13.10", 'function _classApplyDescriptorDestructureSet(e,t){if(t.set)return"__destrObj"in t||(t.__destrObj={set value(r){t.set.call(e,r)}}),t.__destrObj;if(!t.writable)throw new TypeError("attempted to set read only private field");return t}', {
        globals: ["TypeError"],
        locals: {
          _classApplyDescriptorDestructureSet: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_classApplyDescriptorDestructureSet",
        dependencies: {},
        internal: false
      }),
      classApplyDescriptorGet: helper$2("7.13.10", "function _classApplyDescriptorGet(e,t){return t.get?t.get.call(e):t.value}", {
        globals: [],
        locals: {
          _classApplyDescriptorGet: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_classApplyDescriptorGet",
        dependencies: {},
        internal: false
      }),
      classApplyDescriptorSet: helper$2("7.13.10", 'function _classApplyDescriptorSet(e,t,l){if(t.set)t.set.call(e,l);else{if(!t.writable)throw new TypeError("attempted to set read only private field");t.value=l}}', {
        globals: ["TypeError"],
        locals: {
          _classApplyDescriptorSet: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_classApplyDescriptorSet",
        dependencies: {},
        internal: false
      }),
      classCheckPrivateStaticAccess: helper$2("7.13.10", "function _classCheckPrivateStaticAccess(s,a,r){return assertClassBrand(a,s,r)}", {
        globals: [],
        locals: {
          _classCheckPrivateStaticAccess: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_classCheckPrivateStaticAccess",
        dependencies: {
          assertClassBrand: ["body.0.body.body.0.argument.callee"]
        },
        internal: false
      }),
      classCheckPrivateStaticFieldDescriptor: helper$2("7.13.10", 'function _classCheckPrivateStaticFieldDescriptor(t,e){if(void 0===t)throw new TypeError("attempted to "+e+" private static field before its declaration")}', {
        globals: ["TypeError"],
        locals: {
          _classCheckPrivateStaticFieldDescriptor: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_classCheckPrivateStaticFieldDescriptor",
        dependencies: {},
        internal: false
      }),
      classExtractFieldDescriptor: helper$2("7.13.10", "function _classExtractFieldDescriptor(e,t){return classPrivateFieldGet2(t,e)}", {
        globals: [],
        locals: {
          _classExtractFieldDescriptor: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_classExtractFieldDescriptor",
        dependencies: {
          classPrivateFieldGet2: ["body.0.body.body.0.argument.callee"]
        },
        internal: false
      }),
      classPrivateFieldDestructureSet: helper$2("7.4.4", "function _classPrivateFieldDestructureSet(e,t){var r=classPrivateFieldGet2(t,e);return classApplyDescriptorDestructureSet(e,r)}", {
        globals: [],
        locals: {
          _classPrivateFieldDestructureSet: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_classPrivateFieldDestructureSet",
        dependencies: {
          classApplyDescriptorDestructureSet: ["body.0.body.body.1.argument.callee"],
          classPrivateFieldGet2: ["body.0.body.body.0.declarations.0.init.callee"]
        },
        internal: false
      }),
      classPrivateFieldGet: helper$2("7.0.0-beta.0", "function _classPrivateFieldGet(e,t){var r=classPrivateFieldGet2(t,e);return classApplyDescriptorGet(e,r)}", {
        globals: [],
        locals: {
          _classPrivateFieldGet: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_classPrivateFieldGet",
        dependencies: {
          classApplyDescriptorGet: ["body.0.body.body.1.argument.callee"],
          classPrivateFieldGet2: ["body.0.body.body.0.declarations.0.init.callee"]
        },
        internal: false
      }),
      classPrivateFieldSet: helper$2("7.0.0-beta.0", "function _classPrivateFieldSet(e,t,r){var s=classPrivateFieldGet2(t,e);return classApplyDescriptorSet(e,s,r),r}", {
        globals: [],
        locals: {
          _classPrivateFieldSet: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_classPrivateFieldSet",
        dependencies: {
          classApplyDescriptorSet: ["body.0.body.body.1.argument.expressions.0.callee"],
          classPrivateFieldGet2: ["body.0.body.body.0.declarations.0.init.callee"]
        },
        internal: false
      }),
      classPrivateMethodGet: helper$2("7.1.6", "function _classPrivateMethodGet(s,a,r){return assertClassBrand(a,s),r}", {
        globals: [],
        locals: {
          _classPrivateMethodGet: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_classPrivateMethodGet",
        dependencies: {
          assertClassBrand: ["body.0.body.body.0.argument.expressions.0.callee"]
        },
        internal: false
      }),
      classPrivateMethodSet: helper$2("7.1.6", 'function _classPrivateMethodSet(){throw new TypeError("attempted to reassign private method")}', {
        globals: ["TypeError"],
        locals: {
          _classPrivateMethodSet: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_classPrivateMethodSet",
        dependencies: {},
        internal: false
      }),
      classStaticPrivateFieldDestructureSet: helper$2("7.13.10", 'function _classStaticPrivateFieldDestructureSet(t,r,s){return assertClassBrand(r,t),classCheckPrivateStaticFieldDescriptor(s,"set"),classApplyDescriptorDestructureSet(t,s)}', {
        globals: [],
        locals: {
          _classStaticPrivateFieldDestructureSet: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_classStaticPrivateFieldDestructureSet",
        dependencies: {
          classApplyDescriptorDestructureSet: ["body.0.body.body.0.argument.expressions.2.callee"],
          assertClassBrand: ["body.0.body.body.0.argument.expressions.0.callee"],
          classCheckPrivateStaticFieldDescriptor: ["body.0.body.body.0.argument.expressions.1.callee"]
        },
        internal: false
      }),
      classStaticPrivateFieldSpecGet: helper$2("7.0.2", 'function _classStaticPrivateFieldSpecGet(t,s,r){return assertClassBrand(s,t),classCheckPrivateStaticFieldDescriptor(r,"get"),classApplyDescriptorGet(t,r)}', {
        globals: [],
        locals: {
          _classStaticPrivateFieldSpecGet: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_classStaticPrivateFieldSpecGet",
        dependencies: {
          classApplyDescriptorGet: ["body.0.body.body.0.argument.expressions.2.callee"],
          assertClassBrand: ["body.0.body.body.0.argument.expressions.0.callee"],
          classCheckPrivateStaticFieldDescriptor: ["body.0.body.body.0.argument.expressions.1.callee"]
        },
        internal: false
      }),
      classStaticPrivateFieldSpecSet: helper$2("7.0.2", 'function _classStaticPrivateFieldSpecSet(s,t,r,e){return assertClassBrand(t,s),classCheckPrivateStaticFieldDescriptor(r,"set"),classApplyDescriptorSet(s,r,e),e}', {
        globals: [],
        locals: {
          _classStaticPrivateFieldSpecSet: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_classStaticPrivateFieldSpecSet",
        dependencies: {
          classApplyDescriptorSet: ["body.0.body.body.0.argument.expressions.2.callee"],
          assertClassBrand: ["body.0.body.body.0.argument.expressions.0.callee"],
          classCheckPrivateStaticFieldDescriptor: ["body.0.body.body.0.argument.expressions.1.callee"]
        },
        internal: false
      }),
      classStaticPrivateMethodSet: helper$2("7.3.2", 'function _classStaticPrivateMethodSet(){throw new TypeError("attempted to set read only static private field")}', {
        globals: ["TypeError"],
        locals: {
          _classStaticPrivateMethodSet: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_classStaticPrivateMethodSet",
        dependencies: {},
        internal: false
      }),
      defineEnumerableProperties: helper$2("7.0.0-beta.0", 'function _defineEnumerableProperties(e,r){for(var t in r){var n=r[t];n.configurable=n.enumerable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,t,n)}if(Object.getOwnPropertySymbols)for(var a=Object.getOwnPropertySymbols(r),b=0;b<a.length;b++){var i=a[b];(n=r[i]).configurable=n.enumerable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,i,n)}return e}', {
        globals: ["Object"],
        locals: {
          _defineEnumerableProperties: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_defineEnumerableProperties",
        dependencies: {},
        internal: false
      }),
      dispose: helper$2("7.22.0", 'function dispose_SuppressedError(r,e){return"undefined"!=typeof SuppressedError?dispose_SuppressedError=SuppressedError:(dispose_SuppressedError=function(r,e){this.suppressed=e,this.error=r,this.stack=Error().stack},dispose_SuppressedError.prototype=Object.create(Error.prototype,{constructor:{value:dispose_SuppressedError,writable:!0,configurable:!0}})),new dispose_SuppressedError(r,e)}function _dispose(r,e,s){function next(){for(;r.length>0;)try{var o=r.pop(),p=o.d.call(o.v);if(o.a)return Promise.resolve(p).then(next,err)}catch(r){return err(r)}if(s)throw e}function err(r){return e=s?new dispose_SuppressedError(e,r):r,s=!0,next()}return next()}', {
        globals: ["SuppressedError", "Error", "Object", "Promise"],
        locals: {
          dispose_SuppressedError: ["body.0.id", "body.0.body.body.0.argument.expressions.0.alternate.expressions.1.left.object", "body.0.body.body.0.argument.expressions.0.alternate.expressions.1.right.arguments.1.properties.0.value.properties.0.value", "body.0.body.body.0.argument.expressions.1.callee", "body.1.body.body.1.body.body.0.argument.expressions.0.right.consequent.callee", "body.0.body.body.0.argument.expressions.0.consequent.left", "body.0.body.body.0.argument.expressions.0.alternate.expressions.0.left"],
          _dispose: ["body.1.id"]
        },
        exportBindingAssignments: [],
        exportName: "_dispose",
        dependencies: {},
        internal: false
      }),
      objectSpread: helper$2("7.0.0-beta.0", 'function _objectSpread(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?Object(arguments[r]):{},o=Object.keys(t);"function"==typeof Object.getOwnPropertySymbols&&o.push.apply(o,Object.getOwnPropertySymbols(t).filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),o.forEach((function(r){defineProperty(e,r,t[r])}))}return e}', {
        globals: ["Object"],
        locals: {
          _objectSpread: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_objectSpread",
        dependencies: {
          defineProperty: ["body.0.body.body.0.body.body.1.expression.expressions.1.arguments.0.body.body.0.expression.callee"]
        },
        internal: false
      }),
      regeneratorRuntime: helper$2("7.18.0", 'function _regeneratorRuntime(){"use strict";var r=regenerator(),e=r.m(_regeneratorRuntime),t=(Object.getPrototypeOf?Object.getPrototypeOf(e):e.__proto__).constructor;function n(r){var e="function"==typeof r&&r.constructor;return!!e&&(e===t||"GeneratorFunction"===(e.displayName||e.name))}var o={throw:1,return:2,break:3,continue:3};function a(r){var e,t;return function(n){e||(e={stop:function(){return t(n.a,2)},catch:function(){return n.v},abrupt:function(r,e){return t(n.a,o[r],e)},delegateYield:function(r,o,a){return e.resultName=o,t(n.d,values(r),a)},finish:function(r){return t(n.f,r)}},t=function(r,t,o){n.p=e.prev,n.n=e.next;try{return r(t,o)}finally{e.next=n.n}}),e.resultName&&(e[e.resultName]=n.v,e.resultName=void 0),e.sent=n.v,e.next=n.n;try{return r.call(this,e)}finally{n.p=e.prev,n.n=e.next}}}return(_regeneratorRuntime=function(){return{wrap:function(e,t,n,o){return r.w(a(e),t,n,o&&o.reverse())},isGeneratorFunction:n,mark:r.m,awrap:function(r,e){return new OverloadYield(r,e)},AsyncIterator:AsyncIterator,async:function(r,e,t,o,u){return(n(e)?asyncGen:async)(a(r),e,t,o,u)},keys:keys,values:values}})()}', {
        globals: ["Object"],
        locals: {
          _regeneratorRuntime: ["body.0.id", "body.0.body.body.0.declarations.1.init.arguments.0", "body.0.body.body.4.argument.callee.left"]
        },
        exportBindingAssignments: ["body.0.body.body.4.argument.callee"],
        exportName: "_regeneratorRuntime",
        dependencies: {
          OverloadYield: ["body.0.body.body.4.argument.callee.right.body.body.0.argument.properties.3.value.body.body.0.argument.callee"],
          regenerator: ["body.0.body.body.0.declarations.0.init.callee"],
          regeneratorAsync: ["body.0.body.body.4.argument.callee.right.body.body.0.argument.properties.5.value.body.body.0.argument.callee.alternate"],
          regeneratorAsyncGen: ["body.0.body.body.4.argument.callee.right.body.body.0.argument.properties.5.value.body.body.0.argument.callee.consequent"],
          regeneratorAsyncIterator: ["body.0.body.body.4.argument.callee.right.body.body.0.argument.properties.4.value"],
          regeneratorKeys: ["body.0.body.body.4.argument.callee.right.body.body.0.argument.properties.6.value"],
          regeneratorValues: ["body.0.body.body.3.body.body.1.argument.body.body.0.expression.expressions.0.right.expressions.0.right.properties.3.value.body.body.0.argument.expressions.1.arguments.1.callee", "body.0.body.body.4.argument.callee.right.body.body.0.argument.properties.7.value"]
        },
        internal: false
      }),
      using: helper$2("7.22.0", 'function _using(o,n,e){if(null==n)return n;if(Object(n)!==n)throw new TypeError("using declarations can only be used with objects, functions, null, or undefined.");if(e)var r=n[Symbol.asyncDispose||Symbol.for("Symbol.asyncDispose")];if(null==r&&(r=n[Symbol.dispose||Symbol.for("Symbol.dispose")]),"function"!=typeof r)throw new TypeError("Property [Symbol.dispose] is not a function.");return o.push({v:n,d:r,a:e}),n}', {
        globals: ["Object", "TypeError", "Symbol"],
        locals: {
          _using: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_using",
        dependencies: {},
        internal: false
      })
    });
  }

  var cloneNode$c = cloneNode$e,
    identifier$c = identifier$e;
  function deep(obj, path, value) {
    try {
      var parts = path.split(".");
      var last = parts.shift();
      while (parts.length > 0) {
        obj = obj[last];
        last = parts.shift();
      }
      if (arguments.length > 2) {
        obj[last] = value;
      } else {
        return obj[last];
      }
    } catch (e) {
      e.message += " (when accessing " + path + ")";
      throw e;
    }
  }
  function permuteHelperAST(ast, metadata, bindingName, localBindings, getDependency, adjustAst) {
    var locals = metadata.locals,
      dependencies = metadata.dependencies,
      exportBindingAssignments = metadata.exportBindingAssignments,
      exportName = metadata.exportName;
    var bindings = new Set(localBindings || []);
    if (bindingName) bindings.add(bindingName);
    for (var _i = 0, _Object$entries = (Object.entries || function (o) {
        return Object.keys(o).map(function (k) {
          return [k, o[k]];
        });
      })(locals); _i < _Object$entries.length; _i++) {
      var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
        _name = _Object$entries$_i[0],
        paths = _Object$entries$_i[1];
      var newName = _name;
      if (bindingName && _name === exportName) {
        newName = bindingName;
      } else {
        while (bindings.has(newName)) newName = "_" + newName;
      }
      if (newName !== _name) {
        for (var _iterator = _createForOfIteratorHelperLoose(paths), _step; !(_step = _iterator()).done;) {
          var path = _step.value;
          deep(ast, path, identifier$c(newName));
        }
      }
    }
    for (var _i2 = 0, _Object$entries2 = (Object.entries || function (o) {
        return Object.keys(o).map(function (k) {
          return [k, o[k]];
        });
      })(dependencies); _i2 < _Object$entries2.length; _i2++) {
      var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i2], 2),
        _name2 = _Object$entries2$_i[0],
        _paths = _Object$entries2$_i[1];
      var ref = typeof getDependency === "function" && getDependency(_name2) || identifier$c(_name2);
      for (var _iterator2 = _createForOfIteratorHelperLoose(_paths), _step2; !(_step2 = _iterator2()).done;) {
        var _path = _step2.value;
        deep(ast, _path, cloneNode$c(ref));
      }
    }
    adjustAst == null || adjustAst(ast, exportName, function (map) {
      exportBindingAssignments.forEach(function (p) {
        return deep(ast, p, map(deep(ast, p)));
      });
    });
  }
  var helperData = Object.create(null);
  function loadHelper(name) {
    if (!helperData[name]) {
      var helper = helpers$3[name];
      if (!helper) {
        throw Object.assign(new ReferenceError("Unknown helper " + name), {
          code: "BABEL_HELPER_UNKNOWN",
          helper: name
        });
      }
      helperData[name] = {
        minVersion: helper.minVersion,
        build: function build(getDependency, bindingName, localBindings, adjustAst) {
          var ast = helper.ast();
          permuteHelperAST(ast, helper.metadata, bindingName, localBindings, getDependency, adjustAst);
          return {
            nodes: ast.body,
            globals: helper.metadata.globals
          };
        },
        getDependencies: function getDependencies() {
          return Object.keys(helper.metadata.dependencies);
        }
      };
    }
    return helperData[name];
  }
  function get$4(name, getDependency, bindingName, localBindings, adjustAst) {
    {
      if (typeof bindingName === "object") {
        var id = bindingName;
        if ((id == null ? void 0 : id.type) === "Identifier") {
          bindingName = id.name;
        } else {
          bindingName = undefined;
        }
      }
    }
    return loadHelper(name).build(getDependency, bindingName, localBindings, adjustAst);
  }
  function minVersion(name) {
    return loadHelper(name).minVersion;
  }
  function getDependencies(name) {
    return loadHelper(name).getDependencies();
  }
  function isInternal(name) {
    var _helpers$name;
    return (_helpers$name = helpers$3[name]) == null ? void 0 : _helpers$name.metadata.internal;
  }
  {
    exports.ensure = function (name) {
      loadHelper(name);
    };
  }
  var list = Object.keys(helpers$3).map(function (name) {
    return name.replace(/^_/, "");
  });

  var ReferencedIdentifier$1 = ["Identifier", "JSXIdentifier"];
  var ReferencedMemberExpression = ["MemberExpression"];
  var BindingIdentifier = ["Identifier"];
  var Statement = ["Statement"];
  var Expression = ["Expression"];
  var Scope$1 = ["Scopable", "Pattern"];
  var Referenced = null;
  var BlockScoped = null;
  var Var = ["VariableDeclaration"];
  var User = null;
  var Generated = null;
  var Pure = null;
  var Flow = ["Flow", "ImportDeclaration", "ExportDeclaration", "ImportSpecifier"];
  var RestProperty = ["RestElement"];
  var SpreadProperty = ["RestElement"];
  var ExistentialTypeParam = ["ExistsTypeAnnotation"];
  var NumericLiteralTypeAnnotation = ["NumberLiteralTypeAnnotation"];
  var ForAwaitStatement = ["ForOfStatement"];

  var virtualTypes = /*#__PURE__*/Object.freeze({
    __proto__: null,
    BindingIdentifier: BindingIdentifier,
    BlockScoped: BlockScoped,
    ExistentialTypeParam: ExistentialTypeParam,
    Expression: Expression,
    Flow: Flow,
    ForAwaitStatement: ForAwaitStatement,
    Generated: Generated,
    NumericLiteralTypeAnnotation: NumericLiteralTypeAnnotation,
    Pure: Pure,
    Referenced: Referenced,
    ReferencedIdentifier: ReferencedIdentifier$1,
    ReferencedMemberExpression: ReferencedMemberExpression,
    RestProperty: RestProperty,
    Scope: Scope$1,
    SpreadProperty: SpreadProperty,
    Statement: Statement,
    User: User,
    Var: Var
  });

  var browser$1 = {exports: {}};

  var ms;
  var hasRequiredMs;
  function requireMs() {
    if (hasRequiredMs) return ms;
    hasRequiredMs = 1;
    var s = 1000;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    ms = function ms(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === 'string' && val.length > 0) {
        return parse(val);
      } else if (type === 'number' && isFinite(val)) {
        return options["long"] ? fmtLong(val) : fmtShort(val);
      }
      throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || 'ms').toLowerCase();
      switch (type) {
        case 'years':
        case 'year':
        case 'yrs':
        case 'yr':
        case 'y':
          return n * y;
        case 'weeks':
        case 'week':
        case 'w':
          return n * w;
        case 'days':
        case 'day':
        case 'd':
          return n * d;
        case 'hours':
        case 'hour':
        case 'hrs':
        case 'hr':
        case 'h':
          return n * h;
        case 'minutes':
        case 'minute':
        case 'mins':
        case 'min':
        case 'm':
          return n * m;
        case 'seconds':
        case 'second':
        case 'secs':
        case 'sec':
        case 's':
          return n * s;
        case 'milliseconds':
        case 'millisecond':
        case 'msecs':
        case 'msec':
        case 'ms':
          return n;
        default:
          return undefined;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + 'd';
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + 'h';
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + 'm';
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + 's';
      }
      return ms + 'ms';
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, 'day');
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, 'hour');
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, 'minute');
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, 'second');
      }
      return ms + ' ms';
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
    }
    return ms;
  }

  function setup$1(env) {
    createDebug.debug = createDebug;
    createDebug["default"] = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = requireMs();
    createDebug.destroy = destroy;
    Object.keys(env).forEach(function (key) {
      createDebug[key] = env[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      var hash = 0;
      for (var i = 0; i < namespace.length; i++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      var prevTime;
      var enableOverride = null;
      var namespacesCache;
      var enabledCache;
      function debug() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        if (!debug.enabled) {
          return;
        }
        var self = debug;
        var curr = Number(new Date());
        var ms = curr - (prevTime || curr);
        self.diff = ms;
        self.prev = prevTime;
        self.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== 'string') {
          args.unshift('%O');
        }
        var index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {
          if (match === '%%') {
            return '%';
          }
          index++;
          var formatter = createDebug.formatters[format];
          if (typeof formatter === 'function') {
            var val = args[index];
            match = formatter.call(self, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        createDebug.formatArgs.call(self, args);
        var logFn = self.log || createDebug.log;
        logFn.apply(self, args);
      }
      debug.namespace = namespace;
      debug.useColors = createDebug.useColors();
      debug.color = createDebug.selectColor(namespace);
      debug.extend = extend;
      debug.destroy = createDebug.destroy;
      Object.defineProperty(debug, 'enabled', {
        enumerable: true,
        configurable: false,
        get: function get() {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace);
          }
          return enabledCache;
        },
        set: function set(v) {
          enableOverride = v;
        }
      });
      if (typeof createDebug.init === 'function') {
        createDebug.init(debug);
      }
      return debug;
    }
    function extend(namespace, delimiter) {
      var newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      var split = (typeof namespaces === 'string' ? namespaces : '').trim().replace(/\s+/g, ',').split(',').filter(Boolean);
      for (var _iterator = _createForOfIteratorHelperLoose(split), _step; !(_step = _iterator()).done;) {
        var ns = _step.value;
        if (ns[0] === '-') {
          createDebug.skips.push(ns.slice(1));
        } else {
          createDebug.names.push(ns);
        }
      }
    }
    function matchesTemplate(search, template) {
      var searchIndex = 0;
      var templateIndex = 0;
      var starIndex = -1;
      var matchIndex = 0;
      while (searchIndex < search.length) {
        if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === '*')) {
          if (template[templateIndex] === '*') {
            starIndex = templateIndex;
            matchIndex = searchIndex;
            templateIndex++;
          } else {
            searchIndex++;
            templateIndex++;
          }
        } else if (starIndex !== -1) {
          templateIndex = starIndex + 1;
          matchIndex++;
          searchIndex = matchIndex;
        } else {
          return false;
        }
      }
      while (templateIndex < template.length && template[templateIndex] === '*') {
        templateIndex++;
      }
      return templateIndex === template.length;
    }
    function disable() {
      var namespaces = [].concat(_toConsumableArray(createDebug.names), _toConsumableArray(createDebug.skips.map(function (namespace) {
        return '-' + namespace;
      }))).join(',');
      createDebug.enable('');
      return namespaces;
    }
    function enabled(name) {
      for (var _iterator2 = _createForOfIteratorHelperLoose(createDebug.skips), _step2; !(_step2 = _iterator2()).done;) {
        var skip = _step2.value;
        if (matchesTemplate(name, skip)) {
          return false;
        }
      }
      for (var _iterator3 = _createForOfIteratorHelperLoose(createDebug.names), _step3; !(_step3 = _iterator3()).done;) {
        var ns = _step3.value;
        if (matchesTemplate(name, ns)) {
          return true;
        }
      }
      return false;
    }
    function coerce(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy() {
      console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  var common = setup$1;

  (function (module, exports) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = function () {
      var warned = false;
      return function () {
        if (!warned) {
          warned = true;
          console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
        }
      };
    }();
    exports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];
    function useColors() {
      if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      var m;
      return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== 'undefined' && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      var c = 'color: ' + this.color;
      args.splice(1, 0, c, 'color: inherit');
      var index = 0;
      var lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, function (match) {
        if (match === '%%') {
          return;
        }
        index++;
        if (match === '%c') {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports.log = console.debug || console.log || function () {};
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem('debug', namespaces);
        } else {
          exports.storage.removeItem('debug');
        }
      } catch (error) {}
    }
    function load() {
      var r;
      try {
        r = exports.storage.getItem('debug') || exports.storage.getItem('DEBUG');
      } catch (error) {}
      if (!r && typeof browser$1$1 !== 'undefined' && 'env' in browser$1$1) {
        r = browser$1$1.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {}
    }
    module.exports = common(exports);
    var formatters = module.exports.formatters;
    formatters.j = function (v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return '[UnexpectedJSONParseError]: ' + error.message;
      }
    };
  })(browser$1, browser$1.exports);
  var browserExports = browser$1.exports;

  var isBinding = isBinding$1,
    nodeIsBlockScoped = isBlockScoped$2,
    isExportDeclaration$1 = isExportDeclaration$2,
    nodeIsExpression = isExpression$5,
    nodeIsFlow = isFlow$1,
    isForStatement$1 = isForStatement$2,
    isForXStatement = isForXStatement$1,
    isIdentifier$c = isIdentifier$e,
    isImportDeclaration$2 = isImportDeclaration$3,
    isImportSpecifier = isImportSpecifier$1,
    isJSXIdentifier$1 = isJSXIdentifier$3,
    isJSXMemberExpression$1 = isJSXMemberExpression$2,
    isMemberExpression$6 = isMemberExpression$7,
    nodeIsRestElement = isRestElement$2,
    nodeIsReferenced = isReferenced$2,
    nodeIsScope = isScope$1,
    nodeIsStatement = isStatement$9,
    nodeIsVar = isVar$1,
    isVariableDeclaration$2 = isVariableDeclaration$3,
    react$2 = react$3,
    isForOfStatement$1 = isForOfStatement$2;
  var isCompatTag = react$2.isCompatTag;
  function isReferencedIdentifier(opts) {
    var node = this.node,
      parent = this.parent;
    if (!isIdentifier$c(node, opts) && !isJSXMemberExpression$1(parent, opts)) {
      if (isJSXIdentifier$1(node, opts)) {
        if (isCompatTag(node.name)) return false;
      } else {
        return false;
      }
    }
    return nodeIsReferenced(node, parent, this.parentPath.parent);
  }
  function isReferencedMemberExpression() {
    var node = this.node,
      parent = this.parent;
    return isMemberExpression$6(node) && nodeIsReferenced(node, parent);
  }
  function isBindingIdentifier() {
    var node = this.node,
      parent = this.parent;
    var grandparent = this.parentPath.parent;
    return isIdentifier$c(node) && isBinding(node, parent, grandparent);
  }
  function isStatement$6() {
    var node = this.node,
      parent = this.parent;
    if (nodeIsStatement(node)) {
      if (isVariableDeclaration$2(node)) {
        if (isForXStatement(parent, {
          left: node
        })) return false;
        if (isForStatement$1(parent, {
          init: node
        })) return false;
      }
      return true;
    } else {
      return false;
    }
  }
  function isExpression$4() {
    if (this.isIdentifier()) {
      return this.isReferencedIdentifier();
    } else {
      return nodeIsExpression(this.node);
    }
  }
  function isScope() {
    return nodeIsScope(this.node, this.parent);
  }
  function isReferenced$1() {
    return nodeIsReferenced(this.node, this.parent);
  }
  function isBlockScoped$1() {
    return nodeIsBlockScoped(this.node);
  }
  function isVar() {
    return nodeIsVar(this.node);
  }
  function isUser() {
    return this.node && !!this.node.loc;
  }
  function isGenerated() {
    return !this.isUser();
  }
  function isPure(constantsOnly) {
    return this.scope.isPure(this.node, constantsOnly);
  }
  function isFlow() {
    var node = this.node;
    if (nodeIsFlow(node)) {
      return true;
    } else if (isImportDeclaration$2(node)) {
      return node.importKind === "type" || node.importKind === "typeof";
    } else if (isExportDeclaration$1(node)) {
      return node.exportKind === "type";
    } else if (isImportSpecifier(node)) {
      return node.importKind === "type" || node.importKind === "typeof";
    } else {
      return false;
    }
  }
  function isRestProperty() {
    var _this$parentPath;
    return nodeIsRestElement(this.node) && ((_this$parentPath = this.parentPath) == null ? void 0 : _this$parentPath.isObjectPattern());
  }
  function isSpreadProperty() {
    var _this$parentPath2;
    return nodeIsRestElement(this.node) && ((_this$parentPath2 = this.parentPath) == null ? void 0 : _this$parentPath2.isObjectExpression());
  }
  function isForAwaitStatement() {
    return isForOfStatement$1(this.node, {
      "await": true
    });
  }
  {
    exports.isExistentialTypeParam = function isExistentialTypeParam() {
      throw new Error("`path.isExistentialTypeParam` has been renamed to `path.isExistsTypeAnnotation()` in Babel 7.");
    };
    exports.isNumericLiteralTypeAnnotation = function isNumericLiteralTypeAnnotation() {
      throw new Error("`path.isNumericLiteralTypeAnnotation()` has been renamed to `path.isNumberLiteralTypeAnnotation()` in Babel 7.");
    };
  }

  var NodePath_virtual_types_validator = /*#__PURE__*/Object.freeze({
    __proto__: null,
    isBindingIdentifier: isBindingIdentifier,
    isBlockScoped: isBlockScoped$1,
    isExpression: isExpression$4,
    isFlow: isFlow,
    isForAwaitStatement: isForAwaitStatement,
    isGenerated: isGenerated,
    isPure: isPure,
    isReferenced: isReferenced$1,
    isReferencedIdentifier: isReferencedIdentifier,
    isReferencedMemberExpression: isReferencedMemberExpression,
    isRestProperty: isRestProperty,
    isScope: isScope,
    isSpreadProperty: isSpreadProperty,
    isStatement: isStatement$6,
    isUser: isUser,
    isVar: isVar
  });

  var DEPRECATED_KEYS = DEPRECATED_KEYS$1,
    DEPRECATED_ALIASES = DEPRECATED_ALIASES$1,
    FLIPPED_ALIAS_KEYS$2 = FLIPPED_ALIAS_KEYS$3,
    TYPES = TYPES$1,
    deprecationWarning = deprecationWarning$1;
  function isVirtualType(type) {
    return type in virtualTypes;
  }
  function isExplodedVisitor(visitor) {
    return visitor == null ? void 0 : visitor._exploded;
  }
  function explode$1(visitor) {
    if (isExplodedVisitor(visitor)) return visitor;
    visitor._exploded = true;
    for (var _i = 0, _arr = Object.keys(visitor); _i < _arr.length; _i++) {
      var nodeType = _arr[_i];
      if (shouldIgnoreKey(nodeType)) continue;
      var parts = nodeType.split("|");
      if (parts.length === 1) continue;
      var fns = visitor[nodeType];
      delete visitor[nodeType];
      for (var _iterator = _createForOfIteratorHelperLoose(parts), _step; !(_step = _iterator()).done;) {
        var part = _step.value;
        visitor[part] = fns;
      }
    }
    verify$1(visitor);
    delete visitor.__esModule;
    ensureEntranceObjects(visitor);
    ensureCallbackArrays(visitor);
    for (var _i2 = 0, _Object$keys = Object.keys(visitor); _i2 < _Object$keys.length; _i2++) {
      var _nodeType = _Object$keys[_i2];
      if (shouldIgnoreKey(_nodeType)) continue;
      if (!isVirtualType(_nodeType)) continue;
      var _fns = visitor[_nodeType];
      for (var _i3 = 0, _Object$keys2 = Object.keys(_fns); _i3 < _Object$keys2.length; _i3++) {
        var type = _Object$keys2[_i3];
        _fns[type] = wrapCheck(_nodeType, _fns[type]);
      }
      delete visitor[_nodeType];
      var types = virtualTypes[_nodeType];
      if (types !== null) {
        for (var _iterator2 = _createForOfIteratorHelperLoose(types), _step2; !(_step2 = _iterator2()).done;) {
          var _type = _step2.value;
          if (visitor[_type]) {
            mergePair(visitor[_type], _fns);
          } else {
            visitor[_type] = _fns;
          }
        }
      } else {
        mergePair(visitor, _fns);
      }
    }
    for (var _i4 = 0, _arr2 = Object.keys(visitor); _i4 < _arr2.length; _i4++) {
      var _nodeType2 = _arr2[_i4];
      if (shouldIgnoreKey(_nodeType2)) continue;
      var aliases = FLIPPED_ALIAS_KEYS$2[_nodeType2];
      if (_nodeType2 in DEPRECATED_KEYS) {
        var deprecatedKey = DEPRECATED_KEYS[_nodeType2];
        deprecationWarning(_nodeType2, deprecatedKey, "Visitor ");
        aliases = [deprecatedKey];
      } else if (_nodeType2 in DEPRECATED_ALIASES) {
        var deprecatedAlias = DEPRECATED_ALIASES[_nodeType2];
        deprecationWarning(_nodeType2, deprecatedAlias, "Visitor ");
        aliases = FLIPPED_ALIAS_KEYS$2[deprecatedAlias];
      }
      if (!aliases) continue;
      var _fns2 = visitor[_nodeType2];
      delete visitor[_nodeType2];
      for (var _iterator3 = _createForOfIteratorHelperLoose(aliases), _step3; !(_step3 = _iterator3()).done;) {
        var alias = _step3.value;
        var existing = visitor[alias];
        if (existing) {
          mergePair(existing, _fns2);
        } else {
          visitor[alias] = Object.assign({}, _fns2);
        }
      }
    }
    for (var _i5 = 0, _Object$keys3 = Object.keys(visitor); _i5 < _Object$keys3.length; _i5++) {
      var _nodeType3 = _Object$keys3[_i5];
      if (shouldIgnoreKey(_nodeType3)) continue;
      ensureCallbackArrays(visitor[_nodeType3]);
    }
    return visitor;
  }
  function verify$1(visitor) {
    if (visitor._verified) return;
    if (typeof visitor === "function") {
      throw new Error("You passed `traverse()` a function when it expected a visitor object, " + "are you sure you didn't mean `{ enter: Function }`?");
    }
    for (var _i6 = 0, _arr3 = Object.keys(visitor); _i6 < _arr3.length; _i6++) {
      var nodeType = _arr3[_i6];
      if (nodeType === "enter" || nodeType === "exit") {
        validateVisitorMethods(nodeType, visitor[nodeType]);
      }
      if (shouldIgnoreKey(nodeType)) continue;
      if (!TYPES.includes(nodeType)) {
        throw new Error("You gave us a visitor for the node type " + nodeType + " but it's not a valid type in @babel/traverse " + "7.28.0");
      }
      var _visitors = visitor[nodeType];
      if (typeof _visitors === "object") {
        for (var _i7 = 0, _Object$keys4 = Object.keys(_visitors); _i7 < _Object$keys4.length; _i7++) {
          var visitorKey = _Object$keys4[_i7];
          if (visitorKey === "enter" || visitorKey === "exit") {
            validateVisitorMethods(nodeType + "." + visitorKey, _visitors[visitorKey]);
          } else {
            throw new Error("You passed `traverse()` a visitor object with the property " + (nodeType + " that has the invalid property " + visitorKey));
          }
        }
      }
    }
    visitor._verified = true;
  }
  function validateVisitorMethods(path, val) {
    var fns = [].concat(val);
    for (var _iterator4 = _createForOfIteratorHelperLoose(fns), _step4; !(_step4 = _iterator4()).done;) {
      var fn = _step4.value;
      if (typeof fn !== "function") {
        throw new TypeError("Non-function found defined in " + path + " with type " + typeof fn);
      }
    }
  }
  function merge(visitors, states, wrapper) {
    if (states === void 0) {
      states = [];
    }
    var mergedVisitor = {
      _verified: true,
      _exploded: true
    };
    {
      Object.defineProperty(mergedVisitor, "_exploded", {
        enumerable: false
      });
      Object.defineProperty(mergedVisitor, "_verified", {
        enumerable: false
      });
    }
    for (var i = 0; i < visitors.length; i++) {
      var visitor = explode$1(visitors[i]);
      var state = states[i];
      var topVisitor = visitor;
      if (state || wrapper) {
        topVisitor = wrapWithStateOrWrapper(topVisitor, state, wrapper);
      }
      mergePair(mergedVisitor, topVisitor);
      for (var _i8 = 0, _arr4 = Object.keys(visitor); _i8 < _arr4.length; _i8++) {
        var key = _arr4[_i8];
        if (shouldIgnoreKey(key)) continue;
        var typeVisitor = visitor[key];
        if (state || wrapper) {
          typeVisitor = wrapWithStateOrWrapper(typeVisitor, state, wrapper);
        }
        var nodeVisitor = mergedVisitor[key] || (mergedVisitor[key] = {});
        mergePair(nodeVisitor, typeVisitor);
      }
    }
    return mergedVisitor;
  }
  function wrapWithStateOrWrapper(oldVisitor, state, wrapper) {
    var newVisitor = {};
    var _loop = function _loop() {
      var phase = _arr5[_i9];
      var fns = oldVisitor[phase];
      if (!Array.isArray(fns)) return 1;
      fns = fns.map(function (fn) {
        var newFn = fn;
        if (state) {
          newFn = function newFn(path) {
            fn.call(state, path, state);
          };
        }
        if (wrapper) {
          newFn = wrapper(state == null ? void 0 : state.key, phase, newFn);
        }
        if (newFn !== fn) {
          newFn.toString = function () {
            return fn.toString();
          };
        }
        return newFn;
      });
      newVisitor[phase] = fns;
    };
    for (var _i9 = 0, _arr5 = ["enter", "exit"]; _i9 < _arr5.length; _i9++) {
      if (_loop()) continue;
    }
    return newVisitor;
  }
  function ensureEntranceObjects(obj) {
    for (var _i0 = 0, _arr6 = Object.keys(obj); _i0 < _arr6.length; _i0++) {
      var key = _arr6[_i0];
      if (shouldIgnoreKey(key)) continue;
      var fns = obj[key];
      if (typeof fns === "function") {
        obj[key] = {
          enter: fns
        };
      }
    }
  }
  function ensureCallbackArrays(obj) {
    if (obj.enter && !Array.isArray(obj.enter)) obj.enter = [obj.enter];
    if (obj.exit && !Array.isArray(obj.exit)) obj.exit = [obj.exit];
  }
  function wrapCheck(nodeType, fn) {
    var fnKey = "is" + nodeType;
    var validator = NodePath_virtual_types_validator[fnKey];
    var newFn = function newFn(path) {
      if (validator.call(path)) {
        return fn.apply(this, arguments);
      }
    };
    newFn.toString = function () {
      return fn.toString();
    };
    return newFn;
  }
  function shouldIgnoreKey(key) {
    if (key[0] === "_") return true;
    if (key === "enter" || key === "exit" || key === "shouldSkip") return true;
    if (key === "denylist" || key === "noScope" || key === "skipKeys") {
      return true;
    }
    {
      if (key === "blacklist") {
        return true;
      }
    }
    return false;
  }
  function mergePair(dest, src) {
    for (var _i1 = 0, _arr7 = ["enter", "exit"]; _i1 < _arr7.length; _i1++) {
      var phase = _arr7[_i1];
      if (!src[phase]) continue;
      dest[phase] = [].concat(dest[phase] || [], src[phase]);
    }
  }
  var _environmentVisitor = {
    FunctionParent: function FunctionParent(path) {
      if (path.isArrowFunctionExpression()) return;
      path.skip();
      if (path.isMethod()) {
        if (!path.requeueComputedKeyAndDecorators) {
          requeueComputedKeyAndDecorators.call(path);
        } else {
          path.requeueComputedKeyAndDecorators();
        }
      }
    },
    Property: function Property(path) {
      if (path.isObjectProperty()) return;
      path.skip();
      if (!path.requeueComputedKeyAndDecorators) {
        requeueComputedKeyAndDecorators.call(path);
      } else {
        path.requeueComputedKeyAndDecorators();
      }
    }
  };
  function environmentVisitor(visitor) {
    return merge([_environmentVisitor, visitor]);
  }

  var visitors$2 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    environmentVisitor: environmentVisitor,
    explode: explode$1,
    isExplodedVisitor: isExplodedVisitor,
    merge: merge,
    verify: verify$1
  });

  var getAssignmentIdentifiers$1 = getAssignmentIdentifiers$2;
  var renameVisitor = {
    ReferencedIdentifier: function ReferencedIdentifier(_ref, state) {
      var node = _ref.node;
      if (node.name === state.oldName) {
        node.name = state.newName;
      }
    },
    Scope: function Scope(path, state) {
      if (!path.scope.bindingIdentifierEquals(state.oldName, state.binding.identifier)) {
        path.skip();
        if (path.isMethod()) {
          if (!path.requeueComputedKeyAndDecorators) {
            requeueComputedKeyAndDecorators.call(path);
          } else {
            path.requeueComputedKeyAndDecorators();
          }
        }
      }
    },
    ObjectProperty: function ObjectProperty(_ref2, state) {
      var node = _ref2.node,
        scope = _ref2.scope;
      var _ref3 = node.key,
        name = _ref3.name;
      if (node.shorthand && (name === state.oldName || name === state.newName) && scope.getBindingIdentifier(name) === state.binding.identifier) {
        node.shorthand = false;
        {
          var _node$extra;
          if ((_node$extra = node.extra) != null && _node$extra.shorthand) node.extra.shorthand = false;
        }
      }
    },
    "AssignmentExpression|Declaration|VariableDeclarator": function AssignmentExpressionDeclarationVariableDeclarator(path, state) {
      if (path.isVariableDeclaration()) return;
      var ids = path.isAssignmentExpression() ? getAssignmentIdentifiers$1(path.node) : path.getOuterBindingIdentifiers();
      for (var name in ids) {
        if (name === state.oldName) ids[name].name = state.newName;
      }
    }
  };
  var Renamer = function () {
    function Renamer(binding, oldName, newName) {
      this.newName = newName;
      this.oldName = oldName;
      this.binding = binding;
    }
    var _proto = Renamer.prototype;
    _proto.maybeConvertFromExportDeclaration = function maybeConvertFromExportDeclaration(parentDeclar) {
      var maybeExportDeclar = parentDeclar.parentPath;
      if (!maybeExportDeclar.isExportDeclaration()) {
        return;
      }
      if (maybeExportDeclar.isExportDefaultDeclaration()) {
        var declaration = maybeExportDeclar.node.declaration;
        if (isDeclaration(declaration) && !declaration.id) {
          return;
        }
      }
      if (maybeExportDeclar.isExportAllDeclaration()) {
        return;
      }
      maybeExportDeclar.splitExportDeclaration();
    };
    _proto.maybeConvertFromClassFunctionDeclaration = function maybeConvertFromClassFunctionDeclaration(path) {
      return path;
    };
    _proto.maybeConvertFromClassFunctionExpression = function maybeConvertFromClassFunctionExpression(path) {
      return path;
    };
    _proto.rename = function rename() {
      var binding = this.binding,
        oldName = this.oldName,
        newName = this.newName;
      var scope = binding.scope,
        path = binding.path;
      var parentDeclar = path.find(function (path) {
        return path.isDeclaration() || path.isFunctionExpression() || path.isClassExpression();
      });
      if (parentDeclar) {
        var bindingIds = parentDeclar.getOuterBindingIdentifiers();
        if (bindingIds[oldName] === binding.identifier) {
          this.maybeConvertFromExportDeclaration(parentDeclar);
        }
      }
      var blockToTraverse = arguments[0] || scope.block;
      var skipKeys = {
        discriminant: true
      };
      if (isMethod$1(blockToTraverse)) {
        if (blockToTraverse.computed) {
          skipKeys.key = true;
        }
        if (!isObjectMethod(blockToTraverse)) {
          skipKeys.decorators = true;
        }
      }
      traverseNode(blockToTraverse, explode$1(renameVisitor), scope, this, scope.path, skipKeys);
      if (!arguments[0]) {
        scope.removeOwnBinding(oldName);
        scope.bindings[newName] = binding;
        this.binding.identifier.name = newName;
      }
      if (parentDeclar) {
        this.maybeConvertFromClassFunctionDeclaration(path);
        this.maybeConvertFromClassFunctionExpression(path);
      }
    };
    return _createClass(Renamer);
  }();

  var Binding = function () {
    function Binding(_ref) {
      var identifier = _ref.identifier,
        scope = _ref.scope,
        path = _ref.path,
        kind = _ref.kind;
      this.identifier = void 0;
      this.scope = void 0;
      this.path = void 0;
      this.kind = void 0;
      this.constantViolations = [];
      this.constant = true;
      this.referencePaths = [];
      this.referenced = false;
      this.references = 0;
      this.identifier = identifier;
      this.scope = scope;
      this.path = path;
      this.kind = kind;
      if ((kind === "var" || kind === "hoisted") && isInitInLoop(path)) {
        this.reassign(path);
      }
      this.clearValue();
    }
    var _proto = Binding.prototype;
    _proto.deoptValue = function deoptValue() {
      this.clearValue();
      this.hasDeoptedValue = true;
    };
    _proto.setValue = function setValue(value) {
      if (this.hasDeoptedValue) return;
      this.hasValue = true;
      this.value = value;
    };
    _proto.clearValue = function clearValue() {
      this.hasDeoptedValue = false;
      this.hasValue = false;
      this.value = null;
    };
    _proto.reassign = function reassign(path) {
      this.constant = false;
      if (this.constantViolations.includes(path)) {
        return;
      }
      this.constantViolations.push(path);
    };
    _proto.reference = function reference(path) {
      if (this.referencePaths.includes(path)) {
        return;
      }
      this.referenced = true;
      this.references++;
      this.referencePaths.push(path);
    };
    _proto.dereference = function dereference() {
      this.references--;
      this.referenced = !!this.references;
    };
    return _createClass(Binding);
  }();
  function isInitInLoop(path) {
    var isFunctionDeclarationOrHasInit = !path.isVariableDeclarator() || path.node.init;
    for (var parentPath = path.parentPath, key = path.key; parentPath; _parentPath = parentPath, parentPath = _parentPath.parentPath, key = _parentPath.key, _parentPath) {
      var _parentPath;
      if (parentPath.isFunctionParent()) return false;
      if (key === "left" && parentPath.isForXStatement() || isFunctionDeclarationOrHasInit && key === "body" && parentPath.isLoop()) {
        return true;
      }
    }
    return false;
  }

  var globalsBuiltinLower = [
  	"decodeURI",
  	"decodeURIComponent",
  	"encodeURI",
  	"encodeURIComponent",
  	"escape",
  	"eval",
  	"globalThis",
  	"isFinite",
  	"isNaN",
  	"parseFloat",
  	"parseInt",
  	"undefined",
  	"unescape"
  ];

  var globalsBuiltinUpper = [
  	"AggregateError",
  	"Array",
  	"ArrayBuffer",
  	"Atomics",
  	"BigInt",
  	"BigInt64Array",
  	"BigUint64Array",
  	"Boolean",
  	"DataView",
  	"Date",
  	"Error",
  	"EvalError",
  	"FinalizationRegistry",
  	"Float16Array",
  	"Float32Array",
  	"Float64Array",
  	"Function",
  	"Infinity",
  	"Int16Array",
  	"Int32Array",
  	"Int8Array",
  	"Intl",
  	"Iterator",
  	"JSON",
  	"Map",
  	"Math",
  	"NaN",
  	"Number",
  	"Object",
  	"Promise",
  	"Proxy",
  	"RangeError",
  	"ReferenceError",
  	"Reflect",
  	"RegExp",
  	"Set",
  	"SharedArrayBuffer",
  	"String",
  	"Symbol",
  	"SyntaxError",
  	"TypeError",
  	"Uint16Array",
  	"Uint32Array",
  	"Uint8Array",
  	"Uint8ClampedArray",
  	"URIError",
  	"WeakMap",
  	"WeakRef",
  	"WeakSet"
  ];

  var pathsCache = new WeakMap();
  var scope = new WeakMap();
  function clear() {
    clearPath();
    clearScope();
  }
  function clearPath() {
    pathsCache = new WeakMap();
  }
  function clearScope() {
    scope = new WeakMap();
  }
  function getCachedPaths(path) {
    var parent = path.parent;
      path.parentPath;
    return pathsCache.get(parent);
  }
  function getOrCreateCachedPaths(node, parentPath) {
    var paths = pathsCache.get(node);
    if (!paths) pathsCache.set(node, paths = new Map());
    return paths;
  }

  var cache$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    clear: clear,
    clearPath: clearPath,
    clearScope: clearScope,
    getCachedPaths: getCachedPaths,
    getOrCreateCachedPaths: getOrCreateCachedPaths,
    get path () { return pathsCache; },
    get scope () { return scope; }
  });

  var assignmentExpression$7 = assignmentExpression$8,
    callExpression$b = callExpression$c,
    cloneNode$b = cloneNode$e,
    getBindingIdentifiers$3 = getBindingIdentifiers$4,
    identifier$b = identifier$e,
    isArrayExpression$1 = isArrayExpression$2,
    isBinary$1 = isBinary$2,
    isCallExpression$6 = isCallExpression$8,
    isClass = isClass$1,
    isClassBody$1 = isClassBody$2,
    isClassDeclaration$1 = isClassDeclaration$2,
    isExportAllDeclaration = isExportAllDeclaration$1,
    isExportDefaultDeclaration$1 = isExportDefaultDeclaration$2,
    isExportNamedDeclaration$2 = isExportNamedDeclaration$3,
    isFunctionDeclaration$1 = isFunctionDeclaration$2,
    isIdentifier$b = isIdentifier$e,
    isImportDeclaration$1 = isImportDeclaration$3,
    isLiteral$3 = isLiteral$4,
    isMemberExpression$5 = isMemberExpression$7,
    isMethod = isMethod$1,
    isModuleSpecifier = isModuleSpecifier$1,
    isNullLiteral = isNullLiteral$1,
    isObjectExpression$2 = isObjectExpression$3,
    isProperty = isProperty$1,
    isPureish = isPureish$1,
    isRegExpLiteral = isRegExpLiteral$1,
    isSuper$1 = isSuper$2,
    isTaggedTemplateExpression = isTaggedTemplateExpression$1,
    isTemplateLiteral = isTemplateLiteral$1,
    isThisExpression$1 = isThisExpression$2,
    isUnaryExpression = isUnaryExpression$1,
    isVariableDeclaration$1 = isVariableDeclaration$3,
    expressionStatement$5 = expressionStatement$7,
    matchesPattern$1 = matchesPattern$2,
    memberExpression$9 = memberExpression$a,
    numericLiteral$4 = numericLiteral$5,
    toIdentifier = toIdentifier$1,
    variableDeclaration$5 = variableDeclaration$6,
    variableDeclarator$5 = variableDeclarator$6,
    isRecordExpression = isRecordExpression$1,
    isTupleExpression = isTupleExpression$1,
    isObjectProperty$1 = isObjectProperty$2,
    isTopicReference = isTopicReference$1,
    isMetaProperty = isMetaProperty$1,
    isPrivateName$1 = isPrivateName$2,
    isExportDeclaration = isExportDeclaration$2,
    _buildUndefinedNode = buildUndefinedNode$2,
    sequenceExpression$5 = sequenceExpression$6;
  function gatherNodeParts(node, parts) {
    switch (node == null ? void 0 : node.type) {
      default:
        if (isImportDeclaration$1(node) || isExportDeclaration(node)) {
          var _node$specifiers;
          if ((isExportAllDeclaration(node) || isExportNamedDeclaration$2(node) || isImportDeclaration$1(node)) && node.source) {
            gatherNodeParts(node.source, parts);
          } else if ((isExportNamedDeclaration$2(node) || isImportDeclaration$1(node)) && (_node$specifiers = node.specifiers) != null && _node$specifiers.length) {
            for (var _iterator = _createForOfIteratorHelperLoose(node.specifiers), _step; !(_step = _iterator()).done;) {
              var e = _step.value;
              gatherNodeParts(e, parts);
            }
          } else if ((isExportDefaultDeclaration$1(node) || isExportNamedDeclaration$2(node)) && node.declaration) {
            gatherNodeParts(node.declaration, parts);
          }
        } else if (isModuleSpecifier(node)) {
          gatherNodeParts(node.local, parts);
        } else if (isLiteral$3(node) && !isNullLiteral(node) && !isRegExpLiteral(node) && !isTemplateLiteral(node)) {
          parts.push(node.value);
        }
        break;
      case "MemberExpression":
      case "OptionalMemberExpression":
      case "JSXMemberExpression":
        gatherNodeParts(node.object, parts);
        gatherNodeParts(node.property, parts);
        break;
      case "Identifier":
      case "JSXIdentifier":
        parts.push(node.name);
        break;
      case "CallExpression":
      case "OptionalCallExpression":
      case "NewExpression":
        gatherNodeParts(node.callee, parts);
        break;
      case "ObjectExpression":
      case "ObjectPattern":
        for (var _iterator2 = _createForOfIteratorHelperLoose(node.properties), _step2; !(_step2 = _iterator2()).done;) {
          var _e = _step2.value;
          gatherNodeParts(_e, parts);
        }
        break;
      case "SpreadElement":
      case "RestElement":
        gatherNodeParts(node.argument, parts);
        break;
      case "ObjectProperty":
      case "ObjectMethod":
      case "ClassProperty":
      case "ClassMethod":
      case "ClassPrivateProperty":
      case "ClassPrivateMethod":
        gatherNodeParts(node.key, parts);
        break;
      case "ThisExpression":
        parts.push("this");
        break;
      case "Super":
        parts.push("super");
        break;
      case "Import":
      case "ImportExpression":
        parts.push("import");
        break;
      case "DoExpression":
        parts.push("do");
        break;
      case "YieldExpression":
        parts.push("yield");
        gatherNodeParts(node.argument, parts);
        break;
      case "AwaitExpression":
        parts.push("await");
        gatherNodeParts(node.argument, parts);
        break;
      case "AssignmentExpression":
        gatherNodeParts(node.left, parts);
        break;
      case "VariableDeclarator":
        gatherNodeParts(node.id, parts);
        break;
      case "FunctionExpression":
      case "FunctionDeclaration":
      case "ClassExpression":
      case "ClassDeclaration":
        gatherNodeParts(node.id, parts);
        break;
      case "PrivateName":
        gatherNodeParts(node.id, parts);
        break;
      case "ParenthesizedExpression":
        gatherNodeParts(node.expression, parts);
        break;
      case "UnaryExpression":
      case "UpdateExpression":
        gatherNodeParts(node.argument, parts);
        break;
      case "MetaProperty":
        gatherNodeParts(node.meta, parts);
        gatherNodeParts(node.property, parts);
        break;
      case "JSXElement":
        gatherNodeParts(node.openingElement, parts);
        break;
      case "JSXOpeningElement":
        gatherNodeParts(node.name, parts);
        break;
      case "JSXFragment":
        gatherNodeParts(node.openingFragment, parts);
        break;
      case "JSXOpeningFragment":
        parts.push("Fragment");
        break;
      case "JSXNamespacedName":
        gatherNodeParts(node.namespace, parts);
        gatherNodeParts(node.name, parts);
        break;
    }
  }
  function resetScope(scope) {
    {
      scope.references = Object.create(null);
      scope.uids = Object.create(null);
    }
    scope.bindings = Object.create(null);
    scope.globals = Object.create(null);
  }
  {
    var NOT_LOCAL_BINDING = Symbol["for"]("should not be considered a local binding");
  }
  var collectorVisitor = {
    ForStatement: function ForStatement(path) {
      var declar = path.get("init");
      if (declar.isVar()) {
        var scope = path.scope;
        var parentScope = scope.getFunctionParent() || scope.getProgramParent();
        parentScope.registerBinding("var", declar);
      }
    },
    Declaration: function Declaration(path) {
      if (path.isBlockScoped()) return;
      if (path.isImportDeclaration()) return;
      if (path.isExportDeclaration()) return;
      var parent = path.scope.getFunctionParent() || path.scope.getProgramParent();
      parent.registerDeclaration(path);
    },
    ImportDeclaration: function ImportDeclaration(path) {
      var parent = path.scope.getBlockParent();
      parent.registerDeclaration(path);
    },
    TSImportEqualsDeclaration: function TSImportEqualsDeclaration(path) {
      var parent = path.scope.getBlockParent();
      parent.registerDeclaration(path);
    },
    ReferencedIdentifier: function ReferencedIdentifier(path, state) {
      if (isTSQualifiedName(path.parent) && path.parent.right === path.node) {
        return;
      }
      if (path.parentPath.isTSImportEqualsDeclaration()) return;
      state.references.push(path);
    },
    ForXStatement: function ForXStatement(path, state) {
      var left = path.get("left");
      if (left.isPattern() || left.isIdentifier()) {
        state.constantViolations.push(path);
      } else if (left.isVar()) {
        var scope = path.scope;
        var parentScope = scope.getFunctionParent() || scope.getProgramParent();
        parentScope.registerBinding("var", left);
      }
    },
    ExportDeclaration: {
      exit: function exit(path) {
        var node = path.node,
          scope = path.scope;
        if (isExportAllDeclaration(node)) return;
        var declar = node.declaration;
        if (isClassDeclaration$1(declar) || isFunctionDeclaration$1(declar)) {
          var id = declar.id;
          if (!id) return;
          var binding = scope.getBinding(id.name);
          binding == null || binding.reference(path);
        } else if (isVariableDeclaration$1(declar)) {
          for (var _iterator3 = _createForOfIteratorHelperLoose(declar.declarations), _step3; !(_step3 = _iterator3()).done;) {
            var decl = _step3.value;
            for (var _i = 0, _Object$keys = Object.keys(getBindingIdentifiers$3(decl)); _i < _Object$keys.length; _i++) {
              var name = _Object$keys[_i];
              var _binding = scope.getBinding(name);
              _binding == null || _binding.reference(path);
            }
          }
        }
      }
    },
    LabeledStatement: function LabeledStatement(path) {
      path.scope.getBlockParent().registerDeclaration(path);
    },
    AssignmentExpression: function AssignmentExpression(path, state) {
      state.assignments.push(path);
    },
    UpdateExpression: function UpdateExpression(path, state) {
      state.constantViolations.push(path);
    },
    UnaryExpression: function UnaryExpression(path, state) {
      if (path.node.operator === "delete") {
        state.constantViolations.push(path);
      }
    },
    BlockScoped: function BlockScoped(path) {
      var scope = path.scope;
      if (scope.path === path) scope = scope.parent;
      var parent = scope.getBlockParent();
      parent.registerDeclaration(path);
      if (path.isClassDeclaration() && path.node.id) {
        var id = path.node.id;
        var name = id.name;
        path.scope.bindings[name] = path.scope.parent.getBinding(name);
      }
    },
    CatchClause: function CatchClause(path) {
      path.scope.registerBinding("let", path);
    },
    Function: function Function(path) {
      var params = path.get("params");
      for (var _iterator4 = _createForOfIteratorHelperLoose(params), _step4; !(_step4 = _iterator4()).done;) {
        var param = _step4.value;
        path.scope.registerBinding("param", param);
      }
      if (path.isFunctionExpression() && path.node.id && !path.node.id[NOT_LOCAL_BINDING]) {
        path.scope.registerBinding("local", path.get("id"), path);
      }
    },
    ClassExpression: function ClassExpression(path) {
      if (path.node.id && !path.node.id[NOT_LOCAL_BINDING]) {
        path.scope.registerBinding("local", path.get("id"), path);
      }
    },
    TSTypeAnnotation: function TSTypeAnnotation(path) {
      path.skip();
    }
  };
  var scopeVisitor;
  var uid = 0;
  var Scope = function () {
    function Scope(path) {
      this.uid = void 0;
      this.path = void 0;
      this.block = void 0;
      this.inited = void 0;
      this.labels = void 0;
      this.bindings = void 0;
      this.referencesSet = void 0;
      this.globals = void 0;
      this.uidsSet = void 0;
      this.data = void 0;
      this.crawling = void 0;
      var node = path.node;
      var cached = scope.get(node);
      if ((cached == null ? void 0 : cached.path) === path) {
        return cached;
      }
      scope.set(node, this);
      this.uid = uid++;
      this.block = node;
      this.path = path;
      this.labels = new Map();
      this.inited = false;
      {
        Object.defineProperties(this, {
          references: {
            enumerable: true,
            configurable: true,
            writable: true,
            value: Object.create(null)
          },
          uids: {
            enumerable: true,
            configurable: true,
            writable: true,
            value: Object.create(null)
          }
        });
      }
    }
    var _proto = Scope.prototype;
    _proto.generateDeclaredUidIdentifier = function generateDeclaredUidIdentifier(name) {
      var id = this.generateUidIdentifier(name);
      this.push({
        id: id
      });
      return cloneNode$b(id);
    };
    _proto.generateUidIdentifier = function generateUidIdentifier(name) {
      return identifier$b(this.generateUid(name));
    };
    _proto.generateUid = function generateUid(name) {
      if (name === void 0) {
        name = "temp";
      }
      name = toIdentifier(name).replace(/^_+/, "").replace(/\d+$/g, "");
      var uid;
      var i = 0;
      do {
        uid = "_" + name;
        if (i >= 11) uid += i - 1;else if (i >= 9) uid += i - 9;else if (i >= 1) uid += i + 1;
        i++;
      } while (this.hasLabel(uid) || this.hasBinding(uid) || this.hasGlobal(uid) || this.hasReference(uid));
      var program = this.getProgramParent();
      {
        program.references[uid] = true;
        program.uids[uid] = true;
      }
      return uid;
    };
    _proto.generateUidBasedOnNode = function generateUidBasedOnNode(node, defaultName) {
      var parts = [];
      gatherNodeParts(node, parts);
      var id = parts.join("$");
      id = id.replace(/^_/, "") || defaultName || "ref";
      return this.generateUid(id.slice(0, 20));
    };
    _proto.generateUidIdentifierBasedOnNode = function generateUidIdentifierBasedOnNode(node, defaultName) {
      return identifier$b(this.generateUidBasedOnNode(node, defaultName));
    };
    _proto.isStatic = function isStatic(node) {
      if (isThisExpression$1(node) || isSuper$1(node) || isTopicReference(node)) {
        return true;
      }
      if (isIdentifier$b(node)) {
        var binding = this.getBinding(node.name);
        if (binding) {
          return binding.constant;
        } else {
          return this.hasBinding(node.name);
        }
      }
      return false;
    };
    _proto.maybeGenerateMemoised = function maybeGenerateMemoised(node, dontPush) {
      if (this.isStatic(node)) {
        return null;
      } else {
        var id = this.generateUidIdentifierBasedOnNode(node);
        if (!dontPush) {
          this.push({
            id: id
          });
          return cloneNode$b(id);
        }
        return id;
      }
    };
    _proto.checkBlockScopedCollisions = function checkBlockScopedCollisions(local, kind, name, id) {
      if (kind === "param") return;
      if (local.kind === "local") return;
      var duplicate = kind === "let" || local.kind === "let" || local.kind === "const" || local.kind === "module" || local.kind === "param" && kind === "const";
      if (duplicate) {
        throw this.path.hub.buildError(id, "Duplicate declaration \"" + name + "\"", TypeError);
      }
    };
    _proto.rename = function rename(oldName, newName) {
      var binding = this.getBinding(oldName);
      if (binding) {
        newName || (newName = this.generateUidIdentifier(oldName).name);
        var renamer = new Renamer(binding, oldName, newName);
        {
          renamer.rename(arguments[2]);
        }
      }
    };
    _proto.dump = function dump() {
      var sep = "-".repeat(60);
      console.log(sep);
      var scope = this;
      do {
        console.log("#", scope.block.type);
        for (var _i2 = 0, _Object$keys2 = Object.keys(scope.bindings); _i2 < _Object$keys2.length; _i2++) {
          var name = _Object$keys2[_i2];
          var binding = scope.bindings[name];
          console.log(" -", name, {
            constant: binding.constant,
            references: binding.references,
            violations: binding.constantViolations.length,
            kind: binding.kind
          });
        }
      } while (scope = scope.parent);
      console.log(sep);
    };
    _proto.hasLabel = function hasLabel(name) {
      return !!this.getLabel(name);
    };
    _proto.getLabel = function getLabel(name) {
      return this.labels.get(name);
    };
    _proto.registerLabel = function registerLabel(path) {
      this.labels.set(path.node.label.name, path);
    };
    _proto.registerDeclaration = function registerDeclaration(path) {
      if (path.isLabeledStatement()) {
        this.registerLabel(path);
      } else if (path.isFunctionDeclaration()) {
        this.registerBinding("hoisted", path.get("id"), path);
      } else if (path.isVariableDeclaration()) {
        var declarations = path.get("declarations");
        var kind = path.node.kind;
        for (var _iterator5 = _createForOfIteratorHelperLoose(declarations), _step5; !(_step5 = _iterator5()).done;) {
          var declar = _step5.value;
          this.registerBinding(kind === "using" || kind === "await using" ? "const" : kind, declar);
        }
      } else if (path.isClassDeclaration()) {
        if (path.node.declare) return;
        this.registerBinding("let", path);
      } else if (path.isImportDeclaration()) {
        var isTypeDeclaration = path.node.importKind === "type" || path.node.importKind === "typeof";
        var specifiers = path.get("specifiers");
        for (var _iterator6 = _createForOfIteratorHelperLoose(specifiers), _step6; !(_step6 = _iterator6()).done;) {
          var specifier = _step6.value;
          var isTypeSpecifier = isTypeDeclaration || specifier.isImportSpecifier() && (specifier.node.importKind === "type" || specifier.node.importKind === "typeof");
          this.registerBinding(isTypeSpecifier ? "unknown" : "module", specifier);
        }
      } else if (path.isExportDeclaration()) {
        var _declar = path.get("declaration");
        if (_declar.isClassDeclaration() || _declar.isFunctionDeclaration() || _declar.isVariableDeclaration()) {
          this.registerDeclaration(_declar);
        }
      } else {
        this.registerBinding("unknown", path);
      }
    };
    _proto.buildUndefinedNode = function buildUndefinedNode() {
      return _buildUndefinedNode();
    };
    _proto.registerConstantViolation = function registerConstantViolation(path) {
      var ids = path.getAssignmentIdentifiers();
      for (var _i3 = 0, _Object$keys3 = Object.keys(ids); _i3 < _Object$keys3.length; _i3++) {
        var _this$getBinding;
        var name = _Object$keys3[_i3];
        (_this$getBinding = this.getBinding(name)) == null || _this$getBinding.reassign(path);
      }
    };
    _proto.registerBinding = function registerBinding(kind, path, bindingPath) {
      if (bindingPath === void 0) {
        bindingPath = path;
      }
      if (!kind) throw new ReferenceError("no `kind`");
      if (path.isVariableDeclaration()) {
        var declarators = path.get("declarations");
        for (var _iterator7 = _createForOfIteratorHelperLoose(declarators), _step7; !(_step7 = _iterator7()).done;) {
          var declar = _step7.value;
          this.registerBinding(kind, declar);
        }
        return;
      }
      var parent = this.getProgramParent();
      var ids = path.getOuterBindingIdentifiers(true);
      for (var _i4 = 0, _Object$keys4 = Object.keys(ids); _i4 < _Object$keys4.length; _i4++) {
        var name = _Object$keys4[_i4];
        {
          parent.references[name] = true;
        }
        for (var _iterator8 = _createForOfIteratorHelperLoose(ids[name]), _step8; !(_step8 = _iterator8()).done;) {
          var id = _step8.value;
          var local = this.getOwnBinding(name);
          if (local) {
            if (local.identifier === id) continue;
            this.checkBlockScopedCollisions(local, kind, name, id);
          }
          if (local) {
            local.reassign(bindingPath);
          } else {
            this.bindings[name] = new Binding({
              identifier: id,
              scope: this,
              path: bindingPath,
              kind: kind
            });
          }
        }
      }
    };
    _proto.addGlobal = function addGlobal(node) {
      this.globals[node.name] = node;
    };
    _proto.hasUid = function hasUid(name) {
      {
        var scope = this;
        do {
          if (scope.uids[name]) return true;
        } while (scope = scope.parent);
        return false;
      }
    };
    _proto.hasGlobal = function hasGlobal(name) {
      var scope = this;
      do {
        if (scope.globals[name]) return true;
      } while (scope = scope.parent);
      return false;
    };
    _proto.hasReference = function hasReference(name) {
      {
        return !!this.getProgramParent().references[name];
      }
    };
    _proto.isPure = function isPure(node, constantsOnly) {
      if (isIdentifier$b(node)) {
        var binding = this.getBinding(node.name);
        if (!binding) return false;
        if (constantsOnly) return binding.constant;
        return true;
      } else if (isThisExpression$1(node) || isMetaProperty(node) || isTopicReference(node) || isPrivateName$1(node)) {
        return true;
      } else if (isClass(node)) {
        var _node$decorators;
        if (node.superClass && !this.isPure(node.superClass, constantsOnly)) {
          return false;
        }
        if (((_node$decorators = node.decorators) == null ? void 0 : _node$decorators.length) > 0) {
          return false;
        }
        return this.isPure(node.body, constantsOnly);
      } else if (isClassBody$1(node)) {
        for (var _iterator9 = _createForOfIteratorHelperLoose(node.body), _step9; !(_step9 = _iterator9()).done;) {
          var method = _step9.value;
          if (!this.isPure(method, constantsOnly)) return false;
        }
        return true;
      } else if (isBinary$1(node)) {
        return this.isPure(node.left, constantsOnly) && this.isPure(node.right, constantsOnly);
      } else if (isArrayExpression$1(node) || isTupleExpression(node)) {
        for (var _iterator0 = _createForOfIteratorHelperLoose(node.elements), _step0; !(_step0 = _iterator0()).done;) {
          var elem = _step0.value;
          if (elem !== null && !this.isPure(elem, constantsOnly)) return false;
        }
        return true;
      } else if (isObjectExpression$2(node) || isRecordExpression(node)) {
        for (var _iterator1 = _createForOfIteratorHelperLoose(node.properties), _step1; !(_step1 = _iterator1()).done;) {
          var prop = _step1.value;
          if (!this.isPure(prop, constantsOnly)) return false;
        }
        return true;
      } else if (isMethod(node)) {
        var _node$decorators2;
        if (node.computed && !this.isPure(node.key, constantsOnly)) return false;
        if (((_node$decorators2 = node.decorators) == null ? void 0 : _node$decorators2.length) > 0) {
          return false;
        }
        return true;
      } else if (isProperty(node)) {
        var _node$decorators3;
        if (node.computed && !this.isPure(node.key, constantsOnly)) return false;
        if (((_node$decorators3 = node.decorators) == null ? void 0 : _node$decorators3.length) > 0) {
          return false;
        }
        if (isObjectProperty$1(node) || node["static"]) {
          if (node.value !== null && !this.isPure(node.value, constantsOnly)) {
            return false;
          }
        }
        return true;
      } else if (isUnaryExpression(node)) {
        return this.isPure(node.argument, constantsOnly);
      } else if (isTemplateLiteral(node)) {
        for (var _iterator10 = _createForOfIteratorHelperLoose(node.expressions), _step10; !(_step10 = _iterator10()).done;) {
          var expression = _step10.value;
          if (!this.isPure(expression, constantsOnly)) return false;
        }
        return true;
      } else if (isTaggedTemplateExpression(node)) {
        return matchesPattern$1(node.tag, "String.raw") && !this.hasBinding("String", {
          noGlobals: true
        }) && this.isPure(node.quasi, constantsOnly);
      } else if (isMemberExpression$5(node)) {
        return !node.computed && isIdentifier$b(node.object) && node.object.name === "Symbol" && isIdentifier$b(node.property) && node.property.name !== "for" && !this.hasBinding("Symbol", {
          noGlobals: true
        });
      } else if (isCallExpression$6(node)) {
        return matchesPattern$1(node.callee, "Symbol.for") && !this.hasBinding("Symbol", {
          noGlobals: true
        }) && node.arguments.length === 1 && isStringLiteral$5(node.arguments[0]);
      } else {
        return isPureish(node);
      }
    };
    _proto.setData = function setData(key, val) {
      return this.data[key] = val;
    };
    _proto.getData = function getData(key) {
      var scope = this;
      do {
        var data = scope.data[key];
        if (data != null) return data;
      } while (scope = scope.parent);
    };
    _proto.removeData = function removeData(key) {
      var scope = this;
      do {
        var data = scope.data[key];
        if (data != null) scope.data[key] = null;
      } while (scope = scope.parent);
    };
    _proto.init = function init() {
      if (!this.inited) {
        this.inited = true;
        this.crawl();
      }
    };
    _proto.crawl = function crawl() {
      var path = this.path;
      resetScope(this);
      this.data = Object.create(null);
      var scope = this;
      do {
        if (scope.crawling) return;
        if (scope.path.isProgram()) {
          break;
        }
      } while (scope = scope.parent);
      var programParent = scope;
      var state = {
        references: [],
        constantViolations: [],
        assignments: []
      };
      this.crawling = true;
      scopeVisitor || (scopeVisitor = traverse.visitors.merge([{
        Scope: function Scope(path) {
          resetScope(path.scope);
        }
      }, collectorVisitor]));
      if (path.type !== "Program") {
        for (var _iterator11 = _createForOfIteratorHelperLoose(scopeVisitor.enter), _step11; !(_step11 = _iterator11()).done;) {
          var _visit = _step11.value;
          _visit.call(state, path, state);
        }
        var typeVisitors = scopeVisitor[path.type];
        if (typeVisitors) {
          for (var _iterator12 = _createForOfIteratorHelperLoose(typeVisitors.enter), _step12; !(_step12 = _iterator12()).done;) {
            var visit = _step12.value;
            visit.call(state, path, state);
          }
        }
      }
      path.traverse(scopeVisitor, state);
      this.crawling = false;
      for (var _iterator13 = _createForOfIteratorHelperLoose(state.assignments), _step13; !(_step13 = _iterator13()).done;) {
        var _path = _step13.value;
        var ids = _path.getAssignmentIdentifiers();
        for (var _i5 = 0, _Object$keys5 = Object.keys(ids); _i5 < _Object$keys5.length; _i5++) {
          var name = _Object$keys5[_i5];
          if (_path.scope.getBinding(name)) continue;
          programParent.addGlobal(ids[name]);
        }
        _path.scope.registerConstantViolation(_path);
      }
      for (var _iterator14 = _createForOfIteratorHelperLoose(state.references), _step14; !(_step14 = _iterator14()).done;) {
        var ref = _step14.value;
        var binding = ref.scope.getBinding(ref.node.name);
        if (binding) {
          binding.reference(ref);
        } else {
          programParent.addGlobal(ref.node);
        }
      }
      for (var _iterator15 = _createForOfIteratorHelperLoose(state.constantViolations), _step15; !(_step15 = _iterator15()).done;) {
        var _path2 = _step15.value;
        _path2.scope.registerConstantViolation(_path2);
      }
    };
    _proto.push = function push(opts) {
      var path = this.path;
      if (path.isPattern()) {
        path = this.getPatternParent().path;
      } else if (!path.isBlockStatement() && !path.isProgram()) {
        path = this.getBlockParent().path;
      }
      if (path.isSwitchStatement()) {
        path = (this.getFunctionParent() || this.getProgramParent()).path;
      }
      var init = opts.init,
        unique = opts.unique,
        _opts$kind = opts.kind,
        kind = _opts$kind === void 0 ? "var" : _opts$kind,
        id = opts.id;
      if (!init && !unique && (kind === "var" || kind === "let") && path.isFunction() && !path.node.name && isCallExpression$6(path.parent, {
        callee: path.node
      }) && path.parent.arguments.length <= path.node.params.length && isIdentifier$b(id)) {
        path.pushContainer("params", id);
        path.scope.registerBinding("param", path.get("params")[path.node.params.length - 1]);
        return;
      }
      if (path.isLoop() || path.isCatchClause() || path.isFunction()) {
        path.ensureBlock();
        path = path.get("body");
      }
      var blockHoist = opts._blockHoist == null ? 2 : opts._blockHoist;
      var dataKey = "declaration:" + kind + ":" + blockHoist;
      var declarPath = !unique && path.getData(dataKey);
      if (!declarPath) {
        var declar = variableDeclaration$5(kind, []);
        declar._blockHoist = blockHoist;
        var _unshiftContainer = path.unshiftContainer("body", [declar]);
        var _unshiftContainer2 = _slicedToArray(_unshiftContainer, 1);
        declarPath = _unshiftContainer2[0];
        if (!unique) path.setData(dataKey, declarPath);
      }
      var declarator = variableDeclarator$5(id, init);
      var len = declarPath.node.declarations.push(declarator);
      path.scope.registerBinding(kind, declarPath.get("declarations")[len - 1]);
    };
    _proto.getProgramParent = function getProgramParent() {
      var scope = this;
      do {
        if (scope.path.isProgram()) {
          return scope;
        }
      } while (scope = scope.parent);
      throw new Error("Couldn't find a Program");
    };
    _proto.getFunctionParent = function getFunctionParent() {
      var scope = this;
      do {
        if (scope.path.isFunctionParent()) {
          return scope;
        }
      } while (scope = scope.parent);
      return null;
    };
    _proto.getBlockParent = function getBlockParent() {
      var scope = this;
      do {
        if (scope.path.isBlockParent()) {
          return scope;
        }
      } while (scope = scope.parent);
      throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
    };
    _proto.getPatternParent = function getPatternParent() {
      var scope = this;
      do {
        if (!scope.path.isPattern()) {
          return scope.getBlockParent();
        }
      } while (scope = scope.parent.parent);
      throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
    };
    _proto.getAllBindings = function getAllBindings() {
      var ids = Object.create(null);
      var scope = this;
      do {
        for (var _i6 = 0, _Object$keys6 = Object.keys(scope.bindings); _i6 < _Object$keys6.length; _i6++) {
          var key = _Object$keys6[_i6];
          if (key in ids === false) {
            ids[key] = scope.bindings[key];
          }
        }
        scope = scope.parent;
      } while (scope);
      return ids;
    };
    _proto.bindingIdentifierEquals = function bindingIdentifierEquals(name, node) {
      return this.getBindingIdentifier(name) === node;
    };
    _proto.getBinding = function getBinding(name) {
      var scope = this;
      var previousPath;
      do {
        var binding = scope.getOwnBinding(name);
        if (binding) {
          var _previousPath;
          if ((_previousPath = previousPath) != null && _previousPath.isPattern() && binding.kind !== "param" && binding.kind !== "local") ; else {
            return binding;
          }
        } else if (!binding && name === "arguments" && scope.path.isFunction() && !scope.path.isArrowFunctionExpression()) {
          break;
        }
        previousPath = scope.path;
      } while (scope = scope.parent);
    };
    _proto.getOwnBinding = function getOwnBinding(name) {
      return this.bindings[name];
    };
    _proto.getBindingIdentifier = function getBindingIdentifier(name) {
      var _this$getBinding2;
      return (_this$getBinding2 = this.getBinding(name)) == null ? void 0 : _this$getBinding2.identifier;
    };
    _proto.getOwnBindingIdentifier = function getOwnBindingIdentifier(name) {
      var binding = this.bindings[name];
      return binding == null ? void 0 : binding.identifier;
    };
    _proto.hasOwnBinding = function hasOwnBinding(name) {
      return !!this.getOwnBinding(name);
    };
    _proto.hasBinding = function hasBinding(name, opts) {
      if (!name) return false;
      var noGlobals;
      var noUids;
      var upToScope;
      if (typeof opts === "object") {
        noGlobals = opts.noGlobals;
        noUids = opts.noUids;
        upToScope = opts.upToScope;
      } else if (typeof opts === "boolean") {
        noGlobals = opts;
      }
      var scope = this;
      do {
        if (upToScope === scope) {
          break;
        }
        if (scope.hasOwnBinding(name)) {
          return true;
        }
      } while (scope = scope.parent);
      if (!noUids && this.hasUid(name)) return true;
      if (!noGlobals && Scope.globals.includes(name)) return true;
      if (!noGlobals && Scope.contextVariables.includes(name)) return true;
      return false;
    };
    _proto.parentHasBinding = function parentHasBinding(name, opts) {
      var _this$parent;
      return (_this$parent = this.parent) == null ? void 0 : _this$parent.hasBinding(name, opts);
    };
    _proto.moveBindingTo = function moveBindingTo(name, scope) {
      var info = this.getBinding(name);
      if (info) {
        info.scope.removeOwnBinding(name);
        info.scope = scope;
        scope.bindings[name] = info;
      }
    };
    _proto.removeOwnBinding = function removeOwnBinding(name) {
      delete this.bindings[name];
    };
    _proto.removeBinding = function removeBinding(name) {
      var _this$getBinding3;
      (_this$getBinding3 = this.getBinding(name)) == null || _this$getBinding3.scope.removeOwnBinding(name);
      {
        var scope = this;
        do {
          if (scope.uids[name]) {
            scope.uids[name] = false;
          }
        } while (scope = scope.parent);
      }
    };
    _proto.hoistVariables = function hoistVariables(emit) {
      var _this = this;
      if (emit === void 0) {
        emit = function emit(id) {
          return _this.push({
            id: id
          });
        };
      }
      this.crawl();
      var seen = new Set();
      for (var _i7 = 0, _Object$keys7 = Object.keys(this.bindings); _i7 < _Object$keys7.length; _i7++) {
        var name = _Object$keys7[_i7];
        var binding = this.bindings[name];
        if (!binding) continue;
        var path = binding.path;
        if (!path.isVariableDeclarator()) continue;
        var parent = path.parent,
          parentPath = path.parentPath;
        if (parent.kind !== "var" || seen.has(parent)) continue;
        seen.add(path.parent);
        var firstId = void 0;
        var init = [];
        for (var _iterator16 = _createForOfIteratorHelperLoose(parent.declarations), _step16; !(_step16 = _iterator16()).done;) {
          var decl = _step16.value;
          firstId != null ? firstId : firstId = decl.id;
          if (decl.init) {
            init.push(assignmentExpression$7("=", decl.id, decl.init));
          }
          var ids = Object.keys(getBindingIdentifiers$3(decl, false, true, true));
          for (var _i8 = 0, _ids = ids; _i8 < _ids.length; _i8++) {
            var _name = _ids[_i8];
            emit(identifier$b(_name), decl.init != null);
          }
        }
        if (parentPath.parentPath.isFor({
          left: parent
        })) {
          parentPath.replaceWith(firstId);
        } else if (init.length === 0) {
          parentPath.remove();
        } else {
          var expr = init.length === 1 ? init[0] : sequenceExpression$5(init);
          if (parentPath.parentPath.isForStatement({
            init: parent
          })) {
            parentPath.replaceWith(expr);
          } else {
            parentPath.replaceWith(expressionStatement$5(expr));
          }
        }
      }
    };
    return _createClass(Scope, [{
      key: "parent",
      get: function get() {
        var _parent;
        var parent,
          path = this.path;
        do {
          var _path3;
          var shouldSkip = path.key === "key" || path.listKey === "decorators";
          path = path.parentPath;
          if (shouldSkip && path.isMethod()) path = path.parentPath;
          if ((_path3 = path) != null && _path3.isScope()) parent = path;
        } while (path && !parent);
        return (_parent = parent) == null ? void 0 : _parent.scope;
      }
    }, {
      key: "references",
      get: function get() {
        throw new Error("Scope#references is not available in Babel 8. Use Scope#referencesSet instead.");
      }
    }, {
      key: "uids",
      get: function get() {
        throw new Error("Scope#uids is not available in Babel 8. Use Scope#uidsSet instead.");
      }
    }]);
  }();
  Scope.globals = [].concat(_toConsumableArray(globalsBuiltinLower), _toConsumableArray(globalsBuiltinUpper));
  Scope.contextVariables = ["arguments", "undefined", "Infinity", "NaN"];
  {
    Scope.prototype._renameFromMap = function _renameFromMap(map, oldName, newName, value) {
      if (map[oldName]) {
        map[newName] = value;
        map[oldName] = null;
      }
    };
    Scope.prototype.traverse = function (node, opts, state) {
      traverse(node, opts, this, state, this.path);
    };
    Scope.prototype._generateUid = function _generateUid(name, i) {
      var id = name;
      if (i > 1) id += i;
      return "_" + id;
    };
    Scope.prototype.toArray = function toArray(node, i, arrayLikeIsIterable) {
      if (isIdentifier$b(node)) {
        var binding = this.getBinding(node.name);
        if (binding != null && binding.constant && binding.path.isGenericType("Array")) {
          return node;
        }
      }
      if (isArrayExpression$1(node)) {
        return node;
      }
      if (isIdentifier$b(node, {
        name: "arguments"
      })) {
        return callExpression$b(memberExpression$9(memberExpression$9(memberExpression$9(identifier$b("Array"), identifier$b("prototype")), identifier$b("slice")), identifier$b("call")), [node]);
      }
      var helperName;
      var args = [node];
      if (i === true) {
        helperName = "toConsumableArray";
      } else if (typeof i === "number") {
        args.push(numericLiteral$4(i));
        helperName = "slicedToArray";
      } else {
        helperName = "toArray";
      }
      if (arrayLikeIsIterable) {
        args.unshift(this.path.hub.addHelper(helperName));
        helperName = "maybeArrayLike";
      }
      return callExpression$b(this.path.hub.addHelper(helperName), args);
    };
    Scope.prototype.getAllBindingsOfKind = function getAllBindingsOfKind() {
      var ids = Object.create(null);
      for (var _len = arguments.length, kinds = new Array(_len), _key = 0; _key < _len; _key++) {
        kinds[_key] = arguments[_key];
      }
      for (var _i9 = 0, _kinds = kinds; _i9 < _kinds.length; _i9++) {
        var kind = _kinds[_i9];
        var scope = this;
        do {
          for (var _i0 = 0, _Object$keys8 = Object.keys(scope.bindings); _i0 < _Object$keys8.length; _i0++) {
            var name = _Object$keys8[_i0];
            var binding = scope.bindings[name];
            if (binding.kind === kind) ids[name] = binding;
          }
          scope = scope.parent;
        } while (scope);
      }
      return ids;
    };
    Object.defineProperties(Scope.prototype, {
      parentBlock: {
        configurable: true,
        enumerable: true,
        get: function get() {
          return this.path.parent;
        }
      },
      hub: {
        configurable: true,
        enumerable: true,
        get: function get() {
          return this.path.hub;
        }
      }
    });
  }

  var lookup = [];
  var revLookup = [];
  var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
  var inited = false;
  function init () {
    inited = true;
    var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
    for (var i = 0, len = code.length; i < len; ++i) {
      lookup[i] = code[i];
      revLookup[code.charCodeAt(i)] = i;
    }

    revLookup['-'.charCodeAt(0)] = 62;
    revLookup['_'.charCodeAt(0)] = 63;
  }

  function toByteArray (b64) {
    if (!inited) {
      init();
    }
    var i, j, l, tmp, placeHolders, arr;
    var len = b64.length;

    if (len % 4 > 0) {
      throw new Error('Invalid string. Length must be a multiple of 4')
    }

    // the number of equal signs (place holders)
    // if there are two placeholders, than the two characters before it
    // represent one byte
    // if there is only one, then the three characters before it represent 2 bytes
    // this is just a cheap hack to not do indexOf twice
    placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;

    // base64 is 4/3 + up to two characters of the original data
    arr = new Arr(len * 3 / 4 - placeHolders);

    // if there are placeholders, only get up to the last complete 4 chars
    l = placeHolders > 0 ? len - 4 : len;

    var L = 0;

    for (i = 0, j = 0; i < l; i += 4, j += 3) {
      tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)];
      arr[L++] = (tmp >> 16) & 0xFF;
      arr[L++] = (tmp >> 8) & 0xFF;
      arr[L++] = tmp & 0xFF;
    }

    if (placeHolders === 2) {
      tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4);
      arr[L++] = tmp & 0xFF;
    } else if (placeHolders === 1) {
      tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2);
      arr[L++] = (tmp >> 8) & 0xFF;
      arr[L++] = tmp & 0xFF;
    }

    return arr
  }

  function tripletToBase64 (num) {
    return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
  }

  function encodeChunk (uint8, start, end) {
    var tmp;
    var output = [];
    for (var i = start; i < end; i += 3) {
      tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
      output.push(tripletToBase64(tmp));
    }
    return output.join('')
  }

  function fromByteArray (uint8) {
    if (!inited) {
      init();
    }
    var tmp;
    var len = uint8.length;
    var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
    var output = '';
    var parts = [];
    var maxChunkLength = 16383; // must be multiple of 3

    // go through the array every three bytes, we'll deal with trailing stuff later
    for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
      parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));
    }

    // pad the end with zeros, but make sure to not forget the extra bytes
    if (extraBytes === 1) {
      tmp = uint8[len - 1];
      output += lookup[tmp >> 2];
      output += lookup[(tmp << 4) & 0x3F];
      output += '==';
    } else if (extraBytes === 2) {
      tmp = (uint8[len - 2] << 8) + (uint8[len - 1]);
      output += lookup[tmp >> 10];
      output += lookup[(tmp >> 4) & 0x3F];
      output += lookup[(tmp << 2) & 0x3F];
      output += '=';
    }

    parts.push(output);

    return parts.join('')
  }

  function read (buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? (nBytes - 1) : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];

    i += d;

    e = s & ((1 << (-nBits)) - 1);
    s >>= (-nBits);
    nBits += eLen;
    for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

    m = e & ((1 << (-nBits)) - 1);
    e >>= (-nBits);
    nBits += mLen;
    for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

    if (e === 0) {
      e = 1 - eBias;
    } else if (e === eMax) {
      return m ? NaN : ((s ? -1 : 1) * Infinity)
    } else {
      m = m + Math.pow(2, mLen);
      e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
  }

  function write (buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
    var i = isLE ? 0 : (nBytes - 1);
    var d = isLE ? 1 : -1;
    var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

    value = Math.abs(value);

    if (isNaN(value) || value === Infinity) {
      m = isNaN(value) ? 1 : 0;
      e = eMax;
    } else {
      e = Math.floor(Math.log(value) / Math.LN2);
      if (value * (c = Math.pow(2, -e)) < 1) {
        e--;
        c *= 2;
      }
      if (e + eBias >= 1) {
        value += rt / c;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }
      if (value * c >= 2) {
        e++;
        c /= 2;
      }

      if (e + eBias >= eMax) {
        m = 0;
        e = eMax;
      } else if (e + eBias >= 1) {
        m = (value * c - 1) * Math.pow(2, mLen);
        e = e + eBias;
      } else {
        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e = 0;
      }
    }

    for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

    e = (e << mLen) | m;
    eLen += mLen;
    for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

    buffer[offset + i - d] |= s * 128;
  }

  var toString$1 = {}.toString;

  var isArray$3 = Array.isArray || function (arr) {
    return toString$1.call(arr) == '[object Array]';
  };

  /*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
   * @license  MIT
   */
  /* eslint-disable no-proto */


  var INSPECT_MAX_BYTES = 50;

  /**
   * If `Buffer.TYPED_ARRAY_SUPPORT`:
   *   === true    Use Uint8Array implementation (fastest)
   *   === false   Use Object implementation (most compatible, even IE6)
   *
   * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
   * Opera 11.6+, iOS 4.2+.
   *
   * Due to various browser bugs, sometimes the Object implementation will be used even
   * when the browser supports typed arrays.
   *
   * Note:
   *
   *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
   *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
   *
   *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
   *
   *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
   *     incorrect length in some situations.

   * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
   * get the Object implementation, which is slower but behaves correctly.
   */
  Buffer$1.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== undefined
    ? global$1.TYPED_ARRAY_SUPPORT
    : true;

  /*
   * Export kMaxLength after typed array support is determined.
   */
  kMaxLength();

  function kMaxLength () {
    return Buffer$1.TYPED_ARRAY_SUPPORT
      ? 0x7fffffff
      : 0x3fffffff
  }

  function createBuffer (that, length) {
    if (kMaxLength() < length) {
      throw new RangeError('Invalid typed array length')
    }
    if (Buffer$1.TYPED_ARRAY_SUPPORT) {
      // Return an augmented `Uint8Array` instance, for best performance
      that = new Uint8Array(length);
      that.__proto__ = Buffer$1.prototype;
    } else {
      // Fallback: Return an object instance of the Buffer class
      if (that === null) {
        that = new Buffer$1(length);
      }
      that.length = length;
    }

    return that
  }

  /**
   * The Buffer constructor returns instances of `Uint8Array` that have their
   * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
   * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
   * and the `Uint8Array` methods. Square bracket notation works as expected -- it
   * returns a single octet.
   *
   * The `Uint8Array` prototype remains unmodified.
   */

  function Buffer$1 (arg, encodingOrOffset, length) {
    if (!Buffer$1.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer$1)) {
      return new Buffer$1(arg, encodingOrOffset, length)
    }

    // Common case.
    if (typeof arg === 'number') {
      if (typeof encodingOrOffset === 'string') {
        throw new Error(
          'If encoding is specified then the first argument must be a string'
        )
      }
      return allocUnsafe(this, arg)
    }
    return from(this, arg, encodingOrOffset, length)
  }

  Buffer$1.poolSize = 8192; // not used by this implementation

  // TODO: Legacy, not needed anymore. Remove in next major version.
  Buffer$1._augment = function (arr) {
    arr.__proto__ = Buffer$1.prototype;
    return arr
  };

  function from (that, value, encodingOrOffset, length) {
    if (typeof value === 'number') {
      throw new TypeError('"value" argument must not be a number')
    }

    if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
      return fromArrayBuffer(that, value, encodingOrOffset, length)
    }

    if (typeof value === 'string') {
      return fromString(that, value, encodingOrOffset)
    }

    return fromObject(that, value)
  }

  /**
   * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
   * if value is a number.
   * Buffer.from(str[, encoding])
   * Buffer.from(array)
   * Buffer.from(buffer)
   * Buffer.from(arrayBuffer[, byteOffset[, length]])
   **/
  Buffer$1.from = function (value, encodingOrOffset, length) {
    return from(null, value, encodingOrOffset, length)
  };

  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    Buffer$1.prototype.__proto__ = Uint8Array.prototype;
    Buffer$1.__proto__ = Uint8Array;
    if (typeof Symbol !== 'undefined' && Symbol.species &&
        Buffer$1[Symbol.species] === Buffer$1) ;
  }

  function assertSize (size) {
    if (typeof size !== 'number') {
      throw new TypeError('"size" argument must be a number')
    } else if (size < 0) {
      throw new RangeError('"size" argument must not be negative')
    }
  }

  function alloc (that, size, fill, encoding) {
    assertSize(size);
    if (size <= 0) {
      return createBuffer(that, size)
    }
    if (fill !== undefined) {
      // Only pay attention to encoding if it's a string. This
      // prevents accidentally sending in a number that would
      // be interpretted as a start offset.
      return typeof encoding === 'string'
        ? createBuffer(that, size).fill(fill, encoding)
        : createBuffer(that, size).fill(fill)
    }
    return createBuffer(that, size)
  }

  /**
   * Creates a new filled Buffer instance.
   * alloc(size[, fill[, encoding]])
   **/
  Buffer$1.alloc = function (size, fill, encoding) {
    return alloc(null, size, fill, encoding)
  };

  function allocUnsafe (that, size) {
    assertSize(size);
    that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
    if (!Buffer$1.TYPED_ARRAY_SUPPORT) {
      for (var i = 0; i < size; ++i) {
        that[i] = 0;
      }
    }
    return that
  }

  /**
   * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
   * */
  Buffer$1.allocUnsafe = function (size) {
    return allocUnsafe(null, size)
  };
  /**
   * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
   */
  Buffer$1.allocUnsafeSlow = function (size) {
    return allocUnsafe(null, size)
  };

  function fromString (that, string, encoding) {
    if (typeof encoding !== 'string' || encoding === '') {
      encoding = 'utf8';
    }

    if (!Buffer$1.isEncoding(encoding)) {
      throw new TypeError('"encoding" must be a valid string encoding')
    }

    var length = byteLength(string, encoding) | 0;
    that = createBuffer(that, length);

    var actual = that.write(string, encoding);

    if (actual !== length) {
      // Writing a hex string, for example, that contains invalid characters will
      // cause everything after the first invalid character to be ignored. (e.g.
      // 'abxxcd' will be treated as 'ab')
      that = that.slice(0, actual);
    }

    return that
  }

  function fromArrayLike (that, array) {
    var length = array.length < 0 ? 0 : checked(array.length) | 0;
    that = createBuffer(that, length);
    for (var i = 0; i < length; i += 1) {
      that[i] = array[i] & 255;
    }
    return that
  }

  function fromArrayBuffer (that, array, byteOffset, length) {
    array.byteLength; // this throws if `array` is not a valid ArrayBuffer

    if (byteOffset < 0 || array.byteLength < byteOffset) {
      throw new RangeError('\'offset\' is out of bounds')
    }

    if (array.byteLength < byteOffset + (length || 0)) {
      throw new RangeError('\'length\' is out of bounds')
    }

    if (byteOffset === undefined && length === undefined) {
      array = new Uint8Array(array);
    } else if (length === undefined) {
      array = new Uint8Array(array, byteOffset);
    } else {
      array = new Uint8Array(array, byteOffset, length);
    }

    if (Buffer$1.TYPED_ARRAY_SUPPORT) {
      // Return an augmented `Uint8Array` instance, for best performance
      that = array;
      that.__proto__ = Buffer$1.prototype;
    } else {
      // Fallback: Return an object instance of the Buffer class
      that = fromArrayLike(that, array);
    }
    return that
  }

  function fromObject (that, obj) {
    if (internalIsBuffer(obj)) {
      var len = checked(obj.length) | 0;
      that = createBuffer(that, len);

      if (that.length === 0) {
        return that
      }

      obj.copy(that, 0, 0, len);
      return that
    }

    if (obj) {
      if ((typeof ArrayBuffer !== 'undefined' &&
          obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
        if (typeof obj.length !== 'number' || isnan(obj.length)) {
          return createBuffer(that, 0)
        }
        return fromArrayLike(that, obj)
      }

      if (obj.type === 'Buffer' && isArray$3(obj.data)) {
        return fromArrayLike(that, obj.data)
      }
    }

    throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
  }

  function checked (length) {
    // Note: cannot use `length < kMaxLength()` here because that fails when
    // length is NaN (which is otherwise coerced to zero.)
    if (length >= kMaxLength()) {
      throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                           'size: 0x' + kMaxLength().toString(16) + ' bytes')
    }
    return length | 0
  }
  Buffer$1.isBuffer = isBuffer$1;
  function internalIsBuffer (b) {
    return !!(b != null && b._isBuffer)
  }

  Buffer$1.compare = function compare (a, b) {
    if (!internalIsBuffer(a) || !internalIsBuffer(b)) {
      throw new TypeError('Arguments must be Buffers')
    }

    if (a === b) return 0

    var x = a.length;
    var y = b.length;

    for (var i = 0, len = Math.min(x, y); i < len; ++i) {
      if (a[i] !== b[i]) {
        x = a[i];
        y = b[i];
        break
      }
    }

    if (x < y) return -1
    if (y < x) return 1
    return 0
  };

  Buffer$1.isEncoding = function isEncoding (encoding) {
    switch (String(encoding).toLowerCase()) {
      case 'hex':
      case 'utf8':
      case 'utf-8':
      case 'ascii':
      case 'latin1':
      case 'binary':
      case 'base64':
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return true
      default:
        return false
    }
  };

  Buffer$1.concat = function concat (list, length) {
    if (!isArray$3(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }

    if (list.length === 0) {
      return Buffer$1.alloc(0)
    }

    var i;
    if (length === undefined) {
      length = 0;
      for (i = 0; i < list.length; ++i) {
        length += list[i].length;
      }
    }

    var buffer = Buffer$1.allocUnsafe(length);
    var pos = 0;
    for (i = 0; i < list.length; ++i) {
      var buf = list[i];
      if (!internalIsBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers')
      }
      buf.copy(buffer, pos);
      pos += buf.length;
    }
    return buffer
  };

  function byteLength (string, encoding) {
    if (internalIsBuffer(string)) {
      return string.length
    }
    if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
        (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
      return string.byteLength
    }
    if (typeof string !== 'string') {
      string = '' + string;
    }

    var len = string.length;
    if (len === 0) return 0

    // Use a for loop to avoid recursion
    var loweredCase = false;
    for (;;) {
      switch (encoding) {
        case 'ascii':
        case 'latin1':
        case 'binary':
          return len
        case 'utf8':
        case 'utf-8':
        case undefined:
          return utf8ToBytes(string).length
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return len * 2
        case 'hex':
          return len >>> 1
        case 'base64':
          return base64ToBytes(string).length
        default:
          if (loweredCase) return utf8ToBytes(string).length // assume utf8
          encoding = ('' + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer$1.byteLength = byteLength;

  function slowToString (encoding, start, end) {
    var loweredCase = false;

    // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
    // property of a typed array.

    // This behaves neither like String nor Uint8Array in that we set start/end
    // to their upper/lower bounds if the value passed is out of range.
    // undefined is handled specially as per ECMA-262 6th Edition,
    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
    if (start === undefined || start < 0) {
      start = 0;
    }
    // Return early if start > this.length. Done here to prevent potential uint32
    // coercion fail below.
    if (start > this.length) {
      return ''
    }

    if (end === undefined || end > this.length) {
      end = this.length;
    }

    if (end <= 0) {
      return ''
    }

    // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
    end >>>= 0;
    start >>>= 0;

    if (end <= start) {
      return ''
    }

    if (!encoding) encoding = 'utf8';

    while (true) {
      switch (encoding) {
        case 'hex':
          return hexSlice(this, start, end)

        case 'utf8':
        case 'utf-8':
          return utf8Slice(this, start, end)

        case 'ascii':
          return asciiSlice(this, start, end)

        case 'latin1':
        case 'binary':
          return latin1Slice(this, start, end)

        case 'base64':
          return base64Slice(this, start, end)

        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return utf16leSlice(this, start, end)

        default:
          if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
          encoding = (encoding + '').toLowerCase();
          loweredCase = true;
      }
    }
  }

  // The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
  // Buffer instances.
  Buffer$1.prototype._isBuffer = true;

  function swap (b, n, m) {
    var i = b[n];
    b[n] = b[m];
    b[m] = i;
  }

  Buffer$1.prototype.swap16 = function swap16 () {
    var len = this.length;
    if (len % 2 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 16-bits')
    }
    for (var i = 0; i < len; i += 2) {
      swap(this, i, i + 1);
    }
    return this
  };

  Buffer$1.prototype.swap32 = function swap32 () {
    var len = this.length;
    if (len % 4 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 32-bits')
    }
    for (var i = 0; i < len; i += 4) {
      swap(this, i, i + 3);
      swap(this, i + 1, i + 2);
    }
    return this
  };

  Buffer$1.prototype.swap64 = function swap64 () {
    var len = this.length;
    if (len % 8 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 64-bits')
    }
    for (var i = 0; i < len; i += 8) {
      swap(this, i, i + 7);
      swap(this, i + 1, i + 6);
      swap(this, i + 2, i + 5);
      swap(this, i + 3, i + 4);
    }
    return this
  };

  Buffer$1.prototype.toString = function toString () {
    var length = this.length | 0;
    if (length === 0) return ''
    if (arguments.length === 0) return utf8Slice(this, 0, length)
    return slowToString.apply(this, arguments)
  };

  Buffer$1.prototype.equals = function equals (b) {
    if (!internalIsBuffer(b)) throw new TypeError('Argument must be a Buffer')
    if (this === b) return true
    return Buffer$1.compare(this, b) === 0
  };

  Buffer$1.prototype.inspect = function inspect () {
    var str = '';
    var max = INSPECT_MAX_BYTES;
    if (this.length > 0) {
      str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
      if (this.length > max) str += ' ... ';
    }
    return '<Buffer ' + str + '>'
  };

  Buffer$1.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
    if (!internalIsBuffer(target)) {
      throw new TypeError('Argument must be a Buffer')
    }

    if (start === undefined) {
      start = 0;
    }
    if (end === undefined) {
      end = target ? target.length : 0;
    }
    if (thisStart === undefined) {
      thisStart = 0;
    }
    if (thisEnd === undefined) {
      thisEnd = this.length;
    }

    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError('out of range index')
    }

    if (thisStart >= thisEnd && start >= end) {
      return 0
    }
    if (thisStart >= thisEnd) {
      return -1
    }
    if (start >= end) {
      return 1
    }

    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;

    if (this === target) return 0

    var x = thisEnd - thisStart;
    var y = end - start;
    var len = Math.min(x, y);

    var thisCopy = this.slice(thisStart, thisEnd);
    var targetCopy = target.slice(start, end);

    for (var i = 0; i < len; ++i) {
      if (thisCopy[i] !== targetCopy[i]) {
        x = thisCopy[i];
        y = targetCopy[i];
        break
      }
    }

    if (x < y) return -1
    if (y < x) return 1
    return 0
  };

  // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
  // OR the last index of `val` in `buffer` at offset <= `byteOffset`.
  //
  // Arguments:
  // - buffer - a Buffer to search
  // - val - a string, Buffer, or number
  // - byteOffset - an index into `buffer`; will be clamped to an int32
  // - encoding - an optional encoding, relevant is val is a string
  // - dir - true for indexOf, false for lastIndexOf
  function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
    // Empty buffer means no match
    if (buffer.length === 0) return -1

    // Normalize byteOffset
    if (typeof byteOffset === 'string') {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 0x7fffffff) {
      byteOffset = 0x7fffffff;
    } else if (byteOffset < -0x80000000) {
      byteOffset = -0x80000000;
    }
    byteOffset = +byteOffset;  // Coerce to Number.
    if (isNaN(byteOffset)) {
      // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
      byteOffset = dir ? 0 : (buffer.length - 1);
    }

    // Normalize byteOffset: negative offsets start from the end of the buffer
    if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
    if (byteOffset >= buffer.length) {
      if (dir) return -1
      else byteOffset = buffer.length - 1;
    } else if (byteOffset < 0) {
      if (dir) byteOffset = 0;
      else return -1
    }

    // Normalize val
    if (typeof val === 'string') {
      val = Buffer$1.from(val, encoding);
    }

    // Finally, search either indexOf (if dir is true) or lastIndexOf
    if (internalIsBuffer(val)) {
      // Special case: looking for empty string/buffer always fails
      if (val.length === 0) {
        return -1
      }
      return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
    } else if (typeof val === 'number') {
      val = val & 0xFF; // Search for a byte value [0-255]
      if (Buffer$1.TYPED_ARRAY_SUPPORT &&
          typeof Uint8Array.prototype.indexOf === 'function') {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
        }
      }
      return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
    }

    throw new TypeError('val must be string, number or Buffer')
  }

  function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
    var indexSize = 1;
    var arrLength = arr.length;
    var valLength = val.length;

    if (encoding !== undefined) {
      encoding = String(encoding).toLowerCase();
      if (encoding === 'ucs2' || encoding === 'ucs-2' ||
          encoding === 'utf16le' || encoding === 'utf-16le') {
        if (arr.length < 2 || val.length < 2) {
          return -1
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }

    function read (buf, i) {
      if (indexSize === 1) {
        return buf[i]
      } else {
        return buf.readUInt16BE(i * indexSize)
      }
    }

    var i;
    if (dir) {
      var foundIndex = -1;
      for (i = byteOffset; i < arrLength; i++) {
        if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
          if (foundIndex === -1) foundIndex = i;
          if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
        } else {
          if (foundIndex !== -1) i -= i - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
      for (i = byteOffset; i >= 0; i--) {
        var found = true;
        for (var j = 0; j < valLength; j++) {
          if (read(arr, i + j) !== read(val, j)) {
            found = false;
            break
          }
        }
        if (found) return i
      }
    }

    return -1
  }

  Buffer$1.prototype.includes = function includes (val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1
  };

  Buffer$1.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
  };

  Buffer$1.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
  };

  function hexWrite (buf, string, offset, length) {
    offset = Number(offset) || 0;
    var remaining = buf.length - offset;
    if (!length) {
      length = remaining;
    } else {
      length = Number(length);
      if (length > remaining) {
        length = remaining;
      }
    }

    // must be an even number of digits
    var strLen = string.length;
    if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

    if (length > strLen / 2) {
      length = strLen / 2;
    }
    for (var i = 0; i < length; ++i) {
      var parsed = parseInt(string.substr(i * 2, 2), 16);
      if (isNaN(parsed)) return i
      buf[offset + i] = parsed;
    }
    return i
  }

  function utf8Write (buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
  }

  function asciiWrite (buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length)
  }

  function latin1Write (buf, string, offset, length) {
    return asciiWrite(buf, string, offset, length)
  }

  function base64Write (buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length)
  }

  function ucs2Write (buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
  }

  Buffer$1.prototype.write = function write (string, offset, length, encoding) {
    // Buffer#write(string)
    if (offset === undefined) {
      encoding = 'utf8';
      length = this.length;
      offset = 0;
    // Buffer#write(string, encoding)
    } else if (length === undefined && typeof offset === 'string') {
      encoding = offset;
      length = this.length;
      offset = 0;
    // Buffer#write(string, offset[, length][, encoding])
    } else if (isFinite(offset)) {
      offset = offset | 0;
      if (isFinite(length)) {
        length = length | 0;
        if (encoding === undefined) encoding = 'utf8';
      } else {
        encoding = length;
        length = undefined;
      }
    // legacy write(string, encoding, offset, length) - remove in v0.13
    } else {
      throw new Error(
        'Buffer.write(string, encoding, offset[, length]) is no longer supported'
      )
    }

    var remaining = this.length - offset;
    if (length === undefined || length > remaining) length = remaining;

    if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
      throw new RangeError('Attempt to write outside buffer bounds')
    }

    if (!encoding) encoding = 'utf8';

    var loweredCase = false;
    for (;;) {
      switch (encoding) {
        case 'hex':
          return hexWrite(this, string, offset, length)

        case 'utf8':
        case 'utf-8':
          return utf8Write(this, string, offset, length)

        case 'ascii':
          return asciiWrite(this, string, offset, length)

        case 'latin1':
        case 'binary':
          return latin1Write(this, string, offset, length)

        case 'base64':
          // Warning: maxLength not taken into account in base64Write
          return base64Write(this, string, offset, length)

        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return ucs2Write(this, string, offset, length)

        default:
          if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
          encoding = ('' + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };

  Buffer$1.prototype.toJSON = function toJSON () {
    return {
      type: 'Buffer',
      data: Array.prototype.slice.call(this._arr || this, 0)
    }
  };

  function base64Slice (buf, start, end) {
    if (start === 0 && end === buf.length) {
      return fromByteArray(buf)
    } else {
      return fromByteArray(buf.slice(start, end))
    }
  }

  function utf8Slice (buf, start, end) {
    end = Math.min(buf.length, end);
    var res = [];

    var i = start;
    while (i < end) {
      var firstByte = buf[i];
      var codePoint = null;
      var bytesPerSequence = (firstByte > 0xEF) ? 4
        : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
        : 1;

      if (i + bytesPerSequence <= end) {
        var secondByte, thirdByte, fourthByte, tempCodePoint;

        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 0x80) {
              codePoint = firstByte;
            }
            break
          case 2:
            secondByte = buf[i + 1];
            if ((secondByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);
              if (tempCodePoint > 0x7F) {
                codePoint = tempCodePoint;
              }
            }
            break
          case 3:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);
              if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                codePoint = tempCodePoint;
              }
            }
            break
          case 4:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            fourthByte = buf[i + 3];
            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);
              if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                codePoint = tempCodePoint;
              }
            }
        }
      }

      if (codePoint === null) {
        // we did not generate a valid codePoint so insert a
        // replacement char (U+FFFD) and advance only 1 byte
        codePoint = 0xFFFD;
        bytesPerSequence = 1;
      } else if (codePoint > 0xFFFF) {
        // encode to utf16 (surrogate pair dance)
        codePoint -= 0x10000;
        res.push(codePoint >>> 10 & 0x3FF | 0xD800);
        codePoint = 0xDC00 | codePoint & 0x3FF;
      }

      res.push(codePoint);
      i += bytesPerSequence;
    }

    return decodeCodePointsArray(res)
  }

  // Based on http://stackoverflow.com/a/22747272/680742, the browser with
  // the lowest limit is Chrome, with 0x10000 args.
  // We go 1 magnitude less, for safety
  var MAX_ARGUMENTS_LENGTH = 0x1000;

  function decodeCodePointsArray (codePoints) {
    var len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
    }

    // Decode in chunks to avoid "call stack size exceeded".
    var res = '';
    var i = 0;
    while (i < len) {
      res += String.fromCharCode.apply(
        String,
        codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
      );
    }
    return res
  }

  function asciiSlice (buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);

    for (var i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i] & 0x7F);
    }
    return ret
  }

  function latin1Slice (buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);

    for (var i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i]);
    }
    return ret
  }

  function hexSlice (buf, start, end) {
    var len = buf.length;

    if (!start || start < 0) start = 0;
    if (!end || end < 0 || end > len) end = len;

    var out = '';
    for (var i = start; i < end; ++i) {
      out += toHex(buf[i]);
    }
    return out
  }

  function utf16leSlice (buf, start, end) {
    var bytes = buf.slice(start, end);
    var res = '';
    for (var i = 0; i < bytes.length; i += 2) {
      res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    }
    return res
  }

  Buffer$1.prototype.slice = function slice (start, end) {
    var len = this.length;
    start = ~~start;
    end = end === undefined ? len : ~~end;

    if (start < 0) {
      start += len;
      if (start < 0) start = 0;
    } else if (start > len) {
      start = len;
    }

    if (end < 0) {
      end += len;
      if (end < 0) end = 0;
    } else if (end > len) {
      end = len;
    }

    if (end < start) end = start;

    var newBuf;
    if (Buffer$1.TYPED_ARRAY_SUPPORT) {
      newBuf = this.subarray(start, end);
      newBuf.__proto__ = Buffer$1.prototype;
    } else {
      var sliceLen = end - start;
      newBuf = new Buffer$1(sliceLen, undefined);
      for (var i = 0; i < sliceLen; ++i) {
        newBuf[i] = this[i + start];
      }
    }

    return newBuf
  };

  /*
   * Need to make sure that buffer isn't trying to write out of bounds.
   */
  function checkOffset (offset, ext, length) {
    if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
    if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
  }

  Buffer$1.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);

    var val = this[offset];
    var mul = 1;
    var i = 0;
    while (++i < byteLength && (mul *= 0x100)) {
      val += this[offset + i] * mul;
    }

    return val
  };

  Buffer$1.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) {
      checkOffset(offset, byteLength, this.length);
    }

    var val = this[offset + --byteLength];
    var mul = 1;
    while (byteLength > 0 && (mul *= 0x100)) {
      val += this[offset + --byteLength] * mul;
    }

    return val
  };

  Buffer$1.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 1, this.length);
    return this[offset]
  };

  Buffer$1.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] | (this[offset + 1] << 8)
  };

  Buffer$1.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    return (this[offset] << 8) | this[offset + 1]
  };

  Buffer$1.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);

    return ((this[offset]) |
        (this[offset + 1] << 8) |
        (this[offset + 2] << 16)) +
        (this[offset + 3] * 0x1000000)
  };

  Buffer$1.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);

    return (this[offset] * 0x1000000) +
      ((this[offset + 1] << 16) |
      (this[offset + 2] << 8) |
      this[offset + 3])
  };

  Buffer$1.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);

    var val = this[offset];
    var mul = 1;
    var i = 0;
    while (++i < byteLength && (mul *= 0x100)) {
      val += this[offset + i] * mul;
    }
    mul *= 0x80;

    if (val >= mul) val -= Math.pow(2, 8 * byteLength);

    return val
  };

  Buffer$1.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);

    var i = byteLength;
    var mul = 1;
    var val = this[offset + --i];
    while (i > 0 && (mul *= 0x100)) {
      val += this[offset + --i] * mul;
    }
    mul *= 0x80;

    if (val >= mul) val -= Math.pow(2, 8 * byteLength);

    return val
  };

  Buffer$1.prototype.readInt8 = function readInt8 (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 1, this.length);
    if (!(this[offset] & 0x80)) return (this[offset])
    return ((0xff - this[offset] + 1) * -1)
  };

  Buffer$1.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    var val = this[offset] | (this[offset + 1] << 8);
    return (val & 0x8000) ? val | 0xFFFF0000 : val
  };

  Buffer$1.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    var val = this[offset + 1] | (this[offset] << 8);
    return (val & 0x8000) ? val | 0xFFFF0000 : val
  };

  Buffer$1.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);

    return (this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16) |
      (this[offset + 3] << 24)
  };

  Buffer$1.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);

    return (this[offset] << 24) |
      (this[offset + 1] << 16) |
      (this[offset + 2] << 8) |
      (this[offset + 3])
  };

  Buffer$1.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);
    return read(this, offset, true, 23, 4)
  };

  Buffer$1.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);
    return read(this, offset, false, 23, 4)
  };

  Buffer$1.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 8, this.length);
    return read(this, offset, true, 52, 8)
  };

  Buffer$1.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 8, this.length);
    return read(this, offset, false, 52, 8)
  };

  function checkInt (buf, value, offset, ext, max, min) {
    if (!internalIsBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
    if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
    if (offset + ext > buf.length) throw new RangeError('Index out of range')
  }

  Buffer$1.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength) - 1;
      checkInt(this, value, offset, byteLength, maxBytes, 0);
    }

    var mul = 1;
    var i = 0;
    this[offset] = value & 0xFF;
    while (++i < byteLength && (mul *= 0x100)) {
      this[offset + i] = (value / mul) & 0xFF;
    }

    return offset + byteLength
  };

  Buffer$1.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength) - 1;
      checkInt(this, value, offset, byteLength, maxBytes, 0);
    }

    var i = byteLength - 1;
    var mul = 1;
    this[offset + i] = value & 0xFF;
    while (--i >= 0 && (mul *= 0x100)) {
      this[offset + i] = (value / mul) & 0xFF;
    }

    return offset + byteLength
  };

  Buffer$1.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
    if (!Buffer$1.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
    this[offset] = (value & 0xff);
    return offset + 1
  };

  function objectWriteUInt16 (buf, value, offset, littleEndian) {
    if (value < 0) value = 0xffff + value + 1;
    for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
      buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
        (littleEndian ? i : 1 - i) * 8;
    }
  }

  Buffer$1.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    if (Buffer$1.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value & 0xff);
      this[offset + 1] = (value >>> 8);
    } else {
      objectWriteUInt16(this, value, offset, true);
    }
    return offset + 2
  };

  Buffer$1.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    if (Buffer$1.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 8);
      this[offset + 1] = (value & 0xff);
    } else {
      objectWriteUInt16(this, value, offset, false);
    }
    return offset + 2
  };

  function objectWriteUInt32 (buf, value, offset, littleEndian) {
    if (value < 0) value = 0xffffffff + value + 1;
    for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
      buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff;
    }
  }

  Buffer$1.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    if (Buffer$1.TYPED_ARRAY_SUPPORT) {
      this[offset + 3] = (value >>> 24);
      this[offset + 2] = (value >>> 16);
      this[offset + 1] = (value >>> 8);
      this[offset] = (value & 0xff);
    } else {
      objectWriteUInt32(this, value, offset, true);
    }
    return offset + 4
  };

  Buffer$1.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    if (Buffer$1.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 24);
      this[offset + 1] = (value >>> 16);
      this[offset + 2] = (value >>> 8);
      this[offset + 3] = (value & 0xff);
    } else {
      objectWriteUInt32(this, value, offset, false);
    }
    return offset + 4
  };

  Buffer$1.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength - 1);

      checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }

    var i = 0;
    var mul = 1;
    var sub = 0;
    this[offset] = value & 0xFF;
    while (++i < byteLength && (mul *= 0x100)) {
      if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
        sub = 1;
      }
      this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
    }

    return offset + byteLength
  };

  Buffer$1.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength - 1);

      checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }

    var i = byteLength - 1;
    var mul = 1;
    var sub = 0;
    this[offset + i] = value & 0xFF;
    while (--i >= 0 && (mul *= 0x100)) {
      if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
        sub = 1;
      }
      this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
    }

    return offset + byteLength
  };

  Buffer$1.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
    if (!Buffer$1.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
    if (value < 0) value = 0xff + value + 1;
    this[offset] = (value & 0xff);
    return offset + 1
  };

  Buffer$1.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
    if (Buffer$1.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value & 0xff);
      this[offset + 1] = (value >>> 8);
    } else {
      objectWriteUInt16(this, value, offset, true);
    }
    return offset + 2
  };

  Buffer$1.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
    if (Buffer$1.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 8);
      this[offset + 1] = (value & 0xff);
    } else {
      objectWriteUInt16(this, value, offset, false);
    }
    return offset + 2
  };

  Buffer$1.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
    if (Buffer$1.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value & 0xff);
      this[offset + 1] = (value >>> 8);
      this[offset + 2] = (value >>> 16);
      this[offset + 3] = (value >>> 24);
    } else {
      objectWriteUInt32(this, value, offset, true);
    }
    return offset + 4
  };

  Buffer$1.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
    if (value < 0) value = 0xffffffff + value + 1;
    if (Buffer$1.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 24);
      this[offset + 1] = (value >>> 16);
      this[offset + 2] = (value >>> 8);
      this[offset + 3] = (value & 0xff);
    } else {
      objectWriteUInt32(this, value, offset, false);
    }
    return offset + 4
  };

  function checkIEEE754 (buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length) throw new RangeError('Index out of range')
    if (offset < 0) throw new RangeError('Index out of range')
  }

  function writeFloat (buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 4);
    }
    write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4
  }

  Buffer$1.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert)
  };

  Buffer$1.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert)
  };

  function writeDouble (buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 8);
    }
    write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8
  }

  Buffer$1.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert)
  };

  Buffer$1.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert)
  };

  // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
  Buffer$1.prototype.copy = function copy (target, targetStart, start, end) {
    if (!start) start = 0;
    if (!end && end !== 0) end = this.length;
    if (targetStart >= target.length) targetStart = target.length;
    if (!targetStart) targetStart = 0;
    if (end > 0 && end < start) end = start;

    // Copy 0 bytes; we're done
    if (end === start) return 0
    if (target.length === 0 || this.length === 0) return 0

    // Fatal error conditions
    if (targetStart < 0) {
      throw new RangeError('targetStart out of bounds')
    }
    if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
    if (end < 0) throw new RangeError('sourceEnd out of bounds')

    // Are we oob?
    if (end > this.length) end = this.length;
    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start;
    }

    var len = end - start;
    var i;

    if (this === target && start < targetStart && targetStart < end) {
      // descending copy from end
      for (i = len - 1; i >= 0; --i) {
        target[i + targetStart] = this[i + start];
      }
    } else if (len < 1000 || !Buffer$1.TYPED_ARRAY_SUPPORT) {
      // ascending copy from start
      for (i = 0; i < len; ++i) {
        target[i + targetStart] = this[i + start];
      }
    } else {
      Uint8Array.prototype.set.call(
        target,
        this.subarray(start, start + len),
        targetStart
      );
    }

    return len
  };

  // Usage:
  //    buffer.fill(number[, offset[, end]])
  //    buffer.fill(buffer[, offset[, end]])
  //    buffer.fill(string[, offset[, end]][, encoding])
  Buffer$1.prototype.fill = function fill (val, start, end, encoding) {
    // Handle string cases:
    if (typeof val === 'string') {
      if (typeof start === 'string') {
        encoding = start;
        start = 0;
        end = this.length;
      } else if (typeof end === 'string') {
        encoding = end;
        end = this.length;
      }
      if (val.length === 1) {
        var code = val.charCodeAt(0);
        if (code < 256) {
          val = code;
        }
      }
      if (encoding !== undefined && typeof encoding !== 'string') {
        throw new TypeError('encoding must be a string')
      }
      if (typeof encoding === 'string' && !Buffer$1.isEncoding(encoding)) {
        throw new TypeError('Unknown encoding: ' + encoding)
      }
    } else if (typeof val === 'number') {
      val = val & 255;
    }

    // Invalid ranges are not set to a default, so can range check early.
    if (start < 0 || this.length < start || this.length < end) {
      throw new RangeError('Out of range index')
    }

    if (end <= start) {
      return this
    }

    start = start >>> 0;
    end = end === undefined ? this.length : end >>> 0;

    if (!val) val = 0;

    var i;
    if (typeof val === 'number') {
      for (i = start; i < end; ++i) {
        this[i] = val;
      }
    } else {
      var bytes = internalIsBuffer(val)
        ? val
        : utf8ToBytes(new Buffer$1(val, encoding).toString());
      var len = bytes.length;
      for (i = 0; i < end - start; ++i) {
        this[i + start] = bytes[i % len];
      }
    }

    return this
  };

  // HELPER FUNCTIONS
  // ================

  var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

  function base64clean (str) {
    // Node strips out invalid characters like \n and \t from the string, base64-js does not
    str = stringtrim(str).replace(INVALID_BASE64_RE, '');
    // Node converts strings with length < 2 to ''
    if (str.length < 2) return ''
    // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
    while (str.length % 4 !== 0) {
      str = str + '=';
    }
    return str
  }

  function stringtrim (str) {
    if (str.trim) return str.trim()
    return str.replace(/^\s+|\s+$/g, '')
  }

  function toHex (n) {
    if (n < 16) return '0' + n.toString(16)
    return n.toString(16)
  }

  function utf8ToBytes (string, units) {
    units = units || Infinity;
    var codePoint;
    var length = string.length;
    var leadSurrogate = null;
    var bytes = [];

    for (var i = 0; i < length; ++i) {
      codePoint = string.charCodeAt(i);

      // is surrogate component
      if (codePoint > 0xD7FF && codePoint < 0xE000) {
        // last char was a lead
        if (!leadSurrogate) {
          // no lead yet
          if (codePoint > 0xDBFF) {
            // unexpected trail
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
            continue
          } else if (i + 1 === length) {
            // unpaired lead
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
            continue
          }

          // valid lead
          leadSurrogate = codePoint;

          continue
        }

        // 2 leads in a row
        if (codePoint < 0xDC00) {
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          leadSurrogate = codePoint;
          continue
        }

        // valid surrogate pair
        codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
      } else if (leadSurrogate) {
        // valid bmp char, but last char was a lead
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
      }

      leadSurrogate = null;

      // encode utf8
      if (codePoint < 0x80) {
        if ((units -= 1) < 0) break
        bytes.push(codePoint);
      } else if (codePoint < 0x800) {
        if ((units -= 2) < 0) break
        bytes.push(
          codePoint >> 0x6 | 0xC0,
          codePoint & 0x3F | 0x80
        );
      } else if (codePoint < 0x10000) {
        if ((units -= 3) < 0) break
        bytes.push(
          codePoint >> 0xC | 0xE0,
          codePoint >> 0x6 & 0x3F | 0x80,
          codePoint & 0x3F | 0x80
        );
      } else if (codePoint < 0x110000) {
        if ((units -= 4) < 0) break
        bytes.push(
          codePoint >> 0x12 | 0xF0,
          codePoint >> 0xC & 0x3F | 0x80,
          codePoint >> 0x6 & 0x3F | 0x80,
          codePoint & 0x3F | 0x80
        );
      } else {
        throw new Error('Invalid code point')
      }
    }

    return bytes
  }

  function asciiToBytes (str) {
    var byteArray = [];
    for (var i = 0; i < str.length; ++i) {
      // Node's code seems to be doing this and not & 0x7F..
      byteArray.push(str.charCodeAt(i) & 0xFF);
    }
    return byteArray
  }

  function utf16leToBytes (str, units) {
    var c, hi, lo;
    var byteArray = [];
    for (var i = 0; i < str.length; ++i) {
      if ((units -= 2) < 0) break

      c = str.charCodeAt(i);
      hi = c >> 8;
      lo = c % 256;
      byteArray.push(lo);
      byteArray.push(hi);
    }

    return byteArray
  }


  function base64ToBytes (str) {
    return toByteArray(base64clean(str))
  }

  function blitBuffer (src, dst, offset, length) {
    for (var i = 0; i < length; ++i) {
      if ((i + offset >= dst.length) || (i >= src.length)) break
      dst[i + offset] = src[i];
    }
    return i
  }

  function isnan (val) {
    return val !== val // eslint-disable-line no-self-compare
  }


  // the following is from is-buffer, also by Feross Aboukhadijeh and with same lisence
  // The _isBuffer check is for Safari 5-7 support, because it's missing
  // Object.prototype.constructor. Remove this eventually
  function isBuffer$1(obj) {
    return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj))
  }

  function isFastBuffer (obj) {
    return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
  }

  // For Node v0.10 support. Remove this eventually.
  function isSlowBuffer (obj) {
    return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isFastBuffer(obj.slice(0, 0))
  }

  var comma = ",".charCodeAt(0);
  var semicolon = ";".charCodeAt(0);
  var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  var intToChar = new Uint8Array(64);
  var charToInt = new Uint8Array(128);
  for (var i = 0; i < chars.length; i++) {
    var c = chars.charCodeAt(i);
    intToChar[i] = c;
    charToInt[c] = i;
  }
  function decodeInteger(reader, relative) {
    var value = 0;
    var shift = 0;
    var integer = 0;
    do {
      var _c = reader.next();
      integer = charToInt[_c];
      value |= (integer & 31) << shift;
      shift += 5;
    } while (integer & 32);
    var shouldNegate = value & 1;
    value >>>= 1;
    if (shouldNegate) {
      value = -2147483648 | -value;
    }
    return relative + value;
  }
  function encodeInteger(builder, num, relative) {
    var delta = num - relative;
    delta = delta < 0 ? -delta << 1 | 1 : delta << 1;
    do {
      var clamped = delta & 31;
      delta >>>= 5;
      if (delta > 0) clamped |= 32;
      builder.write(intToChar[clamped]);
    } while (delta > 0);
    return num;
  }
  function hasMoreVlq(reader, max) {
    if (reader.pos >= max) return false;
    return reader.peek() !== comma;
  }
  var bufLength = 1024 * 16;
  var td = typeof TextDecoder !== "undefined" ? new TextDecoder() : typeof Buffer$1 !== "undefined" ? {
    decode: function decode(buf) {
      var out = Buffer$1.from(buf.buffer, buf.byteOffset, buf.byteLength);
      return out.toString();
    }
  } : {
    decode: function decode(buf) {
      var out = "";
      for (var _i = 0; _i < buf.length; _i++) {
        out += String.fromCharCode(buf[_i]);
      }
      return out;
    }
  };
  var StringWriter = function () {
    function StringWriter() {
      this.pos = 0;
      this.out = "";
      this.buffer = new Uint8Array(bufLength);
    }
    var _proto = StringWriter.prototype;
    _proto.write = function write(v) {
      var buffer = this.buffer;
      buffer[this.pos++] = v;
      if (this.pos === bufLength) {
        this.out += td.decode(buffer);
        this.pos = 0;
      }
    };
    _proto.flush = function flush() {
      var buffer = this.buffer,
        out = this.out,
        pos = this.pos;
      return pos > 0 ? out + td.decode(buffer.subarray(0, pos)) : out;
    };
    return _createClass(StringWriter);
  }();
  var StringReader = function () {
    function StringReader(buffer) {
      this.pos = 0;
      this.buffer = buffer;
    }
    var _proto2 = StringReader.prototype;
    _proto2.next = function next() {
      return this.buffer.charCodeAt(this.pos++);
    };
    _proto2.peek = function peek() {
      return this.buffer.charCodeAt(this.pos);
    };
    _proto2.indexOf = function indexOf(_char) {
      var buffer = this.buffer,
        pos = this.pos;
      var idx = buffer.indexOf(_char, pos);
      return idx === -1 ? buffer.length : idx;
    };
    return _createClass(StringReader);
  }();
  function decode(mappings) {
    var length = mappings.length;
    var reader = new StringReader(mappings);
    var decoded = [];
    var genColumn = 0;
    var sourcesIndex = 0;
    var sourceLine = 0;
    var sourceColumn = 0;
    var namesIndex = 0;
    do {
      var semi = reader.indexOf(";");
      var line = [];
      var sorted = true;
      var lastCol = 0;
      genColumn = 0;
      while (reader.pos < semi) {
        var seg = void 0;
        genColumn = decodeInteger(reader, genColumn);
        if (genColumn < lastCol) sorted = false;
        lastCol = genColumn;
        if (hasMoreVlq(reader, semi)) {
          sourcesIndex = decodeInteger(reader, sourcesIndex);
          sourceLine = decodeInteger(reader, sourceLine);
          sourceColumn = decodeInteger(reader, sourceColumn);
          if (hasMoreVlq(reader, semi)) {
            namesIndex = decodeInteger(reader, namesIndex);
            seg = [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex];
          } else {
            seg = [genColumn, sourcesIndex, sourceLine, sourceColumn];
          }
        } else {
          seg = [genColumn];
        }
        line.push(seg);
        reader.pos++;
      }
      if (!sorted) sort(line);
      decoded.push(line);
      reader.pos = semi + 1;
    } while (reader.pos <= length);
    return decoded;
  }
  function sort(line) {
    line.sort(sortComparator$1);
  }
  function sortComparator$1(a, b) {
    return a[0] - b[0];
  }
  function encode(decoded) {
    var writer = new StringWriter();
    var sourcesIndex = 0;
    var sourceLine = 0;
    var sourceColumn = 0;
    var namesIndex = 0;
    for (var _i6 = 0; _i6 < decoded.length; _i6++) {
      var line = decoded[_i6];
      if (_i6 > 0) writer.write(semicolon);
      if (line.length === 0) continue;
      var genColumn = 0;
      for (var j = 0; j < line.length; j++) {
        var segment = line[j];
        if (j > 0) writer.write(comma);
        genColumn = encodeInteger(writer, segment[0], genColumn);
        if (segment.length === 1) continue;
        sourcesIndex = encodeInteger(writer, segment[1], sourcesIndex);
        sourceLine = encodeInteger(writer, segment[2], sourceLine);
        sourceColumn = encodeInteger(writer, segment[3], sourceColumn);
        if (segment.length === 4) continue;
        namesIndex = encodeInteger(writer, segment[4], namesIndex);
      }
    }
    return writer.flush();
  }

  var schemeRegex = /^[\w+.-]+:\/\//;
  var urlRegex = /^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/;
  var fileRegex = /^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?(\/?[^#?]*)(\?[^#]*)?(#.*)?/i;
  function isAbsoluteUrl(input) {
    return schemeRegex.test(input);
  }
  function isSchemeRelativeUrl(input) {
    return input.startsWith('//');
  }
  function isAbsolutePath(input) {
    return input.startsWith('/');
  }
  function isFileUrl(input) {
    return input.startsWith('file:');
  }
  function isRelative(input) {
    return /^[.?#]/.test(input);
  }
  function parseAbsoluteUrl(input) {
    var match = urlRegex.exec(input);
    return makeUrl(match[1], match[2] || '', match[3], match[4] || '', match[5] || '/', match[6] || '', match[7] || '');
  }
  function parseFileUrl(input) {
    var match = fileRegex.exec(input);
    var path = match[2];
    return makeUrl('file:', '', match[1] || '', '', isAbsolutePath(path) ? path : '/' + path, match[3] || '', match[4] || '');
  }
  function makeUrl(scheme, user, host, port, path, query, hash) {
    return {
      scheme: scheme,
      user: user,
      host: host,
      port: port,
      path: path,
      query: query,
      hash: hash,
      type: 7
    };
  }
  function parseUrl(input) {
    if (isSchemeRelativeUrl(input)) {
      var _url = parseAbsoluteUrl('http:' + input);
      _url.scheme = '';
      _url.type = 6;
      return _url;
    }
    if (isAbsolutePath(input)) {
      var _url2 = parseAbsoluteUrl('http://foo.com' + input);
      _url2.scheme = '';
      _url2.host = '';
      _url2.type = 5;
      return _url2;
    }
    if (isFileUrl(input)) return parseFileUrl(input);
    if (isAbsoluteUrl(input)) return parseAbsoluteUrl(input);
    var url = parseAbsoluteUrl('http://foo.com/' + input);
    url.scheme = '';
    url.host = '';
    url.type = input ? input.startsWith('?') ? 3 : input.startsWith('#') ? 2 : 4 : 1;
    return url;
  }
  function stripPathFilename(path) {
    if (path.endsWith('/..')) return path;
    var index = path.lastIndexOf('/');
    return path.slice(0, index + 1);
  }
  function mergePaths(url, base) {
    normalizePath(base, base.type);
    if (url.path === '/') {
      url.path = base.path;
    } else {
      url.path = stripPathFilename(base.path) + url.path;
    }
  }
  function normalizePath(url, type) {
    var rel = type <= 4;
    var pieces = url.path.split('/');
    var pointer = 1;
    var positive = 0;
    var addTrailingSlash = false;
    for (var i = 1; i < pieces.length; i++) {
      var piece = pieces[i];
      if (!piece) {
        addTrailingSlash = true;
        continue;
      }
      addTrailingSlash = false;
      if (piece === '.') continue;
      if (piece === '..') {
        if (positive) {
          addTrailingSlash = true;
          positive--;
          pointer--;
        } else if (rel) {
          pieces[pointer++] = piece;
        }
        continue;
      }
      pieces[pointer++] = piece;
      positive++;
    }
    var path = '';
    for (var _i = 1; _i < pointer; _i++) {
      path += '/' + pieces[_i];
    }
    if (!path || addTrailingSlash && !path.endsWith('/..')) {
      path += '/';
    }
    url.path = path;
  }
  function resolve$5(input, base) {
    if (!input && !base) return '';
    var url = parseUrl(input);
    var inputType = url.type;
    if (base && inputType !== 7) {
      var baseUrl = parseUrl(base);
      var baseType = baseUrl.type;
      switch (inputType) {
        case 1:
          url.hash = baseUrl.hash;
        case 2:
          url.query = baseUrl.query;
        case 3:
        case 4:
          mergePaths(url, baseUrl);
        case 5:
          url.user = baseUrl.user;
          url.host = baseUrl.host;
          url.port = baseUrl.port;
        case 6:
          url.scheme = baseUrl.scheme;
      }
      if (baseType > inputType) inputType = baseType;
    }
    normalizePath(url, inputType);
    var queryHash = url.query + url.hash;
    switch (inputType) {
      case 2:
      case 3:
        return queryHash;
      case 4:
        {
          var path = url.path.slice(1);
          if (!path) return queryHash || '.';
          if (isRelative(base || input) && !isRelative(path)) {
            return './' + path + queryHash;
          }
          return path + queryHash;
        }
      case 5:
        return url.path + queryHash;
      default:
        return url.scheme + '//' + url.user + url.host + url.port + url.path + queryHash;
    }
  }

  function stripFilename(path) {
    if (!path) return "";
    var index = path.lastIndexOf("/");
    return path.slice(0, index + 1);
  }
  function resolver(mapUrl, sourceRoot) {
    var from = stripFilename(mapUrl);
    var prefix = sourceRoot ? sourceRoot + "/" : "";
    return function (source) {
      return resolve$5(prefix + (source || ""), from);
    };
  }
  var COLUMN$1 = 0;
  var SOURCES_INDEX$1 = 1;
  var SOURCE_LINE$1 = 2;
  var SOURCE_COLUMN$1 = 3;
  var NAMES_INDEX$1 = 4;
  function maybeSort(mappings, owned) {
    var unsortedIndex = nextUnsortedSegmentLine(mappings, 0);
    if (unsortedIndex === mappings.length) return mappings;
    if (!owned) mappings = mappings.slice();
    for (var i = unsortedIndex; i < mappings.length; i = nextUnsortedSegmentLine(mappings, i + 1)) {
      mappings[i] = sortSegments(mappings[i], owned);
    }
    return mappings;
  }
  function nextUnsortedSegmentLine(mappings, start) {
    for (var i = start; i < mappings.length; i++) {
      if (!isSorted(mappings[i])) return i;
    }
    return mappings.length;
  }
  function isSorted(line) {
    for (var j = 1; j < line.length; j++) {
      if (line[j][COLUMN$1] < line[j - 1][COLUMN$1]) {
        return false;
      }
    }
    return true;
  }
  function sortSegments(line, owned) {
    if (!owned) line = line.slice();
    return line.sort(sortComparator);
  }
  function sortComparator(a, b) {
    return a[COLUMN$1] - b[COLUMN$1];
  }
  var found = false;
  function binarySearch(haystack, needle, low, high) {
    while (low <= high) {
      var mid = low + (high - low >> 1);
      var cmp = haystack[mid][COLUMN$1] - needle;
      if (cmp === 0) {
        found = true;
        return mid;
      }
      if (cmp < 0) {
        low = mid + 1;
      } else {
        high = mid - 1;
      }
    }
    found = false;
    return low - 1;
  }
  function upperBound(haystack, needle, index) {
    for (var i = index + 1; i < haystack.length; index = i++) {
      if (haystack[i][COLUMN$1] !== needle) break;
    }
    return index;
  }
  function lowerBound(haystack, needle, index) {
    for (var i = index - 1; i >= 0; index = i--) {
      if (haystack[i][COLUMN$1] !== needle) break;
    }
    return index;
  }
  function memoizedState() {
    return {
      lastKey: -1,
      lastNeedle: -1,
      lastIndex: -1
    };
  }
  function memoizedBinarySearch(haystack, needle, state, key) {
    var lastKey = state.lastKey,
      lastNeedle = state.lastNeedle,
      lastIndex = state.lastIndex;
    var low = 0;
    var high = haystack.length - 1;
    if (key === lastKey) {
      if (needle === lastNeedle) {
        found = lastIndex !== -1 && haystack[lastIndex][COLUMN$1] === needle;
        return lastIndex;
      }
      if (needle >= lastNeedle) {
        low = lastIndex === -1 ? 0 : lastIndex;
      } else {
        high = lastIndex;
      }
    }
    state.lastKey = key;
    state.lastNeedle = needle;
    return state.lastIndex = binarySearch(haystack, needle, low, high);
  }
  function parse$3(map) {
    return typeof map === "string" ? JSON.parse(map) : map;
  }
  var LINE_GTR_ZERO = "`line` must be greater than 0 (lines start at line 1)";
  var COL_GTR_EQ_ZERO = "`column` must be greater than or equal to 0 (columns start at column 0)";
  var LEAST_UPPER_BOUND = -1;
  var GREATEST_LOWER_BOUND = 1;
  var TraceMap = _createClass(function TraceMap(map, mapUrl) {
    var isString = typeof map === "string";
    if (!isString && map._decodedMemo) return map;
    var parsed = parse$3(map);
    var version = parsed.version,
      file = parsed.file,
      names = parsed.names,
      sourceRoot = parsed.sourceRoot,
      sources = parsed.sources,
      sourcesContent = parsed.sourcesContent;
    this.version = version;
    this.file = file;
    this.names = names || [];
    this.sourceRoot = sourceRoot;
    this.sources = sources;
    this.sourcesContent = sourcesContent;
    this.ignoreList = parsed.ignoreList || parsed.x_google_ignoreList || void 0;
    var resolve = resolver(mapUrl, sourceRoot);
    this.resolvedSources = sources.map(resolve);
    var mappings = parsed.mappings;
    if (typeof mappings === "string") {
      this._encoded = mappings;
      this._decoded = void 0;
    } else if (Array.isArray(mappings)) {
      this._encoded = void 0;
      this._decoded = maybeSort(mappings, isString);
    } else if (parsed.sections) {
      throw new Error("TraceMap passed sectioned source map, please use FlattenMap export instead");
    } else {
      throw new Error("invalid source map: " + JSON.stringify(parsed));
    }
    this._decodedMemo = memoizedState();
    this._bySources = void 0;
    this._bySourceMemos = void 0;
  });
  function cast$2(map) {
    return map;
  }
  function decodedMappings(map) {
    var _a;
    return (_a = cast$2(map))._decoded || (_a._decoded = decode(cast$2(map)._encoded));
  }
  function traceSegment(map, line, column) {
    var decoded = decodedMappings(map);
    if (line >= decoded.length) return null;
    var segments = decoded[line];
    var index = traceSegmentInternal(segments, cast$2(map)._decodedMemo, line, column, GREATEST_LOWER_BOUND);
    return index === -1 ? null : segments[index];
  }
  function originalPositionFor$1(map, needle) {
    var line = needle.line,
      column = needle.column,
      bias = needle.bias;
    line--;
    if (line < 0) throw new Error(LINE_GTR_ZERO);
    if (column < 0) throw new Error(COL_GTR_EQ_ZERO);
    var decoded = decodedMappings(map);
    if (line >= decoded.length) return OMapping(null, null, null, null);
    var segments = decoded[line];
    var index = traceSegmentInternal(segments, cast$2(map)._decodedMemo, line, column, bias || GREATEST_LOWER_BOUND);
    if (index === -1) return OMapping(null, null, null, null);
    var segment = segments[index];
    if (segment.length === 1) return OMapping(null, null, null, null);
    var names = map.names,
      resolvedSources = map.resolvedSources;
    return OMapping(resolvedSources[segment[SOURCES_INDEX$1]], segment[SOURCE_LINE$1] + 1, segment[SOURCE_COLUMN$1], segment.length === 5 ? names[segment[NAMES_INDEX$1]] : null);
  }
  function OMapping(source, line, column, name) {
    return {
      source: source,
      line: line,
      column: column,
      name: name
    };
  }
  function traceSegmentInternal(segments, memo, line, column, bias) {
    var index = memoizedBinarySearch(segments, column, memo, line);
    if (found) {
      index = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column, index);
    } else if (bias === LEAST_UPPER_BOUND) index++;
    if (index === -1 || index === segments.length) return -1;
    return index;
  }

  var SetArray$1 = _createClass(function SetArray() {
    this._indexes = {
      __proto__: null
    };
    this.array = [];
  });
  function cast$1(set) {
    return set;
  }
  function get$3(setarr, key) {
    return cast$1(setarr)._indexes[key];
  }
  function put$1(setarr, key) {
    var index = get$3(setarr, key);
    if (index !== void 0) return index;
    var _cast = cast$1(setarr),
      array = _cast.array,
      indexes = _cast._indexes;
    var length = array.push(key);
    return indexes[key] = length - 1;
  }
  var COLUMN = 0;
  var SOURCES_INDEX = 1;
  var SOURCE_LINE = 2;
  var SOURCE_COLUMN = 3;
  var NAMES_INDEX = 4;
  var NO_NAME = -1;
  var GenMapping$1 = _createClass(function GenMapping(_temp) {
    var _ref = _temp === void 0 ? {} : _temp,
      file = _ref.file,
      sourceRoot = _ref.sourceRoot;
    this._names = new SetArray$1();
    this._sources = new SetArray$1();
    this._sourcesContent = [];
    this._mappings = [];
    this.file = file;
    this.sourceRoot = sourceRoot;
    this._ignoreList = new SetArray$1();
  });
  function cast2(map) {
    return map;
  }
  var maybeAddMapping = function maybeAddMapping(map, mapping) {
    return addMappingInternal(true, map, mapping);
  };
  function setSourceContent$1(map, source, content) {
    var _cast3 = cast2(map),
      sources = _cast3._sources,
      sourcesContent = _cast3._sourcesContent;
    var index = put$1(sources, source);
    sourcesContent[index] = content;
  }
  function toDecodedMap(map) {
    var _cast5 = cast2(map),
      mappings = _cast5._mappings,
      sources = _cast5._sources,
      sourcesContent = _cast5._sourcesContent,
      names = _cast5._names,
      ignoreList = _cast5._ignoreList;
    removeEmptyFinalLines(mappings);
    return {
      version: 3,
      file: map.file || void 0,
      names: names.array,
      sourceRoot: map.sourceRoot || void 0,
      sources: sources.array,
      sourcesContent: sourcesContent,
      mappings: mappings,
      ignoreList: ignoreList.array
    };
  }
  function toEncodedMap(map) {
    var decoded = toDecodedMap(map);
    return Object.assign({}, decoded, {
      mappings: encode(decoded.mappings)
    });
  }
  function allMappings(map) {
    var out = [];
    var _cast6 = cast2(map),
      mappings = _cast6._mappings,
      sources = _cast6._sources,
      names = _cast6._names;
    for (var i = 0; i < mappings.length; i++) {
      var line = mappings[i];
      for (var j = 0; j < line.length; j++) {
        var seg = line[j];
        var generated = {
          line: i + 1,
          column: seg[COLUMN]
        };
        var source = void 0;
        var original = void 0;
        var name = void 0;
        if (seg.length !== 1) {
          source = sources.array[seg[SOURCES_INDEX]];
          original = {
            line: seg[SOURCE_LINE] + 1,
            column: seg[SOURCE_COLUMN]
          };
          if (seg.length === 5) name = names.array[seg[NAMES_INDEX]];
        }
        out.push({
          generated: generated,
          source: source,
          original: original,
          name: name
        });
      }
    }
    return out;
  }
  function addSegmentInternal(skipable, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) {
    var _cast7 = cast2(map),
      mappings = _cast7._mappings,
      sources = _cast7._sources,
      sourcesContent = _cast7._sourcesContent,
      names = _cast7._names;
    var line = getIndex(mappings, genLine);
    var index = getColumnIndex$1(line, genColumn);
    if (!source) {
      if (skipSourceless(line, index)) return;
      return insert$1(line, index, [genColumn]);
    }
    var sourcesIndex = put$1(sources, source);
    var namesIndex = name ? put$1(names, name) : NO_NAME;
    if (sourcesIndex === sourcesContent.length) sourcesContent[sourcesIndex] = content != null ? content : null;
    if (skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex)) {
      return;
    }
    return insert$1(line, index, name ? [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex] : [genColumn, sourcesIndex, sourceLine, sourceColumn]);
  }
  function getIndex(arr, index) {
    for (var i = arr.length; i <= index; i++) {
      arr[i] = [];
    }
    return arr[index];
  }
  function getColumnIndex$1(line, genColumn) {
    var index = line.length;
    for (var i = index - 1; i >= 0; index = i--) {
      var current = line[i];
      if (genColumn >= current[COLUMN]) break;
    }
    return index;
  }
  function insert$1(array, index, value) {
    for (var i = array.length; i > index; i--) {
      array[i] = array[i - 1];
    }
    array[index] = value;
  }
  function removeEmptyFinalLines(mappings) {
    var length = mappings.length;
    var len = length;
    for (var i = len - 1; i >= 0; len = i, i--) {
      if (mappings[i].length > 0) break;
    }
    if (len < length) mappings.length = len;
  }
  function skipSourceless(line, index) {
    if (index === 0) return true;
    var prev = line[index - 1];
    return prev.length === 1;
  }
  function skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex) {
    if (index === 0) return false;
    var prev = line[index - 1];
    if (prev.length === 1) return false;
    return sourcesIndex === prev[SOURCES_INDEX] && sourceLine === prev[SOURCE_LINE] && sourceColumn === prev[SOURCE_COLUMN] && namesIndex === (prev.length === 5 ? prev[NAMES_INDEX] : NO_NAME);
  }
  function addMappingInternal(skipable, map, mapping) {
    var generated = mapping.generated,
      source = mapping.source,
      original = mapping.original,
      name = mapping.name,
      content = mapping.content;
    if (!source) {
      return addSegmentInternal(skipable, map, generated.line - 1, generated.column, null, null, null, null, null);
    }
    return addSegmentInternal(skipable, map, generated.line - 1, generated.column, source, original.line - 1, original.column, name, content);
  }

  var SourceMap$1 = function () {
    function SourceMap(opts, code) {
      var _opts$sourceFileName;
      this._map = void 0;
      this._rawMappings = void 0;
      this._sourceFileName = void 0;
      this._lastGenLine = 0;
      this._lastSourceLine = 0;
      this._lastSourceColumn = 0;
      this._inputMap = void 0;
      var map = this._map = new GenMapping$1({
        sourceRoot: opts.sourceRoot
      });
      this._sourceFileName = (_opts$sourceFileName = opts.sourceFileName) == null ? void 0 : _opts$sourceFileName.replace(/\\/g, "/");
      this._rawMappings = undefined;
      if (opts.inputSourceMap) {
        this._inputMap = new TraceMap(opts.inputSourceMap);
        var resolvedSources = this._inputMap.resolvedSources;
        if (resolvedSources.length) {
          for (var i = 0; i < resolvedSources.length; i++) {
            var _this$_inputMap$sourc;
            setSourceContent$1(map, resolvedSources[i], (_this$_inputMap$sourc = this._inputMap.sourcesContent) == null ? void 0 : _this$_inputMap$sourc[i]);
          }
        }
      }
      if (typeof code === "string" && !opts.inputSourceMap) {
        setSourceContent$1(map, this._sourceFileName, code);
      } else if (typeof code === "object") {
        for (var _i = 0, _Object$keys = Object.keys(code); _i < _Object$keys.length; _i++) {
          var sourceFileName = _Object$keys[_i];
          setSourceContent$1(map, sourceFileName.replace(/\\/g, "/"), code[sourceFileName]);
        }
      }
    }
    var _proto = SourceMap.prototype;
    _proto.get = function get() {
      return toEncodedMap(this._map);
    };
    _proto.getDecoded = function getDecoded() {
      return toDecodedMap(this._map);
    };
    _proto.getRawMappings = function getRawMappings() {
      return this._rawMappings || (this._rawMappings = allMappings(this._map));
    };
    _proto.mark = function mark(generated, line, column, identifierName, identifierNamePos, filename) {
      var _originalMapping;
      this._rawMappings = undefined;
      var originalMapping;
      if (line != null) {
        if (this._inputMap) {
          originalMapping = originalPositionFor$1(this._inputMap, {
            line: line,
            column: column
          });
          if (!originalMapping.name && identifierNamePos) {
            var originalIdentifierMapping = originalPositionFor$1(this._inputMap, identifierNamePos);
            if (originalIdentifierMapping.name) {
              identifierName = originalIdentifierMapping.name;
            }
          }
        } else {
          originalMapping = {
            source: (filename == null ? void 0 : filename.replace(/\\/g, "/")) || this._sourceFileName,
            line: line,
            column: column
          };
        }
      }
      maybeAddMapping(this._map, {
        name: identifierName,
        generated: generated,
        source: (_originalMapping = originalMapping) == null ? void 0 : _originalMapping.source,
        original: originalMapping
      });
    };
    return _createClass(SourceMap);
  }();

  var Buffer = function () {
    function Buffer(map, indentChar) {
      this._map = null;
      this._buf = "";
      this._str = "";
      this._appendCount = 0;
      this._last = 0;
      this._queue = [];
      this._queueCursor = 0;
      this._canMarkIdName = true;
      this._indentChar = "";
      this._fastIndentations = [];
      this._position = {
        line: 1,
        column: 0
      };
      this._sourcePosition = {
        identifierName: undefined,
        identifierNamePos: undefined,
        line: undefined,
        column: undefined,
        filename: undefined
      };
      this._map = map;
      this._indentChar = indentChar;
      for (var i = 0; i < 64; i++) {
        this._fastIndentations.push(indentChar.repeat(i));
      }
      this._allocQueue();
    }
    var _proto = Buffer.prototype;
    _proto._allocQueue = function _allocQueue() {
      var queue = this._queue;
      for (var i = 0; i < 16; i++) {
        queue.push({
          "char": 0,
          repeat: 1,
          line: undefined,
          column: undefined,
          identifierName: undefined,
          identifierNamePos: undefined,
          filename: ""
        });
      }
    };
    _proto._pushQueue = function _pushQueue(_char, repeat, line, column, filename) {
      var cursor = this._queueCursor;
      if (cursor === this._queue.length) {
        this._allocQueue();
      }
      var item = this._queue[cursor];
      item["char"] = _char;
      item.repeat = repeat;
      item.line = line;
      item.column = column;
      item.filename = filename;
      this._queueCursor++;
    };
    _proto._popQueue = function _popQueue() {
      if (this._queueCursor === 0) {
        throw new Error("Cannot pop from empty queue");
      }
      return this._queue[--this._queueCursor];
    };
    _proto.get = function get() {
      this._flush();
      var map = this._map;
      var result = {
        code: (this._buf + this._str).trimRight(),
        decodedMap: map == null ? void 0 : map.getDecoded(),
        get __mergedMap() {
          return this.map;
        },
        get map() {
          var resultMap = map ? map.get() : null;
          result.map = resultMap;
          return resultMap;
        },
        set map(value) {
          Object.defineProperty(result, "map", {
            value: value,
            writable: true
          });
        },
        get rawMappings() {
          var mappings = map == null ? void 0 : map.getRawMappings();
          result.rawMappings = mappings;
          return mappings;
        },
        set rawMappings(value) {
          Object.defineProperty(result, "rawMappings", {
            value: value,
            writable: true
          });
        }
      };
      return result;
    };
    _proto.append = function append(str, maybeNewline) {
      this._flush();
      this._append(str, this._sourcePosition, maybeNewline);
    };
    _proto.appendChar = function appendChar(_char2) {
      this._flush();
      this._appendChar(_char2, 1, this._sourcePosition);
    };
    _proto.queue = function queue(_char3) {
      if (_char3 === 10) {
        while (this._queueCursor !== 0) {
          var _char4 = this._queue[this._queueCursor - 1]["char"];
          if (_char4 !== 32 && _char4 !== 9) {
            break;
          }
          this._queueCursor--;
        }
      }
      var sourcePosition = this._sourcePosition;
      this._pushQueue(_char3, 1, sourcePosition.line, sourcePosition.column, sourcePosition.filename);
    };
    _proto.queueIndentation = function queueIndentation(repeat) {
      if (repeat === 0) return;
      this._pushQueue(-1, repeat, undefined, undefined, undefined);
    };
    _proto._flush = function _flush() {
      var queueCursor = this._queueCursor;
      var queue = this._queue;
      for (var i = 0; i < queueCursor; i++) {
        var item = queue[i];
        this._appendChar(item["char"], item.repeat, item);
      }
      this._queueCursor = 0;
    };
    _proto._appendChar = function _appendChar(_char5, repeat, sourcePos) {
      this._last = _char5;
      if (_char5 === -1) {
        var fastIndentation = this._fastIndentations[repeat];
        if (fastIndentation !== undefined) {
          this._str += fastIndentation;
        } else {
          this._str += repeat > 1 ? this._indentChar.repeat(repeat) : this._indentChar;
        }
      } else {
        this._str += repeat > 1 ? String.fromCharCode(_char5).repeat(repeat) : String.fromCharCode(_char5);
      }
      if (_char5 !== 10) {
        this._mark(sourcePos.line, sourcePos.column, sourcePos.identifierName, sourcePos.identifierNamePos, sourcePos.filename);
        this._position.column += repeat;
      } else {
        this._position.line++;
        this._position.column = 0;
      }
      if (this._canMarkIdName) {
        sourcePos.identifierName = undefined;
        sourcePos.identifierNamePos = undefined;
      }
    };
    _proto._append = function _append(str, sourcePos, maybeNewline) {
      var len = str.length;
      var position = this._position;
      this._last = str.charCodeAt(len - 1);
      if (++this._appendCount > 4096) {
        +this._str;
        this._buf += this._str;
        this._str = str;
        this._appendCount = 0;
      } else {
        this._str += str;
      }
      if (!maybeNewline && !this._map) {
        position.column += len;
        return;
      }
      var column = sourcePos.column,
        identifierName = sourcePos.identifierName,
        identifierNamePos = sourcePos.identifierNamePos,
        filename = sourcePos.filename;
      var line = sourcePos.line;
      if ((identifierName != null || identifierNamePos != null) && this._canMarkIdName) {
        sourcePos.identifierName = undefined;
        sourcePos.identifierNamePos = undefined;
      }
      var i = str.indexOf("\n");
      var last = 0;
      if (i !== 0) {
        this._mark(line, column, identifierName, identifierNamePos, filename);
      }
      while (i !== -1) {
        position.line++;
        position.column = 0;
        last = i + 1;
        if (last < len && line !== undefined) {
          this._mark(++line, 0, null, null, filename);
        }
        i = str.indexOf("\n", last);
      }
      position.column += len - last;
    };
    _proto._mark = function _mark(line, column, identifierName, identifierNamePos, filename) {
      var _this$_map;
      (_this$_map = this._map) == null || _this$_map.mark(this._position, line, column, identifierName, identifierNamePos, filename);
    };
    _proto.removeTrailingNewline = function removeTrailingNewline() {
      var queueCursor = this._queueCursor;
      if (queueCursor !== 0 && this._queue[queueCursor - 1]["char"] === 10) {
        this._queueCursor--;
      }
    };
    _proto.removeLastSemicolon = function removeLastSemicolon() {
      var queueCursor = this._queueCursor;
      if (queueCursor !== 0 && this._queue[queueCursor - 1]["char"] === 59) {
        this._queueCursor--;
      }
    };
    _proto.getLastChar = function getLastChar() {
      var queueCursor = this._queueCursor;
      return queueCursor !== 0 ? this._queue[queueCursor - 1]["char"] : this._last;
    };
    _proto.getNewlineCount = function getNewlineCount() {
      var queueCursor = this._queueCursor;
      var count = 0;
      if (queueCursor === 0) return this._last === 10 ? 1 : 0;
      for (var i = queueCursor - 1; i >= 0; i--) {
        if (this._queue[i]["char"] !== 10) {
          break;
        }
        count++;
      }
      return count === queueCursor && this._last === 10 ? count + 1 : count;
    };
    _proto.endsWithCharAndNewline = function endsWithCharAndNewline() {
      var queue = this._queue;
      var queueCursor = this._queueCursor;
      if (queueCursor !== 0) {
        var lastCp = queue[queueCursor - 1]["char"];
        if (lastCp !== 10) return;
        if (queueCursor > 1) {
          return queue[queueCursor - 2]["char"];
        } else {
          return this._last;
        }
      }
    };
    _proto.hasContent = function hasContent() {
      return this._queueCursor !== 0 || !!this._last;
    };
    _proto.exactSource = function exactSource(loc, cb) {
      if (!this._map) {
        cb();
        return;
      }
      this.source("start", loc);
      var identifierName = loc.identifierName;
      var sourcePos = this._sourcePosition;
      if (identifierName) {
        this._canMarkIdName = false;
        sourcePos.identifierName = identifierName;
      }
      cb();
      if (identifierName) {
        this._canMarkIdName = true;
        sourcePos.identifierName = undefined;
        sourcePos.identifierNamePos = undefined;
      }
      this.source("end", loc);
    };
    _proto.source = function source(prop, loc) {
      if (!this._map) return;
      this._normalizePosition(prop, loc, 0);
    };
    _proto.sourceWithOffset = function sourceWithOffset(prop, loc, columnOffset) {
      if (!this._map) return;
      this._normalizePosition(prop, loc, columnOffset);
    };
    _proto._normalizePosition = function _normalizePosition(prop, loc, columnOffset) {
      var pos = loc[prop];
      var target = this._sourcePosition;
      if (pos) {
        target.line = pos.line;
        target.column = Math.max(pos.column + columnOffset, 0);
        target.filename = loc.filename;
      }
    };
    _proto.getCurrentColumn = function getCurrentColumn() {
      var queue = this._queue;
      var queueCursor = this._queueCursor;
      var lastIndex = -1;
      var len = 0;
      for (var i = 0; i < queueCursor; i++) {
        var item = queue[i];
        if (item["char"] === 10) {
          lastIndex = len;
        }
        len += item.repeat;
      }
      return lastIndex === -1 ? this._position.column + len : len - 1 - lastIndex;
    };
    _proto.getCurrentLine = function getCurrentLine() {
      var count = 0;
      var queue = this._queue;
      for (var i = 0; i < this._queueCursor; i++) {
        if (queue[i]["char"] === 10) {
          count++;
        }
      }
      return this._position.line + count;
    };
    return _createClass(Buffer);
  }();

  var FLIPPED_ALIAS_KEYS$1 = FLIPPED_ALIAS_KEYS$3,
    isArrayExpression = isArrayExpression$2,
    isAssignmentExpression$1 = isAssignmentExpression$2,
    isBinary = isBinary$2,
    isBlockStatement$2 = isBlockStatement$3,
    isCallExpression$5 = isCallExpression$8,
    isFunction$4 = isFunction$6,
    isIdentifier$a = isIdentifier$e,
    isLiteral$2 = isLiteral$4,
    isMemberExpression$4 = isMemberExpression$7,
    isObjectExpression$1 = isObjectExpression$3,
    isOptionalCallExpression$1 = isOptionalCallExpression$2,
    isOptionalMemberExpression$2 = isOptionalMemberExpression$3,
    isStringLiteral$2 = isStringLiteral$5;
  function crawlInternal(node, state) {
    if (!node) return state;
    if (isMemberExpression$4(node) || isOptionalMemberExpression$2(node)) {
      crawlInternal(node.object, state);
      if (node.computed) crawlInternal(node.property, state);
    } else if (isBinary(node) || isAssignmentExpression$1(node)) {
      crawlInternal(node.left, state);
      crawlInternal(node.right, state);
    } else if (isCallExpression$5(node) || isOptionalCallExpression$1(node)) {
      state.hasCall = true;
      crawlInternal(node.callee, state);
    } else if (isFunction$4(node)) {
      state.hasFunction = true;
    } else if (isIdentifier$a(node)) {
      state.hasHelper = state.hasHelper || node.callee && isHelper(node.callee);
    }
    return state;
  }
  function crawl(node) {
    return crawlInternal(node, {
      hasCall: false,
      hasFunction: false,
      hasHelper: false
    });
  }
  function isHelper(node) {
    if (!node) return false;
    if (isMemberExpression$4(node)) {
      return isHelper(node.object) || isHelper(node.property);
    } else if (isIdentifier$a(node)) {
      return node.name === "require" || node.name.charCodeAt(0) === 95;
    } else if (isCallExpression$5(node)) {
      return isHelper(node.callee);
    } else if (isBinary(node) || isAssignmentExpression$1(node)) {
      return isIdentifier$a(node.left) && isHelper(node.left) || isHelper(node.right);
    } else {
      return false;
    }
  }
  function isType$1(node) {
    return isLiteral$2(node) || isObjectExpression$1(node) || isArrayExpression(node) || isIdentifier$a(node) || isMemberExpression$4(node);
  }
  var nodes = {
    AssignmentExpression: function AssignmentExpression(node) {
      var state = crawl(node.right);
      if (state.hasCall && state.hasHelper || state.hasFunction) {
        return state.hasFunction ? 1 | 2 : 2;
      }
    },
    SwitchCase: function SwitchCase(node, parent) {
      return (!!node.consequent.length || parent.cases[0] === node ? 1 : 0) | (!node.consequent.length && parent.cases[parent.cases.length - 1] === node ? 2 : 0);
    },
    LogicalExpression: function LogicalExpression(node) {
      if (isFunction$4(node.left) || isFunction$4(node.right)) {
        return 2;
      }
    },
    Literal: function Literal(node) {
      if (isStringLiteral$2(node) && node.value === "use strict") {
        return 2;
      }
    },
    CallExpression: function CallExpression(node) {
      if (isFunction$4(node.callee) || isHelper(node)) {
        return 1 | 2;
      }
    },
    OptionalCallExpression: function OptionalCallExpression(node) {
      if (isFunction$4(node.callee)) {
        return 1 | 2;
      }
    },
    VariableDeclaration: function VariableDeclaration(node) {
      for (var i = 0; i < node.declarations.length; i++) {
        var declar = node.declarations[i];
        var enabled = isHelper(declar.id) && !isType$1(declar.init);
        if (!enabled && declar.init) {
          var state = crawl(declar.init);
          enabled = isHelper(declar.init) && state.hasCall || state.hasFunction;
        }
        if (enabled) {
          return 1 | 2;
        }
      }
    },
    IfStatement: function IfStatement(node) {
      if (isBlockStatement$2(node.consequent)) {
        return 1 | 2;
      }
    }
  };
  nodes.ObjectProperty = nodes.ObjectTypeProperty = nodes.ObjectMethod = function (node, parent) {
    if (parent.properties[0] === node) {
      return 1;
    }
  };
  nodes.ObjectTypeCallProperty = function (node, parent) {
    var _parent$properties;
    if (parent.callProperties[0] === node && !((_parent$properties = parent.properties) != null && _parent$properties.length)) {
      return 1;
    }
  };
  nodes.ObjectTypeIndexer = function (node, parent) {
    var _parent$properties2, _parent$callPropertie;
    if (parent.indexers[0] === node && !((_parent$properties2 = parent.properties) != null && _parent$properties2.length) && !((_parent$callPropertie = parent.callProperties) != null && _parent$callPropertie.length)) {
      return 1;
    }
  };
  nodes.ObjectTypeInternalSlot = function (node, parent) {
    var _parent$properties3, _parent$callPropertie2, _parent$indexers;
    if (parent.internalSlots[0] === node && !((_parent$properties3 = parent.properties) != null && _parent$properties3.length) && !((_parent$callPropertie2 = parent.callProperties) != null && _parent$callPropertie2.length) && !((_parent$indexers = parent.indexers) != null && _parent$indexers.length)) {
      return 1;
    }
  };
  [["Function", true], ["Class", true], ["Loop", true], ["LabeledStatement", true], ["SwitchStatement", true], ["TryStatement", true]].forEach(function (_ref) {
    var _ref2 = _slicedToArray(_ref, 2),
      type = _ref2[0],
      amounts = _ref2[1];
    [type].concat(FLIPPED_ALIAS_KEYS$1[type] || []).forEach(function (type) {
      var ret = amounts ? 1 | 2 : 0;
      nodes[type] = function () {
        return ret;
      };
    });
  });

  var isArrayTypeAnnotation$1 = isArrayTypeAnnotation$2,
    isBinaryExpression = isBinaryExpression$1,
    isCallExpression$4 = isCallExpression$8,
    isForOfStatement = isForOfStatement$2,
    isIndexedAccessType = isIndexedAccessType$1,
    isMemberExpression$3 = isMemberExpression$7,
    isObjectPattern = isObjectPattern$1,
    isOptionalMemberExpression$1 = isOptionalMemberExpression$3,
    isYieldExpression = isYieldExpression$1,
    isStatement$5 = isStatement$9;
  var PRECEDENCE = new Map([["||", 0], ["??", 0], ["|>", 0], ["&&", 1], ["|", 2], ["^", 3], ["&", 4], ["==", 5], ["===", 5], ["!=", 5], ["!==", 5], ["<", 6], [">", 6], ["<=", 6], [">=", 6], ["in", 6], ["instanceof", 6], [">>", 7], ["<<", 7], [">>>", 7], ["+", 8], ["-", 8], ["*", 9], ["/", 9], ["%", 9], ["**", 10]]);
  function getBinaryPrecedence(node, nodeType) {
    if (nodeType === "BinaryExpression" || nodeType === "LogicalExpression") {
      return PRECEDENCE.get(node.operator);
    }
    if (nodeType === "TSAsExpression" || nodeType === "TSSatisfiesExpression") {
      return PRECEDENCE.get("in");
    }
  }
  function isTSTypeExpression(nodeType) {
    return nodeType === "TSAsExpression" || nodeType === "TSSatisfiesExpression" || nodeType === "TSTypeAssertion";
  }
  var isClassExtendsClause = function isClassExtendsClause(node, parent) {
    var parentType = parent.type;
    return (parentType === "ClassDeclaration" || parentType === "ClassExpression") && parent.superClass === node;
  };
  var hasPostfixPart = function hasPostfixPart(node, parent) {
    var parentType = parent.type;
    return (parentType === "MemberExpression" || parentType === "OptionalMemberExpression") && parent.object === node || (parentType === "CallExpression" || parentType === "OptionalCallExpression" || parentType === "NewExpression") && parent.callee === node || parentType === "TaggedTemplateExpression" && parent.tag === node || parentType === "TSNonNullExpression";
  };
  function NullableTypeAnnotation$1(node, parent) {
    return isArrayTypeAnnotation$1(parent);
  }
  function FunctionTypeAnnotation$1(node, parent, tokenContext) {
    var parentType = parent.type;
    return (parentType === "UnionTypeAnnotation" || parentType === "IntersectionTypeAnnotation" || parentType === "ArrayTypeAnnotation" || Boolean(tokenContext & TokenContext.arrowFlowReturnType)
    );
  }
  function UpdateExpression$2(node, parent) {
    return hasPostfixPart(node, parent) || isClassExtendsClause(node, parent);
  }
  function needsParenBeforeExpressionBrace(tokenContext) {
    return Boolean(tokenContext & (TokenContext.expressionStatement | TokenContext.arrowBody));
  }
  function ObjectExpression$2(node, parent, tokenContext) {
    return needsParenBeforeExpressionBrace(tokenContext);
  }
  function DoExpression$1(node, parent, tokenContext) {
    return !node.async && Boolean(tokenContext & TokenContext.expressionStatement);
  }
  function Binary(node, parent) {
    var parentType = parent.type;
    if (node.type === "BinaryExpression" && node.operator === "**" && parentType === "BinaryExpression" && parent.operator === "**") {
      return parent.left === node;
    }
    if (isClassExtendsClause(node, parent)) {
      return true;
    }
    if (hasPostfixPart(node, parent) || parentType === "UnaryExpression" || parentType === "SpreadElement" || parentType === "AwaitExpression") {
      return true;
    }
    var parentPos = getBinaryPrecedence(parent, parentType);
    if (parentPos != null) {
      var nodePos = getBinaryPrecedence(node, node.type);
      if (parentPos === nodePos && parentType === "BinaryExpression" && parent.right === node || parentPos > nodePos) {
        return true;
      }
    }
    return undefined;
  }
  function UnionTypeAnnotation$1(node, parent) {
    var parentType = parent.type;
    return parentType === "ArrayTypeAnnotation" || parentType === "NullableTypeAnnotation" || parentType === "IntersectionTypeAnnotation" || parentType === "UnionTypeAnnotation";
  }
  function OptionalIndexedAccessType$1(node, parent) {
    return isIndexedAccessType(parent) && parent.objectType === node;
  }
  function TSAsExpression$1(node, parent) {
    if ((parent.type === "AssignmentExpression" || parent.type === "AssignmentPattern") && parent.left === node) {
      return true;
    }
    if (parent.type === "BinaryExpression" && (parent.operator === "|" || parent.operator === "&") && node === parent.left) {
      return true;
    }
    return Binary(node, parent);
  }
  function TSConditionalType$1(node, parent) {
    var parentType = parent.type;
    if (parentType === "TSArrayType" || parentType === "TSIndexedAccessType" && parent.objectType === node || parentType === "TSOptionalType" || parentType === "TSTypeOperator" || parentType === "TSTypeParameter") {
      return true;
    }
    if ((parentType === "TSIntersectionType" || parentType === "TSUnionType") && parent.types[0] === node) {
      return true;
    }
    if (parentType === "TSConditionalType" && (parent.checkType === node || parent.extendsType === node)) {
      return true;
    }
    return false;
  }
  function TSUnionType$1(node, parent) {
    var parentType = parent.type;
    return parentType === "TSIntersectionType" || parentType === "TSTypeOperator" || parentType === "TSArrayType" || parentType === "TSIndexedAccessType" && parent.objectType === node || parentType === "TSOptionalType";
  }
  function TSIntersectionType$1(node, parent) {
    var parentType = parent.type;
    return parentType === "TSTypeOperator" || parentType === "TSArrayType" || parentType === "TSIndexedAccessType" && parent.objectType === node || parentType === "TSOptionalType";
  }
  function TSInferType$1(node, parent) {
    var parentType = parent.type;
    if (parentType === "TSArrayType" || parentType === "TSIndexedAccessType" && parent.objectType === node || parentType === "TSOptionalType") {
      return true;
    }
    if (node.typeParameter.constraint) {
      if ((parentType === "TSIntersectionType" || parentType === "TSUnionType") && parent.types[0] === node) {
        return true;
      }
    }
    return false;
  }
  function TSTypeOperator$1(node, parent) {
    var parentType = parent.type;
    return parentType === "TSArrayType" || parentType === "TSIndexedAccessType" && parent.objectType === node || parentType === "TSOptionalType";
  }
  function TSInstantiationExpression$1(node, parent) {
    var parentType = parent.type;
    return (parentType === "CallExpression" || parentType === "OptionalCallExpression" || parentType === "NewExpression" || parentType === "TSInstantiationExpression") && !!parent.typeParameters;
  }
  function TSFunctionType$1(node, parent) {
    var parentType = parent.type;
    return parentType === "TSIntersectionType" || parentType === "TSUnionType" || parentType === "TSTypeOperator" || parentType === "TSOptionalType" || parentType === "TSArrayType" || parentType === "TSIndexedAccessType" && parent.objectType === node || parentType === "TSConditionalType" && (parent.checkType === node || parent.extendsType === node);
  }
  function BinaryExpression$1(node, parent, tokenContext) {
    return node.operator === "in" && Boolean(tokenContext & TokenContext.forInOrInitHeadAccumulate);
  }
  function SequenceExpression$2(node, parent) {
    var parentType = parent.type;
    if (parentType === "SequenceExpression" || parentType === "ParenthesizedExpression" || parentType === "MemberExpression" && parent.property === node || parentType === "OptionalMemberExpression" && parent.property === node || parentType === "TemplateLiteral") {
      return false;
    }
    if (parentType === "ClassDeclaration") {
      return true;
    }
    if (parentType === "ForOfStatement") {
      return parent.right === node;
    }
    if (parentType === "ExportDefaultDeclaration") {
      return true;
    }
    return !isStatement$5(parent);
  }
  function YieldExpression$1(node, parent) {
    var parentType = parent.type;
    return parentType === "BinaryExpression" || parentType === "LogicalExpression" || parentType === "UnaryExpression" || parentType === "SpreadElement" || hasPostfixPart(node, parent) || parentType === "AwaitExpression" && isYieldExpression(node) || parentType === "ConditionalExpression" && node === parent.test || isClassExtendsClause(node, parent) || isTSTypeExpression(parentType);
  }
  function ClassExpression(node, parent, tokenContext) {
    return Boolean(tokenContext & (TokenContext.expressionStatement | TokenContext.exportDefault));
  }
  function UnaryLike(node, parent) {
    return hasPostfixPart(node, parent) || isBinaryExpression(parent) && parent.operator === "**" && parent.left === node || isClassExtendsClause(node, parent);
  }
  function FunctionExpression$1(node, parent, tokenContext) {
    return Boolean(tokenContext & (TokenContext.expressionStatement | TokenContext.exportDefault));
  }
  function ConditionalExpression$2(node, parent) {
    var parentType = parent.type;
    if (parentType === "UnaryExpression" || parentType === "SpreadElement" || parentType === "BinaryExpression" || parentType === "LogicalExpression" || parentType === "ConditionalExpression" && parent.test === node || parentType === "AwaitExpression" || isTSTypeExpression(parentType)) {
      return true;
    }
    return UnaryLike(node, parent);
  }
  function OptionalMemberExpression$1(node, parent) {
    return isCallExpression$4(parent) && parent.callee === node || isMemberExpression$3(parent) && parent.object === node;
  }
  function AssignmentExpression$2(node, parent, tokenContext) {
    if (needsParenBeforeExpressionBrace(tokenContext) && isObjectPattern(node.left)) {
      return true;
    } else {
      return ConditionalExpression$2(node, parent);
    }
  }
  function LogicalExpression$1(node, parent) {
    var parentType = parent.type;
    if (isTSTypeExpression(parentType)) return true;
    if (parentType !== "LogicalExpression") return false;
    switch (node.operator) {
      case "||":
        return parent.operator === "??" || parent.operator === "&&";
      case "&&":
        return parent.operator === "??";
      case "??":
        return parent.operator !== "??";
    }
  }
  function Identifier$1(node, parent, tokenContext, getRawIdentifier) {
    var _node$extra;
    var parentType = parent.type;
    if ((_node$extra = node.extra) != null && _node$extra.parenthesized && parentType === "AssignmentExpression" && parent.left === node) {
      var rightType = parent.right.type;
      if ((rightType === "FunctionExpression" || rightType === "ClassExpression") && parent.right.id == null) {
        return true;
      }
    }
    if (getRawIdentifier && getRawIdentifier(node) !== node.name) {
      return false;
    }
    if (node.name === "let") {
      var isFollowedByBracket = isMemberExpression$3(parent, {
        object: node,
        computed: true
      }) || isOptionalMemberExpression$1(parent, {
        object: node,
        computed: true,
        optional: false
      });
      if (isFollowedByBracket && tokenContext & (TokenContext.expressionStatement | TokenContext.forInitHead | TokenContext.forInHead)) {
        return true;
      }
      return Boolean(tokenContext & TokenContext.forOfHead);
    }
    return node.name === "async" && isForOfStatement(parent, {
      left: node,
      "await": false
    });
  }

  var parens = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ArrowFunctionExpression: ConditionalExpression$2,
    AssignmentExpression: AssignmentExpression$2,
    AwaitExpression: YieldExpression$1,
    Binary: Binary,
    BinaryExpression: BinaryExpression$1,
    ClassExpression: ClassExpression,
    ConditionalExpression: ConditionalExpression$2,
    DoExpression: DoExpression$1,
    FunctionExpression: FunctionExpression$1,
    FunctionTypeAnnotation: FunctionTypeAnnotation$1,
    Identifier: Identifier$1,
    IntersectionTypeAnnotation: UnionTypeAnnotation$1,
    LogicalExpression: LogicalExpression$1,
    NullableTypeAnnotation: NullableTypeAnnotation$1,
    ObjectExpression: ObjectExpression$2,
    OptionalCallExpression: OptionalMemberExpression$1,
    OptionalIndexedAccessType: OptionalIndexedAccessType$1,
    OptionalMemberExpression: OptionalMemberExpression$1,
    SequenceExpression: SequenceExpression$2,
    TSAsExpression: TSAsExpression$1,
    TSConditionalType: TSConditionalType$1,
    TSConstructorType: TSFunctionType$1,
    TSFunctionType: TSFunctionType$1,
    TSInferType: TSInferType$1,
    TSInstantiationExpression: TSInstantiationExpression$1,
    TSIntersectionType: TSIntersectionType$1,
    TSSatisfiesExpression: TSAsExpression$1,
    TSTypeAssertion: UnaryLike,
    TSTypeOperator: TSTypeOperator$1,
    TSUnionType: TSUnionType$1,
    UnaryLike: UnaryLike,
    UnionTypeAnnotation: UnionTypeAnnotation$1,
    UpdateExpression: UpdateExpression$2,
    YieldExpression: YieldExpression$1
  });

  var FLIPPED_ALIAS_KEYS = FLIPPED_ALIAS_KEYS$3,
    VISITOR_KEYS$6 = VISITOR_KEYS$7,
    isCallExpression$3 = isCallExpression$8,
    isDecorator = isDecorator$1,
    isMemberExpression$2 = isMemberExpression$7,
    isNewExpression$1 = isNewExpression$3,
    isParenthesizedExpression$1 = isParenthesizedExpression$2;
  var TokenContext = {
    normal: 0,
    expressionStatement: 1,
    arrowBody: 2,
    exportDefault: 4,
    arrowFlowReturnType: 8,
    forInitHead: 16,
    forInHead: 32,
    forOfHead: 64,
    forInOrInitHeadAccumulate: 128,
    forInOrInitHeadAccumulatePassThroughMask: 128
  };
  function expandAliases(obj) {
    var map = new Map();
    function add(type, func) {
      var fn = map.get(type);
      map.set(type, fn ? function (node, parent, stack, getRawIdentifier) {
        var _fn;
        return (_fn = fn(node, parent, stack, getRawIdentifier)) != null ? _fn : func(node, parent, stack, getRawIdentifier);
      } : func);
    }
    for (var _i = 0, _Object$keys = Object.keys(obj); _i < _Object$keys.length; _i++) {
      var type = _Object$keys[_i];
      var aliases = FLIPPED_ALIAS_KEYS[type];
      if (aliases) {
        for (var _iterator = _createForOfIteratorHelperLoose(aliases), _step; !(_step = _iterator()).done;) {
          var alias = _step.value;
          add(alias, obj[type]);
        }
      } else {
        add(type, obj[type]);
      }
    }
    return map;
  }
  var expandedParens = expandAliases(parens);
  expandAliases(nodes);
  function isOrHasCallExpression(node) {
    if (isCallExpression$3(node)) {
      return true;
    }
    return isMemberExpression$2(node) && isOrHasCallExpression(node.object);
  }
  function needsParens$1(node, parent, tokenContext, getRawIdentifier) {
    var _expandedParens$get;
    if (!parent) return false;
    if (isNewExpression$1(parent) && parent.callee === node) {
      if (isOrHasCallExpression(node)) return true;
    }
    if (isDecorator(parent)) {
      return !isDecoratorMemberExpression(node) && !(isCallExpression$3(node) && isDecoratorMemberExpression(node.callee)) && !isParenthesizedExpression$1(node);
    }
    return (_expandedParens$get = expandedParens.get(node.type)) == null ? void 0 : _expandedParens$get(node, parent, tokenContext, getRawIdentifier);
  }
  function isDecoratorMemberExpression(node) {
    switch (node.type) {
      case "Identifier":
        return true;
      case "MemberExpression":
        return !node.computed && node.property.type === "Identifier" && isDecoratorMemberExpression(node.object);
      default:
        return false;
    }
  }
  function isLastChild(parent, child) {
    var visitorKeys = VISITOR_KEYS$6[parent.type];
    for (var i = visitorKeys.length - 1; i >= 0; i--) {
      var val = parent[visitorKeys[i]];
      if (val === child) {
        return true;
      } else if (Array.isArray(val)) {
        var j = val.length - 1;
        while (j >= 0 && val[j] === null) j--;
        return j >= 0 && val[j] === child;
      } else if (val) {
        return false;
      }
    }
    return false;
  }

  var _marked$a = _regenerator().m(childrenIterator);
  var traverseFast$2 = traverseFast$3,
    VISITOR_KEYS$5 = VISITOR_KEYS$7;
  var TokenMap = function () {
    function TokenMap(ast, tokens, source) {
      var _this = this;
      this._tokens = void 0;
      this._source = void 0;
      this._nodesToTokenIndexes = new Map();
      this._nodesOccurrencesCountCache = new Map();
      this._tokensCache = new Map();
      this._tokens = tokens;
      this._source = source;
      traverseFast$2(ast, function (node) {
        var indexes = _this._getTokensIndexesOfNode(node);
        if (indexes.length > 0) _this._nodesToTokenIndexes.set(node, indexes);
      });
      this._tokensCache = null;
    }
    var _proto = TokenMap.prototype;
    _proto.has = function has(node) {
      return this._nodesToTokenIndexes.has(node);
    };
    _proto.getIndexes = function getIndexes(node) {
      return this._nodesToTokenIndexes.get(node);
    };
    _proto.find = function find(node, condition) {
      var indexes = this._nodesToTokenIndexes.get(node);
      if (indexes) {
        for (var k = 0; k < indexes.length; k++) {
          var index = indexes[k];
          var tok = this._tokens[index];
          if (condition(tok, index)) return tok;
        }
      }
      return null;
    };
    _proto.findLastIndex = function findLastIndex(node, condition) {
      var indexes = this._nodesToTokenIndexes.get(node);
      if (indexes) {
        for (var k = indexes.length - 1; k >= 0; k--) {
          var index = indexes[k];
          var tok = this._tokens[index];
          if (condition(tok, index)) return index;
        }
      }
      return -1;
    };
    _proto.findMatching = function findMatching(node, test, occurrenceCount) {
      if (occurrenceCount === void 0) {
        occurrenceCount = 0;
      }
      var indexes = this._nodesToTokenIndexes.get(node);
      if (indexes) {
        var i = 0;
        var count = occurrenceCount;
        if (count > 1) {
          var cache = this._nodesOccurrencesCountCache.get(node);
          if (cache && cache.test === test && cache.count < count) {
            i = cache.i + 1;
            occurrenceCount -= cache.count + 1;
          }
        }
        for (; i < indexes.length; i++) {
          var tok = this._tokens[indexes[i]];
          if (this.matchesOriginal(tok, test)) {
            if (occurrenceCount === 0) {
              if (count > 0) {
                this._nodesOccurrencesCountCache.set(node, {
                  test: test,
                  count: count,
                  i: i
                });
              }
              return tok;
            }
            occurrenceCount--;
          }
        }
      }
      return null;
    };
    _proto.matchesOriginal = function matchesOriginal(token, test) {
      if (token.end - token.start !== test.length) return false;
      if (token.value != null) return token.value === test;
      return this._source.startsWith(test, token.start);
    };
    _proto.startMatches = function startMatches(node, test) {
      var indexes = this._nodesToTokenIndexes.get(node);
      if (!indexes) return false;
      var tok = this._tokens[indexes[0]];
      if (tok.start !== node.start) return false;
      return this.matchesOriginal(tok, test);
    };
    _proto.endMatches = function endMatches(node, test) {
      var indexes = this._nodesToTokenIndexes.get(node);
      if (!indexes) return false;
      var tok = this._tokens[indexes[indexes.length - 1]];
      if (tok.end !== node.end) return false;
      return this.matchesOriginal(tok, test);
    };
    _proto._getTokensIndexesOfNode = function _getTokensIndexesOfNode(node) {
      if (node.start == null || node.end == null) return [];
      var _this$_findTokensOfNo = this._findTokensOfNode(node, 0, this._tokens.length - 1),
        first = _this$_findTokensOfNo.first,
        last = _this$_findTokensOfNo.last;
      var low = first;
      var children = childrenIterator(node);
      if ((node.type === "ExportNamedDeclaration" || node.type === "ExportDefaultDeclaration") && node.declaration && node.declaration.type === "ClassDeclaration") {
        children.next();
      }
      var indexes = [];
      for (var _iterator = _createForOfIteratorHelperLoose(children), _step; !(_step = _iterator()).done;) {
        var child = _step.value;
        if (child == null) continue;
        if (child.start == null || child.end == null) continue;
        var childTok = this._findTokensOfNode(child, low, last);
        var high = childTok.first;
        for (var _k = low; _k < high; _k++) indexes.push(_k);
        low = childTok.last + 1;
      }
      for (var k = low; k <= last; k++) indexes.push(k);
      return indexes;
    };
    _proto._findTokensOfNode = function _findTokensOfNode(node, low, high) {
      var cached = this._tokensCache.get(node);
      if (cached) return cached;
      var first = this._findFirstTokenOfNode(node.start, low, high);
      var last = this._findLastTokenOfNode(node.end, first, high);
      this._tokensCache.set(node, {
        first: first,
        last: last
      });
      return {
        first: first,
        last: last
      };
    };
    _proto._findFirstTokenOfNode = function _findFirstTokenOfNode(start, low, high) {
      while (low <= high) {
        var mid = high + low >> 1;
        if (start < this._tokens[mid].start) {
          high = mid - 1;
        } else if (start > this._tokens[mid].start) {
          low = mid + 1;
        } else {
          return mid;
        }
      }
      return low;
    };
    _proto._findLastTokenOfNode = function _findLastTokenOfNode(end, low, high) {
      while (low <= high) {
        var mid = high + low >> 1;
        if (end < this._tokens[mid].end) {
          high = mid - 1;
        } else if (end > this._tokens[mid].end) {
          low = mid + 1;
        } else {
          return mid;
        }
      }
      return high;
    };
    return _createClass(TokenMap);
  }();
  function childrenIterator(node) {
    var i, keys, _iterator2, _step2, key, child;
    return _regenerator().w(function (_context) {
      while (1) switch (_context.n) {
        case 0:
          if (!(node.type === "TemplateLiteral")) {
            _context.n = 6;
            break;
          }
          _context.n = 1;
          return node.quasis[0];
        case 1:
          i = 1;
        case 2:
          if (!(i < node.quasis.length)) {
            _context.n = 5;
            break;
          }
          _context.n = 3;
          return node.expressions[i - 1];
        case 3:
          _context.n = 4;
          return node.quasis[i];
        case 4:
          i++;
          _context.n = 2;
          break;
        case 5:
          return _context.a(2);
        case 6:
          keys = VISITOR_KEYS$5[node.type];
          _iterator2 = _createForOfIteratorHelperLoose(keys);
        case 7:
          if ((_step2 = _iterator2()).done) {
            _context.n = 12;
            break;
          }
          key = _step2.value;
          child = node[key];
          if (child) {
            _context.n = 8;
            break;
          }
          return _context.a(3, 11);
        case 8:
          if (!Array.isArray(child)) {
            _context.n = 10;
            break;
          }
          return _context.d(_regeneratorValues(child), 9);
        case 9:
          _context.n = 11;
          break;
        case 10:
          _context.n = 11;
          return child;
        case 11:
          _context.n = 7;
          break;
        case 12:
          return _context.a(2);
      }
    }, _marked$a);
  }

  function TaggedTemplateExpression$1(node) {
    this.print(node.tag);
    {
      this.print(node.typeParameters);
    }
    this.print(node.quasi);
  }
  function TemplateElement() {
    throw new Error("TemplateElement printing is handled in TemplateLiteral");
  }
  function _printTemplate(node, substitutions) {
    var quasis = node.quasis;
    var partRaw = "`";
    for (var i = 0; i < quasis.length - 1; i++) {
      partRaw += quasis[i].value.raw;
      this.token(partRaw + "${", true);
      this.print(substitutions[i]);
      partRaw = "}";
      if (this.tokenMap) {
        var token = this.tokenMap.findMatching(node, "}", i);
        if (token) this._catchUpTo(token.loc.start);
      }
    }
    partRaw += quasis[quasis.length - 1].value.raw;
    this.token(partRaw + "`", true);
  }
  function TemplateLiteral$1(node) {
    this._printTemplate(node, node.expressions);
  }

  var isCallExpression$2 = isCallExpression$8,
    isLiteral$1 = isLiteral$4,
    isMemberExpression$1 = isMemberExpression$7,
    isNewExpression = isNewExpression$3,
    isPattern$1 = isPattern$2;
  function UnaryExpression$1(node) {
    var operator = node.operator;
    if (operator === "void" || operator === "delete" || operator === "typeof" || operator === "throw") {
      this.word(operator);
      this.space();
    } else {
      this.token(operator);
    }
    this.print(node.argument);
  }
  function DoExpression(node) {
    if (node.async) {
      this.word("async", true);
      this.space();
    }
    this.word("do");
    this.space();
    this.print(node.body);
  }
  function ParenthesizedExpression$1(node) {
    this.tokenChar(40);
    var exit = this.enterDelimited();
    this.print(node.expression);
    exit();
    this.rightParens(node);
  }
  function UpdateExpression$1(node) {
    if (node.prefix) {
      this.token(node.operator);
      this.print(node.argument);
    } else {
      this.print(node.argument, true);
      this.token(node.operator);
    }
  }
  function ConditionalExpression$1(node) {
    this.print(node.test);
    this.space();
    this.tokenChar(63);
    this.space();
    this.print(node.consequent);
    this.space();
    this.tokenChar(58);
    this.space();
    this.print(node.alternate);
  }
  function NewExpression$1(node, parent) {
    this.word("new");
    this.space();
    this.print(node.callee);
    if (this.format.minified && node.arguments.length === 0 && !node.optional && !isCallExpression$2(parent, {
      callee: node
    }) && !isMemberExpression$1(parent) && !isNewExpression(parent)) {
      return;
    }
    this.print(node.typeArguments);
    {
      this.print(node.typeParameters);
    }
    if (node.optional) {
      this.token("?.");
    }
    if (node.arguments.length === 0 && this.tokenMap && !this.tokenMap.endMatches(node, ")")) {
      return;
    }
    this.tokenChar(40);
    var exit = this.enterDelimited();
    this.printList(node.arguments, this.shouldPrintTrailingComma(")"));
    exit();
    this.rightParens(node);
  }
  function SequenceExpression$1(node) {
    this.printList(node.expressions);
  }
  function ThisExpression() {
    this.word("this");
  }
  function Super() {
    this.word("super");
  }
  function _shouldPrintDecoratorsBeforeExport(node) {
    if (typeof this.format.decoratorsBeforeExport === "boolean") {
      return this.format.decoratorsBeforeExport;
    }
    return typeof node.start === "number" && node.start === node.declaration.start;
  }
  function Decorator(node) {
    this.tokenChar(64);
    this.print(node.expression);
    this.newline();
  }
  function OptionalMemberExpression(node) {
    var computed = node.computed;
    var optional = node.optional,
      property = node.property;
    this.print(node.object);
    if (!computed && isMemberExpression$1(property)) {
      throw new TypeError("Got a MemberExpression for MemberExpression property");
    }
    if (isLiteral$1(property) && typeof property.value === "number") {
      computed = true;
    }
    if (optional) {
      this.token("?.");
    }
    if (computed) {
      this.tokenChar(91);
      this.print(property);
      this.tokenChar(93);
    } else {
      if (!optional) {
        this.tokenChar(46);
      }
      this.print(property);
    }
  }
  function OptionalCallExpression(node) {
    this.print(node.callee);
    {
      this.print(node.typeParameters);
    }
    if (node.optional) {
      this.token("?.");
    }
    this.print(node.typeArguments);
    this.tokenChar(40);
    var exit = this.enterDelimited();
    this.printList(node.arguments);
    exit();
    this.rightParens(node);
  }
  function CallExpression$1(node) {
    this.print(node.callee);
    this.print(node.typeArguments);
    {
      this.print(node.typeParameters);
    }
    this.tokenChar(40);
    var exit = this.enterDelimited();
    this.printList(node.arguments, this.shouldPrintTrailingComma(")"));
    exit();
    this.rightParens(node);
  }
  function Import() {
    this.word("import");
  }
  function AwaitExpression(node) {
    this.word("await");
    this.space();
    this.print(node.argument);
  }
  function YieldExpression(node) {
    if (node.delegate) {
      this.word("yield", true);
      this.tokenChar(42);
      if (node.argument) {
        this.space();
        this.print(node.argument);
      }
    } else if (node.argument) {
      this.word("yield", true);
      this.space();
      this.print(node.argument);
    } else {
      this.word("yield");
    }
  }
  function EmptyStatement() {
    this.semicolon(true);
  }
  function ExpressionStatement(node) {
    this.tokenContext |= TokenContext.expressionStatement;
    this.print(node.expression);
    this.semicolon();
  }
  function AssignmentPattern(node) {
    this.print(node.left);
    if (node.left.type === "Identifier" || isPattern$1(node.left)) {
      if (node.left.optional) this.tokenChar(63);
      this.print(node.left.typeAnnotation);
    }
    this.space();
    this.tokenChar(61);
    this.space();
    this.print(node.right);
  }
  function AssignmentExpression$1(node) {
    this.print(node.left);
    this.space();
    if (node.operator === "in" || node.operator === "instanceof") {
      this.word(node.operator);
    } else {
      this.token(node.operator);
      this._endsWithDiv = node.operator === "/";
    }
    this.space();
    this.print(node.right);
  }
  function BindExpression(node) {
    this.print(node.object);
    this.token("::");
    this.print(node.callee);
  }
  function MemberExpression(node) {
    this.print(node.object);
    if (!node.computed && isMemberExpression$1(node.property)) {
      throw new TypeError("Got a MemberExpression for MemberExpression property");
    }
    var computed = node.computed;
    if (isLiteral$1(node.property) && typeof node.property.value === "number") {
      computed = true;
    }
    if (computed) {
      var exit = this.enterDelimited();
      this.tokenChar(91);
      this.print(node.property);
      this.tokenChar(93);
      exit();
    } else {
      this.tokenChar(46);
      this.print(node.property);
    }
  }
  function MetaProperty(node) {
    this.print(node.meta);
    this.tokenChar(46);
    this.print(node.property);
  }
  function PrivateName(node) {
    this.tokenChar(35);
    this.print(node.id);
  }
  function V8IntrinsicIdentifier(node) {
    this.tokenChar(37);
    this.word(node.name);
  }
  function ModuleExpression(node) {
    this.word("module", true);
    this.space();
    this.tokenChar(123);
    this.indent();
    var body = node.body;
    if (body.body.length || body.directives.length) {
      this.newline();
    }
    this.print(body);
    this.dedent();
    this.rightBrace(node);
  }

  var isFor = isFor$1,
    isForStatement = isForStatement$2,
    isIfStatement$1 = isIfStatement$2,
    isStatement$4 = isStatement$9;
  function WithStatement(node) {
    this.word("with");
    this.space();
    this.tokenChar(40);
    this.print(node.object);
    this.tokenChar(41);
    this.printBlock(node);
  }
  function IfStatement(node) {
    this.word("if");
    this.space();
    this.tokenChar(40);
    this.print(node.test);
    this.tokenChar(41);
    this.space();
    var needsBlock = node.alternate && isIfStatement$1(getLastStatement(node.consequent));
    if (needsBlock) {
      this.tokenChar(123);
      this.newline();
      this.indent();
    }
    this.printAndIndentOnComments(node.consequent);
    if (needsBlock) {
      this.dedent();
      this.newline();
      this.tokenChar(125);
    }
    if (node.alternate) {
      if (this.endsWith(125)) this.space();
      this.word("else");
      this.space();
      this.printAndIndentOnComments(node.alternate);
    }
  }
  function getLastStatement(statement) {
    var body = statement.body;
    if (isStatement$4(body) === false) {
      return statement;
    }
    return getLastStatement(body);
  }
  function ForStatement(node) {
    this.word("for");
    this.space();
    this.tokenChar(40);
    {
      var exit = this.enterForStatementInit();
      this.print(node.init);
      exit();
    }
    this.tokenChar(59);
    if (node.test) {
      this.space();
      this.print(node.test);
    }
    this.token(";", false, 1);
    if (node.update) {
      this.space();
      this.print(node.update);
    }
    this.tokenChar(41);
    this.printBlock(node);
  }
  function WhileStatement(node) {
    this.word("while");
    this.space();
    this.tokenChar(40);
    this.print(node.test);
    this.tokenChar(41);
    this.printBlock(node);
  }
  function ForXStatement(node) {
    this.word("for");
    this.space();
    var isForOf = node.type === "ForOfStatement";
    if (isForOf && node["await"]) {
      this.word("await");
      this.space();
    }
    this.noIndentInnerCommentsHere();
    this.tokenChar(40);
    {
      var exit = this.enterForXStatementInit(isForOf);
      this.print(node.left);
      exit == null || exit();
    }
    this.space();
    this.word(isForOf ? "of" : "in");
    this.space();
    this.print(node.right);
    this.tokenChar(41);
    this.printBlock(node);
  }
  var ForInStatement = ForXStatement;
  var ForOfStatement = ForXStatement;
  function DoWhileStatement(node) {
    this.word("do");
    this.space();
    this.print(node.body);
    this.space();
    this.word("while");
    this.space();
    this.tokenChar(40);
    this.print(node.test);
    this.tokenChar(41);
    this.semicolon();
  }
  function printStatementAfterKeyword(printer, node) {
    if (node) {
      printer.space();
      printer.printTerminatorless(node);
    }
    printer.semicolon();
  }
  function BreakStatement(node) {
    this.word("break");
    printStatementAfterKeyword(this, node.label);
  }
  function ContinueStatement(node) {
    this.word("continue");
    printStatementAfterKeyword(this, node.label);
  }
  function ReturnStatement(node) {
    this.word("return");
    printStatementAfterKeyword(this, node.argument);
  }
  function ThrowStatement(node) {
    this.word("throw");
    printStatementAfterKeyword(this, node.argument);
  }
  function LabeledStatement(node) {
    this.print(node.label);
    this.tokenChar(58);
    this.space();
    this.print(node.body);
  }
  function TryStatement(node) {
    this.word("try");
    this.space();
    this.print(node.block);
    this.space();
    if (node.handlers) {
      this.print(node.handlers[0]);
    } else {
      this.print(node.handler);
    }
    if (node.finalizer) {
      this.space();
      this.word("finally");
      this.space();
      this.print(node.finalizer);
    }
  }
  function CatchClause(node) {
    this.word("catch");
    this.space();
    if (node.param) {
      this.tokenChar(40);
      this.print(node.param);
      this.print(node.param.typeAnnotation);
      this.tokenChar(41);
      this.space();
    }
    this.print(node.body);
  }
  function SwitchStatement(node) {
    this.word("switch");
    this.space();
    this.tokenChar(40);
    this.print(node.discriminant);
    this.tokenChar(41);
    this.space();
    this.tokenChar(123);
    this.printSequence(node.cases, true, undefined, function addNewlines(leading, cas) {
      if (!leading && node.cases[node.cases.length - 1] === cas) return -1;
    });
    this.rightBrace(node);
  }
  function SwitchCase(node) {
    if (node.test) {
      this.word("case");
      this.space();
      this.print(node.test);
      this.tokenChar(58);
    } else {
      this.word("default");
      this.tokenChar(58);
    }
    if (node.consequent.length) {
      this.newline();
      this.printSequence(node.consequent, true);
    }
  }
  function DebuggerStatement() {
    this.word("debugger");
    this.semicolon();
  }
  function VariableDeclaration(node, parent) {
    if (node.declare) {
      this.word("declare");
      this.space();
    }
    var kind = node.kind;
    if (kind === "await using") {
      this.word("await");
      this.space();
      this.word("using", true);
    } else {
      this.word(kind, kind === "using");
    }
    this.space();
    var hasInits = false;
    if (!isFor(parent)) {
      for (var _iterator = _createForOfIteratorHelperLoose(node.declarations), _step; !(_step = _iterator()).done;) {
        var declar = _step.value;
        if (declar.init) {
          hasInits = true;
        }
      }
    }
    this.printList(node.declarations, undefined, undefined, node.declarations.length > 1, hasInits ? function (occurrenceCount) {
      this.token(",", false, occurrenceCount);
      this.newline();
    } : undefined);
    if (isFor(parent)) {
      if (isForStatement(parent)) {
        if (parent.init === node) return;
      } else {
        if (parent.left === node) return;
      }
    }
    this.semicolon();
  }
  function VariableDeclarator$1(node) {
    this.print(node.id);
    if (node.definite) this.tokenChar(33);
    this.print(node.id.typeAnnotation);
    if (node.init) {
      this.space();
      this.tokenChar(61);
      this.space();
      this.print(node.init);
    }
  }

  var isExportDefaultDeclaration = isExportDefaultDeclaration$2,
    isExportNamedDeclaration$1 = isExportNamedDeclaration$3;
  function ClassDeclaration(node, parent) {
    var inExport = isExportDefaultDeclaration(parent) || isExportNamedDeclaration$1(parent);
    if (!inExport || !this._shouldPrintDecoratorsBeforeExport(parent)) {
      this.printJoin(node.decorators);
    }
    if (node.declare) {
      this.word("declare");
      this.space();
    }
    if (node["abstract"]) {
      this.word("abstract");
      this.space();
    }
    this.word("class");
    if (node.id) {
      this.space();
      this.print(node.id);
    }
    this.print(node.typeParameters);
    if (node.superClass) {
      this.space();
      this.word("extends");
      this.space();
      this.print(node.superClass);
      this.print(node.superTypeParameters);
    }
    if (node["implements"]) {
      this.space();
      this.word("implements");
      this.space();
      this.printList(node["implements"]);
    }
    this.space();
    this.print(node.body);
  }
  function ClassBody(node) {
    this.tokenChar(123);
    if (node.body.length === 0) {
      this.tokenChar(125);
    } else {
      this.newline();
      var separator = classBodyEmptySemicolonsPrinter(this, node);
      separator == null || separator(-1);
      var exit = this.enterDelimited();
      this.printJoin(node.body, true, true, separator, true);
      exit();
      if (!this.endsWith(10)) this.newline();
      this.rightBrace(node);
    }
  }
  function classBodyEmptySemicolonsPrinter(printer, node) {
    if (!printer.tokenMap || node.start == null || node.end == null) {
      return null;
    }
    var indexes = printer.tokenMap.getIndexes(node);
    if (!indexes) return null;
    var k = 1;
    var occurrenceCount = 0;
    var nextLocIndex = 0;
    var advanceNextLocIndex = function advanceNextLocIndex() {
      while (nextLocIndex < node.body.length && node.body[nextLocIndex].start == null) {
        nextLocIndex++;
      }
    };
    advanceNextLocIndex();
    return function (i) {
      if (nextLocIndex <= i) {
        nextLocIndex = i + 1;
        advanceNextLocIndex();
      }
      var end = nextLocIndex === node.body.length ? node.end : node.body[nextLocIndex].start;
      var tok;
      while (k < indexes.length && printer.tokenMap.matchesOriginal(tok = printer._tokens[indexes[k]], ";") && tok.start < end) {
        printer.token(";", undefined, occurrenceCount++);
        k++;
      }
    };
  }
  function ClassProperty(node) {
    this.printJoin(node.decorators);
    if (!node["static"] && !this.format.preserveFormat) {
      var _node$key$loc;
      var endLine = (_node$key$loc = node.key.loc) == null || (_node$key$loc = _node$key$loc.end) == null ? void 0 : _node$key$loc.line;
      if (endLine) this.catchUp(endLine);
    }
    this.tsPrintClassMemberModifiers(node);
    if (node.computed) {
      this.tokenChar(91);
      this.print(node.key);
      this.tokenChar(93);
    } else {
      this._variance(node);
      this.print(node.key);
    }
    if (node.optional) {
      this.tokenChar(63);
    }
    if (node.definite) {
      this.tokenChar(33);
    }
    this.print(node.typeAnnotation);
    if (node.value) {
      this.space();
      this.tokenChar(61);
      this.space();
      this.print(node.value);
    }
    this.semicolon();
  }
  function ClassAccessorProperty(node) {
    var _node$key$loc2;
    this.printJoin(node.decorators);
    var endLine = (_node$key$loc2 = node.key.loc) == null || (_node$key$loc2 = _node$key$loc2.end) == null ? void 0 : _node$key$loc2.line;
    if (endLine) this.catchUp(endLine);
    this.tsPrintClassMemberModifiers(node);
    this.word("accessor", true);
    this.space();
    if (node.computed) {
      this.tokenChar(91);
      this.print(node.key);
      this.tokenChar(93);
    } else {
      this._variance(node);
      this.print(node.key);
    }
    if (node.optional) {
      this.tokenChar(63);
    }
    if (node.definite) {
      this.tokenChar(33);
    }
    this.print(node.typeAnnotation);
    if (node.value) {
      this.space();
      this.tokenChar(61);
      this.space();
      this.print(node.value);
    }
    this.semicolon();
  }
  function ClassPrivateProperty(node) {
    this.printJoin(node.decorators);
    this.tsPrintClassMemberModifiers(node);
    this.print(node.key);
    if (node.optional) {
      this.tokenChar(63);
    }
    if (node.definite) {
      this.tokenChar(33);
    }
    this.print(node.typeAnnotation);
    if (node.value) {
      this.space();
      this.tokenChar(61);
      this.space();
      this.print(node.value);
    }
    this.semicolon();
  }
  function ClassMethod(node) {
    this._classMethodHead(node);
    this.space();
    this.print(node.body);
  }
  function ClassPrivateMethod(node) {
    this._classMethodHead(node);
    this.space();
    this.print(node.body);
  }
  function _classMethodHead(node) {
    this.printJoin(node.decorators);
    if (!this.format.preserveFormat) {
      var _node$key$loc3;
      var endLine = (_node$key$loc3 = node.key.loc) == null || (_node$key$loc3 = _node$key$loc3.end) == null ? void 0 : _node$key$loc3.line;
      if (endLine) this.catchUp(endLine);
    }
    this.tsPrintClassMemberModifiers(node);
    this._methodHead(node);
  }
  function StaticBlock(node) {
    this.word("static");
    this.space();
    this.tokenChar(123);
    if (node.body.length === 0) {
      this.tokenChar(125);
    } else {
      this.newline();
      this.printSequence(node.body, true);
      this.rightBrace(node);
    }
  }

  var isIdentifier$9 = isIdentifier$e;
  function _params(node, idNode, parentNode) {
    this.print(node.typeParameters);
    var nameInfo = _getFuncIdName.call(this, idNode, parentNode);
    if (nameInfo) {
      this.sourceIdentifierName(nameInfo.name, nameInfo.pos);
    }
    this.tokenChar(40);
    this._parameters(node.params, ")");
    var noLineTerminator = node.type === "ArrowFunctionExpression";
    this.print(node.returnType, noLineTerminator);
    this._noLineTerminator = noLineTerminator;
  }
  function _parameters(parameters, endToken) {
    var exit = this.enterDelimited();
    var trailingComma = this.shouldPrintTrailingComma(endToken);
    var paramLength = parameters.length;
    for (var i = 0; i < paramLength; i++) {
      this._param(parameters[i]);
      if (trailingComma || i < paramLength - 1) {
        this.token(",", null, i);
        this.space();
      }
    }
    this.token(endToken);
    exit();
  }
  function _param(parameter) {
    this.printJoin(parameter.decorators);
    this.print(parameter);
    if (parameter.optional) {
      this.tokenChar(63);
    }
    this.print(parameter.typeAnnotation);
  }
  function _methodHead(node) {
    var kind = node.kind;
    var key = node.key;
    if (kind === "get" || kind === "set") {
      this.word(kind);
      this.space();
    }
    if (node.async) {
      this.word("async", true);
      this.space();
    }
    if (kind === "method" || kind === "init") {
      if (node.generator) {
        this.tokenChar(42);
      }
    }
    if (node.computed) {
      this.tokenChar(91);
      this.print(key);
      this.tokenChar(93);
    } else {
      this.print(key);
    }
    if (node.optional) {
      this.tokenChar(63);
    }
    this._params(node, node.computed && node.key.type !== "StringLiteral" ? undefined : node.key, undefined);
  }
  function _predicate(node, noLineTerminatorAfter) {
    if (node.predicate) {
      if (!node.returnType) {
        this.tokenChar(58);
      }
      this.space();
      this.print(node.predicate, noLineTerminatorAfter);
    }
  }
  function _functionHead(node, parent) {
    if (node.async) {
      this.word("async");
      if (!this.format.preserveFormat) {
        this._endsWithInnerRaw = false;
      }
      this.space();
    }
    this.word("function");
    if (node.generator) {
      if (!this.format.preserveFormat) {
        this._endsWithInnerRaw = false;
      }
      this.tokenChar(42);
    }
    this.space();
    if (node.id) {
      this.print(node.id);
    }
    this._params(node, node.id, parent);
    if (node.type !== "TSDeclareFunction") {
      this._predicate(node);
    }
  }
  function FunctionExpression(node, parent) {
    this._functionHead(node, parent);
    this.space();
    this.print(node.body);
  }
  function ArrowFunctionExpression(node, parent) {
    if (node.async) {
      this.word("async", true);
      this.space();
    }
    if (this._shouldPrintArrowParamsParens(node)) {
      this._params(node, undefined, parent);
    } else {
      this.print(node.params[0], true);
    }
    this._predicate(node, true);
    this.space();
    this.printInnerComments();
    this.token("=>");
    this.space();
    this.tokenContext |= TokenContext.arrowBody;
    this.print(node.body);
  }
  function _shouldPrintArrowParamsParens(node) {
    var _firstParam$leadingCo, _firstParam$trailingC;
    if (node.params.length !== 1) return true;
    if (node.typeParameters || node.returnType || node.predicate) {
      return true;
    }
    var firstParam = node.params[0];
    if (!isIdentifier$9(firstParam) || firstParam.typeAnnotation || firstParam.optional || (_firstParam$leadingCo = firstParam.leadingComments) != null && _firstParam$leadingCo.length || (_firstParam$trailingC = firstParam.trailingComments) != null && _firstParam$trailingC.length) {
      return true;
    }
    if (this.tokenMap) {
      if (node.loc == null) return true;
      if (this.tokenMap.findMatching(node, "(") !== null) return true;
      var arrowToken = this.tokenMap.findMatching(node, "=>");
      if ((arrowToken == null ? void 0 : arrowToken.loc) == null) return true;
      return arrowToken.loc.start.line !== node.loc.start.line;
    }
    if (this.format.retainLines) return true;
    return false;
  }
  function _getFuncIdName(idNode, parent) {
    var id = idNode;
    if (!id && parent) {
      var parentType = parent.type;
      if (parentType === "VariableDeclarator") {
        id = parent.id;
      } else if (parentType === "AssignmentExpression" || parentType === "AssignmentPattern") {
        id = parent.left;
      } else if (parentType === "ObjectProperty" || parentType === "ClassProperty") {
        if (!parent.computed || parent.key.type === "StringLiteral") {
          id = parent.key;
        }
      } else if (parentType === "ClassPrivateProperty" || parentType === "ClassAccessorProperty") {
        id = parent.key;
      }
    }
    if (!id) return;
    var nameInfo;
    if (id.type === "Identifier") {
      var _id$loc, _id$loc2;
      nameInfo = {
        pos: (_id$loc = id.loc) == null ? void 0 : _id$loc.start,
        name: ((_id$loc2 = id.loc) == null ? void 0 : _id$loc2.identifierName) || id.name
      };
    } else if (id.type === "PrivateName") {
      var _id$loc3;
      nameInfo = {
        pos: (_id$loc3 = id.loc) == null ? void 0 : _id$loc3.start,
        name: "#" + id.id.name
      };
    } else if (id.type === "StringLiteral") {
      var _id$loc4;
      nameInfo = {
        pos: (_id$loc4 = id.loc) == null ? void 0 : _id$loc4.start,
        name: id.value
      };
    }
    return nameInfo;
  }

  var isClassDeclaration = isClassDeclaration$2,
    isExportDefaultSpecifier = isExportDefaultSpecifier$1,
    isExportNamespaceSpecifier = isExportNamespaceSpecifier$1,
    isImportDefaultSpecifier = isImportDefaultSpecifier$1,
    isImportNamespaceSpecifier = isImportNamespaceSpecifier$1,
    isStatement$3 = isStatement$9;
  function ImportSpecifier(node) {
    if (node.importKind === "type" || node.importKind === "typeof") {
      this.word(node.importKind);
      this.space();
    }
    this.print(node.imported);
    if (node.local && node.local.name !== node.imported.name) {
      this.space();
      this.word("as");
      this.space();
      this.print(node.local);
    }
  }
  function ImportDefaultSpecifier(node) {
    this.print(node.local);
  }
  function ExportDefaultSpecifier(node) {
    this.print(node.exported);
  }
  function ExportSpecifier(node) {
    if (node.exportKind === "type") {
      this.word("type");
      this.space();
    }
    this.print(node.local);
    if (node.exported && node.local.name !== node.exported.name) {
      this.space();
      this.word("as");
      this.space();
      this.print(node.exported);
    }
  }
  function ExportNamespaceSpecifier(node) {
    this.tokenChar(42);
    this.space();
    this.word("as");
    this.space();
    this.print(node.exported);
  }
  var warningShown = false;
  function _printAttributes(node, hasPreviousBrace) {
    var _node$extra;
    var importAttributesKeyword = this.format.importAttributesKeyword;
    var attributes = node.attributes,
      assertions = node.assertions;
    if (attributes && !importAttributesKeyword && node.extra && (node.extra.deprecatedAssertSyntax || node.extra.deprecatedWithLegacySyntax) && !warningShown) {
      warningShown = true;
      console.warn("You are using import attributes, without specifying the desired output syntax.\nPlease specify the \"importAttributesKeyword\" generator option, whose value can be one of:\n - \"with\"        : `import { a } from \"b\" with { type: \"json\" };`\n - \"assert\"      : `import { a } from \"b\" assert { type: \"json\" };`\n - \"with-legacy\" : `import { a } from \"b\" with type: \"json\";`\n");
    }
    var useAssertKeyword = importAttributesKeyword === "assert" || !importAttributesKeyword && assertions;
    this.word(useAssertKeyword ? "assert" : "with");
    this.space();
    if (!useAssertKeyword && (importAttributesKeyword === "with-legacy" || !importAttributesKeyword && (_node$extra = node.extra) != null && _node$extra.deprecatedWithLegacySyntax)) {
      this.printList(attributes || assertions);
      return;
    }
    var occurrenceCount = hasPreviousBrace ? 1 : 0;
    this.token("{", null, occurrenceCount);
    this.space();
    this.printList(attributes || assertions, this.shouldPrintTrailingComma("}"));
    this.space();
    this.token("}", null, occurrenceCount);
  }
  function ExportAllDeclaration(node) {
    var _node$attributes, _node$assertions;
    this.word("export");
    this.space();
    if (node.exportKind === "type") {
      this.word("type");
      this.space();
    }
    this.tokenChar(42);
    this.space();
    this.word("from");
    this.space();
    if ((_node$attributes = node.attributes) != null && _node$attributes.length || (_node$assertions = node.assertions) != null && _node$assertions.length) {
      this.print(node.source, true);
      this.space();
      this._printAttributes(node, false);
    } else {
      this.print(node.source);
    }
    this.semicolon();
  }
  function maybePrintDecoratorsBeforeExport(printer, node) {
    if (isClassDeclaration(node.declaration) && printer._shouldPrintDecoratorsBeforeExport(node)) {
      printer.printJoin(node.declaration.decorators);
    }
  }
  function ExportNamedDeclaration(node) {
    maybePrintDecoratorsBeforeExport(this, node);
    this.word("export");
    this.space();
    if (node.declaration) {
      var declar = node.declaration;
      this.print(declar);
      if (!isStatement$3(declar)) this.semicolon();
    } else {
      if (node.exportKind === "type") {
        this.word("type");
        this.space();
      }
      var specifiers = node.specifiers.slice(0);
      var hasSpecial = false;
      for (;;) {
        var first = specifiers[0];
        if (isExportDefaultSpecifier(first) || isExportNamespaceSpecifier(first)) {
          hasSpecial = true;
          this.print(specifiers.shift());
          if (specifiers.length) {
            this.tokenChar(44);
            this.space();
          }
        } else {
          break;
        }
      }
      var hasBrace = false;
      if (specifiers.length || !specifiers.length && !hasSpecial) {
        hasBrace = true;
        this.tokenChar(123);
        if (specifiers.length) {
          this.space();
          this.printList(specifiers, this.shouldPrintTrailingComma("}"));
          this.space();
        }
        this.tokenChar(125);
      }
      if (node.source) {
        var _node$attributes2, _node$assertions2;
        this.space();
        this.word("from");
        this.space();
        if ((_node$attributes2 = node.attributes) != null && _node$attributes2.length || (_node$assertions2 = node.assertions) != null && _node$assertions2.length) {
          this.print(node.source, true);
          this.space();
          this._printAttributes(node, hasBrace);
        } else {
          this.print(node.source);
        }
      }
      this.semicolon();
    }
  }
  function ExportDefaultDeclaration(node) {
    maybePrintDecoratorsBeforeExport(this, node);
    this.word("export");
    this.noIndentInnerCommentsHere();
    this.space();
    this.word("default");
    this.space();
    this.tokenContext |= TokenContext.exportDefault;
    var declar = node.declaration;
    this.print(declar);
    if (!isStatement$3(declar)) this.semicolon();
  }
  function ImportDeclaration(node) {
    var _node$attributes3, _node$assertions3;
    this.word("import");
    this.space();
    var isTypeKind = node.importKind === "type" || node.importKind === "typeof";
    if (isTypeKind) {
      this.noIndentInnerCommentsHere();
      this.word(node.importKind);
      this.space();
    } else if (node.module) {
      this.noIndentInnerCommentsHere();
      this.word("module");
      this.space();
    } else if (node.phase) {
      this.noIndentInnerCommentsHere();
      this.word(node.phase);
      this.space();
    }
    var specifiers = node.specifiers.slice(0);
    var hasSpecifiers = !!specifiers.length;
    while (hasSpecifiers) {
      var first = specifiers[0];
      if (isImportDefaultSpecifier(first) || isImportNamespaceSpecifier(first)) {
        this.print(specifiers.shift());
        if (specifiers.length) {
          this.tokenChar(44);
          this.space();
        }
      } else {
        break;
      }
    }
    var hasBrace = false;
    if (specifiers.length) {
      hasBrace = true;
      this.tokenChar(123);
      this.space();
      this.printList(specifiers, this.shouldPrintTrailingComma("}"));
      this.space();
      this.tokenChar(125);
    } else if (isTypeKind && !hasSpecifiers) {
      hasBrace = true;
      this.tokenChar(123);
      this.tokenChar(125);
    }
    if (hasSpecifiers || isTypeKind) {
      this.space();
      this.word("from");
      this.space();
    }
    if ((_node$attributes3 = node.attributes) != null && _node$attributes3.length || (_node$assertions3 = node.assertions) != null && _node$assertions3.length) {
      this.print(node.source, true);
      this.space();
      this._printAttributes(node, hasBrace);
    } else {
      this.print(node.source);
    }
    this.semicolon();
  }
  function ImportAttribute(node) {
    this.print(node.key);
    this.tokenChar(58);
    this.space();
    this.print(node.value);
  }
  function ImportNamespaceSpecifier(node) {
    this.tokenChar(42);
    this.space();
    this.word("as");
    this.space();
    this.print(node.local);
  }
  function ImportExpression(node) {
    this.word("import");
    if (node.phase) {
      this.tokenChar(46);
      this.word(node.phase);
    }
    this.tokenChar(40);
    var shouldPrintTrailingComma = this.shouldPrintTrailingComma(")");
    this.print(node.source);
    if (node.options != null) {
      this.tokenChar(44);
      this.space();
      this.print(node.options);
    }
    if (shouldPrintTrailingComma) {
      this.tokenChar(44);
    }
    this.rightParens(node);
  }

  var object = {};
  var hasOwnProperty$2 = object.hasOwnProperty;
  var forOwn = function forOwn(object, callback) {
    for (var key in object) {
      if (hasOwnProperty$2.call(object, key)) {
        callback(key, object[key]);
      }
    }
  };
  var extend = function extend(destination, source) {
    if (!source) {
      return destination;
    }
    forOwn(source, function (key, value) {
      destination[key] = value;
    });
    return destination;
  };
  var forEach = function forEach(array, callback) {
    var length = array.length;
    var index = -1;
    while (++index < length) {
      callback(array[index]);
    }
  };
  var fourHexEscape = function fourHexEscape(hex) {
    return "\\u" + ('0000' + hex).slice(-4);
  };
  var hexadecimal = function hexadecimal(code, lowercase) {
    var hexadecimal = code.toString(16);
    if (lowercase) return hexadecimal;
    return hexadecimal.toUpperCase();
  };
  var toString = object.toString;
  var isArray$2 = Array.isArray;
  var isBuffer = function isBuffer(value) {
    return typeof Buffer$1 === 'function' && Buffer$1.isBuffer(value);
  };
  var isObject$1 = function isObject(value) {
    return toString.call(value) == '[object Object]';
  };
  var isString$1 = function isString(value) {
    return typeof value == 'string' || toString.call(value) == '[object String]';
  };
  var isNumber$1 = function isNumber(value) {
    return typeof value == 'number' || toString.call(value) == '[object Number]';
  };
  var isFunction$3 = function isFunction(value) {
    return typeof value == 'function';
  };
  var isMap = function isMap(value) {
    return toString.call(value) == '[object Map]';
  };
  var isSet = function isSet(value) {
    return toString.call(value) == '[object Set]';
  };
  var singleEscapes = {
    '\\': '\\\\',
    '\b': '\\b',
    '\f': '\\f',
    '\n': '\\n',
    '\r': '\\r',
    '\t': '\\t'
  };
  var regexSingleEscape = /[\\\b\f\n\r\t]/;
  var regexDigit = /[0-9]/;
  var regexWhitespace = /[\xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/;
  var escapeEverythingRegex = /([\uD800-\uDBFF][\uDC00-\uDFFF])|([\uD800-\uDFFF])|(['"`])|[^]/g;
  var escapeNonAsciiRegex = /([\uD800-\uDBFF][\uDC00-\uDFFF])|([\uD800-\uDFFF])|(['"`])|[^ !#-&\(-\[\]-_a-~]/g;
  var _jsesc = function jsesc(argument, options) {
    var increaseIndentation = function increaseIndentation() {
      oldIndent = indent;
      ++options.indentLevel;
      indent = options.indent.repeat(options.indentLevel);
    };
    var defaults = {
      'escapeEverything': false,
      'minimal': false,
      'isScriptContext': false,
      'quotes': 'single',
      'wrap': false,
      'es6': false,
      'json': false,
      'compact': true,
      'lowercaseHex': false,
      'numbers': 'decimal',
      'indent': '\t',
      'indentLevel': 0,
      '__inline1__': false,
      '__inline2__': false
    };
    var json = options && options.json;
    if (json) {
      defaults.quotes = 'double';
      defaults.wrap = true;
    }
    options = extend(defaults, options);
    if (options.quotes != 'single' && options.quotes != 'double' && options.quotes != 'backtick') {
      options.quotes = 'single';
    }
    var quote = options.quotes == 'double' ? '"' : options.quotes == 'backtick' ? '`' : '\'';
    var compact = options.compact;
    var lowercaseHex = options.lowercaseHex;
    var indent = options.indent.repeat(options.indentLevel);
    var oldIndent = '';
    var inline1 = options.__inline1__;
    var inline2 = options.__inline2__;
    var newLine = compact ? '' : '\n';
    var result;
    var isEmpty = true;
    var useBinNumbers = options.numbers == 'binary';
    var useOctNumbers = options.numbers == 'octal';
    var useDecNumbers = options.numbers == 'decimal';
    var useHexNumbers = options.numbers == 'hexadecimal';
    if (json && argument && isFunction$3(argument.toJSON)) {
      argument = argument.toJSON();
    }
    if (!isString$1(argument)) {
      if (isMap(argument)) {
        if (argument.size == 0) {
          return 'new Map()';
        }
        if (!compact) {
          options.__inline1__ = true;
          options.__inline2__ = false;
        }
        return 'new Map(' + _jsesc(Array.from(argument), options) + ')';
      }
      if (isSet(argument)) {
        if (argument.size == 0) {
          return 'new Set()';
        }
        return 'new Set(' + _jsesc(Array.from(argument), options) + ')';
      }
      if (isBuffer(argument)) {
        if (argument.length == 0) {
          return 'Buffer.from([])';
        }
        return 'Buffer.from(' + _jsesc(Array.from(argument), options) + ')';
      }
      if (isArray$2(argument)) {
        result = [];
        options.wrap = true;
        if (inline1) {
          options.__inline1__ = false;
          options.__inline2__ = true;
        }
        if (!inline2) {
          increaseIndentation();
        }
        forEach(argument, function (value) {
          isEmpty = false;
          if (inline2) {
            options.__inline2__ = false;
          }
          result.push((compact || inline2 ? '' : indent) + _jsesc(value, options));
        });
        if (isEmpty) {
          return '[]';
        }
        if (inline2) {
          return '[' + result.join(', ') + ']';
        }
        return '[' + newLine + result.join(',' + newLine) + newLine + (compact ? '' : oldIndent) + ']';
      } else if (isNumber$1(argument)) {
        if (json) {
          return JSON.stringify(argument);
        }
        if (useDecNumbers) {
          return String(argument);
        }
        if (useHexNumbers) {
          var _hexadecimal = argument.toString(16);
          if (!lowercaseHex) {
            _hexadecimal = _hexadecimal.toUpperCase();
          }
          return '0x' + _hexadecimal;
        }
        if (useBinNumbers) {
          return '0b' + argument.toString(2);
        }
        if (useOctNumbers) {
          return '0o' + argument.toString(8);
        }
      } else if (!isObject$1(argument)) {
        if (json) {
          return JSON.stringify(argument) || 'null';
        }
        return String(argument);
      } else {
        result = [];
        options.wrap = true;
        increaseIndentation();
        forOwn(argument, function (key, value) {
          isEmpty = false;
          result.push((compact ? '' : indent) + _jsesc(key, options) + ':' + (compact ? '' : ' ') + _jsesc(value, options));
        });
        if (isEmpty) {
          return '{}';
        }
        return '{' + newLine + result.join(',' + newLine) + newLine + (compact ? '' : oldIndent) + '}';
      }
    }
    var regex = options.escapeEverything ? escapeEverythingRegex : escapeNonAsciiRegex;
    result = argument.replace(regex, function (_char, pair, lone, quoteChar, index, string) {
      if (pair) {
        if (options.minimal) return pair;
        var first = pair.charCodeAt(0);
        var second = pair.charCodeAt(1);
        if (options.es6) {
          var codePoint = (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
          var _hex = hexadecimal(codePoint, lowercaseHex);
          return "\\u{" + _hex + '}';
        }
        return fourHexEscape(hexadecimal(first, lowercaseHex)) + fourHexEscape(hexadecimal(second, lowercaseHex));
      }
      if (lone) {
        return fourHexEscape(hexadecimal(lone.charCodeAt(0), lowercaseHex));
      }
      if (_char == '\0' && !json && !regexDigit.test(string.charAt(index + 1))) {
        return '\\0';
      }
      if (quoteChar) {
        if (quoteChar == quote || options.escapeEverything) {
          return '\\' + quoteChar;
        }
        return quoteChar;
      }
      if (regexSingleEscape.test(_char)) {
        return singleEscapes[_char];
      }
      if (options.minimal && !regexWhitespace.test(_char)) {
        return _char;
      }
      var hex = hexadecimal(_char.charCodeAt(0), lowercaseHex);
      if (json || hex.length > 2) {
        return fourHexEscape(hex);
      }
      return '\\x' + ('00' + hex).slice(-2);
    });
    if (quote == '`') {
      result = result.replace(/\$\{/g, '\\${');
    }
    if (options.isScriptContext) {
      result = result.replace(/<\/(script|style)/gi, '<\\/$1').replace(/<!--/g, json ? "\\u003C!--" : '\\x3C!--');
    }
    if (options.wrap) {
      result = quote + result + quote;
    }
    return result;
  };
  _jsesc.version = '3.0.2';
  var jsesc_1 = _jsesc;

  var isAssignmentPattern$2 = isAssignmentPattern$3,
    isIdentifier$8 = isIdentifier$e;
  var lastRawIdentNode = null;
  var lastRawIdentResult = "";
  function _getRawIdentifier(node) {
    if (node === lastRawIdentNode) return lastRawIdentResult;
    lastRawIdentNode = node;
    var name = node.name;
    var token = this.tokenMap.find(node, function (tok) {
      return tok.value === name;
    });
    if (token) {
      lastRawIdentResult = this._originalCode.slice(token.start, token.end);
      return lastRawIdentResult;
    }
    return lastRawIdentResult = node.name;
  }
  function Identifier(node) {
    var _node$loc;
    this.sourceIdentifierName(((_node$loc = node.loc) == null ? void 0 : _node$loc.identifierName) || node.name);
    this.word(this.tokenMap ? this._getRawIdentifier(node) : node.name);
  }
  function ArgumentPlaceholder() {
    this.tokenChar(63);
  }
  function RestElement$1(node) {
    this.token("...");
    this.print(node.argument);
  }
  function ObjectExpression$1(node) {
    var props = node.properties;
    this.tokenChar(123);
    if (props.length) {
      var exit = this.enterDelimited();
      this.space();
      this.printList(props, this.shouldPrintTrailingComma("}"), true, true);
      this.space();
      exit();
    }
    this.sourceWithOffset("end", node.loc, -1);
    this.tokenChar(125);
  }
  function ObjectMethod(node) {
    this.printJoin(node.decorators);
    this._methodHead(node);
    this.space();
    this.print(node.body);
  }
  function ObjectProperty(node) {
    this.printJoin(node.decorators);
    if (node.computed) {
      this.tokenChar(91);
      this.print(node.key);
      this.tokenChar(93);
    } else {
      if (isAssignmentPattern$2(node.value) && isIdentifier$8(node.key) && node.key.name === node.value.left.name) {
        this.print(node.value);
        return;
      }
      this.print(node.key);
      if (node.shorthand && isIdentifier$8(node.key) && isIdentifier$8(node.value) && node.key.name === node.value.name) {
        return;
      }
    }
    this.tokenChar(58);
    this.space();
    this.print(node.value);
  }
  function ArrayExpression$1(node) {
    var elems = node.elements;
    var len = elems.length;
    this.tokenChar(91);
    var exit = this.enterDelimited();
    for (var i = 0; i < elems.length; i++) {
      var elem = elems[i];
      if (elem) {
        if (i > 0) this.space();
        this.print(elem);
        if (i < len - 1 || this.shouldPrintTrailingComma("]")) {
          this.token(",", false, i);
        }
      } else {
        this.token(",", false, i);
      }
    }
    exit();
    this.tokenChar(93);
  }
  function RecordExpression(node) {
    var props = node.properties;
    var startToken;
    var endToken;
    {
      if (this.format.recordAndTupleSyntaxType === "bar") {
        startToken = "{|";
        endToken = "|}";
      } else if (this.format.recordAndTupleSyntaxType !== "hash" && this.format.recordAndTupleSyntaxType != null) {
        throw new Error("The \"recordAndTupleSyntaxType\" generator option must be \"bar\" or \"hash\" (" + JSON.stringify(this.format.recordAndTupleSyntaxType) + " received).");
      } else {
        startToken = "#{";
        endToken = "}";
      }
    }
    this.token(startToken);
    if (props.length) {
      this.space();
      this.printList(props, this.shouldPrintTrailingComma(endToken), true, true);
      this.space();
    }
    this.token(endToken);
  }
  function TupleExpression(node) {
    var elems = node.elements;
    var len = elems.length;
    var startToken;
    var endToken;
    {
      if (this.format.recordAndTupleSyntaxType === "bar") {
        startToken = "[|";
        endToken = "|]";
      } else if (this.format.recordAndTupleSyntaxType === "hash") {
        startToken = "#[";
        endToken = "]";
      } else {
        throw new Error(this.format.recordAndTupleSyntaxType + " is not a valid recordAndTuple syntax type");
      }
    }
    this.token(startToken);
    for (var i = 0; i < elems.length; i++) {
      var elem = elems[i];
      if (elem) {
        if (i > 0) this.space();
        this.print(elem);
        if (i < len - 1 || this.shouldPrintTrailingComma(endToken)) {
          this.token(",", false, i);
        }
      }
    }
    this.token(endToken);
  }
  function RegExpLiteral$1(node) {
    this.word("/" + node.pattern + "/" + node.flags);
  }
  function BooleanLiteral$1(node) {
    this.word(node.value ? "true" : "false");
  }
  function NullLiteral$1() {
    this.word("null");
  }
  function NumericLiteral$1(node) {
    var raw = this.getPossibleRaw(node);
    var opts = this.format.jsescOption;
    var value = node.value;
    var str = value + "";
    if (opts.numbers) {
      this.number(jsesc_1(value, opts), value);
    } else if (raw == null) {
      this.number(str, value);
    } else if (this.format.minified) {
      this.number(raw.length < str.length ? raw : str, value);
    } else {
      this.number(raw, value);
    }
  }
  function StringLiteral$1(node) {
    var raw = this.getPossibleRaw(node);
    if (!this.format.minified && raw !== undefined) {
      this.token(raw);
      return;
    }
    var val = jsesc_1(node.value, this.format.jsescOption);
    this.token(val);
  }
  function BigIntLiteral(node) {
    var raw = this.getPossibleRaw(node);
    if (!this.format.minified && raw !== undefined) {
      this.word(raw);
      return;
    }
    this.word(node.value + "n");
  }
  var validTopicTokenSet = new Set(["^^", "@@", "^", "%", "#"]);
  function TopicReference() {
    var topicToken = this.format.topicToken;
    if (validTopicTokenSet.has(topicToken)) {
      this.token(topicToken);
    } else {
      var givenTopicTokenJSON = JSON.stringify(topicToken);
      var validTopics = Array.from(validTopicTokenSet, function (v) {
        return JSON.stringify(v);
      });
      throw new Error("The \"topicToken\" generator option must be one of " + (validTopics.join(", ") + " (" + givenTopicTokenJSON + " received instead)."));
    }
  }
  function PipelineTopicExpression(node) {
    this.print(node.expression);
  }
  function PipelineBareFunction(node) {
    this.print(node.callee);
  }
  function PipelinePrimaryTopicReference() {
    this.tokenChar(35);
  }
  function VoidPattern() {
    this.word("void");
  }

  var isDeclareExportDeclaration = isDeclareExportDeclaration$1,
    isStatement$2 = isStatement$9;
  function AnyTypeAnnotation() {
    this.word("any");
  }
  function ArrayTypeAnnotation(node) {
    this.print(node.elementType, true);
    this.tokenChar(91);
    this.tokenChar(93);
  }
  function BooleanTypeAnnotation() {
    this.word("boolean");
  }
  function BooleanLiteralTypeAnnotation(node) {
    this.word(node.value ? "true" : "false");
  }
  function NullLiteralTypeAnnotation() {
    this.word("null");
  }
  function DeclareClass(node, parent) {
    if (!isDeclareExportDeclaration(parent)) {
      this.word("declare");
      this.space();
    }
    this.word("class");
    this.space();
    this._interfaceish(node);
  }
  function DeclareFunction(node, parent) {
    if (!isDeclareExportDeclaration(parent)) {
      this.word("declare");
      this.space();
    }
    this.word("function");
    this.space();
    this.print(node.id);
    this.print(node.id.typeAnnotation.typeAnnotation);
    if (node.predicate) {
      this.space();
      this.print(node.predicate);
    }
    this.semicolon();
  }
  function InferredPredicate() {
    this.tokenChar(37);
    this.word("checks");
  }
  function DeclaredPredicate(node) {
    this.tokenChar(37);
    this.word("checks");
    this.tokenChar(40);
    this.print(node.value);
    this.tokenChar(41);
  }
  function DeclareInterface(node) {
    this.word("declare");
    this.space();
    this.InterfaceDeclaration(node);
  }
  function DeclareModule(node) {
    this.word("declare");
    this.space();
    this.word("module");
    this.space();
    this.print(node.id);
    this.space();
    this.print(node.body);
  }
  function DeclareModuleExports(node) {
    this.word("declare");
    this.space();
    this.word("module");
    this.tokenChar(46);
    this.word("exports");
    this.print(node.typeAnnotation);
  }
  function DeclareTypeAlias(node) {
    this.word("declare");
    this.space();
    this.TypeAlias(node);
  }
  function DeclareOpaqueType(node, parent) {
    if (!isDeclareExportDeclaration(parent)) {
      this.word("declare");
      this.space();
    }
    this.OpaqueType(node);
  }
  function DeclareVariable(node, parent) {
    if (!isDeclareExportDeclaration(parent)) {
      this.word("declare");
      this.space();
    }
    this.word("var");
    this.space();
    this.print(node.id);
    this.print(node.id.typeAnnotation);
    this.semicolon();
  }
  function DeclareExportDeclaration(node) {
    this.word("declare");
    this.space();
    this.word("export");
    this.space();
    if (node["default"]) {
      this.word("default");
      this.space();
    }
    FlowExportDeclaration.call(this, node);
  }
  function DeclareExportAllDeclaration(node) {
    this.word("declare");
    this.space();
    ExportAllDeclaration.call(this, node);
  }
  function EnumDeclaration(node) {
    var id = node.id,
      body = node.body;
    this.word("enum");
    this.space();
    this.print(id);
    this.print(body);
  }
  function enumExplicitType(context, name, hasExplicitType) {
    if (hasExplicitType) {
      context.space();
      context.word("of");
      context.space();
      context.word(name);
    }
    context.space();
  }
  function enumBody(context, node) {
    var members = node.members;
    context.token("{");
    context.indent();
    context.newline();
    for (var _iterator = _createForOfIteratorHelperLoose(members), _step; !(_step = _iterator()).done;) {
      var member = _step.value;
      context.print(member);
      context.newline();
    }
    if (node.hasUnknownMembers) {
      context.token("...");
      context.newline();
    }
    context.dedent();
    context.token("}");
  }
  function EnumBooleanBody(node) {
    var explicitType = node.explicitType;
    enumExplicitType(this, "boolean", explicitType);
    enumBody(this, node);
  }
  function EnumNumberBody(node) {
    var explicitType = node.explicitType;
    enumExplicitType(this, "number", explicitType);
    enumBody(this, node);
  }
  function EnumStringBody(node) {
    var explicitType = node.explicitType;
    enumExplicitType(this, "string", explicitType);
    enumBody(this, node);
  }
  function EnumSymbolBody(node) {
    enumExplicitType(this, "symbol", true);
    enumBody(this, node);
  }
  function EnumDefaultedMember(node) {
    var id = node.id;
    this.print(id);
    this.tokenChar(44);
  }
  function enumInitializedMember(context, node) {
    context.print(node.id);
    context.space();
    context.token("=");
    context.space();
    context.print(node.init);
    context.token(",");
  }
  function EnumBooleanMember(node) {
    enumInitializedMember(this, node);
  }
  function EnumNumberMember(node) {
    enumInitializedMember(this, node);
  }
  function EnumStringMember(node) {
    enumInitializedMember(this, node);
  }
  function FlowExportDeclaration(node) {
    if (node.declaration) {
      var declar = node.declaration;
      this.print(declar);
      if (!isStatement$2(declar)) this.semicolon();
    } else {
      this.tokenChar(123);
      if (node.specifiers.length) {
        this.space();
        this.printList(node.specifiers);
        this.space();
      }
      this.tokenChar(125);
      if (node.source) {
        this.space();
        this.word("from");
        this.space();
        this.print(node.source);
      }
      this.semicolon();
    }
  }
  function ExistsTypeAnnotation() {
    this.tokenChar(42);
  }
  function FunctionTypeAnnotation(node, parent) {
    this.print(node.typeParameters);
    this.tokenChar(40);
    if (node["this"]) {
      this.word("this");
      this.tokenChar(58);
      this.space();
      this.print(node["this"].typeAnnotation);
      if (node.params.length || node.rest) {
        this.tokenChar(44);
        this.space();
      }
    }
    this.printList(node.params);
    if (node.rest) {
      if (node.params.length) {
        this.tokenChar(44);
        this.space();
      }
      this.token("...");
      this.print(node.rest);
    }
    this.tokenChar(41);
    var type = parent == null ? void 0 : parent.type;
    if (type != null && (type === "ObjectTypeCallProperty" || type === "ObjectTypeInternalSlot" || type === "DeclareFunction" || type === "ObjectTypeProperty" && parent.method)) {
      this.tokenChar(58);
    } else {
      this.space();
      this.token("=>");
    }
    this.space();
    this.print(node.returnType);
  }
  function FunctionTypeParam(node) {
    this.print(node.name);
    if (node.optional) this.tokenChar(63);
    if (node.name) {
      this.tokenChar(58);
      this.space();
    }
    this.print(node.typeAnnotation);
  }
  function InterfaceExtends(node) {
    this.print(node.id);
    this.print(node.typeParameters, true);
  }
  function _interfaceish(node) {
    var _node$extends;
    this.print(node.id);
    this.print(node.typeParameters);
    if ((_node$extends = node["extends"]) != null && _node$extends.length) {
      this.space();
      this.word("extends");
      this.space();
      this.printList(node["extends"]);
    }
    if (node.type === "DeclareClass") {
      var _node$mixins, _node$implements;
      if ((_node$mixins = node.mixins) != null && _node$mixins.length) {
        this.space();
        this.word("mixins");
        this.space();
        this.printList(node.mixins);
      }
      if ((_node$implements = node["implements"]) != null && _node$implements.length) {
        this.space();
        this.word("implements");
        this.space();
        this.printList(node["implements"]);
      }
    }
    this.space();
    this.print(node.body);
  }
  function _variance(node) {
    var _node$variance;
    var kind = (_node$variance = node.variance) == null ? void 0 : _node$variance.kind;
    if (kind != null) {
      if (kind === "plus") {
        this.tokenChar(43);
      } else if (kind === "minus") {
        this.tokenChar(45);
      }
    }
  }
  function InterfaceDeclaration(node) {
    this.word("interface");
    this.space();
    this._interfaceish(node);
  }
  function andSeparator(occurrenceCount) {
    this.space();
    this.token("&", false, occurrenceCount);
    this.space();
  }
  function InterfaceTypeAnnotation(node) {
    var _node$extends2;
    this.word("interface");
    if ((_node$extends2 = node["extends"]) != null && _node$extends2.length) {
      this.space();
      this.word("extends");
      this.space();
      this.printList(node["extends"]);
    }
    this.space();
    this.print(node.body);
  }
  function IntersectionTypeAnnotation(node) {
    this.printJoin(node.types, undefined, undefined, andSeparator);
  }
  function MixedTypeAnnotation() {
    this.word("mixed");
  }
  function EmptyTypeAnnotation() {
    this.word("empty");
  }
  function NullableTypeAnnotation(node) {
    this.tokenChar(63);
    this.print(node.typeAnnotation);
  }
  function NumberTypeAnnotation() {
    this.word("number");
  }
  function StringTypeAnnotation() {
    this.word("string");
  }
  function ThisTypeAnnotation() {
    this.word("this");
  }
  function TupleTypeAnnotation(node) {
    this.tokenChar(91);
    this.printList(node.types);
    this.tokenChar(93);
  }
  function TypeofTypeAnnotation(node) {
    this.word("typeof");
    this.space();
    this.print(node.argument);
  }
  function TypeAlias(node) {
    this.word("type");
    this.space();
    this.print(node.id);
    this.print(node.typeParameters);
    this.space();
    this.tokenChar(61);
    this.space();
    this.print(node.right);
    this.semicolon();
  }
  function TypeAnnotation(node, parent) {
    this.tokenChar(58);
    this.space();
    if (parent.type === "ArrowFunctionExpression") {
      this.tokenContext |= TokenContext.arrowFlowReturnType;
    } else if (node.optional) {
      this.tokenChar(63);
    }
    this.print(node.typeAnnotation);
  }
  function TypeParameterInstantiation(node) {
    this.tokenChar(60);
    this.printList(node.params);
    this.tokenChar(62);
  }
  function TypeParameter(node) {
    this._variance(node);
    this.word(node.name);
    if (node.bound) {
      this.print(node.bound);
    }
    if (node["default"]) {
      this.space();
      this.tokenChar(61);
      this.space();
      this.print(node["default"]);
    }
  }
  function OpaqueType(node) {
    this.word("opaque");
    this.space();
    this.word("type");
    this.space();
    this.print(node.id);
    this.print(node.typeParameters);
    if (node.supertype) {
      this.tokenChar(58);
      this.space();
      this.print(node.supertype);
    }
    if (node.impltype) {
      this.space();
      this.tokenChar(61);
      this.space();
      this.print(node.impltype);
    }
    this.semicolon();
  }
  function ObjectTypeAnnotation(node) {
    var _this = this;
    if (node.exact) {
      this.token("{|");
    } else {
      this.tokenChar(123);
    }
    var props = [].concat(_toConsumableArray(node.properties), _toConsumableArray(node.callProperties || []), _toConsumableArray(node.indexers || []), _toConsumableArray(node.internalSlots || []));
    if (props.length) {
      this.newline();
      this.space();
      this.printJoin(props, true, true, undefined, undefined, function addNewlines(leading) {
        if (leading && !props[0]) return 1;
      }, function () {
        if (props.length !== 1 || node.inexact) {
          _this.token(",");
          _this.space();
        }
      });
      this.space();
    }
    if (node.inexact) {
      this.indent();
      this.token("...");
      if (props.length) {
        this.newline();
      }
      this.dedent();
    }
    if (node.exact) {
      this.token("|}");
    } else {
      this.tokenChar(125);
    }
  }
  function ObjectTypeInternalSlot(node) {
    if (node["static"]) {
      this.word("static");
      this.space();
    }
    this.tokenChar(91);
    this.tokenChar(91);
    this.print(node.id);
    this.tokenChar(93);
    this.tokenChar(93);
    if (node.optional) this.tokenChar(63);
    if (!node.method) {
      this.tokenChar(58);
      this.space();
    }
    this.print(node.value);
  }
  function ObjectTypeCallProperty(node) {
    if (node["static"]) {
      this.word("static");
      this.space();
    }
    this.print(node.value);
  }
  function ObjectTypeIndexer(node) {
    if (node["static"]) {
      this.word("static");
      this.space();
    }
    this._variance(node);
    this.tokenChar(91);
    if (node.id) {
      this.print(node.id);
      this.tokenChar(58);
      this.space();
    }
    this.print(node.key);
    this.tokenChar(93);
    this.tokenChar(58);
    this.space();
    this.print(node.value);
  }
  function ObjectTypeProperty(node) {
    if (node.proto) {
      this.word("proto");
      this.space();
    }
    if (node["static"]) {
      this.word("static");
      this.space();
    }
    if (node.kind === "get" || node.kind === "set") {
      this.word(node.kind);
      this.space();
    }
    this._variance(node);
    this.print(node.key);
    if (node.optional) this.tokenChar(63);
    if (!node.method) {
      this.tokenChar(58);
      this.space();
    }
    this.print(node.value);
  }
  function ObjectTypeSpreadProperty(node) {
    this.token("...");
    this.print(node.argument);
  }
  function QualifiedTypeIdentifier(node) {
    this.print(node.qualification);
    this.tokenChar(46);
    this.print(node.id);
  }
  function SymbolTypeAnnotation() {
    this.word("symbol");
  }
  function orSeparator(occurrenceCount) {
    this.space();
    this.token("|", false, occurrenceCount);
    this.space();
  }
  function UnionTypeAnnotation(node) {
    this.printJoin(node.types, undefined, undefined, orSeparator);
  }
  function TypeCastExpression$1(node) {
    this.tokenChar(40);
    this.print(node.expression);
    this.print(node.typeAnnotation);
    this.tokenChar(41);
  }
  function Variance(node) {
    if (node.kind === "plus") {
      this.tokenChar(43);
    } else {
      this.tokenChar(45);
    }
  }
  function VoidTypeAnnotation() {
    this.word("void");
  }
  function IndexedAccessType(node) {
    this.print(node.objectType, true);
    this.tokenChar(91);
    this.print(node.indexType);
    this.tokenChar(93);
  }
  function OptionalIndexedAccessType(node) {
    this.print(node.objectType);
    if (node.optional) {
      this.token("?.");
    }
    this.tokenChar(91);
    this.print(node.indexType);
    this.tokenChar(93);
  }

  function File$1(node) {
    if (node.program) {
      this.print(node.program.interpreter);
    }
    this.print(node.program);
  }
  function Program(node) {
    var _node$directives;
    this.noIndentInnerCommentsHere();
    this.printInnerComments();
    var directivesLen = (_node$directives = node.directives) == null ? void 0 : _node$directives.length;
    if (directivesLen) {
      var _node$directives$trai;
      var newline = node.body.length ? 2 : 1;
      this.printSequence(node.directives, undefined, newline);
      if (!((_node$directives$trai = node.directives[directivesLen - 1].trailingComments) != null && _node$directives$trai.length)) {
        this.newline(newline);
      }
    }
    this.printSequence(node.body);
  }
  function BlockStatement(node) {
    var _node$directives2;
    this.tokenChar(123);
    var exit = this.enterDelimited();
    var directivesLen = (_node$directives2 = node.directives) == null ? void 0 : _node$directives2.length;
    if (directivesLen) {
      var _node$directives$trai2;
      var newline = node.body.length ? 2 : 1;
      this.printSequence(node.directives, true, newline);
      if (!((_node$directives$trai2 = node.directives[directivesLen - 1].trailingComments) != null && _node$directives$trai2.length)) {
        this.newline(newline);
      }
    }
    this.printSequence(node.body, true);
    exit();
    this.rightBrace(node);
  }
  function Directive(node) {
    this.print(node.value);
    this.semicolon();
  }
  var unescapedSingleQuoteRE = /(?:^|[^\\])(?:\\\\)*'/;
  var unescapedDoubleQuoteRE = /(?:^|[^\\])(?:\\\\)*"/;
  function DirectiveLiteral(node) {
    var raw = this.getPossibleRaw(node);
    if (!this.format.minified && raw !== undefined) {
      this.token(raw);
      return;
    }
    var value = node.value;
    if (!unescapedDoubleQuoteRE.test(value)) {
      this.token("\"" + value + "\"");
    } else if (!unescapedSingleQuoteRE.test(value)) {
      this.token("'" + value + "'");
    } else {
      throw new Error("Malformed AST: it is not possible to print a directive containing" + " both unescaped single and double quotes.");
    }
  }
  function InterpreterDirective(node) {
    this.token("#!" + node.value);
    this.newline(1, true);
  }
  function Placeholder(node) {
    this.token("%%");
    this.print(node.name);
    this.token("%%");
    if (node.expectedNode === "Statement") {
      this.semicolon();
    }
  }

  function JSXAttribute(node) {
    this.print(node.name);
    if (node.value) {
      this.tokenChar(61);
      this.print(node.value);
    }
  }
  function JSXIdentifier(node) {
    this.word(node.name);
  }
  function JSXNamespacedName(node) {
    this.print(node.namespace);
    this.tokenChar(58);
    this.print(node.name);
  }
  function JSXMemberExpression(node) {
    this.print(node.object);
    this.tokenChar(46);
    this.print(node.property);
  }
  function JSXSpreadAttribute(node) {
    this.tokenChar(123);
    this.token("...");
    this.print(node.argument);
    this.rightBrace(node);
  }
  function JSXExpressionContainer(node) {
    this.tokenChar(123);
    this.print(node.expression);
    this.rightBrace(node);
  }
  function JSXSpreadChild(node) {
    this.tokenChar(123);
    this.token("...");
    this.print(node.expression);
    this.rightBrace(node);
  }
  function JSXText(node) {
    var raw = this.getPossibleRaw(node);
    if (raw !== undefined) {
      this.token(raw, true);
    } else {
      this.token(node.value, true);
    }
  }
  function JSXElement(node) {
    var open = node.openingElement;
    this.print(open);
    if (open.selfClosing) return;
    this.indent();
    for (var _iterator = _createForOfIteratorHelperLoose(node.children), _step; !(_step = _iterator()).done;) {
      var child = _step.value;
      this.print(child);
    }
    this.dedent();
    this.print(node.closingElement);
  }
  function spaceSeparator() {
    this.space();
  }
  function JSXOpeningElement(node) {
    this.tokenChar(60);
    this.print(node.name);
    {
      if (node.typeArguments) {
        this.print(node.typeArguments);
      }
      this.print(node.typeParameters);
    }
    if (node.attributes.length > 0) {
      this.space();
      this.printJoin(node.attributes, undefined, undefined, spaceSeparator);
    }
    if (node.selfClosing) {
      this.space();
      this.tokenChar(47);
    }
    this.tokenChar(62);
  }
  function JSXClosingElement(node) {
    this.tokenChar(60);
    this.tokenChar(47);
    this.print(node.name);
    this.tokenChar(62);
  }
  function JSXEmptyExpression() {
    this.printInnerComments();
  }
  function JSXFragment(node) {
    this.print(node.openingFragment);
    this.indent();
    for (var _iterator2 = _createForOfIteratorHelperLoose(node.children), _step2; !(_step2 = _iterator2()).done;) {
      var child = _step2.value;
      this.print(child);
    }
    this.dedent();
    this.print(node.closingFragment);
  }
  function JSXOpeningFragment() {
    this.tokenChar(60);
    this.tokenChar(62);
  }
  function JSXClosingFragment() {
    this.token("</");
    this.tokenChar(62);
  }

  function TSTypeAnnotation(node, parent) {
    this.token((parent.type === "TSFunctionType" || parent.type === "TSConstructorType") && parent.typeAnnotation === node ? "=>" : ":");
    this.space();
    if (node.optional) this.tokenChar(63);
    this.print(node.typeAnnotation);
  }
  function TSTypeParameterInstantiation(node, parent) {
    var _this = this;
    this.tokenChar(60);
    var printTrailingSeparator = parent.type === "ArrowFunctionExpression" && node.params.length === 1;
    if (this.tokenMap && node.start != null && node.end != null) {
      printTrailingSeparator && (printTrailingSeparator = !!this.tokenMap.find(node, function (t) {
        return _this.tokenMap.matchesOriginal(t, ",");
      }));
      printTrailingSeparator || (printTrailingSeparator = this.shouldPrintTrailingComma(">"));
    }
    this.printList(node.params, printTrailingSeparator);
    this.tokenChar(62);
  }
  function TSTypeParameter(node) {
    if (node["const"]) {
      this.word("const");
      this.space();
    }
    if (node["in"]) {
      this.word("in");
      this.space();
    }
    if (node.out) {
      this.word("out");
      this.space();
    }
    this.word(node.name);
    if (node.constraint) {
      this.space();
      this.word("extends");
      this.space();
      this.print(node.constraint);
    }
    if (node["default"]) {
      this.space();
      this.tokenChar(61);
      this.space();
      this.print(node["default"]);
    }
  }
  function TSParameterProperty(node) {
    if (node.accessibility) {
      this.word(node.accessibility);
      this.space();
    }
    if (node.readonly) {
      this.word("readonly");
      this.space();
    }
    this._param(node.parameter);
  }
  function TSDeclareFunction(node, parent) {
    if (node.declare) {
      this.word("declare");
      this.space();
    }
    this._functionHead(node, parent);
    this.semicolon();
  }
  function TSDeclareMethod(node) {
    this._classMethodHead(node);
    this.semicolon();
  }
  function TSQualifiedName(node) {
    this.print(node.left);
    this.tokenChar(46);
    this.print(node.right);
  }
  function TSCallSignatureDeclaration(node) {
    this.tsPrintSignatureDeclarationBase(node);
    maybePrintTrailingCommaOrSemicolon(this, node);
  }
  function maybePrintTrailingCommaOrSemicolon(printer, node) {
    if (!printer.tokenMap || !node.start || !node.end) {
      printer.semicolon();
      return;
    }
    if (printer.tokenMap.endMatches(node, ",")) {
      printer.token(",");
    } else if (printer.tokenMap.endMatches(node, ";")) {
      printer.semicolon();
    }
  }
  function TSConstructSignatureDeclaration(node) {
    this.word("new");
    this.space();
    this.tsPrintSignatureDeclarationBase(node);
    maybePrintTrailingCommaOrSemicolon(this, node);
  }
  function TSPropertySignature(node) {
    var readonly = node.readonly;
    if (readonly) {
      this.word("readonly");
      this.space();
    }
    this.tsPrintPropertyOrMethodName(node);
    this.print(node.typeAnnotation);
    maybePrintTrailingCommaOrSemicolon(this, node);
  }
  function tsPrintPropertyOrMethodName(node) {
    if (node.computed) {
      this.tokenChar(91);
    }
    this.print(node.key);
    if (node.computed) {
      this.tokenChar(93);
    }
    if (node.optional) {
      this.tokenChar(63);
    }
  }
  function TSMethodSignature(node) {
    var kind = node.kind;
    if (kind === "set" || kind === "get") {
      this.word(kind);
      this.space();
    }
    this.tsPrintPropertyOrMethodName(node);
    this.tsPrintSignatureDeclarationBase(node);
    maybePrintTrailingCommaOrSemicolon(this, node);
  }
  function TSIndexSignature(node) {
    var readonly = node.readonly,
      isStatic = node["static"];
    if (isStatic) {
      this.word("static");
      this.space();
    }
    if (readonly) {
      this.word("readonly");
      this.space();
    }
    this.tokenChar(91);
    this._parameters(node.parameters, "]");
    this.print(node.typeAnnotation);
    maybePrintTrailingCommaOrSemicolon(this, node);
  }
  function TSAnyKeyword() {
    this.word("any");
  }
  function TSBigIntKeyword() {
    this.word("bigint");
  }
  function TSUnknownKeyword() {
    this.word("unknown");
  }
  function TSNumberKeyword() {
    this.word("number");
  }
  function TSObjectKeyword() {
    this.word("object");
  }
  function TSBooleanKeyword() {
    this.word("boolean");
  }
  function TSStringKeyword() {
    this.word("string");
  }
  function TSSymbolKeyword() {
    this.word("symbol");
  }
  function TSVoidKeyword() {
    this.word("void");
  }
  function TSUndefinedKeyword() {
    this.word("undefined");
  }
  function TSNullKeyword() {
    this.word("null");
  }
  function TSNeverKeyword() {
    this.word("never");
  }
  function TSIntrinsicKeyword() {
    this.word("intrinsic");
  }
  function TSThisType() {
    this.word("this");
  }
  function TSFunctionType(node) {
    this.tsPrintFunctionOrConstructorType(node);
  }
  function TSConstructorType(node) {
    if (node["abstract"]) {
      this.word("abstract");
      this.space();
    }
    this.word("new");
    this.space();
    this.tsPrintFunctionOrConstructorType(node);
  }
  function tsPrintFunctionOrConstructorType(node) {
    var typeParameters = node.typeParameters;
    var parameters = node.parameters;
    this.print(typeParameters);
    this.tokenChar(40);
    this._parameters(parameters, ")");
    this.space();
    var returnType = node.typeAnnotation;
    this.print(returnType);
  }
  function TSTypeReference(node) {
    var typeArguments = node.typeParameters;
    this.print(node.typeName, !!typeArguments);
    this.print(typeArguments);
  }
  function TSTypePredicate(node) {
    if (node.asserts) {
      this.word("asserts");
      this.space();
    }
    this.print(node.parameterName);
    if (node.typeAnnotation) {
      this.space();
      this.word("is");
      this.space();
      this.print(node.typeAnnotation.typeAnnotation);
    }
  }
  function TSTypeQuery(node) {
    this.word("typeof");
    this.space();
    this.print(node.exprName);
    var typeArguments = node.typeParameters;
    if (typeArguments) {
      this.print(typeArguments);
    }
  }
  function TSTypeLiteral(node) {
    var _this2 = this;
    printBraced(this, node, function () {
      return _this2.printJoin(node.members, true, true);
    });
  }
  function TSArrayType(node) {
    this.print(node.elementType, true);
    this.tokenChar(91);
    this.tokenChar(93);
  }
  function TSTupleType(node) {
    this.tokenChar(91);
    this.printList(node.elementTypes, this.shouldPrintTrailingComma("]"));
    this.tokenChar(93);
  }
  function TSOptionalType(node) {
    this.print(node.typeAnnotation);
    this.tokenChar(63);
  }
  function TSRestType(node) {
    this.token("...");
    this.print(node.typeAnnotation);
  }
  function TSNamedTupleMember(node) {
    this.print(node.label);
    if (node.optional) this.tokenChar(63);
    this.tokenChar(58);
    this.space();
    this.print(node.elementType);
  }
  function TSUnionType(node) {
    tsPrintUnionOrIntersectionType(this, node, "|");
  }
  function TSIntersectionType(node) {
    tsPrintUnionOrIntersectionType(this, node, "&");
  }
  function tsPrintUnionOrIntersectionType(printer, node, sep) {
    var _printer$tokenMap;
    var hasLeadingToken = 0;
    if ((_printer$tokenMap = printer.tokenMap) != null && _printer$tokenMap.startMatches(node, sep)) {
      hasLeadingToken = 1;
      printer.token(sep);
    }
    printer.printJoin(node.types, undefined, undefined, function (i) {
      this.space();
      this.token(sep, null, i + hasLeadingToken);
      this.space();
    });
  }
  function TSConditionalType(node) {
    this.print(node.checkType);
    this.space();
    this.word("extends");
    this.space();
    this.print(node.extendsType);
    this.space();
    this.tokenChar(63);
    this.space();
    this.print(node.trueType);
    this.space();
    this.tokenChar(58);
    this.space();
    this.print(node.falseType);
  }
  function TSInferType(node) {
    this.word("infer");
    this.print(node.typeParameter);
  }
  function TSParenthesizedType(node) {
    this.tokenChar(40);
    this.print(node.typeAnnotation);
    this.tokenChar(41);
  }
  function TSTypeOperator(node) {
    this.word(node.operator);
    this.space();
    this.print(node.typeAnnotation);
  }
  function TSIndexedAccessType(node) {
    this.print(node.objectType, true);
    this.tokenChar(91);
    this.print(node.indexType);
    this.tokenChar(93);
  }
  function TSMappedType(node) {
    var nameType = node.nameType,
      optional = node.optional,
      readonly = node.readonly,
      typeAnnotation = node.typeAnnotation;
    this.tokenChar(123);
    var exit = this.enterDelimited();
    this.space();
    if (readonly) {
      tokenIfPlusMinus(this, readonly);
      this.word("readonly");
      this.space();
    }
    this.tokenChar(91);
    {
      this.word(node.typeParameter.name);
    }
    this.space();
    this.word("in");
    this.space();
    {
      this.print(node.typeParameter.constraint);
    }
    if (nameType) {
      this.space();
      this.word("as");
      this.space();
      this.print(nameType);
    }
    this.tokenChar(93);
    if (optional) {
      tokenIfPlusMinus(this, optional);
      this.tokenChar(63);
    }
    if (typeAnnotation) {
      this.tokenChar(58);
      this.space();
      this.print(typeAnnotation);
    }
    this.space();
    exit();
    this.tokenChar(125);
  }
  function tokenIfPlusMinus(self, tok) {
    if (tok !== true) {
      self.token(tok);
    }
  }
  function TSTemplateLiteralType(node) {
    this._printTemplate(node, node.types);
  }
  function TSLiteralType(node) {
    this.print(node.literal);
  }
  function TSClassImplements(node) {
    this.print(node.expression);
    this.print(node.typeArguments);
  }
  function TSInterfaceDeclaration(node) {
    var declare = node.declare,
      id = node.id,
      typeParameters = node.typeParameters,
      extendz = node["extends"],
      body = node.body;
    if (declare) {
      this.word("declare");
      this.space();
    }
    this.word("interface");
    this.space();
    this.print(id);
    this.print(typeParameters);
    if (extendz != null && extendz.length) {
      this.space();
      this.word("extends");
      this.space();
      this.printList(extendz);
    }
    this.space();
    this.print(body);
  }
  function TSInterfaceBody(node) {
    var _this3 = this;
    printBraced(this, node, function () {
      return _this3.printJoin(node.body, true, true);
    });
  }
  function TSTypeAliasDeclaration(node) {
    var declare = node.declare,
      id = node.id,
      typeParameters = node.typeParameters,
      typeAnnotation = node.typeAnnotation;
    if (declare) {
      this.word("declare");
      this.space();
    }
    this.word("type");
    this.space();
    this.print(id);
    this.print(typeParameters);
    this.space();
    this.tokenChar(61);
    this.space();
    this.print(typeAnnotation);
    this.semicolon();
  }
  function TSTypeExpression(node) {
    var type = node.type,
      expression = node.expression,
      typeAnnotation = node.typeAnnotation;
    this.print(expression, true);
    this.space();
    this.word(type === "TSAsExpression" ? "as" : "satisfies");
    this.space();
    this.print(typeAnnotation);
  }
  function TSTypeAssertion(node) {
    var typeAnnotation = node.typeAnnotation,
      expression = node.expression;
    this.tokenChar(60);
    this.print(typeAnnotation);
    this.tokenChar(62);
    this.space();
    this.print(expression);
  }
  function TSInstantiationExpression(node) {
    this.print(node.expression);
    {
      this.print(node.typeParameters);
    }
  }
  function TSEnumDeclaration(node) {
    var declare = node.declare,
      isConst = node["const"],
      id = node.id;
    if (declare) {
      this.word("declare");
      this.space();
    }
    if (isConst) {
      this.word("const");
      this.space();
    }
    this.word("enum");
    this.space();
    this.print(id);
    this.space();
    {
      TSEnumBody.call(this, node);
    }
  }
  function TSEnumBody(node) {
    var _this4 = this;
    printBraced(this, node, function () {
      var _this4$shouldPrintTra;
      return _this4.printList(node.members, (_this4$shouldPrintTra = _this4.shouldPrintTrailingComma("}")) != null ? _this4$shouldPrintTra : true, true, true);
    });
  }
  function TSEnumMember(node) {
    var id = node.id,
      initializer = node.initializer;
    this.print(id);
    if (initializer) {
      this.space();
      this.tokenChar(61);
      this.space();
      this.print(initializer);
    }
  }
  function TSModuleDeclaration(node) {
    var declare = node.declare,
      id = node.id,
      kind = node.kind;
    if (declare) {
      this.word("declare");
      this.space();
    }
    {
      if (!node.global) {
        this.word(kind != null ? kind : id.type === "Identifier" ? "namespace" : "module");
        this.space();
      }
      this.print(id);
      if (!node.body) {
        this.semicolon();
        return;
      }
      var body = node.body;
      while (body.type === "TSModuleDeclaration") {
        this.tokenChar(46);
        this.print(body.id);
        body = body.body;
      }
      this.space();
      this.print(body);
    }
  }
  function TSModuleBlock(node) {
    var _this5 = this;
    printBraced(this, node, function () {
      return _this5.printSequence(node.body, true);
    });
  }
  function TSImportType(node) {
    var argument = node.argument,
      qualifier = node.qualifier,
      options = node.options;
    this.word("import");
    this.tokenChar(40);
    this.print(argument);
    if (options) {
      this.tokenChar(44);
      this.print(options);
    }
    this.tokenChar(41);
    if (qualifier) {
      this.tokenChar(46);
      this.print(qualifier);
    }
    var typeArguments = node.typeParameters;
    if (typeArguments) {
      this.print(typeArguments);
    }
  }
  function TSImportEqualsDeclaration(node) {
    var id = node.id,
      moduleReference = node.moduleReference;
    if (node.isExport) {
      this.word("export");
      this.space();
    }
    this.word("import");
    this.space();
    this.print(id);
    this.space();
    this.tokenChar(61);
    this.space();
    this.print(moduleReference);
    this.semicolon();
  }
  function TSExternalModuleReference(node) {
    this.token("require(");
    this.print(node.expression);
    this.tokenChar(41);
  }
  function TSNonNullExpression$1(node) {
    this.print(node.expression);
    this.tokenChar(33);
  }
  function TSExportAssignment(node) {
    this.word("export");
    this.space();
    this.tokenChar(61);
    this.space();
    this.print(node.expression);
    this.semicolon();
  }
  function TSNamespaceExportDeclaration(node) {
    this.word("export");
    this.space();
    this.word("as");
    this.space();
    this.word("namespace");
    this.space();
    this.print(node.id);
    this.semicolon();
  }
  function tsPrintSignatureDeclarationBase(node) {
    var typeParameters = node.typeParameters;
    var parameters = node.parameters;
    this.print(typeParameters);
    this.tokenChar(40);
    this._parameters(parameters, ")");
    var returnType = node.typeAnnotation;
    this.print(returnType);
  }
  function tsPrintClassMemberModifiers(node) {
    var isPrivateField = node.type === "ClassPrivateProperty";
    var isPublicField = node.type === "ClassAccessorProperty" || node.type === "ClassProperty";
    printModifiersList(this, node, [isPublicField && node.declare && "declare", !isPrivateField && node.accessibility]);
    if (node["static"]) {
      this.word("static");
      this.space();
    }
    printModifiersList(this, node, [!isPrivateField && node["abstract"] && "abstract", !isPrivateField && node.override && "override", (isPublicField || isPrivateField) && node.readonly && "readonly"]);
  }
  function printBraced(printer, node, cb) {
    printer.token("{");
    var exit = printer.enterDelimited();
    cb();
    exit();
    printer.rightBrace(node);
  }
  function printModifiersList(printer, node, modifiers) {
    var _printer$tokenMap2;
    var modifiersSet = new Set();
    for (var _iterator = _createForOfIteratorHelperLoose(modifiers), _step; !(_step = _iterator()).done;) {
      var modifier = _step.value;
      if (modifier) modifiersSet.add(modifier);
    }
    (_printer$tokenMap2 = printer.tokenMap) == null || _printer$tokenMap2.find(node, function (tok) {
      if (modifiersSet.has(tok.value)) {
        printer.token(tok.value);
        printer.space();
        modifiersSet["delete"](tok.value);
        return modifiersSet.size === 0;
      }
    });
    for (var _iterator2 = _createForOfIteratorHelperLoose(modifiersSet), _step2; !(_step2 = _iterator2()).done;) {
      var _modifier = _step2.value;
      printer.word(_modifier);
      printer.space();
    }
  }

  var generatorFunctions = /*#__PURE__*/Object.freeze({
    __proto__: null,
    AnyTypeAnnotation: AnyTypeAnnotation,
    ArgumentPlaceholder: ArgumentPlaceholder,
    ArrayExpression: ArrayExpression$1,
    ArrayPattern: ArrayExpression$1,
    ArrayTypeAnnotation: ArrayTypeAnnotation,
    ArrowFunctionExpression: ArrowFunctionExpression,
    AssignmentExpression: AssignmentExpression$1,
    AssignmentPattern: AssignmentPattern,
    AwaitExpression: AwaitExpression,
    BigIntLiteral: BigIntLiteral,
    BinaryExpression: AssignmentExpression$1,
    BindExpression: BindExpression,
    BlockStatement: BlockStatement,
    BooleanLiteral: BooleanLiteral$1,
    BooleanLiteralTypeAnnotation: BooleanLiteralTypeAnnotation,
    BooleanTypeAnnotation: BooleanTypeAnnotation,
    BreakStatement: BreakStatement,
    CallExpression: CallExpression$1,
    CatchClause: CatchClause,
    ClassAccessorProperty: ClassAccessorProperty,
    ClassBody: ClassBody,
    ClassDeclaration: ClassDeclaration,
    ClassExpression: ClassDeclaration,
    ClassImplements: InterfaceExtends,
    ClassMethod: ClassMethod,
    ClassPrivateMethod: ClassPrivateMethod,
    ClassPrivateProperty: ClassPrivateProperty,
    ClassProperty: ClassProperty,
    ConditionalExpression: ConditionalExpression$1,
    ContinueStatement: ContinueStatement,
    DebuggerStatement: DebuggerStatement,
    DeclareClass: DeclareClass,
    DeclareExportAllDeclaration: DeclareExportAllDeclaration,
    DeclareExportDeclaration: DeclareExportDeclaration,
    DeclareFunction: DeclareFunction,
    DeclareInterface: DeclareInterface,
    DeclareModule: DeclareModule,
    DeclareModuleExports: DeclareModuleExports,
    DeclareOpaqueType: DeclareOpaqueType,
    DeclareTypeAlias: DeclareTypeAlias,
    DeclareVariable: DeclareVariable,
    DeclaredPredicate: DeclaredPredicate,
    Decorator: Decorator,
    Directive: Directive,
    DirectiveLiteral: DirectiveLiteral,
    DoExpression: DoExpression,
    DoWhileStatement: DoWhileStatement,
    EmptyStatement: EmptyStatement,
    EmptyTypeAnnotation: EmptyTypeAnnotation,
    EnumBooleanBody: EnumBooleanBody,
    EnumBooleanMember: EnumBooleanMember,
    EnumDeclaration: EnumDeclaration,
    EnumDefaultedMember: EnumDefaultedMember,
    EnumNumberBody: EnumNumberBody,
    EnumNumberMember: EnumNumberMember,
    EnumStringBody: EnumStringBody,
    EnumStringMember: EnumStringMember,
    EnumSymbolBody: EnumSymbolBody,
    ExistsTypeAnnotation: ExistsTypeAnnotation,
    ExportAllDeclaration: ExportAllDeclaration,
    ExportDefaultDeclaration: ExportDefaultDeclaration,
    ExportDefaultSpecifier: ExportDefaultSpecifier,
    ExportNamedDeclaration: ExportNamedDeclaration,
    ExportNamespaceSpecifier: ExportNamespaceSpecifier,
    ExportSpecifier: ExportSpecifier,
    ExpressionStatement: ExpressionStatement,
    File: File$1,
    ForInStatement: ForInStatement,
    ForOfStatement: ForOfStatement,
    ForStatement: ForStatement,
    FunctionDeclaration: FunctionExpression,
    FunctionExpression: FunctionExpression,
    FunctionTypeAnnotation: FunctionTypeAnnotation,
    FunctionTypeParam: FunctionTypeParam,
    GenericTypeAnnotation: InterfaceExtends,
    Identifier: Identifier,
    IfStatement: IfStatement,
    Import: Import,
    ImportAttribute: ImportAttribute,
    ImportDeclaration: ImportDeclaration,
    ImportDefaultSpecifier: ImportDefaultSpecifier,
    ImportExpression: ImportExpression,
    ImportNamespaceSpecifier: ImportNamespaceSpecifier,
    ImportSpecifier: ImportSpecifier,
    IndexedAccessType: IndexedAccessType,
    InferredPredicate: InferredPredicate,
    InterfaceDeclaration: InterfaceDeclaration,
    InterfaceExtends: InterfaceExtends,
    InterfaceTypeAnnotation: InterfaceTypeAnnotation,
    InterpreterDirective: InterpreterDirective,
    IntersectionTypeAnnotation: IntersectionTypeAnnotation,
    JSXAttribute: JSXAttribute,
    JSXClosingElement: JSXClosingElement,
    JSXClosingFragment: JSXClosingFragment,
    JSXElement: JSXElement,
    JSXEmptyExpression: JSXEmptyExpression,
    JSXExpressionContainer: JSXExpressionContainer,
    JSXFragment: JSXFragment,
    JSXIdentifier: JSXIdentifier,
    JSXMemberExpression: JSXMemberExpression,
    JSXNamespacedName: JSXNamespacedName,
    JSXOpeningElement: JSXOpeningElement,
    JSXOpeningFragment: JSXOpeningFragment,
    JSXSpreadAttribute: JSXSpreadAttribute,
    JSXSpreadChild: JSXSpreadChild,
    JSXText: JSXText,
    LabeledStatement: LabeledStatement,
    LogicalExpression: AssignmentExpression$1,
    MemberExpression: MemberExpression,
    MetaProperty: MetaProperty,
    MixedTypeAnnotation: MixedTypeAnnotation,
    ModuleExpression: ModuleExpression,
    NewExpression: NewExpression$1,
    NullLiteral: NullLiteral$1,
    NullLiteralTypeAnnotation: NullLiteralTypeAnnotation,
    NullableTypeAnnotation: NullableTypeAnnotation,
    NumberLiteralTypeAnnotation: NumericLiteral$1,
    NumberTypeAnnotation: NumberTypeAnnotation,
    NumericLiteral: NumericLiteral$1,
    ObjectExpression: ObjectExpression$1,
    ObjectMethod: ObjectMethod,
    ObjectPattern: ObjectExpression$1,
    ObjectProperty: ObjectProperty,
    ObjectTypeAnnotation: ObjectTypeAnnotation,
    ObjectTypeCallProperty: ObjectTypeCallProperty,
    ObjectTypeIndexer: ObjectTypeIndexer,
    ObjectTypeInternalSlot: ObjectTypeInternalSlot,
    ObjectTypeProperty: ObjectTypeProperty,
    ObjectTypeSpreadProperty: ObjectTypeSpreadProperty,
    OpaqueType: OpaqueType,
    OptionalCallExpression: OptionalCallExpression,
    OptionalIndexedAccessType: 